Index: gcc/README
diff -c gcc/README:1.1.1.1 gcc/README:1.3
*** gcc/README:1.1.1.1	Wed Feb 15 21:22:24 2006
--- gcc/README	Wed Sep 18 07:47:59 2019
***************
*** 1,3 ****
--- 1,11 ----
+ See gcc/gccmvs.txt for documentation on MVS
+ See gcc/gcccms.txt for documentation on CMS
+ See gcc/gccvse.txt for documentation on VSE
+ See gcc/gccmus.txt for documentation on MUSIC/SP
+ See gcc/gccdos.txt for documentation on PDOS/Windows
+ 
+ 
+ 
  This directory contains the GNU Compiler Collection (GCC).
  
  The GNU Compiler Collection is free software.  See the file COPYING
Index: gcc/config.sub
diff -c gcc/config.sub:1.1.1.1 gcc/config.sub:1.6
*** gcc/config.sub:1.1.1.1	Wed Feb 15 21:22:24 2006
--- gcc/config.sub	Fri Nov 03 16:15:22 2006
***************
*** 652,658 ****
  		basic_machine=i386-pc
  		os=-msdos
  		;;
! 	mvs)
  		basic_machine=i370-ibm
  		os=-mvs
  		;;
--- 652,658 ----
  		basic_machine=i386-pc
  		os=-msdos
  		;;
! 	mvs*)
  		basic_machine=i370-ibm
  		os=-mvs
  		;;
Index: gcc/gcc/__header.h
diff -c nul gcc/gcc/__header.h:1.2
*** nul	Tue Oct 01 16:28:41 2019
--- gcc/gcc/__header.h	Tue Oct 31 17:08:38 2006
***************
*** 0 ****
--- 1,14 ----
+ builtin-attrs.def builtina.h
+ builtin-types.def builtint.h
+ builtins.def builtind.h
+ c-common.def ccommond.h
+ diagnostic.def diagndef.h
+ machmode.def machmodd.h
+ params.def paramsd.h
+ predict.def predictd.h
+ rtl.def rtld.h
+ stab.def stabd.h
+ timevar.def timevard.h
+ tree.def treed.h
+ insn-constants.h i-constants.h
+ langhooks-def.h langhdef.h
Index: gcc/gcc/allcms.bat
diff -c nul gcc/gcc/allcms.bat:1.14
*** nul	Tue Oct 01 16:28:42 2019
--- gcc/gcc/allcms.bat	Tue Apr 24 18:07:31 2018
***************
*** 0 ****
--- 1,24 ----
+ cd ..\..\pdos\pdpclib
+ del *.o
+ make -f makefile.w32
+ cd ..\..\gcc\gcc
+ call compile -DTARGET_CMS
+ call compmvs -DTARGET_CMS -DUSE_MEMMGR -ansi -pedantic-errors
+ del output.txt
+ call zipmvs
+ mkdir ..\temp
+ del /q ..\temp\*.*
+ cd ..\temp
+ unzip ..\gcc\all
+ unzip *.zip
+ del *.zip
+ del ..\gcc\all.zip
+ zip -0mX ..\gcc\all *
+ cd ..\gcc
+ 
+ rem for S/380 testing, use this
+ call runcms allcms.exec output.txt all.zip gcccms-exe.vmarc
+ 
+ rem for S/390 testing, use this
+ rem mvsendec encb all.zip all.dat
+ rem loc2ebc all.dat xfer.card
Index: gcc/gcc/allcms.exec
diff -c nul gcc/gcc/allcms.exec:1.41
*** nul	Tue Oct 01 16:28:42 2019
--- gcc/gcc/allcms.exec	Mon Apr 06 15:19:36 2015
***************
*** 0 ****
--- 1,35 ----
+ * Usage - ALLCMS <SRC> <EXE> <WORK>
+ 
+ * This script compiles all the files on SRC disk (default is A)
+ * and copies the resultant modules to the EXE disk (default B)
+ * while using the WORK disk (default C) as a temporary area
+ 
+ &SRC = A
+ &EXE = B
+ &WORK = C
+ 
+ &IF &INDEX EQ 0 &GOTO -FINARGS
+ &SRC = &1
+ &ARGS &2 &3 &4 &5 &6 &7 &8 &9
+ 
+ &IF &INDEX EQ 0 &GOTO -FINARGS
+ &EXE = &1
+ &ARGS &2 &3 &4 &5 &6 &7 &8 &9
+ 
+ &IF &INDEX EQ 0 &GOTO -FINARGS
+ &WORK = &1
+ 
+ -FINARGS
+ 
+ 
+ * Strictly, we're only expecting a blocksize of 80, but
+ * mvsunzip can handle short blocks, so we specify the max
+ FILEDEF INPUT TAP1 (LRECL 0 BLKSIZE 32760 RECFM U
+ MVSUNZIP DD:INPUT &SRC
+ FILEDEF INPUT CLEAR
+ 
+ 
+ EXEC COMPILE &SRC &EXE &WORK
+ 
+ 
+ VMARC PACK * * &EXE (TAP2 BLOCK 80
Index: gcc/gcc/allmus.bat
diff -c nul gcc/gcc/allmus.bat:1.10
*** nul	Tue Oct 01 16:28:42 2019
--- gcc/gcc/allmus.bat	Mon Sep 30 16:33:41 2019
***************
*** 0 ****
--- 1,31 ----
+ cd ..\..\pdos\pdpclib
+ 
+ del *.o
+ make -f makefile.w32
+ 
+ cd ..\..\gcc\gcc
+ 
+ gcc -s -o mvsendec ../../pdos/pdpclib/mvsendec.c
+ 
+ rem !!!!!!!
+ rem This is useful during testing to get a faster compile but
+ rem should NOT be used for release
+ rem !!!!!!!
+ rem call fudge
+ 
+ call compile
+ call compmvs -DMUSIC -DIFOX -DUSE_MEMMGR
+ call zipmvs
+ 
+ mkdir ..\temp
+ del /q ..\temp\*.*
+ cd ..\temp
+ unzip ..\gcc\all
+ unzip *.zip
+ del *.zip
+ del ..\gcc\all.zip
+ zip -0mX ..\gcc\all *
+ cd ..\gcc
+ 
+ call runmus compmus.job output.txt all.zip gccmus.mfarc
+ grep "Files are different" output.txt
Index: gcc/gcc/allmvs.bat
diff -c nul gcc/gcc/allmvs.bat:1.7
*** nul	Tue Oct 01 16:28:42 2019
--- gcc/gcc/allmvs.bat	Mon Apr 03 00:14:58 2017
***************
*** 0 ****
--- 1,17 ----
+ cd ..\..\pdos\pdpclib
+ 
+ del *.o
+ make -f makefile.w32
+ 
+ cd ..\..\gcc\gcc
+ 
+ rem !!!!!!!
+ rem This is useful during testing to get a faster compile but
+ rem should NOT be used for release
+ rem !!!!!!!
+ rem call fudge
+ 
+ call compile
+ call compmvs -ansi -pedantic-errors
+ call zipmvs
+ call subjobs
Index: gcc/gcc/allpdos.bat
diff -c nul gcc/gcc/allpdos.bat:1.8
*** nul	Tue Oct 01 16:28:42 2019
--- gcc/gcc/allpdos.bat	Mon Apr 03 00:14:58 2017
***************
*** 0 ****
--- 1,26 ----
+ rem we don't yet have the ability to link a program on PDOS
+ rem so instead we just test that the standard MVS build
+ rem produces the expected assembler output on PDOS.
+ 
+ cd ..\..\pdos\pdpclib
+ 
+ del *.o
+ make -f makefile.w32
+ 
+ cd ..\..\gcc\gcc
+ 
+ rem !!!!!!!
+ rem This is useful during testing to get a faster compile but
+ rem should NOT be used for release
+ rem !!!!!!!
+ rem call fudge
+ 
+ call compile
+ call compmvs -ansi -pedantic-errors
+ call zipmvs
+ 
+ call zippdos
+ 
+ rem now we rebuild GCC from source on PDOS, and compare results
+ rem with what we had on the PC via cross-compile
+ call runpdos comppdos.bat output.txt all.zip
Index: gcc/gcc/allvse.bat
diff -c nul gcc/gcc/allvse.bat:1.20
*** nul	Tue Oct 01 16:28:42 2019
--- gcc/gcc/allvse.bat	Mon Sep 30 16:33:11 2019
***************
*** 0 ****
--- 1,18 ----
+ 
+ del *.s
+ 
+ cd ..\..\pdos\pdpclib
+ 
+ del *.o
+ make -f makefile.w32
+ 
+ cd ..\..\gcc\gcc
+ 
+ call compile -DTARGET_VSE
+ 
+ call compmvs -DTARGET_VSE -DUSE_MEMMGR -ansi -pedantic-errors
+ 
+ call zipvse
+ 
+ m4 -I . -I ..\..\pdos\pdpclib compvse.m4 >alljcl.jcl
+ call runvse alljcl.jcl output.txt all.zip gccvse-exe.obj
Index: gcc/gcc/auto-host.h
diff -c nul gcc/gcc/auto-host.h:1.1
*** nul	Tue Oct 01 16:28:42 2019
--- gcc/gcc/auto-host.h	Wed Feb 15 21:25:41 2006
***************
*** 0 ****
--- 1,305 ----
+ /* auto-host.h.  Generated automatically by configure.  */
+ /* config.in.  Generated automatically from configure.in by autoheader.  */
+ 
+ /* Define if using alloca.c.  */
+ /* #undef C_ALLOCA */
+ 
+ /* Define to empty if the keyword does not work.  */
+ /* #undef const */
+ 
+ /* Define to one of _getb67, GETB67, getb67 for Cray-2 and Cray-YMP systems.
+    This function is required for alloca.c support on those systems.  */
+ /* #undef CRAY_STACKSEG_END */
+ 
+ /* Define to the type of elements in the array set by `getgroups'.
+    Usually this is either `int' or `gid_t'.  */
+ #define GETGROUPS_T gid_t
+ 
+ /* Define to `int' if <sys/types.h> doesn't define.  */
+ /* #undef gid_t */
+ 
+ /* Define if you have alloca, as a function or macro.  */
+ /*#define HAVE_ALLOCA 1*/
+ 
+ /* Define if you have <alloca.h> and it should be used (not on Ultrix).  */
+ /*#define HAVE_ALLOCA_H 1*/
+ 
+ /* Define if you have the ANSI # stringizing operator in cpp. */
+ #define HAVE_STRINGIZE 1
+ 
+ /* Define if you have <sys/wait.h> that is POSIX.1 compatible.  */
+ /* #define HAVE_SYS_WAIT_H 1 */
+ 
+ /* Define if you have <vfork.h>.  */
+ /* #undef HAVE_VFORK_H */
+ 
+ /* Define as __inline if that's what the C compiler calls it.  */
+ /* #undef inline */
+ 
+ /* Define if your C compiler doesn't accept -c and -o together.  */
+ /* #undef NO_MINUS_C_MINUS_O */
+ 
+ /* Define to `long' if <sys/types.h> doesn't define.  */
+ /* #undef off_t */
+ 
+ /* Define to `int' if <sys/types.h> doesn't define.  */
+ /* #undef pid_t */
+ 
+ /* Define to `unsigned' if <sys/types.h> doesn't define.  */
+ /* #undef size_t */
+ 
+ /* If using the C implementation of alloca, define if you know the
+    direction of stack growth for your system; otherwise it will be
+    automatically deduced at run-time.
+  STACK_DIRECTION > 0 => grows toward higher addresses
+  STACK_DIRECTION < 0 => grows toward lower addresses
+  STACK_DIRECTION = 0 => direction of growth unknown
+  */
+ /* #undef STACK_DIRECTION */
+ 
+ /* Define if you have the ANSI C header files.  */
+ #define STDC_HEADERS 1
+ 
+ /* Define if you can safely include both <sys/time.h> and <time.h>.  */
+ /* #define TIME_WITH_SYS_TIME 1 */
+ 
+ /* Define to `int' if <sys/types.h> doesn't define.  */
+ /* #undef uid_t */
+ 
+ /* Define vfork as fork if vfork does not work.  */
+ /* #undef vfork */
+ 
+ /* Define if your assembler supports specifying the maximum number
+    of bytes to skip when using the GAS .p2align command.  */
+ /* #undef HAVE_GAS_MAX_SKIP_P2ALIGN */
+ 
+ /* Define if your assembler supports .balign and .p2align.  */
+ /* #undef HAVE_GAS_BALIGN_AND_P2ALIGN */
+ 
+ /* Define if your assembler uses the old HImode fild and fist notation.  */
+ /* #undef HAVE_GAS_FILDS_FISTS */
+ 
+ /* Define to `int' if <sys/types.h> doesn't define.  */
+ /* #undef ssize_t */
+ 
+ /* Define if cpp should also search $prefix/include.  */
+ /* #define PREFIX_INCLUDE_DIR "/phil/include" */
+ 
+ /* Define if you have the __argz_count function.  */
+ /* #undef HAVE___ARGZ_COUNT */
+ 
+ /* Define if you have the __argz_next function.  */
+ /* #undef HAVE___ARGZ_NEXT */
+ 
+ /* Define if you have the __argz_stringify function.  */
+ /* #undef HAVE___ARGZ_STRINGIFY */
+ 
+ /* Define if you have the atoll function.  */
+ /* #undef HAVE_ATOLL */
+ 
+ /* Define if you have the atoq function.  */
+ /* #undef HAVE_ATOQ */
+ 
+ /* Define if you have the clock function.  */
+ /* #define HAVE_CLOCK 1 */
+ 
+ /* Define if you have the dcgettext function.  */
+ /* #define HAVE_DCGETTEXT 1 */
+ 
+ /* Define if you have the dup2 function.  */
+ /* #define HAVE_DUP2 1 */
+ 
+ /* Define if you have the feof_unlocked function.  */
+ /* #undef HAVE_FEOF_UNLOCKED */
+ 
+ /* Define if you have the fgets_unlocked function.  */
+ /* #undef HAVE_FGETS_UNLOCKED */
+ 
+ /* Define if you have the fprintf_unlocked function.  */
+ /* #undef HAVE_FPRINTF_UNLOCKED */
+ 
+ /* Define if you have the fputc_unlocked function.  */
+ /* #undef HAVE_FPUTC_UNLOCKED */
+ 
+ /* Define if you have the fputs_unlocked function.  */
+ /* #undef HAVE_FPUTS_UNLOCKED */
+ 
+ /* Define if you have the fwrite_unlocked function.  */
+ /* #undef HAVE_FWRITE_UNLOCKED */
+ 
+ /* Define to enable the use of a default linker. */
+ /* #undef DEFAULT_LINKER */
+ 
+ /* Define to enable the use of a default assembler. */
+ /* #undef DEFAULT_ASSEMBLER */
+ 
+ /* Define if you want more run-time sanity checks.  This one gets a grab
+    bag of miscellaneous but relatively cheap checks. */
+ /* #undef ENABLE_CHECKING */
+ 
+ /* Define if you want all operations on trees (the basic data
+    structure of the front ends) to be checked for dynamic type safety
+    at runtime.  This is moderately expensive. */
+ /* #undef ENABLE_TREE_CHECKING */
+ 
+ /* Define if you want all operations on RTL (the basic data structure
+    of the optimizer and back end) to be checked for dynamic type safety
+    at runtime.  This is quite expensive. */
+ /* #undef ENABLE_RTL_CHECKING */
+ 
+ /* Define if you want the garbage collector to do object poisoning and
+    other memory allocation checks.  This is quite expensive. */
+ /* #undef ENABLE_GC_CHECKING */
+ 
+ /* Define if you want the garbage collector to operate in maximally
+    paranoid mode, validating the entire heap and collecting garbage at
+    every opportunity.  This is extremely expensive. */
+ /* #undef ENABLE_GC_ALWAYS_COLLECT */
+ 
+ /* Define if you want to use __cxa_atexit, rather than atexit, to
+    register C++ destructors for local statics and global objects.
+    This is essential for fully standards-compliant handling of
+    destructors, but requires __cxa_atexit in libc. */
+ /* #undef DEFAULT_USE_CXA_ATEXIT */
+ 
+ /* Define if you want the C and C++ compilers to support multibyte
+    character sets for source code. */
+ /* #undef MULTIBYTE_CHARS */
+ 
+ /* Define if your compiler understands volatile. */
+ #define HAVE_VOLATILE 1
+ 
+ /* Define if your compiler supports the `long double' type. */
+ #define HAVE_LONG_DOUBLE 1
+ 
+ /* Define if your compiler supports the `long long' type. */
+ /* #define HAVE_LONG_LONG 1 */
+ 
+ /* Define if your compiler supports the `__int64' type. */
+ /* #undef HAVE___INT64 */
+ 
+ /* Define if the `_Bool' type is built-in. */
+ /*#define HAVE__BOOL 1*/
+ 
+ /* The number of bytes in type short */
+ #define SIZEOF_SHORT 2
+ 
+ /* The number of bytes in type int */
+ #define SIZEOF_INT 4
+ 
+ /* The number of bytes in type long */
+ #define SIZEOF_LONG 4
+ 
+ /* The number of bytes in type long long */
+ #define SIZEOF_LONG_LONG 8
+ 
+ /* The number of bytes in type __int64 */
+ /* #undef SIZEOF___INT64 */
+ 
+ /* Define if the host execution character set is EBCDIC. */
+ /* #undef HOST_EBCDIC */
+ 
+ /* Always define this when using the GNU C Library */
+ /* #undef _GNU_SOURCE */
+ 
+ /* Define if you have a working <stdbool.h> header file. */
+ /*#define HAVE_STDBOOL_H 1*/
+ 
+ /* Define if you can safely include both <string.h> and <strings.h>. */
+ /* #define STRING_WITH_STRINGS 1*/
+ 
+ /* Define as the number of bits in a byte, if `limits.h' doesn't. */
+ /* #undef CHAR_BIT */
+ 
+ /* Define if the host machine stores words of multi-word integers in
+    big-endian order. */
+ /* #undef HOST_WORDS_BIG_ENDIAN */
+ 
+ /* Define to the floating point format of the host machine, if not IEEE. */
+ /* #undef HOST_FLOAT_FORMAT */
+ 
+ /* Define to 1 if the host machine stores floating point numbers in
+    memory with the word containing the sign bit at the lowest address,
+    or to 0 if it does it the other way around.
+ 
+    This macro should not be defined if the ordering is the same as for
+    multi-word integers. */
+ /* #undef HOST_FLOAT_WORDS_BIG_ENDIAN */
+ 
+ /* Define if you have a working <inttypes.h> header file. */
+ /* #undef HAVE_INTTYPES_H */
+ 
+ /* Define if printf supports %p. */
+ #define HAVE_PRINTF_PTR 1
+ 
+ /* Define to be the last portion of registry key on windows hosts. */
+ #define WIN32_REGISTRY_KEY "3.2.3"
+ 
+ /* Define if your assembler supports .subsection and .subsection -1 starts
+    emitting at the beginning of your section. */
+ /* #undef HAVE_GAS_SUBSECTION_ORDERING */
+ 
+ /* Define if your assembler supports .weak. */
+ /* #undef HAVE_GAS_WEAK */
+ 
+ /* Define if your assembler supports .hidden. */
+ /* #undef HAVE_GAS_HIDDEN */
+ 
+ /* Define if your assembler supports .uleb128. */
+ /* #undef HAVE_AS_LEB128 */
+ 
+ /* Define if your assembler mis-optimizes .eh_frame data. */
+ /* #undef USE_AS_TRADITIONAL_FORMAT */
+ 
+ /* Define if your assembler supports marking sections with SHF_MERGE flag. */
+ /* #undef HAVE_GAS_SHF_MERGE */
+ 
+ /* Define if your assembler supports explicit relocations. */
+ /* #undef HAVE_AS_EXPLICIT_RELOCS */
+ 
+ /* Define if your assembler supports .register. */
+ /* #undef HAVE_AS_REGISTER_PSEUDO_OP */
+ 
+ /* Define if your assembler supports -relax option. */
+ /* #undef HAVE_AS_RELAX_OPTION */
+ 
+ /* Define if your assembler and linker support unaligned PC relative relocs. */
+ /* #undef HAVE_AS_SPARC_UA_PCREL */
+ 
+ /* Define if your assembler and linker support unaligned PC relative relocs against hidden symbols. */
+ /* #undef HAVE_AS_SPARC_UA_PCREL_HIDDEN */
+ 
+ /* Define if your assembler supports offsetable %lo(). */
+ /* #undef HAVE_AS_OFFSETABLE_LO10 */
+ 
+ /* Define true if the assembler supports '.long foo@GOTOFF'. */
+ /* #undef HAVE_AS_GOTOFF_IN_DATA */
+ 
+ /* Define if your assembler supports dwarf2 .file/.loc directives,
+    and preserves file table indices exactly as given. */
+ /* #undef HAVE_AS_DWARF2_DEBUG_LINE */
+ 
+ /* Define if your assembler supports the --gdwarf2 option. */
+ /* #undef HAVE_AS_GDWARF2_DEBUG_FLAG */
+ 
+ /* Define if your assembler supports the --gstabs option. */
+ /* #undef HAVE_AS_GSTABS_DEBUG_FLAG */
+ 
+ /* Define if your linker supports --eh-frame-hdr option. */
+ /* #undef HAVE_LD_EH_FRAME_HDR */
+ 
+ /* Define 0/1 to force the choice for exception handling model. */
+ /* #undef CONFIG_SJLJ_EXCEPTIONS */
+ 
+ 
+ /* Bison unconditionally undefines `const' if neither `__STDC__' nor
+    __cplusplus are defined.  That's a problem since we use `const' in
+    the GCC headers, and the resulting bison code is therefore type
+    unsafe.  Thus, we must match the bison behavior here.  */
+ 
+ #ifndef __STDC__
+ #ifndef __cplusplus
+ /* #undef const */
+ #define const
+ #endif
+ #endif
Index: gcc/gcc/bootstrap.bat
diff -c nul gcc/gcc/bootstrap.bat:1.3
*** nul	Tue Oct 01 16:28:42 2019
--- gcc/gcc/bootstrap.bat	Fri Nov 27 07:05:35 2009
***************
*** 0 ****
--- 1,15 ----
+ call compile
+ copy gccmvs.exe ..\..\zlib\contrib\minizip
+ call compmvs -ansi -pedantic-errors
+ 
+ pushd ..\..\zlib\contrib\minizip
+ call compile
+ del gccmvs.exe
+ call runmvs mini1.jcl temp1.txt
+ call runmvs mini2.jcl temp2.txt
+ popd
+ 
+ call makeutil
+ call runmvs makeutil.jcl makeutil.out
+ del makeutil.jcl
+ call allmvs
Index: gcc/gcc/builtins.c
diff -c gcc/gcc/builtins.c:1.1.1.1 gcc/gcc/builtins.c:1.13
*** gcc/gcc/builtins.c:1.1.1.1	Wed Feb 15 21:22:25 2006
--- gcc/gcc/builtins.c	Tue Nov 07 19:19:57 2017
***************
*** 41,46 ****
--- 41,50 ----
  #include "predict.h"
  #include "tm_p.h"
  #include "target.h"
+ #ifdef S390
+ /* avoid warning */
+ #include "integrate.h"
+ #endif
  
  #define CALLED_AS_BUILT_IN(NODE) \
     (!strncmp (IDENTIFIER_POINTER (DECL_NAME (NODE)), "__builtin_", 10))
***************
*** 343,349 ****
--- 347,357 ----
        if (j > 2 * HOST_BITS_PER_WIDE_INT)
  	abort ();
        if (ch)
+ #ifdef MAP_OUTCHAR
+ 	ch = MAP_OUTCHAR((unsigned char) str[i]) & 0xFF;
+ #else
  	ch = (unsigned char) str[i];
+ #endif
        c[j / HOST_BITS_PER_WIDE_INT] |= ch << (j % HOST_BITS_PER_WIDE_INT);
      }
    return immed_double_const (c[0], c[1], mode);
***************
*** 1962,1967 ****
--- 1970,1976 ----
        len_rtx = expand_expr (len, NULL_RTX, VOIDmode, 0);
        src_str = c_getstr (src);
  
+ #if !TARGET_MVS && !TARGET_CMS
        /* If SRC is a string constant and block move would be done
  	 by pieces, we can avoid loading the string from memory
  	 and only stored the computed constants.  */
***************
*** 1976,1981 ****
--- 1985,1991 ----
  			   (PTR) src_str, dest_align);
  	  return force_operand (XEXP (dest_mem, 0), NULL_RTX);
  	}
+ #endif
  
        src_mem = get_memory_rtx (src);
        set_mem_align (src_mem, src_align);
***************
*** 2015,2020 ****
--- 2025,2038 ----
    if (len == 0)
      return 0;
  
+ #ifdef MAP_OUTCHAR
+   if (compare_tree_int (len, 1) == 0)
+   {
+     char *p = (char *)c_getstr (TREE_VALUE (TREE_CHAIN (arglist)));
+     if (ISPRINT(p[0])) p[0] = MAP_OUTCHAR(p[0]);
+   }
+ #endif
+ 
    len = size_binop (PLUS_EXPR, len, ssize_int (1));
    chainon (arglist, build_tree_list (NULL_TREE, len));
    return expand_expr (build_function_call_expr (fn, arglist),
***************
*** 2077,2082 ****
--- 2095,2108 ----
        if (slen == 0 || TREE_CODE (slen) != INTEGER_CST)
  	return 0;
  
+ #ifdef MAP_OUTCHAR
+       if (compare_tree_int (slen, 1) == 0)
+       {
+         char *p = (char *)c_getstr (TREE_VALUE (TREE_CHAIN (arglist)));
+         if (ISPRINT(p[0])) p[0] = MAP_OUTCHAR(p[0]);
+       }
+ #endif
+ 
        slen = size_binop (PLUS_EXPR, slen, ssize_int (1));
  
        /* We're required to pad with trailing zeros if the requested
***************
*** 3284,3289 ****
--- 3310,3321 ----
    rtx op0;
    rtx result;
  
+ /* This function is generating bad code for MVS,
+    so we just return failure instead. */
+ #if TARGET_MVS
+   return 0;
+ #endif
+ 
    if (!validate_arglist (arglist, INTEGER_TYPE, VOID_TYPE))
      return 0;
  
***************
*** 3368,3379 ****
        }
      case 0: /* length is 1, call fputc.  */
        {
! 	const char *p = c_getstr (TREE_VALUE (arglist));
  
  	if (p != NULL)
  	  {
  	    /* New argument list transforming fputs(string, stream) to
  	       fputc(string[0], stream).  */
  	    arglist =
  	      build_tree_list (NULL_TREE, TREE_VALUE (TREE_CHAIN (arglist)));
  	    arglist =
--- 3400,3414 ----
        }
      case 0: /* length is 1, call fputc.  */
        {
! 	char *p = (char *)c_getstr (TREE_VALUE (arglist));
  
  	if (p != NULL)
  	  {
  	    /* New argument list transforming fputs(string, stream) to
  	       fputc(string[0], stream).  */
+ #ifdef MAP_OUTCHAR
+             if (ISPRINT(p[0])) p[0] = MAP_OUTCHAR(p[0]);
+ #endif
  	    arglist =
  	      build_tree_list (NULL_TREE, TREE_VALUE (TREE_CHAIN (arglist)));
  	    arglist =
***************
*** 3604,3610 ****
    tree arglist = TREE_OPERAND (exp, 1);
    enum built_in_function fcode = DECL_FUNCTION_CODE (fndecl);
  
!   /* Perform postincrements before expanding builtin functions.  */
    emit_queue ();
  
    if (DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_MD)
--- 3639,3645 ----
    tree arglist = TREE_OPERAND (exp, 1);
    enum built_in_function fcode = DECL_FUNCTION_CODE (fndecl);
  
!   /* Perform postincrements before expanding builtin functions. */
    emit_queue ();
  
    if (DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_MD)
Index: gcc/gcc/c-common.c
diff -c gcc/gcc/c-common.c:1.1.1.1 gcc/gcc/c-common.c:1.7
*** gcc/gcc/c-common.c:1.1.1.1	Wed Feb 15 21:22:25 2006
--- gcc/gcc/c-common.c	Wed Dec 12 17:31:29 2007
***************
*** 2853,2858 ****
--- 2853,2866 ----
  #undef DEF_FUNCTION_TYPE_VAR_1
  #undef DEF_POINTER_TYPE
  
+ /* Prevent the name "builtins.def" etc from going to the generated
+    assembler */
+ #ifdef TARGET_MVS
+ #define xxabort (abort)
+ #else
+ #define xxabort abort
+ #endif
+ 
  #define DEF_BUILTIN(ENUM, NAME, CLASS,					\
                      TYPE, LIBTYPE, BOTH_P, FALLBACK_P, NONANSI_P)	\
    if (NAME)								\
***************
*** 2860,2866 ****
        tree decl;							\
  									\
        if (strncmp (NAME, "__builtin_", strlen ("__builtin_")) != 0)	\
! 	abort ();							\
  									\
        if (!BOTH_P)							\
  	decl = builtin_function (NAME, builtin_types[TYPE], ENUM,	\
--- 2868,2874 ----
        tree decl;							\
  									\
        if (strncmp (NAME, "__builtin_", strlen ("__builtin_")) != 0)	\
! 	xxabort ();							\
  									\
        if (!BOTH_P)							\
  	decl = builtin_function (NAME, builtin_types[TYPE], ENUM,	\
***************
*** 3992,3998 ****
--- 4000,4014 ----
  	  /* Given printf("c"), (where c is any one character,)
               convert "c"[0] to an int and pass that to the replacement
               function.  */
+ #ifdef MAP_OUTCHAR
+ 	  { 
+ 	    unsigned x = TREE_STRING_POINTER (stripped_string)[0];
+ 	    if (ISPRINT(x)) x = MAP_OUTCHAR(x);
+ 	    arglist = build_int_2 (x, 0);
+ 	  }
+ #else
  	  arglist = build_int_2 (TREE_STRING_POINTER (stripped_string)[0], 0);
+ #endif
  	  arglist = build_tree_list (NULL_TREE, arglist);
  	  
  	  fn = fn_putchar;
***************
*** 4003,4012 ****
           includes the terminating NULL in its count.  */
        else if (TREE_STRING_LENGTH (stripped_string) > 2
  	       && TREE_STRING_POINTER (stripped_string)
! 	       [TREE_STRING_LENGTH (stripped_string) - 2] == '\n')
          {
  	  /* Create a NULL-terminated string that's one char shorter
! 	     than the original, stripping off the trailing '\n'.  */
  	  const int newlen = TREE_STRING_LENGTH (stripped_string) - 1;
  	  char *newstr = (char *) alloca (newlen);
  	  memcpy (newstr, TREE_STRING_POINTER (stripped_string), newlen - 1);
--- 4019,4028 ----
           includes the terminating NULL in its count.  */
        else if (TREE_STRING_LENGTH (stripped_string) > 2
  	       && TREE_STRING_POINTER (stripped_string)
! 	       [TREE_STRING_LENGTH (stripped_string) - 2] == TARGET_NEWLINE)
          {
  	  /* Create a NULL-terminated string that's one char shorter
! 	     than the original, stripping off the trailing TARGET_NEWLINE.  */
  	  const int newlen = TREE_STRING_LENGTH (stripped_string) - 1;
  	  char *newstr = (char *) alloca (newlen);
  	  memcpy (newstr, TREE_STRING_POINTER (stripped_string), newlen - 1);
***************
*** 4186,4191 ****
--- 4202,4210 ----
  
    /* Mark as "unspecified" (see c_common_post_options).  */
    flag_bounds_check = -1;
+ #if TARGET_MVS
+   flag_no_builtin = 1;
+ #endif
  }
  
  /* Post-switch processing.  */
Index: gcc/gcc/c-lex.c
diff -c gcc/gcc/c-lex.c:1.1.1.1 gcc/gcc/c-lex.c:1.6
*** gcc/gcc/c-lex.c:1.1.1.1	Wed Feb 15 21:22:25 2006
--- gcc/gcc/c-lex.c	Thu Sep 29 02:30:02 2016
***************
*** 1349,1355 ****
  	  else
  	    mask = ~0;
  	  c = cpp_parse_escape (parse_in, &p, limit,
! 				mask, flag_traditional);
  	}
  	
        /* Add this single character into the buffer either as a wchar_t
--- 1349,1355 ----
  	  else
  	    mask = ~0;
  	  c = cpp_parse_escape (parse_in, &p, limit,
! 				mask, flag_traditional, 1);
  	}
  	
        /* Add this single character into the buffer either as a wchar_t
Index: gcc/gcc/c-parse.c
diff -c gcc/gcc/c-parse.c:1.1.1.1 gcc/gcc/c-parse.c:1.3
*** gcc/gcc/c-parse.c:1.1.1.1	Wed Feb 15 21:22:28 2006
--- gcc/gcc/c-parse.c	Tue Oct 31 20:16:46 2006
***************
*** 452,459 ****
--- 452,467 ----
  #define YYUNDEFTOK  2
  #define YYMAXUTOK   323
  
+ #ifdef HOST_EBCDIC
+ #define YYTRANSLATE(YYX) 						\
+   ((unsigned int) (YYX) <= YYMAXUTOK ? \
+   ((unsigned int) (YYX) < 256 ? yytranslate[_sch_ebcasc[YYX]] \
+   : yytranslate[YYX]) : YYUNDEFTOK)
+ #else
  #define YYTRANSLATE(YYX) 						\
    ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
+ #endif
+ 
  
  /* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
  static const unsigned char yytranslate[] =
Index: gcc/gcc/cfgcleanup.c
diff -c gcc/gcc/cfgcleanup.c:1.1.1.1 gcc/gcc/cfgcleanup.c:1.4
*** gcc/gcc/cfgcleanup.c:1.1.1.1	Wed Feb 15 21:22:25 2006
--- gcc/gcc/cfgcleanup.c	Fri Nov 03 18:10:07 2006
***************
*** 59,69 ****
      BB_FORWARDER_BLOCK = 2
  };
  
! #define BB_FLAGS(BB) (enum bb_flags) (BB)->aux
  #define BB_SET_FLAG(BB, FLAG) \
!   (BB)->aux = (void *) (long) ((enum bb_flags) (BB)->aux | (FLAG))
  #define BB_CLEAR_FLAG(BB, FLAG) \
!   (BB)->aux = (void *) (long) ((enum bb_flags) (BB)->aux & ~(FLAG))
  
  #define FORWARDER_BLOCK_P(BB) (BB_FLAGS (BB) & BB_FORWARDER_BLOCK)
  
--- 59,73 ----
      BB_FORWARDER_BLOCK = 2
  };
  
! /* I've no idea why they're mucking around converting
!    between enums and pointers, but it is generating
!    a lot of warnings, and I'm not surprised.  I added
!    a (long) cast to shut it up. */
! #define BB_FLAGS(BB) (enum bb_flags) (long) (BB)->aux
  #define BB_SET_FLAG(BB, FLAG) \
!   (BB)->aux = (void *) (long) ((enum bb_flags) (long) (BB)->aux | (FLAG))
  #define BB_CLEAR_FLAG(BB, FLAG) \
!   (BB)->aux = (void *) (long) ((enum bb_flags) (long) (BB)->aux & ~(FLAG))
  
  #define FORWARDER_BLOCK_P(BB) (BB_FLAGS (BB) & BB_FORWARDER_BLOCK)
  
Index: gcc/gcc/checkgen.bat
diff -c nul gcc/gcc/checkgen.bat:1.3
*** nul	Tue Oct 01 16:28:42 2019
--- gcc/gcc/checkgen.bat	Mon May 25 19:22:18 2009
***************
*** 0 ****
--- 1,4 ----
+ del alljcl.jcl
+ type gencomp.jcl >>alljcl.jcl
+ type checkgen.jcl >>alljcl.jcl
+ call runmvs alljcl.jcl output.txt
Index: gcc/gcc/checkgen.jcl
diff -c nul gcc/gcc/checkgen.jcl:1.3
*** nul	Tue Oct 01 16:28:42 2019
--- gcc/gcc/checkgen.jcl	Sat May 02 15:38:21 2009
***************
*** 0 ****
--- 1,33 ----
+ //GCCGEN   JOB CLASS=C,REGION=0K
+ //*
+ //COMPARE  PROC GCCPREF='GCC',LIB=''
+ //COMPR    EXEC PGM=IEBCOMPR
+ //SYSPRINT DD SYSOUT=*
+ //SYSUT1   DD DSN=&GCCPREF..&LIB,DISP=SHR
+ //SYSUT2   DD DSN=&GCCPREF..&LIB.2,DISP=SHR
+ //SYSIN    DD DUMMY
+ //         PEND
+ //*
+ //DELETE   PROC GCCPREF='GCC'
+ //DEL      EXEC PGM=IEFBR14
+ //DD5      DD DSN=&GCCPREF..SOURCE2,DISP=(MOD,DELETE),
+ //       UNIT=SYSALLDA,SPACE=(TRK,(0))
+ //DD6      DD DSN=&GCCPREF..INCLUDE2,DISP=(MOD,DELETE),
+ //       UNIT=SYSALLDA,SPACE=(TRK,(0))
+ //         PEND
+ //*
+ //*
+ //*
+ //CMP      EXEC COMPARE,LIB='SOURCE'
+ //SYSIN    DD *
+  COMPARE TYPORG=PO
+ /*
+ //*
+ //CMP2     EXEC COMPARE,LIB='INCLUDE'
+ //SYSIN    DD *
+  COMPARE TYPORG=PO
+ /*
+ //*
+ //CLEAN    EXEC DELETE,COND=(4,LT)
+ //*
+ //
Index: gcc/gcc/cload.exec
diff -c nul gcc/gcc/cload.exec:1.6
*** nul	Tue Oct 01 16:28:42 2019
--- gcc/gcc/cload.exec	Thu Jan 22 09:19:01 2009
***************
*** 0 ****
--- 1,7 ----
+ &CONTROL CMS MSG
+ FI SYSIN TERM (LRECL 80 RECFM F
+ FI SYSPRINT TERM (LRECL 80 RECFM F
+ LOAD CLIB &1 (NOAUTO NOLIBE
+ FI SYSIN CLEAR
+ FI SYSPRINT CLEAR
+ &EXIT
Index: gcc/gcc/cmsutil.bat
diff -c nul gcc/gcc/cmsutil.bat:1.5
*** nul	Tue Oct 01 16:28:42 2019
--- gcc/gcc/cmsutil.bat	Fri Nov 27 07:05:35 2009
***************
*** 0 ****
--- 1,14 ----
+ cd ..\..\pdos\pdpclib
+ del *.o
+ copy pdptop.mac backup.mac
+ copy pdp370.mac pdptop.mac
+ make -f makefile.w32
+ cd ..\..\gcc\gcc
+ call compile -DTARGET_CMS
+ call compmvs -DTARGET_CMS -UUSE_MEMMGR -ansi -pedantic-errors
+ copy copyfile.s cpyfil.s
+ m4 -I ../../pdos/pdpclib cmsutil.m4 >cmsutil.txt
+ cd ..\..\pdos\pdpclib
+ copy backup.mac pdptop.mac
+ del backup.mac
+ cd ..\..\gcc\gcc
Index: gcc/gcc/cmsutil.exec
diff -c nul gcc/gcc/cmsutil.exec:1.13
*** nul	Tue Oct 01 16:28:42 2019
--- gcc/gcc/cmsutil.exec	Fri Feb 16 02:54:19 2018
***************
*** 0 ****
--- 1,114 ----
+ *******************************************************************
+ *
+ * This EXEC compiles C & S source loaded from the TDF file
+ * or AWS tape onto the appropriate disks
+ *
+ *
+ *******************************************************************
+ &CONTROL
+ 
+ MACLIB GEN PDPCLIB PDPPRLG PDPEPIL PDPTOP PDPMAIN
+ GLOBAL MACLIB OSMACRO DMSGPI PDPCLIB
+ 
+ 
+ ASSEMBLE CMSSUPA
+ ASSEMBLE CMSSTART
+ ASSEMBLE START
+ ASSEMBLE STDIO
+ ASSEMBLE STDLIB
+ ASSEMBLE CTYPE
+ ASSEMBLE STRING
+ ASSEMBLE TIME
+ ASSEMBLE ERRNO
+ ASSEMBLE ASSERT
+ ASSEMBLE LOCALE
+ ASSEMBLE MATH
+ ASSEMBLE SETJMP
+ ASSEMBLE SIGNAL
+ ASSEMBLE MVSUNZIP
+ ASSEMBLE HEXDUMP
+ ASSEMBLE MVSENDEC
+ ASSEMBLE CPYFIL
+ 
+ &STACK HT
+ LOAD    CMSSTART (NOLIBE NOAUTO
+ INCLUDE START (NOLIBE NOAUTO
+ INCLUDE CMSSUPA (NOLIBE NOAUTO
+ INCLUDE STDIO (NOLIBE NOAUTO
+ INCLUDE STDLIB (NOLIBE NOAUTO
+ INCLUDE CTYPE (NOLIBE NOAUTO
+ INCLUDE STRING (NOLIBE NOAUTO
+ INCLUDE TIME (NOLIBE NOAUTO
+ INCLUDE ERRNO (NOLIBE NOAUTO
+ INCLUDE ASSERT (NOLIBE NOAUTO
+ INCLUDE LOCALE (NOLIBE NOAUTO
+ INCLUDE MATH (NOLIBE NOAUTO
+ INCLUDE SETJMP (NOLIBE NOAUTO
+ INCLUDE SIGNAL (NOLIBE NOAUTO
+ &STACK RT
+ INCLUDE MVSUNZIP (NOLIBE NOAUTO
+ GENMOD MVSUNZIP
+ ERASE LOAD MAP A
+ 
+ &STACK HT
+ LOAD    CMSSTART (NOLIBE NOAUTO
+ INCLUDE START (NOLIBE NOAUTO
+ INCLUDE CMSSUPA (NOLIBE NOAUTO
+ INCLUDE STDIO (NOLIBE NOAUTO
+ INCLUDE STDLIB (NOLIBE NOAUTO
+ INCLUDE CTYPE (NOLIBE NOAUTO
+ INCLUDE STRING (NOLIBE NOAUTO
+ INCLUDE TIME (NOLIBE NOAUTO
+ INCLUDE ERRNO (NOLIBE NOAUTO
+ INCLUDE ASSERT (NOLIBE NOAUTO
+ INCLUDE LOCALE (NOLIBE NOAUTO
+ INCLUDE MATH (NOLIBE NOAUTO
+ INCLUDE SETJMP (NOLIBE NOAUTO
+ INCLUDE SIGNAL (NOLIBE NOAUTO
+ &STACK RT
+ INCLUDE HEXDUMP (NOLIBE NOAUTO
+ GENMOD HEXDUMP
+ ERASE LOAD MAP A
+ 
+ &STACK HT
+ LOAD    CMSSTART (NOLIBE NOAUTO
+ INCLUDE START (NOLIBE NOAUTO
+ INCLUDE CMSSUPA (NOLIBE NOAUTO
+ INCLUDE STDIO (NOLIBE NOAUTO
+ INCLUDE STDLIB (NOLIBE NOAUTO
+ INCLUDE CTYPE (NOLIBE NOAUTO
+ INCLUDE STRING (NOLIBE NOAUTO
+ INCLUDE TIME (NOLIBE NOAUTO
+ INCLUDE ERRNO (NOLIBE NOAUTO
+ INCLUDE ASSERT (NOLIBE NOAUTO
+ INCLUDE LOCALE (NOLIBE NOAUTO
+ INCLUDE MATH (NOLIBE NOAUTO
+ INCLUDE SETJMP (NOLIBE NOAUTO
+ INCLUDE SIGNAL (NOLIBE NOAUTO
+ &STACK RT
+ INCLUDE MVSENDEC (NOLIBE NOAUTO
+ GENMOD MVSENDEC
+ ERASE LOAD MAP A
+ 
+ &STACK HT
+ LOAD    CMSSTART (NOLIBE NOAUTO
+ INCLUDE START (NOLIBE NOAUTO
+ INCLUDE CMSSUPA (NOLIBE NOAUTO
+ INCLUDE STDIO (NOLIBE NOAUTO
+ INCLUDE STDLIB (NOLIBE NOAUTO
+ INCLUDE CTYPE (NOLIBE NOAUTO
+ INCLUDE STRING (NOLIBE NOAUTO
+ INCLUDE TIME (NOLIBE NOAUTO
+ INCLUDE ERRNO (NOLIBE NOAUTO
+ INCLUDE ASSERT (NOLIBE NOAUTO
+ INCLUDE LOCALE (NOLIBE NOAUTO
+ INCLUDE MATH (NOLIBE NOAUTO
+ INCLUDE SETJMP (NOLIBE NOAUTO
+ INCLUDE SIGNAL (NOLIBE NOAUTO
+ &STACK RT
+ INCLUDE CPYFIL (NOLIBE NOAUTO
+ GENMOD CPYFIL
+ ERASE LOAD MAP A
+ 
+ ERASE * LISTING A
+ ERASE * TEXT A
Index: gcc/gcc/cmsutil.m4
diff -c nul gcc/gcc/cmsutil.m4:1.9
*** nul	Tue Oct 01 16:28:42 2019
--- gcc/gcc/cmsutil.m4	Tue Dec 29 19:59:00 2015
***************
*** 0 ****
--- 1,48 ----
+ :READ  PDPTOP   COPY     A
+ undivert(pdp370.mac)dnl
+ :READ  PDPMAIN  COPY    A
+ undivert(pdpmain.mac)dnl
+ :READ  PDPPRLG  MACRO    A
+ undivert(pdpprlg.mac)dnl
+ :READ  PDPEPIL  MACRO    A
+ undivert(pdpepil.mac)dnl
+ :READ  CMSSTART ASSEMBLE A
+ undivert(cmsstart.asm)dnl
+ :READ  CMSSUPA  ASSEMBLE A
+ undivert(cmssupa.asm)dnl
+ :READ  START    ASSEMBLE A
+ undivert(start.s)dnl
+ :READ  STDIO    ASSEMBLE A
+ undivert(stdio.s)dnl
+ :READ  STDLIB   ASSEMBLE A
+ undivert(stdlib.s)dnl
+ :READ  CTYPE    ASSEMBLE A
+ undivert(ctype.s)dnl
+ :READ  STRING   ASSEMBLE A
+ undivert(string.s)dnl
+ :READ  TIME     ASSEMBLE A
+ undivert(time.s)dnl
+ :READ  ERRNO    ASSEMBLE A
+ undivert(errno.s)dnl
+ :READ  ASSERT   ASSEMBLE A
+ undivert(assert.s)dnl
+ :READ  LOCALE   ASSEMBLE A
+ undivert(locale.s)dnl
+ :READ  MATH     ASSEMBLE A
+ undivert(math.s)dnl
+ :READ  SETJMP   ASSEMBLE A
+ undivert(setjmp.s)dnl
+ :READ  SIGNAL   ASSEMBLE A
+ undivert(signal.s)dnl
+ :READ  MVSUNZIP ASSEMBLE A
+ undivert(mvsunzip.s)dnl
+ :READ  HEXDUMP  ASSEMBLE A
+ undivert(hexdump.s)dnl
+ :READ  MVSENDEC ASSEMBLE A
+ undivert(mvsendec.s)dnl
+ :READ  CPYFIL   ASSEMBLE A
+ undivert(cpyfil.s)dnl
+ :READ  CMSUTIL  EXEC     A
+ undivert(cmsutil.exec)dnl
+ :READ  RUNSPOOL EXEC     A
+ undivert(runspool.exec)dnl
Index: gcc/gcc/combine.c
diff -c gcc/gcc/combine.c:1.1.1.1 gcc/gcc/combine.c:1.2
*** gcc/gcc/combine.c:1.1.1.1	Wed Feb 15 21:22:25 2006
--- gcc/gcc/combine.c	Sat Nov 10 09:59:45 2007
***************
*** 314,321 ****
  {
    struct undo *next;
    int is_int;
!   union {rtx r; unsigned int i;} old_contents;
!   union {rtx *r; unsigned int *i;} where;
  };
  
  /* Record a bunch of changes to be undone, up to MAX_UNDO of them.
--- 314,321 ----
  {
    struct undo *next;
    int is_int;
!   union {rtx r; int i;} old_contents;
!   union {rtx *r; int *i;} where;
  };
  
  /* Record a bunch of changes to be undone, up to MAX_UNDO of them.
***************
*** 339,346 ****
  static int n_occurrences;
  
  static void do_SUBST			PARAMS ((rtx *, rtx));
! static void do_SUBST_INT		PARAMS ((unsigned int *,
! 						 unsigned int));
  static void init_reg_last_arrays	PARAMS ((void));
  static void setup_incoming_promotions   PARAMS ((void));
  static void set_nonzero_bits_and_sign_copies  PARAMS ((rtx, rtx, void *));
--- 339,346 ----
  static int n_occurrences;
  
  static void do_SUBST			PARAMS ((rtx *, rtx));
! static void do_SUBST_INT		PARAMS ((int *,
! 						 int));
  static void init_reg_last_arrays	PARAMS ((void));
  static void setup_incoming_promotions   PARAMS ((void));
  static void set_nonzero_bits_and_sign_copies  PARAMS ((rtx, rtx, void *));
***************
*** 472,481 ****
  
  static void
  do_SUBST_INT (into, newval)
!      unsigned int *into, newval;
  {
    struct undo *buf;
!   unsigned int oldval = *into;
  
    if (oldval == newval)
      return;
--- 472,481 ----
  
  static void
  do_SUBST_INT (into, newval)
!      int *into, newval;
  {
    struct undo *buf;
!   int oldval = *into;
  
    if (oldval == newval)
      return;
Index: gcc/gcc/comp386.bat
diff -c nul gcc/gcc/comp386.bat:1.14
*** nul	Tue Oct 01 16:28:43 2019
--- gcc/gcc/comp386.bat	Tue Sep 10 18:02:31 2019
***************
*** 0 ****
--- 1,526 ----
+ del *.s
+ del *.o
+ del temp.a
+ del gcc-pdos.exe
+ 
+ call stdcompi alias.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi attribs.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi bb-reorder.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi bitmap.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi builtins.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi c-aux-info.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi c-common.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi c-convert.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi c-decl.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi c-errors.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi c-format.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi c-lang.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi c-lex.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi c-objc-common.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi c-parse.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi c-pragma.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi c-semantics.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi c-typeck.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi caller-save.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi calls.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi cfg.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi cfganal.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi cfgbuild.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi cfgcleanup.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi cfglayout.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi cfgloop.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi cfgrtl.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi combine.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi conflict.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi convert.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi cppdefault.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi cpperror.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi cppexp.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi cppfiles.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi cpphash.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi cppinit.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi cpplex.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi cpplib.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi cppmacro.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi cppmain.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi cppspec.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi cse.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi cselib.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi debug.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi dependence.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi df.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi diagnostic.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi dominance.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi dwarf2asm.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi dwarf2out.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi emit-rtl.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi except.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi explow.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi expmed.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi expr.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi final.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi flow.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi fold-const.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi function.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi gcc.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi gccspec.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi gcse.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi genrtl.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi ggc-common.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi ggc-page.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi global.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi graph.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi hash.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi haifa-sched.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi hashtable.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi hooks.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi ifcvt.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi insn-attrtab.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi insn-emit.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi insn-extract.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi insn-opinit.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi insn-output.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi insn-peep.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi insn-recog.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi integrate.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi jump.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi langhooks.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi lcm.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi line-map.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi lists.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi local-alloc.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi loop.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi mkdeps.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi optabs.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi params.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi predict.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi prefix.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi print-rtl.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi print-tree.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi profile.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi real.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi recog.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi regclass.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi regmove.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi regrename.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi reload.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi reload1.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi resource.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi rtl-error.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi rtl.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi rtlanal.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi sbitmap.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi sched-deps.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi sched-rgn.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi sched-vis.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi sibcall.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi simplify-rtx.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi ssa-ccp.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi ssa-dce.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi ssa.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi stmt.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi stor-layout.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi stringpool.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi timevar.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi toplev.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi tree-dump.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi tree-inline.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi tree.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi unroll.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi varasm.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi varray.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi version.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ 
+ call stdcompi ../libiberty/xmalloc.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi ../libiberty/xstrerror.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi ../libiberty/xstrdup.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi ../libiberty/xexit.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi ../libiberty/concat.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi ../libiberty/hex.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi ../libiberty/alloca.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi ../libiberty/lbasename.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi ../libiberty/obstack.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi ../libiberty/strsignal.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi ../libiberty/safe-ctype.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi ../libiberty/splay-tree.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi ../libiberty/fibheap.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi ../libiberty/hashtab.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi ../libiberty/asprintf.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi ../libiberty/vasprintf.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi ../libiberty/getpagesize.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi ../libiberty/partition.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ 
+ call stdcompi config/i386/i386.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ 
+ call stdcompi unixio.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ 
+ call stdcompi reg-stack.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi doloop.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi sdbout.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi dbxout.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi ../libiberty/md5.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ 
+ call stdcompi ../../pdos/pdpclib/stdio.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi ../../pdos/pdpclib/stdlib.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi ../../pdos/pdpclib/ctype.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi ../../pdos/pdpclib/string.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi ../../pdos/pdpclib/time.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi ../../pdos/pdpclib/errno.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi ../../pdos/pdpclib/assert.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi ../../pdos/pdpclib/locale.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi ../../pdos/pdpclib/math.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi ../../pdos/pdpclib/setjmp.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi ../../pdos/pdpclib/signal.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi ../../pdos/pdpclib/start.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi ../../pdos/pdpclib/__memmgr.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi ../../pdos/pdpclib/liballoc.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ 
+ call stdcompi ../../pdos/pdpclib/pdosst32.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi ../../pdos/pdpclib/pdossupc.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompi ../../pdos/src/pos.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ 
+ as386 -o alias.o alias.s
+ as386 -o alloca.o alloca.s
+ as386 -o asprintf.o asprintf.s
+ as386 -o assert.o assert.s
+ as386 -o attribs.o attribs.s
+ as386 -o bb-reorder.o bb-reorder.s
+ as386 -o bitmap.o bitmap.s
+ as386 -o builtins.o builtins.s
+ as386 -o c-aux-info.o c-aux-info.s
+ as386 -o c-common.o c-common.s
+ as386 -o c-convert.o c-convert.s
+ as386 -o c-decl.o c-decl.s
+ as386 -o c-errors.o c-errors.s
+ as386 -o c-format.o c-format.s
+ as386 -o c-lang.o c-lang.s
+ as386 -o c-lex.o c-lex.s
+ as386 -o c-objc-common.o c-objc-common.s
+ as386 -o c-parse.o c-parse.s
+ as386 -o c-pragma.o c-pragma.s
+ as386 -o c-semantics.o c-semantics.s
+ as386 -o c-typeck.o c-typeck.s
+ as386 -o caller-save.o caller-save.s
+ as386 -o calls.o calls.s
+ as386 -o cfg.o cfg.s
+ as386 -o cfganal.o cfganal.s
+ as386 -o cfgbuild.o cfgbuild.s
+ as386 -o cfgcleanup.o cfgcleanup.s
+ as386 -o cfglayout.o cfglayout.s
+ as386 -o cfgloop.o cfgloop.s
+ as386 -o cfgrtl.o cfgrtl.s
+ as386 -o combine.o combine.s
+ as386 -o concat.o concat.s
+ as386 -o conflict.o conflict.s
+ as386 -o convert.o convert.s
+ as386 -o cppdefault.o cppdefault.s
+ as386 -o cpperror.o cpperror.s
+ as386 -o cppexp.o cppexp.s
+ as386 -o cppfiles.o cppfiles.s
+ as386 -o cpphash.o cpphash.s
+ as386 -o cppinit.o cppinit.s
+ as386 -o cpplex.o cpplex.s
+ as386 -o cpplib.o cpplib.s
+ as386 -o cppmacro.o cppmacro.s
+ as386 -o cppmain.o cppmain.s
+ as386 -o cppspec.o cppspec.s
+ as386 -o cse.o cse.s
+ as386 -o cselib.o cselib.s
+ as386 -o ctype.o ctype.s
+ as386 -o dbxout.o dbxout.s
+ as386 -o debug.o debug.s
+ as386 -o dependence.o dependence.s
+ as386 -o df.o df.s
+ as386 -o diagnostic.o diagnostic.s
+ as386 -o doloop.o doloop.s
+ as386 -o dominance.o dominance.s
+ as386 -o dwarf2asm.o dwarf2asm.s
+ as386 -o dwarf2out.o dwarf2out.s
+ as386 -o emit-rtl.o emit-rtl.s
+ as386 -o errno.o errno.s
+ as386 -o except.o except.s
+ as386 -o explow.o explow.s
+ as386 -o expmed.o expmed.s
+ as386 -o expr.o expr.s
+ as386 -o fibheap.o fibheap.s
+ as386 -o final.o final.s
+ as386 -o flow.o flow.s
+ as386 -o fold-const.o fold-const.s
+ as386 -o function.o function.s
+ as386 -o gcc.o gcc.s
+ as386 -o gccspec.o gccspec.s
+ as386 -o gcse.o gcse.s
+ as386 -o genrtl.o genrtl.s
+ as386 -o getpagesize.o getpagesize.s
+ as386 -o ggc-common.o ggc-common.s
+ as386 -o ggc-page.o ggc-page.s
+ as386 -o global.o global.s
+ as386 -o graph.o graph.s
+ as386 -o haifa-sched.o haifa-sched.s
+ as386 -o hash.o hash.s
+ as386 -o hashtab.o hashtab.s
+ as386 -o hashtable.o hashtable.s
+ as386 -o hex.o hex.s
+ as386 -o hooks.o hooks.s
+ as386 -o i386.o i386.s
+ as386 -o ifcvt.o ifcvt.s
+ as386 -o insn-attrtab.o insn-attrtab.s
+ as386 -o insn-emit.o insn-emit.s
+ as386 -o insn-extract.o insn-extract.s
+ as386 -o insn-opinit.o insn-opinit.s
+ as386 -o insn-output.o insn-output.s
+ as386 -o insn-peep.o insn-peep.s
+ as386 -o insn-recog.o insn-recog.s
+ as386 -o integrate.o integrate.s
+ as386 -o jump.o jump.s
+ as386 -o langhooks.o langhooks.s
+ as386 -o lbasename.o lbasename.s
+ as386 -o lcm.o lcm.s
+ as386 -o line-map.o line-map.s
+ as386 -o lists.o lists.s
+ as386 -o local-alloc.o local-alloc.s
+ as386 -o locale.o locale.s
+ as386 -o loop.o loop.s
+ as386 -o math.o math.s
+ as386 -o md5.o md5.s
+ as386 -o mkdeps.o mkdeps.s
+ as386 -o obstack.o obstack.s
+ as386 -o optabs.o optabs.s
+ as386 -o params.o params.s
+ as386 -o partition.o partition.s
+ as386 -o predict.o predict.s
+ as386 -o prefix.o prefix.s
+ as386 -o print-rtl.o print-rtl.s
+ as386 -o print-tree.o print-tree.s
+ as386 -o profile.o profile.s
+ as386 -o real.o real.s
+ as386 -o recog.o recog.s
+ as386 -o reg-stack.o reg-stack.s
+ as386 -o regclass.o regclass.s
+ as386 -o regmove.o regmove.s
+ as386 -o regrename.o regrename.s
+ as386 -o reload.o reload.s
+ as386 -o reload1.o reload1.s
+ as386 -o resource.o resource.s
+ as386 -o rtl-error.o rtl-error.s
+ as386 -o rtl.o rtl.s
+ as386 -o rtlanal.o rtlanal.s
+ as386 -o safe-ctype.o safe-ctype.s
+ as386 -o sbitmap.o sbitmap.s
+ as386 -o sched-deps.o sched-deps.s
+ as386 -o sched-rgn.o sched-rgn.s
+ as386 -o sched-vis.o sched-vis.s
+ as386 -o sdbout.o sdbout.s
+ as386 -o setjmp.o setjmp.s
+ as386 -o sibcall.o sibcall.s
+ as386 -o signal.o signal.s
+ as386 -o simplify-rtx.o simplify-rtx.s
+ as386 -o splay-tree.o splay-tree.s
+ as386 -o ssa-ccp.o ssa-ccp.s
+ as386 -o ssa-dce.o ssa-dce.s
+ as386 -o ssa.o ssa.s
+ as386 -o start.o start.s
+ as386 -o stdio.o stdio.s
+ as386 -o stdlib.o stdlib.s
+ as386 -o stmt.o stmt.s
+ as386 -o stor-layout.o stor-layout.s
+ as386 -o string.o string.s
+ as386 -o stringpool.o stringpool.s
+ as386 -o strsignal.o strsignal.s
+ as386 -o time.o time.s
+ as386 -o timevar.o timevar.s
+ as386 -o toplev.o toplev.s
+ as386 -o tree-dump.o tree-dump.s
+ as386 -o tree-inline.o tree-inline.s
+ as386 -o tree.o tree.s
+ as386 -o unixio.o unixio.s
+ as386 -o unroll.o unroll.s
+ as386 -o varasm.o varasm.s
+ as386 -o varray.o varray.s
+ as386 -o vasprintf.o vasprintf.s
+ as386 -o version.o version.s
+ as386 -o xexit.o xexit.s
+ as386 -o xmalloc.o xmalloc.s
+ as386 -o xstrdup.o xstrdup.s
+ as386 -o xstrerror.o xstrerror.s
+ as386 -o __memmgr.o __memmgr.s
+ as386 -o liballoc.o liballoc.s
+ 
+ as386 -o pdosst32.o pdosst32.s
+ as386 -o pdossupc.o pdossupc.s
+ as386 -o pos.o pos.s
+ as386 -o support.o ../../pdos/src/support.s
+ 
+ ar386 r temp.a alias.o
+ ar386 r temp.a alloca.o
+ ar386 r temp.a asprintf.o
+ ar386 r temp.a assert.o
+ ar386 r temp.a attribs.o
+ ar386 r temp.a bb-reorder.o
+ ar386 r temp.a bitmap.o
+ ar386 r temp.a builtins.o
+ ar386 r temp.a c-aux-info.o
+ ar386 r temp.a c-common.o
+ ar386 r temp.a c-convert.o
+ ar386 r temp.a c-decl.o
+ ar386 r temp.a c-errors.o
+ ar386 r temp.a c-format.o
+ ar386 r temp.a c-lang.o
+ ar386 r temp.a c-lex.o
+ ar386 r temp.a c-objc-common.o
+ ar386 r temp.a c-parse.o
+ ar386 r temp.a c-pragma.o
+ ar386 r temp.a c-semantics.o
+ ar386 r temp.a c-typeck.o
+ ar386 r temp.a caller-save.o
+ ar386 r temp.a calls.o
+ ar386 r temp.a cfg.o
+ ar386 r temp.a cfganal.o
+ ar386 r temp.a cfgbuild.o
+ ar386 r temp.a cfgcleanup.o
+ ar386 r temp.a cfglayout.o
+ ar386 r temp.a cfgloop.o
+ ar386 r temp.a cfgrtl.o
+ ar386 r temp.a combine.o
+ ar386 r temp.a concat.o
+ ar386 r temp.a conflict.o
+ ar386 r temp.a convert.o
+ ar386 r temp.a cppdefault.o
+ ar386 r temp.a cpperror.o
+ ar386 r temp.a cppexp.o
+ ar386 r temp.a cppfiles.o
+ ar386 r temp.a cpphash.o
+ ar386 r temp.a cppinit.o
+ ar386 r temp.a cpplex.o
+ ar386 r temp.a cpplib.o
+ ar386 r temp.a cppmacro.o
+ ar386 r temp.a cppmain.o
+ ar386 r temp.a cppspec.o
+ ar386 r temp.a cse.o
+ ar386 r temp.a cselib.o
+ ar386 r temp.a ctype.o
+ ar386 r temp.a dbxout.o
+ ar386 r temp.a debug.o
+ ar386 r temp.a dependence.o
+ ar386 r temp.a df.o
+ ar386 r temp.a diagnostic.o
+ ar386 r temp.a doloop.o
+ ar386 r temp.a dominance.o
+ ar386 r temp.a dwarf2asm.o
+ ar386 r temp.a dwarf2out.o
+ ar386 r temp.a emit-rtl.o
+ ar386 r temp.a errno.o
+ ar386 r temp.a except.o
+ ar386 r temp.a explow.o
+ ar386 r temp.a expmed.o
+ ar386 r temp.a expr.o
+ ar386 r temp.a fibheap.o
+ ar386 r temp.a final.o
+ ar386 r temp.a flow.o
+ ar386 r temp.a fold-const.o
+ ar386 r temp.a function.o
+ ar386 r temp.a gcc.o
+ ar386 r temp.a gccspec.o
+ ar386 r temp.a gcse.o
+ ar386 r temp.a genrtl.o
+ ar386 r temp.a getpagesize.o
+ ar386 r temp.a ggc-common.o
+ ar386 r temp.a ggc-page.o
+ ar386 r temp.a global.o
+ ar386 r temp.a graph.o
+ ar386 r temp.a haifa-sched.o
+ ar386 r temp.a hash.o
+ ar386 r temp.a hashtab.o
+ ar386 r temp.a hashtable.o
+ ar386 r temp.a hex.o
+ ar386 r temp.a hooks.o
+ ar386 r temp.a i386.o
+ ar386 r temp.a ifcvt.o
+ ar386 r temp.a insn-attrtab.o
+ ar386 r temp.a insn-emit.o
+ ar386 r temp.a insn-extract.o
+ ar386 r temp.a insn-opinit.o
+ ar386 r temp.a insn-output.o
+ ar386 r temp.a insn-peep.o
+ ar386 r temp.a insn-recog.o
+ ar386 r temp.a integrate.o
+ ar386 r temp.a jump.o
+ ar386 r temp.a langhooks.o
+ ar386 r temp.a lbasename.o
+ ar386 r temp.a lcm.o
+ ar386 r temp.a line-map.o
+ ar386 r temp.a lists.o
+ ar386 r temp.a local-alloc.o
+ ar386 r temp.a locale.o
+ ar386 r temp.a loop.o
+ ar386 r temp.a math.o
+ ar386 r temp.a md5.o
+ ar386 r temp.a mkdeps.o
+ ar386 r temp.a obstack.o
+ ar386 r temp.a optabs.o
+ ar386 r temp.a params.o
+ ar386 r temp.a partition.o
+ ar386 r temp.a pdossupc.o
+ ar386 r temp.a pos.o
+ ar386 r temp.a predict.o
+ ar386 r temp.a prefix.o
+ ar386 r temp.a print-rtl.o
+ ar386 r temp.a print-tree.o
+ ar386 r temp.a profile.o
+ ar386 r temp.a real.o
+ ar386 r temp.a recog.o
+ ar386 r temp.a reg-stack.o
+ ar386 r temp.a regclass.o
+ ar386 r temp.a regmove.o
+ ar386 r temp.a regrename.o
+ ar386 r temp.a reload.o
+ ar386 r temp.a reload1.o
+ ar386 r temp.a resource.o
+ ar386 r temp.a rtl-error.o
+ ar386 r temp.a rtl.o
+ ar386 r temp.a rtlanal.o
+ ar386 r temp.a safe-ctype.o
+ ar386 r temp.a sbitmap.o
+ ar386 r temp.a sched-deps.o
+ ar386 r temp.a sched-rgn.o
+ ar386 r temp.a sched-vis.o
+ ar386 r temp.a sdbout.o
+ ar386 r temp.a setjmp.o
+ ar386 r temp.a sibcall.o
+ ar386 r temp.a signal.o
+ ar386 r temp.a simplify-rtx.o
+ ar386 r temp.a splay-tree.o
+ ar386 r temp.a ssa-ccp.o
+ ar386 r temp.a ssa-dce.o
+ ar386 r temp.a ssa.o
+ ar386 r temp.a start.o
+ ar386 r temp.a stdio.o
+ ar386 r temp.a stdlib.o
+ ar386 r temp.a stmt.o
+ ar386 r temp.a stor-layout.o
+ ar386 r temp.a string.o
+ ar386 r temp.a stringpool.o
+ ar386 r temp.a strsignal.o
+ ar386 r temp.a support.o
+ ar386 r temp.a time.o
+ ar386 r temp.a timevar.o
+ ar386 r temp.a toplev.o
+ ar386 r temp.a tree-dump.o
+ ar386 r temp.a tree-inline.o
+ ar386 r temp.a tree.o
+ ar386 r temp.a unixio.o
+ ar386 r temp.a unroll.o
+ ar386 r temp.a varasm.o
+ ar386 r temp.a varray.o
+ ar386 r temp.a vasprintf.o
+ ar386 r temp.a version.o
+ ar386 r temp.a xexit.o
+ ar386 r temp.a xmalloc.o
+ ar386 r temp.a xstrdup.o
+ ar386 r temp.a xstrerror.o
+ ar386 r temp.a __memmgr.o
+ ar386 r temp.a liballoc.o
+ 
+ ld386 -s -e ___pdosst32 -o gcc-pdos.exe pdosst32.o temp.a
+ ld386 -r -s -e ___pdosst32 -o gcc-pdos.exe pdosst32.o temp.a
+ strip386 --strip-unneeded gcc-pdos.exe
Index: gcc/gcc/compile
diff -c nul gcc/gcc/compile:1.7
*** nul	Tue Oct 01 16:28:43 2019
--- gcc/gcc/compile	Fri Jun 26 08:07:53 2009
***************
*** 0 ****
--- 1,162 ----
+ #/bin/sh
+ 
+ rm gccmvs
+ rm *.o
+ 
+ FILES="
+   alias
+   attribs
+   bb-reorder
+   bitmap
+   builtins
+   c-aux-info
+   c-common
+   c-convert
+   c-decl
+   c-errors
+   c-format
+   c-lang
+   c-lex
+   c-objc-common
+   c-parse
+   c-pragma
+   c-semantics
+   c-typeck
+   caller-save
+   calls
+   cfg
+   cfganal
+   cfgbuild
+   cfgcleanup
+   cfglayout
+   cfgloop
+   cfgrtl
+   combine
+   conflict
+   convert
+   cppdefault
+   cpperror
+   cppexp
+   cppfiles
+   cpphash
+   cppinit
+   cpplex
+   cpplib
+   cppmacro
+   cppmain
+   cppspec
+   cse
+   cselib
+   debug
+   dependence
+   df
+   diagnostic
+   dominance
+   dwarf2asm
+   dwarf2out
+   emit-rtl
+   except
+   explow
+   expmed
+   expr
+   final
+   flow
+   fold-const
+   function
+   gcc
+   gccspec
+   gcse
+   genrtl
+   ggc-common
+   ggc-page
+   global
+   graph
+   hash
+   hashtable
+   hooks
+   ifcvt
+   insn-attrtab
+   insn-emit
+   insn-extract
+   insn-opinit
+   insn-output
+   insn-recog
+   integrate
+   jump
+   langhooks
+   lcm
+   line-map
+   lists
+   local-alloc
+   loop
+   mkdeps
+   optabs
+   params
+   predict
+   prefix
+   print-rtl
+   print-tree
+   profile
+   real
+   recog
+   regclass
+   regmove
+   regrename
+   reload
+   reload1
+   resource
+   rtl-error
+   rtl
+   rtlanal
+   sbitmap
+   sibcall
+   simplify-rtx
+   ssa-ccp
+   ssa-dce
+   ssa
+   stmt
+   stor-layout
+   stringpool
+   timevar
+   toplev
+   tree-dump
+   tree-inline
+   tree
+   unroll
+   varasm
+   varray
+   version
+   ../libiberty/xmalloc
+   ../libiberty/xstrerror
+   ../libiberty/xstrdup
+   ../libiberty/xexit
+   ../libiberty/concat
+   ../libiberty/hex
+   ../libiberty/alloca
+   ../libiberty/lbasename
+   ../libiberty/obstack
+   ../libiberty/strsignal
+   ../libiberty/safe-ctype
+   ../libiberty/splay-tree
+   ../libiberty/fibheap
+   ../libiberty/hashtab
+   ../libiberty/asprintf
+   ../libiberty/vasprintf
+   ../libiberty/getpagesize
+   ../libiberty/partition
+   config/i370/i370-c
+   config/i370/i370
+   unixio
+   "
+ for file in $FILES
+ 
+ do
+ 
+ echo "Compiling - $file"
+ gcc -nostdinc -O2 -c -ansi -pedantic-errors -DHAVE_CONFIG_H -DIN_GCC -DPUREISO $* -I ../../pdos/pdpclib -I . -I config/i370 -I ../include $file.c
+ 
+ done
+ 
+ gcc -nostdlib -o gccmvs *.o ../../pdos/pdpclib/pdplinux.a -lgcc
+ 
+ exit
Index: gcc/gcc/compile.bat
diff -c nul gcc/gcc/compile.bat:1.8
*** nul	Tue Oct 01 16:28:43 2019
--- gcc/gcc/compile.bat	Mon Feb 11 21:09:43 2019
***************
*** 0 ****
--- 1,156 ----
+ del gccmvs.exe
+ del *.obj
+ del *.o
+ 
+ call stdcomp alias.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp attribs.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp bb-reorder.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp bitmap.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp builtins.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp c-aux-info.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp c-common.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp c-convert.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp c-decl.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp c-errors.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp c-format.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp c-lang.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp c-lex.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp c-objc-common.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp c-parse.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp c-pragma.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp c-semantics.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp c-typeck.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp caller-save.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp calls.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp cfg.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp cfganal.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp cfgbuild.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp cfgcleanup.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp cfglayout.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp cfgloop.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp cfgrtl.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp combine.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp conflict.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp convert.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp cppdefault.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp cpperror.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp cppexp.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp cppfiles.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp cpphash.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp cppinit.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp cpplex.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp cpplib.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp cppmacro.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp cppmain.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp cppspec.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp cse.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp cselib.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp debug.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp dependence.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp df.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp diagnostic.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp dominance.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp dwarf2asm.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp dwarf2out.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp emit-rtl.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp except.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp explow.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp expmed.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp expr.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp final.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp flow.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp fold-const.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp function.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp gcc.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp gccspec.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp gcse.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp genrtl.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp ggc-common.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp ggc-page.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp global.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp graph.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp hash.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp hashtable.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp hooks.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp ifcvt.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp insn-attrtab.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp insn-emit.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp insn-extract.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp insn-opinit.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp insn-output.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp insn-recog.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp integrate.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp jump.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp langhooks.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp lcm.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp line-map.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp lists.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp local-alloc.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp loop.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp mkdeps.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp optabs.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp params.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp predict.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp prefix.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp print-rtl.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp print-tree.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp profile.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp real.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp recog.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp regclass.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp regmove.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp regrename.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp reload.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp reload1.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp resource.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp rtl-error.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp rtl.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp rtlanal.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp sbitmap.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp sibcall.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp simplify-rtx.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp ssa-ccp.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp ssa-dce.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp ssa.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp stmt.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp stor-layout.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp stringpool.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp timevar.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp toplev.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp tree-dump.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp tree-inline.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp tree.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp unroll.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp varasm.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp varray.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp version.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ 
+ call stdcomp ..\libiberty\xmalloc.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp ..\libiberty\xstrerror.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp ..\libiberty\xstrdup.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp ..\libiberty\xexit.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp ..\libiberty\concat.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp ..\libiberty\hex.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp ..\libiberty\alloca.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp ..\libiberty\lbasename.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp ..\libiberty\obstack.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp ..\libiberty\strsignal.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp ..\libiberty\safe-ctype.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp ..\libiberty\splay-tree.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp ..\libiberty\fibheap.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp ..\libiberty\hashtab.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp ..\libiberty\asprintf.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp ..\libiberty\vasprintf.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp ..\libiberty\getpagesize.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp ..\libiberty\partition.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ 
+ call stdcomp config\i370\i370-c.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp config\i370\i370.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ 
+ call stdcomp unixio.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ 
+ rem bcc32 -w- -A -egccmvs.exe *.obj
+ rem wcl386 -zq -e=1 -za -w- -fe=gccmvs.exe *.obj
+ rem cl /Fegccmvs.exe *.obj
+ rem gcc -s -o gccmvs.exe *.o
+ gcc -s -nostdlib -o gccmvs.exe *.o ../../pdos/pdpclib/pdpwin32.a -lkernel32
Index: gcc/gcc/compile.exec
diff -c nul gcc/gcc/compile.exec:1.13
*** nul	Tue Oct 01 16:28:43 2019
--- gcc/gcc/compile.exec	Sat May 26 17:23:36 2018
***************
*** 0 ****
--- 1,169 ----
+ &TRACE OFF
+ 
+ * Usage - COMPILE <SRC> <EXE> <WORK>
+ 
+ * This script compiles all the files on SRC disk (default is A)
+ * and copies the resultant modules to the EXE disk (default B)
+ * while using the WORK disk (default C) as a temporary area
+ 
+ &SRC = A
+ &EXE = B
+ &WORK = C
+ 
+ * Set this if you want to build a 370 version of PDPCLIB
+ * so that your executables are maximally portable. Set
+ * to 390 or 380 otherwise. Note that if you set to 380
+ * you should also change stdpdp.parm to define USE_MEMMGR
+ &BLD = 370
+ 
+ * Set this to 1 if you have a pure 370 environment (ie
+ * not z/VM and not VM/380) so can't do 31-bit compiles
+ &ALL370 = 0
+ 
+ &IF &INDEX EQ 0 &GOTO -FINARGS
+ &SRC = &1
+ &ARGS &2 &3 &4 &5 &6 &7 &8 &9
+ 
+ &IF &INDEX EQ 0 &GOTO -FINARGS
+ &EXE = &1
+ &ARGS &2 &3 &4 &5 &6 &7 &8 &9
+ 
+ &IF &INDEX EQ 0 &GOTO -FINARGS
+ &WORK = &1
+ 
+ -FINARGS
+ 
+ 
+ &IF &SRC EQ &WORK &GOTO -NOERASE
+ * Erase the work disk and avoid errors by copying
+ * a dummy file
+ COPY PDPTOP MAC &SRC = = &WORK (REPL
+ LIST * * &WORK (EXEC
+ EXEC CMS ERASE
+ -NOERASE
+ 
+ COPY PDPTOP MAC &SRC = COPY = (REPL LRECL 80 RECFM F
+ COPY PDPMAIN MAC &SRC = COPY = (REPL LRECL 80 RECFM F
+ COPY PDPPRLG MAC &SRC = MACRO = (REPL LRECL 80 RECFM F
+ COPY PDPEPIL MAC &SRC = MACRO = (REPL LRECL 80 RECFM F
+ COPY __HEADER H &SRC HEADER GCC &SRC (REPL
+ 
+ MACLIB GEN PDPCLIB PDPPRLG PDPEPIL PDPTOP PDPMAIN
+ GLOBAL MACLIB PDPCLIB OSMACRO DMSGPI
+ 
+ * Pass 1
+ EXEC GCCAALL &SRC
+ EXEC GCCLINK &SRC
+ EXEC MKCLIB &SRC
+ 
+ * Skip the rebuild and verification on a 370 environment
+ * since there isn't enough memory
+ &IF &ALL370 = 1 &GOTO -NO31
+ 
+ * Make copy of assembler for later comparison
+ &IF &SRC EQ &WORK &GOTO -NOCPCMP
+ COPY * S &SRC = = &WORK (REPL
+ -NOCPCMP
+ 
+ * Pass 2
+ EXEC GCCCALL &SRC
+ EXEC GCCAALL &SRC
+ EXEC GCCLINK &SRC
+ EXEC MKCLIB &SRC
+ 
+ * Compare assembler source is identical. Note that
+ * if you wish to use an option other than -Os to
+ * compile, you'll need to do a 3rd pass for
+ * matching assembler, due to low-level floating
+ * point quirks.
+ &IF &SRC EQ &WORK &GOTO -NOCMPR
+ EXEC ITERGCC DIFFCMS Y Y Y Y &SRC &WORK
+ -NOCMPR
+ 
+ * Now we need a normal S/370 or S/390 (no memmgr,
+ * no S/380) version of PDPCLIB. So let's
+ * compile what we need, using the new C compiler
+ 
+ &IF &BLD NE 370 &GOTO -NO370
+ COPY PDP370 MAC &SRC PDPTOP COPY = (REPL LRECL 80 RECFM F
+ -NO370
+ MACLIB GEN PDPCLIB PDPPRLG PDPEPIL PDPTOP PDPMAIN
+ GLOBAL MACLIB OSMACRO DMSGPI PDPCLIB
+ &ASMNAME = ASMAHL
+ 
+ EXEC GCCAONE CMSSUPA &SRC &ASMNAME
+ EXEC GCCAONE CMSSTART &SRC &ASMNAME
+ EXEC GCCE START C &SRC (PARM STDPDP
+ EXEC GCCE STDIO C &SRC (PARM STDPDP
+ EXEC GCCE STDLIB C &SRC (PARM STDPDP
+ EXEC GCCE CTYPE C &SRC (PARM STDPDP
+ EXEC GCCE STRING C &SRC (PARM STDPDP
+ EXEC GCCE TIME C &SRC (PARM STDPDP
+ EXEC GCCE ERRNO C &SRC (PARM STDPDP
+ EXEC GCCE ASSERT C &SRC (PARM STDPDP
+ EXEC GCCE LOCALE C &SRC (PARM STDPDP
+ EXEC GCCE MATH C &SRC (PARM STDPDP
+ EXEC GCCE SETJMP C &SRC (PARM STDPDP
+ EXEC GCCE SIGNAL C &SRC (PARM STDPDP
+ EXEC GCCE __MEMMGR C &SRC (PARM STDPDP
+ EXEC MKCLIB &SRC
+ 
+ 
+ * Now we build a 370 version of the executable, even though
+ * we're on an 380+ system, because we have everything needed
+ * available.
+ &IF &BLD NE 370 &GOTO -NO370B
+ EXEC GCCLINK &SRC GCC370
+ -NO370B
+ 
+ 
+ -NO31
+ 
+ 
+ * Compile a utility needed to change CSECT names
+ EXEC GCCE NAMCSECT C &SRC
+ EXEC CLOAD NAMCSECT
+ GENMOD NAMCSECT
+ 
+ 
+ * Generate PDPCLIB TXTLIB
+ EXEC MKPDPC &SRC &ASMNAME STDPDP
+ 
+ GLOBAL TXTLIB PDPCLIB
+ 
+ 
+ * Build some useful utilities
+ EXEC GCCE MVSUNZIP C &SRC
+ LOAD MVSUNZIP (NOAUTO NOMAP
+ GENMOD MVSUNZIP
+ 
+ EXEC GCCE HEXDUMP C &SRC
+ LOAD HEXDUMP (NOAUTO NOMAP
+ GENMOD HEXDUMP
+ 
+ EXEC GCCE MVSENDEC C &SRC
+ LOAD MVSENDEC (NOAUTO NOMAP
+ GENMOD MVSENDEC
+ 
+ * Rename COPYFILE since it clashes with CMS
+ COPY COPYFILE C &SRC CPYFIL C &SRC (REPLACE
+ EXEC GCCE CPYFIL C &SRC
+ LOAD CPYFIL (NOAUTO NOMAP
+ GENMOD CPYFIL
+ 
+ * Compile example program
+ EXEC GCCE PDPTEST C &SRC
+ LOAD PDPTEST (NOAUTO NOMAP
+ GENMOD PDPTEST
+ 
+ * Copy important stuff onto the B disk
+ &IF &SRC EQ &EXE &GOTO -NOCPY
+ EXEC COPYGCC &SRC &EXE
+ -NOCPY
+ 
+ 
+ * Quick test using pdptest
+ PDPTEST PaulEdwards was Here
+ 
+ * Build 380 version of C library post-build
+ * EXEC MAKE380 &SRC
Index: gcc/gcc/compilei.bat
diff -c nul gcc/gcc/compilei.bat:1.3
*** nul	Tue Oct 01 16:28:43 2019
--- gcc/gcc/compilei.bat	Thu Jul 04 16:20:16 2019
***************
*** 0 ****
--- 1,167 ----
+ del gcc386.exe
+ del *.obj
+ del *.o
+ 
+ call stdcomp alias.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp attribs.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp bb-reorder.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp bitmap.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp builtins.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp c-aux-info.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp c-common.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp c-convert.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp c-decl.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp c-errors.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp c-format.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp c-lang.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp c-lex.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp c-objc-common.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp c-parse.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp c-pragma.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp c-semantics.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp c-typeck.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp caller-save.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp calls.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp cfg.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp cfganal.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp cfgbuild.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp cfgcleanup.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp cfglayout.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp cfgloop.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp cfgrtl.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp combine.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp conflict.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp convert.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp cppdefault.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp cpperror.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp cppexp.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp cppfiles.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp cpphash.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp cppinit.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp cpplex.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp cpplib.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp cppmacro.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp cppmain.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp cppspec.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp cse.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp cselib.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp debug.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp dependence.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp df.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp diagnostic.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp dominance.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp dwarf2asm.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp dwarf2out.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp emit-rtl.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp except.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp explow.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp expmed.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp expr.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp final.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp flow.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp fold-const.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp function.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp gcc.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp gccspec.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp gcse.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp genrtl.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp ggc-common.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp ggc-page.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp global.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp graph.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp hash.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp haifa-sched.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp hashtable.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp hooks.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp ifcvt.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp insn-attrtab.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp insn-emit.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp insn-extract.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp insn-opinit.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp insn-output.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp insn-peep.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp insn-recog.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp integrate.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp jump.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp langhooks.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp lcm.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp line-map.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp lists.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp local-alloc.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp loop.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp mkdeps.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp optabs.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp params.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp predict.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp prefix.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp print-rtl.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp print-tree.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp profile.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp real.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp recog.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp regclass.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp regmove.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp regrename.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp reload.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp reload1.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp resource.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp rtl-error.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp rtl.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp rtlanal.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp sbitmap.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp sched-deps.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp sched-rgn.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp sched-vis.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp sibcall.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp simplify-rtx.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp ssa-ccp.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp ssa-dce.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp ssa.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp stmt.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp stor-layout.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp stringpool.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp timevar.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp toplev.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp tree-dump.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp tree-inline.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp tree.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp unroll.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp varasm.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp varray.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp version.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ 
+ call stdcomp ..\libiberty\xmalloc.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp ..\libiberty\xstrerror.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp ..\libiberty\xstrdup.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp ..\libiberty\xexit.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp ..\libiberty\concat.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp ..\libiberty\hex.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp ..\libiberty\alloca.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp ..\libiberty\lbasename.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp ..\libiberty\obstack.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp ..\libiberty\strsignal.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp ..\libiberty\safe-ctype.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp ..\libiberty\splay-tree.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp ..\libiberty\fibheap.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp ..\libiberty\hashtab.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp ..\libiberty\asprintf.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp ..\libiberty\vasprintf.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp ..\libiberty\getpagesize.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp ..\libiberty\partition.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ 
+ call stdcomp config\i386\i386.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp config\i386\winnt.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ 
+ call stdcomp unixio.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ 
+ call stdcomp reg-stack.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp doloop.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp sdbout.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp dbxout.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp ..\libiberty\md5.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ 
+ rem bcc32 -w- -A -egcc386.exe *.obj
+ rem wcl386 -zq -e=1 -za -w- -fe=gcc386.exe *.obj
+ rem cl /Fegcc386.exe *.obj
+ rem gcc -s -o gcc386.exe *.o
+ gcc -s -nostdlib -o gcc386.exe *.o ../../pdos/pdpclib/pdpwin32.a -lkernel32 -lgcc
Index: gcc/gcc/compiles.bat
diff -c nul gcc/gcc/compiles.bat:1.1
*** nul	Tue Oct 01 16:28:43 2019
--- gcc/gcc/compiles.bat	Tue Nov 07 18:58:12 2017
***************
*** 0 ****
--- 1,160 ----
+ del gccmvs.exe
+ del *.obj
+ del *.o
+ 
+ call stdcomp alias.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp attribs.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp bb-reorder.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp bitmap.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp builtins.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp c-aux-info.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp c-common.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp c-convert.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp c-decl.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp c-errors.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp c-format.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp c-lang.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp c-lex.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp c-objc-common.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp c-parse.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp c-pragma.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp c-semantics.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp c-typeck.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp caller-save.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp calls.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp cfg.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp cfganal.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp cfgbuild.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp cfgcleanup.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp cfglayout.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp cfgloop.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp cfgrtl.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp combine.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp conflict.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp convert.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp cppdefault.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp cpperror.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp cppexp.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp cppfiles.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp cpphash.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp cppinit.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp cpplex.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp cpplib.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp cppmacro.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp cppmain.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp cppspec.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp cse.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp cselib.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp debug.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp dependence.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp df.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp diagnostic.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp dominance.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp dwarf2asm.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp dwarf2out.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp emit-rtl.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp except.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp explow.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp expmed.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp expr.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp final.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp flow.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp fold-const.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp function.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp gcc.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp gccspec.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp gcse.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp genrtl.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp ggc-common.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp ggc-page.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp global.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp graph.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp hash.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp haifa-sched.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp hashtable.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp hooks.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp ifcvt.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp insn-attrtab.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp insn-emit.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp insn-extract.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp insn-opinit.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp insn-output.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp insn-peep.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp insn-recog.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp integrate.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp jump.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp langhooks.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp lcm.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp line-map.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp lists.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp local-alloc.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp loop.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp mkdeps.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp optabs.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp params.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp predict.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp prefix.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp print-rtl.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp print-tree.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp profile.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp real.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp recog.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp regclass.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp regmove.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp regrename.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp reload.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp reload1.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp resource.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp rtl-error.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp rtl.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp rtlanal.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp sbitmap.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp sched-deps.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp sched-rgn.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp sched-vis.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp sibcall.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp simplify-rtx.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp ssa-ccp.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp ssa-dce.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp ssa.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp stmt.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp stor-layout.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp stringpool.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp timevar.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp toplev.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp tree-dump.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp tree-inline.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp tree.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp unroll.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp varasm.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp varray.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp version.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ 
+ call stdcomp ..\libiberty\xmalloc.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp ..\libiberty\xstrerror.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp ..\libiberty\xstrdup.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp ..\libiberty\xexit.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp ..\libiberty\concat.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp ..\libiberty\hex.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp ..\libiberty\alloca.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp ..\libiberty\lbasename.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp ..\libiberty\obstack.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp ..\libiberty\strsignal.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp ..\libiberty\safe-ctype.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp ..\libiberty\splay-tree.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp ..\libiberty\fibheap.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp ..\libiberty\hashtab.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp ..\libiberty\asprintf.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp ..\libiberty\vasprintf.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp ..\libiberty\getpagesize.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcomp ..\libiberty\partition.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ 
+ call stdcomp config\s390\s390.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ 
+ call stdcomp unixio.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ 
+ rem bcc32 -w- -A -egccmvs.exe *.obj
+ rem wcl386 -zq -e=1 -za -w- -fe=gccmvs.exe *.obj
+ rem cl /Fegccmvs.exe *.obj
+ rem gcc -s -o gccmvs.exe *.o
+ gcc -s -nostdlib -o gccmvs.exe *.o ../../pdos/pdpclib/pdpwin32.a -lkernel32 -lgcc
Index: gcc/gcc/compmus.exec
diff -c nul gcc/gcc/compmus.exec:1.3
*** nul	Tue Oct 01 16:28:43 2019
--- gcc/gcc/compmus.exec	Sun Nov 22 14:40:30 2009
***************
*** 0 ****
--- 1,160 ----
+ /inc rexx
+ 'copy *.mac *.m'
+ 'musaone alias'
+ 'musaone attribs'
+ 'musaone bb-reorder'
+ 'musaone bitmap'
+ 'musaone builtins'
+ 'musaone c-aux-info'
+ 'musaone c-common'
+ 'musaone c-convert'
+ 'musaone c-decl'
+ 'musaone c-errors'
+ 'musaone c-format'
+ 'musaone c-lang'
+ 'musaone c-lex'
+ 'musaone c-objc-common'
+ 'musaone c-parse'
+ 'musaone c-pragma'
+ 'musaone c-semantics'
+ 'musaone c-typeck'
+ 'musaone caller-save'
+ 'musaone calls'
+ 'musaone cfg'
+ 'musaone cfganal'
+ 'musaone cfgbuild'
+ 'musaone cfgcleanup'
+ 'musaone cfglayout'
+ 'musaone cfgloop'
+ 'musaone cfgrtl'
+ 'musaone combine'
+ 'musaone conflict'
+ 'musaone convert'
+ 'musaone cppdefault'
+ 'musaone cpperror'
+ 'musaone cppexp'
+ 'musaone cppfiles'
+ 'musaone cpphash'
+ 'musaone cppinit'
+ 'musaone cpplex'
+ 'musaone cpplib'
+ 'musaone cppmacro'
+ 'musaone cppmain'
+ 'musaone cppspec'
+ 'musaone cse'
+ 'musaone cselib'
+ 'musaone debug'
+ 'musaone dependence'
+ 'musaone df'
+ 'musaone diagnostic'
+ 'musaone dominance'
+ 'musaone dwarf2asm'
+ 'musaone dwarf2out'
+ 'musaone emit-rtl'
+ 'musaone except'
+ 'musaone explow'
+ 'musaone expmed'
+ 'musaone expr'
+ 'musaone final'
+ 'musaone flow'
+ 'musaone fold-const'
+ 'musaone function'
+ 'musaone gcc'
+ 'musaone gccspec'
+ 'musaone gcse'
+ 'musaone genrtl'
+ 'musaone ggc-common'
+ 'musaone ggc-page'
+ 'musaone global'
+ 'musaone graph'
+ 'musaone hash'
+ 'musaone hashtable'
+ 'musaone hooks'
+ 'musaone ifcvt'
+ 'musaone insn-attrtab'
+ 'musaone insn-emit'
+ 'musaone insn-extract'
+ 'musaone insn-opinit'
+ 'musaone insn-output'
+ 'musaone insn-recog'
+ 'musaone integrate'
+ 'musaone jump'
+ 'musaone langhooks'
+ 'musaone lcm'
+ 'musaone line-map'
+ 'musaone lists'
+ 'musaone local-alloc'
+ 'musaone loop'
+ 'musaone mkdeps'
+ 'musaone optabs'
+ 'musaone params'
+ 'musaone predict'
+ 'musaone prefix'
+ 'musaone print-rtl'
+ 'musaone print-tree'
+ 'musaone profile'
+ 'musaone real'
+ 'musaone recog'
+ 'musaone regclass'
+ 'musaone regmove'
+ 'musaone regrename'
+ 'musaone reload'
+ 'musaone reload1'
+ 'musaone resource'
+ 'musaone rtl-error'
+ 'musaone rtl'
+ 'musaone rtlanal'
+ 'musaone sbitmap'
+ 'musaone sibcall'
+ 'musaone simplify-rtx'
+ 'musaone ssa-ccp'
+ 'musaone ssa-dce'
+ 'musaone ssa'
+ 'musaone stmt'
+ 'musaone stor-layout'
+ 'musaone stringpool'
+ 'musaone timevar'
+ 'musaone toplev'
+ 'musaone tree-dump'
+ 'musaone tree-inline'
+ 'musaone tree'
+ 'musaone unroll'
+ 'musaone varasm'
+ 'musaone varray'
+ 'musaone version'
+ 'musaone xmalloc'
+ 'musaone xstrerror'
+ 'musaone xstrdup'
+ 'musaone xexit'
+ 'musaone concat'
+ 'musaone hex'
+ 'musaone alloca'
+ 'musaone lbasename'
+ 'musaone obstack'
+ 'musaone strsignal'
+ 'musaone safe-ctype'
+ 'musaone splay-tree'
+ 'musaone fibheap'
+ 'musaone hashtab'
+ 'musaone asprintf'
+ 'musaone vasprintf'
+ 'musaone getpagesize'
+ 'musaone partition'
+ 'musaone i370-c'
+ 'musaone i370'
+ 'musaone unixio'
+ 'musaone stdio'
+ 'musaone stdlib'
+ 'musaone ctype'
+ 'musaone string'
+ 'musaone time'
+ 'musaone errno'
+ 'musaone assert'
+ 'musaone locale'
+ 'musaone math'
+ 'musaone setjmp'
+ 'musaone signal'
+ 'musaone start'
+ 'musaone __memmgr'
+ 'musaone musstart'
+ 'musaone mussupa'
Index: gcc/gcc/compmus.job
diff -c nul gcc/gcc/compmus.job:1.37
*** nul	Tue Oct 01 16:28:43 2019
--- gcc/gcc/compmus.job	Wed Jul 01 14:44:26 2015
***************
*** 0 ****
--- 1,2914 ----
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /inc rexx
+ 'purge *'
+ 'purge old\*'
+ 'purge new\*'
+ 'purge exe\*'
+ 'rmdir old'
+ 'rmdir new'
+ 'rmdir exe'
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file in tape osrecfm(u) oslrecl(0) osblksize(32760) vol(PCTOMF) old
+ /parm dd:in
+ /load xmon
+ mvsunzip n(mvsunzip.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /inc rexx
+ 'copy *.exec *'
+ 'copy *.mac *.m'
+ 'copy musstart.asm musstart.s'
+ 'copy mussupa.asm mussupa.s'
+ 'mkdir old'
+ 'copy *.s old\*.s'
+ 'musaall'
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999
+ /file lmod n(gcc.lmod) new(repl) lr(128) recfm(f) sp(100) shr
+ /file lkedwork uds(@bld.lked01) vol(musicz) bufno(0)
+ /etc new delete nrec(64000)
+ /load lked
+ /job map,nogo,print,stats,mode=os,name=gcc
+ .org 4a00
+ /inc alias.obj
+ /inc attribs.obj
+ /inc bb-reorder.obj
+ /inc bitmap.obj
+ /inc builtins.obj
+ /inc c-aux-info.obj
+ /inc c-common.obj
+ /inc c-convert.obj
+ /inc c-decl.obj
+ /inc c-errors.obj
+ /inc c-format.obj
+ /inc c-lang.obj
+ /inc c-lex.obj
+ /inc c-objc-common.obj
+ /inc c-parse.obj
+ /inc c-pragma.obj
+ /inc c-semantics.obj
+ /inc c-typeck.obj
+ /inc caller-save.obj
+ /inc calls.obj
+ /inc cfg.obj
+ /inc cfganal.obj
+ /inc cfgbuild.obj
+ /inc cfgcleanup.obj
+ /inc cfglayout.obj
+ /inc cfgloop.obj
+ /inc cfgrtl.obj
+ /inc combine.obj
+ /inc conflict.obj
+ /inc convert.obj
+ /inc cppdefault.obj
+ /inc cpperror.obj
+ /inc cppexp.obj
+ /inc cppfiles.obj
+ /inc cpphash.obj
+ /inc cppinit.obj
+ /inc cpplex.obj
+ /inc cpplib.obj
+ /inc cppmacro.obj
+ /inc cppmain.obj
+ /inc cppspec.obj
+ /inc cse.obj
+ /inc cselib.obj
+ /inc debug.obj
+ /inc dependence.obj
+ /inc df.obj
+ /inc diagnostic.obj
+ /inc dominance.obj
+ /inc dwarf2asm.obj
+ /inc dwarf2out.obj
+ /inc emit-rtl.obj
+ /inc except.obj
+ /inc explow.obj
+ /inc expmed.obj
+ /inc expr.obj
+ /inc final.obj
+ /inc flow.obj
+ /inc fold-const.obj
+ /inc function.obj
+ /inc gcc.obj
+ /inc gccspec.obj
+ /inc gcse.obj
+ /inc genrtl.obj
+ /inc ggc-common.obj
+ /inc ggc-page.obj
+ /inc global.obj
+ /inc graph.obj
+ /inc hash.obj
+ /inc hashtable.obj
+ /inc hooks.obj
+ /inc ifcvt.obj
+ /inc insn-attrtab.obj
+ /inc insn-emit.obj
+ /inc insn-extract.obj
+ /inc insn-opinit.obj
+ /inc insn-output.obj
+ /inc insn-recog.obj
+ /inc integrate.obj
+ /inc jump.obj
+ /inc langhooks.obj
+ /inc lcm.obj
+ /inc line-map.obj
+ /inc lists.obj
+ /inc local-alloc.obj
+ /inc loop.obj
+ /inc mkdeps.obj
+ /inc optabs.obj
+ /inc params.obj
+ /inc predict.obj
+ /inc prefix.obj
+ /inc print-rtl.obj
+ /inc print-tree.obj
+ /inc profile.obj
+ /inc real.obj
+ /inc recog.obj
+ /inc regclass.obj
+ /inc regmove.obj
+ /inc regrename.obj
+ /inc reload.obj
+ /inc reload1.obj
+ /inc resource.obj
+ /inc rtl-error.obj
+ /inc rtl.obj
+ /inc rtlanal.obj
+ /inc sbitmap.obj
+ /inc sibcall.obj
+ /inc simplify-rtx.obj
+ /inc ssa-ccp.obj
+ /inc ssa-dce.obj
+ /inc ssa.obj
+ /inc stmt.obj
+ /inc stor-layout.obj
+ /inc stringpool.obj
+ /inc timevar.obj
+ /inc toplev.obj
+ /inc tree-dump.obj
+ /inc tree-inline.obj
+ /inc tree.obj
+ /inc unroll.obj
+ /inc varasm.obj
+ /inc varray.obj
+ /inc version.obj
+ /inc xmalloc.obj
+ /inc xstrerror.obj
+ /inc xstrdup.obj
+ /inc xexit.obj
+ /inc concat.obj
+ /inc hex.obj
+ /inc alloca.obj
+ /inc lbasename.obj
+ /inc obstack.obj
+ /inc strsignal.obj
+ /inc safe-ctype.obj
+ /inc splay-tree.obj
+ /inc fibheap.obj
+ /inc hashtab.obj
+ /inc asprintf.obj
+ /inc vasprintf.obj
+ /inc getpagesize.obj
+ /inc partition.obj
+ /inc i370-c.obj
+ /inc i370.obj
+ /inc unixio.obj
+ /inc stdio.obj
+ /inc stdlib.obj
+ /inc ctype.obj
+ /inc string.obj
+ /inc time.obj
+ /inc errno.obj
+ /inc assert.obj
+ /inc locale.obj
+ /inc math.obj
+ /inc setjmp.obj
+ /inc signal.obj
+ /inc start.obj
+ /inc __memmgr.obj
+ /inc musstart.obj
+ /inc mussupa.obj
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=3000,xregion=64m
+ /parm *
+ /inc dir
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /parm --version
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /PARM *.S
+ /INC PURGE
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(alias.c) shr
+ /file o n(alias.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(attribs.c) shr
+ /file o n(attribs.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(bb-reorder.c) shr
+ /file o n(bb-reorder.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(bitmap.c) shr
+ /file o n(bitmap.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(builtins.c) shr
+ /file o n(builtins.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(c-aux-info.c) shr
+ /file o n(c-aux-info.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(c-common.c) shr
+ /file o n(c-common.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(c-convert.c) shr
+ /file o n(c-convert.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(c-decl.c) shr
+ /file o n(c-decl.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(c-errors.c) shr
+ /file o n(c-errors.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(c-format.c) shr
+ /file o n(c-format.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(c-lang.c) shr
+ /file o n(c-lang.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(c-lex.c) shr
+ /file o n(c-lex.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(c-objc-common.c) shr
+ /file o n(c-objc-common.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(c-parse.c) shr
+ /file o n(c-parse.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(c-pragma.c) shr
+ /file o n(c-pragma.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(c-semantics.c) shr
+ /file o n(c-semantics.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(c-typeck.c) shr
+ /file o n(c-typeck.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(caller-save.c) shr
+ /file o n(caller-save.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(calls.c) shr
+ /file o n(calls.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(cfg.c) shr
+ /file o n(cfg.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(cfganal.c) shr
+ /file o n(cfganal.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(cfgbuild.c) shr
+ /file o n(cfgbuild.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(cfgcleanup.c) shr
+ /file o n(cfgcleanup.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(cfglayout.c) shr
+ /file o n(cfglayout.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(cfgloop.c) shr
+ /file o n(cfgloop.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(cfgrtl.c) shr
+ /file o n(cfgrtl.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(combine.c) shr
+ /file o n(combine.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(conflict.c) shr
+ /file o n(conflict.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(convert.c) shr
+ /file o n(convert.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(cppdefault.c) shr
+ /file o n(cppdefault.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(cpperror.c) shr
+ /file o n(cpperror.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(cppexp.c) shr
+ /file o n(cppexp.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(cppfiles.c) shr
+ /file o n(cppfiles.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(cpphash.c) shr
+ /file o n(cpphash.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(cppinit.c) shr
+ /file o n(cppinit.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(cpplex.c) shr
+ /file o n(cpplex.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(cpplib.c) shr
+ /file o n(cpplib.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(cppmacro.c) shr
+ /file o n(cppmacro.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(cppmain.c) shr
+ /file o n(cppmain.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(cppspec.c) shr
+ /file o n(cppspec.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(cse.c) shr
+ /file o n(cse.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(cselib.c) shr
+ /file o n(cselib.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(debug.c) shr
+ /file o n(debug.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(dependence.c) shr
+ /file o n(dependence.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(df.c) shr
+ /file o n(df.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(diagnostic.c) shr
+ /file o n(diagnostic.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(dominance.c) shr
+ /file o n(dominance.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(dwarf2asm.c) shr
+ /file o n(dwarf2asm.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(dwarf2out.c) shr
+ /file o n(dwarf2out.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(emit-rtl.c) shr
+ /file o n(emit-rtl.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(except.c) shr
+ /file o n(except.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(explow.c) shr
+ /file o n(explow.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(expmed.c) shr
+ /file o n(expmed.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(expr.c) shr
+ /file o n(expr.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(final.c) shr
+ /file o n(final.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(flow.c) shr
+ /file o n(flow.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(fold-const.c) shr
+ /file o n(fold-const.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(function.c) shr
+ /file o n(function.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(gcc.c) shr
+ /file o n(gcc.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(gccspec.c) shr
+ /file o n(gccspec.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(gcse.c) shr
+ /file o n(gcse.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(genrtl.c) shr
+ /file o n(genrtl.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(ggc-common.c) shr
+ /file o n(ggc-common.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(ggc-page.c) shr
+ /file o n(ggc-page.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(global.c) shr
+ /file o n(global.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(graph.c) shr
+ /file o n(graph.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(hash.c) shr
+ /file o n(hash.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(hashtable.c) shr
+ /file o n(hashtable.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(hooks.c) shr
+ /file o n(hooks.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(ifcvt.c) shr
+ /file o n(ifcvt.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(insn-attrtab.c) shr
+ /file o n(insn-attrtab.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(insn-emit.c) shr
+ /file o n(insn-emit.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(insn-extract.c) shr
+ /file o n(insn-extract.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(insn-opinit.c) shr
+ /file o n(insn-opinit.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(insn-output.c) shr
+ /file o n(insn-output.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(insn-recog.c) shr
+ /file o n(insn-recog.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(integrate.c) shr
+ /file o n(integrate.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(jump.c) shr
+ /file o n(jump.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(langhooks.c) shr
+ /file o n(langhooks.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(lcm.c) shr
+ /file o n(lcm.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(line-map.c) shr
+ /file o n(line-map.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(lists.c) shr
+ /file o n(lists.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(local-alloc.c) shr
+ /file o n(local-alloc.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(loop.c) shr
+ /file o n(loop.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(mkdeps.c) shr
+ /file o n(mkdeps.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(optabs.c) shr
+ /file o n(optabs.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(params.c) shr
+ /file o n(params.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(predict.c) shr
+ /file o n(predict.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(prefix.c) shr
+ /file o n(prefix.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(print-rtl.c) shr
+ /file o n(print-rtl.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(print-tree.c) shr
+ /file o n(print-tree.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(profile.c) shr
+ /file o n(profile.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(real.c) shr
+ /file o n(real.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(recog.c) shr
+ /file o n(recog.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(regclass.c) shr
+ /file o n(regclass.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(regmove.c) shr
+ /file o n(regmove.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(regrename.c) shr
+ /file o n(regrename.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(reload.c) shr
+ /file o n(reload.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(reload1.c) shr
+ /file o n(reload1.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(resource.c) shr
+ /file o n(resource.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(rtl-error.c) shr
+ /file o n(rtl-error.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(rtl.c) shr
+ /file o n(rtl.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(rtlanal.c) shr
+ /file o n(rtlanal.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(sbitmap.c) shr
+ /file o n(sbitmap.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(sibcall.c) shr
+ /file o n(sibcall.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(simplify-rtx.c) shr
+ /file o n(simplify-rtx.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(ssa-ccp.c) shr
+ /file o n(ssa-ccp.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(ssa-dce.c) shr
+ /file o n(ssa-dce.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(ssa.c) shr
+ /file o n(ssa.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(stmt.c) shr
+ /file o n(stmt.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(stor-layout.c) shr
+ /file o n(stor-layout.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(stringpool.c) shr
+ /file o n(stringpool.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(timevar.c) shr
+ /file o n(timevar.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(toplev.c) shr
+ /file o n(toplev.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(tree-dump.c) shr
+ /file o n(tree-dump.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(tree-inline.c) shr
+ /file o n(tree-inline.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(tree.c) shr
+ /file o n(tree.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(unroll.c) shr
+ /file o n(unroll.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(varasm.c) shr
+ /file o n(varasm.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(varray.c) shr
+ /file o n(varray.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(version.c) shr
+ /file o n(version.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(xmalloc.c) shr
+ /file o n(xmalloc.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(xstrerror.c) shr
+ /file o n(xstrerror.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(xstrdup.c) shr
+ /file o n(xstrdup.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(xexit.c) shr
+ /file o n(xexit.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(concat.c) shr
+ /file o n(concat.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(hex.c) shr
+ /file o n(hex.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(alloca.c) shr
+ /file o n(alloca.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(lbasename.c) shr
+ /file o n(lbasename.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(obstack.c) shr
+ /file o n(obstack.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(strsignal.c) shr
+ /file o n(strsignal.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(safe-ctype.c) shr
+ /file o n(safe-ctype.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(splay-tree.c) shr
+ /file o n(splay-tree.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(fibheap.c) shr
+ /file o n(fibheap.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(hashtab.c) shr
+ /file o n(hashtab.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(asprintf.c) shr
+ /file o n(asprintf.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(vasprintf.c) shr
+ /file o n(vasprintf.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(getpagesize.c) shr
+ /file o n(getpagesize.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(partition.c) shr
+ /file o n(partition.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(i370-c.c) shr
+ /file o n(i370-c.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(i370.c) shr
+ /file o n(i370.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(unixio.c) shr
+ /file o n(unixio.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -remap -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DIFOX -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(stdio.c) shr
+ /file o n(stdio.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -DUSE_MEMMGR -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(stdlib.c) shr
+ /file o n(stdlib.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -DUSE_MEMMGR -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(ctype.c) shr
+ /file o n(ctype.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -DUSE_MEMMGR -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(string.c) shr
+ /file o n(string.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -DUSE_MEMMGR -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(time.c) shr
+ /file o n(time.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -DUSE_MEMMGR -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(errno.c) shr
+ /file o n(errno.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -DUSE_MEMMGR -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(assert.c) shr
+ /file o n(assert.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -DUSE_MEMMGR -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(locale.c) shr
+ /file o n(locale.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -DUSE_MEMMGR -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(math.c) shr
+ /file o n(math.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -DUSE_MEMMGR -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(setjmp.c) shr
+ /file o n(setjmp.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -DUSE_MEMMGR -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(signal.c) shr
+ /file o n(signal.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -DUSE_MEMMGR -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(start.c) shr
+ /file o n(start.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -DUSE_MEMMGR -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(__memmgr.c) shr
+ /file o n(__memmgr.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -DUSE_MEMMGR -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /inc rexx
+ 'copy musstart.asm musstart.s'
+ 'copy mussupa.asm mussupa.s'
+ 'copy gcc.lmod old\gcc.lmod'
+ 'purge gcc.lmod'
+ 'musaall'
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999
+ /file lmod n(gcc.lmod) new(repl) lr(128) recfm(f) sp(100) shr
+ /file lkedwork uds(@bld.lked01) vol(musicz) bufno(0)
+ /etc new delete nrec(64000)
+ /load lked
+ /job map,nogo,print,stats,mode=os,name=gcc
+ .org 4a00
+ /inc alias.obj
+ /inc attribs.obj
+ /inc bb-reorder.obj
+ /inc bitmap.obj
+ /inc builtins.obj
+ /inc c-aux-info.obj
+ /inc c-common.obj
+ /inc c-convert.obj
+ /inc c-decl.obj
+ /inc c-errors.obj
+ /inc c-format.obj
+ /inc c-lang.obj
+ /inc c-lex.obj
+ /inc c-objc-common.obj
+ /inc c-parse.obj
+ /inc c-pragma.obj
+ /inc c-semantics.obj
+ /inc c-typeck.obj
+ /inc caller-save.obj
+ /inc calls.obj
+ /inc cfg.obj
+ /inc cfganal.obj
+ /inc cfgbuild.obj
+ /inc cfgcleanup.obj
+ /inc cfglayout.obj
+ /inc cfgloop.obj
+ /inc cfgrtl.obj
+ /inc combine.obj
+ /inc conflict.obj
+ /inc convert.obj
+ /inc cppdefault.obj
+ /inc cpperror.obj
+ /inc cppexp.obj
+ /inc cppfiles.obj
+ /inc cpphash.obj
+ /inc cppinit.obj
+ /inc cpplex.obj
+ /inc cpplib.obj
+ /inc cppmacro.obj
+ /inc cppmain.obj
+ /inc cppspec.obj
+ /inc cse.obj
+ /inc cselib.obj
+ /inc debug.obj
+ /inc dependence.obj
+ /inc df.obj
+ /inc diagnostic.obj
+ /inc dominance.obj
+ /inc dwarf2asm.obj
+ /inc dwarf2out.obj
+ /inc emit-rtl.obj
+ /inc except.obj
+ /inc explow.obj
+ /inc expmed.obj
+ /inc expr.obj
+ /inc final.obj
+ /inc flow.obj
+ /inc fold-const.obj
+ /inc function.obj
+ /inc gcc.obj
+ /inc gccspec.obj
+ /inc gcse.obj
+ /inc genrtl.obj
+ /inc ggc-common.obj
+ /inc ggc-page.obj
+ /inc global.obj
+ /inc graph.obj
+ /inc hash.obj
+ /inc hashtable.obj
+ /inc hooks.obj
+ /inc ifcvt.obj
+ /inc insn-attrtab.obj
+ /inc insn-emit.obj
+ /inc insn-extract.obj
+ /inc insn-opinit.obj
+ /inc insn-output.obj
+ /inc insn-recog.obj
+ /inc integrate.obj
+ /inc jump.obj
+ /inc langhooks.obj
+ /inc lcm.obj
+ /inc line-map.obj
+ /inc lists.obj
+ /inc local-alloc.obj
+ /inc loop.obj
+ /inc mkdeps.obj
+ /inc optabs.obj
+ /inc params.obj
+ /inc predict.obj
+ /inc prefix.obj
+ /inc print-rtl.obj
+ /inc print-tree.obj
+ /inc profile.obj
+ /inc real.obj
+ /inc recog.obj
+ /inc regclass.obj
+ /inc regmove.obj
+ /inc regrename.obj
+ /inc reload.obj
+ /inc reload1.obj
+ /inc resource.obj
+ /inc rtl-error.obj
+ /inc rtl.obj
+ /inc rtlanal.obj
+ /inc sbitmap.obj
+ /inc sibcall.obj
+ /inc simplify-rtx.obj
+ /inc ssa-ccp.obj
+ /inc ssa-dce.obj
+ /inc ssa.obj
+ /inc stmt.obj
+ /inc stor-layout.obj
+ /inc stringpool.obj
+ /inc timevar.obj
+ /inc toplev.obj
+ /inc tree-dump.obj
+ /inc tree-inline.obj
+ /inc tree.obj
+ /inc unroll.obj
+ /inc varasm.obj
+ /inc varray.obj
+ /inc version.obj
+ /inc xmalloc.obj
+ /inc xstrerror.obj
+ /inc xstrdup.obj
+ /inc xexit.obj
+ /inc concat.obj
+ /inc hex.obj
+ /inc alloca.obj
+ /inc lbasename.obj
+ /inc obstack.obj
+ /inc strsignal.obj
+ /inc safe-ctype.obj
+ /inc splay-tree.obj
+ /inc fibheap.obj
+ /inc hashtab.obj
+ /inc asprintf.obj
+ /inc vasprintf.obj
+ /inc getpagesize.obj
+ /inc partition.obj
+ /inc i370-c.obj
+ /inc i370.obj
+ /inc unixio.obj
+ /inc stdio.obj
+ /inc stdlib.obj
+ /inc ctype.obj
+ /inc string.obj
+ /inc time.obj
+ /inc errno.obj
+ /inc assert.obj
+ /inc locale.obj
+ /inc math.obj
+ /inc setjmp.obj
+ /inc signal.obj
+ /inc start.obj
+ /inc __memmgr.obj
+ /inc musstart.obj
+ /inc mussupa.obj
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /inc rexx
+ 'mkdir new'
+ 'copy *.s new\*.s'
+ 'musdall'
+ 'copy pdp370.m pdptop.m -repl'
+ 'purge *.obj'
+ 'purge *.s'
+ 'copy musstart.asm musstart.s'
+ 'copy mussupa.asm mussupa.s'
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file o prt osrecfm(f) oslrecl(256)
+ /file sysin n(pdptest.c) shr
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(stdio.c) shr
+ /file o n(stdio.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(stdlib.c) shr
+ /file o n(stdlib.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(ctype.c) shr
+ /file o n(ctype.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(string.c) shr
+ /file o n(string.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(time.c) shr
+ /file o n(time.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(errno.c) shr
+ /file o n(errno.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(assert.c) shr
+ /file o n(assert.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(locale.c) shr
+ /file o n(locale.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(math.c) shr
+ /file o n(math.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(setjmp.c) shr
+ /file o n(setjmp.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(signal.c) shr
+ /file o n(signal.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(start.c) shr
+ /file o n(start.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(copyfile.c) shr
+ /file o n(copyfile.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(hexdump.c) shr
+ /file o n(hexdump.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(mvsunzip.c) shr
+ /file o n(mvsunzip.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(mvsendec.c) shr
+ /file o n(mvsendec.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -Os -S -DMUSIC -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file sysin n(pdptest.c) shr
+ /file o n(pdptest.s) new recfm(v) sp(1000)
+ /file sysincl pds(*.h)
+ /file include pds(*.h)
+ /parm -O0 -S -o dd:o -
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /inc rexx
+ 'musaone stdio'
+ 'musaone stdlib'
+ 'musaone ctype'
+ 'musaone string'
+ 'musaone time'
+ 'musaone errno'
+ 'musaone assert'
+ 'musaone locale'
+ 'musaone math'
+ 'musaone setjmp'
+ 'musaone signal'
+ 'musaone start'
+ 'musaone musstart'
+ 'musaone mussupa'
+ 
+ 'musaone pdptest'
+ 'musaone copyfile'
+ 'musaone hexdump'
+ 'musaone mvsunzip'
+ 'musaone mvsendec'
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /SAVE PDPLINK.INC REPL
+ /inc stdio.obj
+ /inc stdlib.obj
+ /inc ctype.obj
+ /inc string.obj
+ /inc time.obj
+ /inc errno.obj
+ /inc assert.obj
+ /inc locale.obj
+ /inc math.obj
+ /inc setjmp.obj
+ /inc signal.obj
+ /inc start.obj
+ /inc musstart.obj
+ /inc mussupa.obj
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999
+ /file lmod n(pdptest.lmod) new(repl) lr(128) recfm(f) sp(100) shr
+ /load lked
+ /job map,nogo,print,stats,mode=os,name=pdptest
+ .org 4a00
+ /inc pdptest.obj
+ /inc pdplink.inc(nest)
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999
+ /file lmod n(copyfile.lmod) new(repl) lr(128) recfm(f) sp(100) shr
+ /load lked
+ /job map,nogo,print,stats,mode=os,name=copyfile
+ .org 4a00
+ /inc copyfile.obj
+ /inc pdplink.inc(nest)
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999
+ /file lmod n(hexdump.lmod) new(repl) lr(128) recfm(f) sp(100) shr
+ /load lked
+ /job map,nogo,print,stats,mode=os,name=hexdump
+ .org 4a00
+ /inc hexdump.obj
+ /inc pdplink.inc(nest)
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999
+ /file lmod n(mvsunzip.lmod) new(repl) lr(128) recfm(f) sp(100) shr
+ /load lked
+ /job map,nogo,print,stats,mode=os,name=mvsunzip
+ .org 4a00
+ /inc mvsunzip.obj
+ /inc pdplink.inc(nest)
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999
+ /file lmod n(mvsendec.lmod) new(repl) lr(128) recfm(f) sp(100) shr
+ /load lked
+ /job map,nogo,print,stats,mode=os,name=mvsendec
+ .org 4a00
+ /inc mvsendec.obj
+ /inc pdplink.inc(nest)
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /SAVE PDPTEST REPL
+ /inc rexx
+ parse arg parms
+ queue "/sys region=9999"
+ queue "/file sysprint prt osrecfm(f) oslrecl(256)"
+ queue "/parm " parms
+ queue "/load xmon"
+ queue "pdptest n(pdptest.lmod) lcparm"
+ "EXEC"
+ exit rc
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /SAVE COPYFILE REPL
+ /inc rexx
+ parse arg parms
+ queue "/sys region=9999"
+ queue "/file sysprint prt osrecfm(f) oslrecl(256)"
+ queue "/parm " parms
+ queue "/load xmon"
+ queue "copyfile n(copyfile.lmod) lcparm"
+ "EXEC"
+ exit rc
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /SAVE HEXDUMP REPL
+ /inc rexx
+ parse arg parms
+ queue "/sys region=9999"
+ queue "/file sysprint prt osrecfm(f) oslrecl(256)"
+ queue "/parm " parms
+ queue "/load xmon"
+ queue "hexdump n(hexdump.lmod) lcparm"
+ "EXEC"
+ exit rc
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /SAVE MVSUNZIP REPL
+ /inc rexx
+ parse arg parms
+ queue "/sys region=9999"
+ queue "/file sysprint prt osrecfm(f) oslrecl(256)"
+ queue "/parm " parms
+ queue "/load xmon"
+ queue "mvsunzip n(mvsunzip.lmod) lcparm"
+ "EXEC"
+ exit rc
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /SAVE MVSENDEC REPL
+ /inc rexx
+ parse arg parms
+ queue "/sys region=9999"
+ queue "/file sysprint prt osrecfm(f) oslrecl(256)"
+ queue "/parm " parms
+ queue "/load xmon"
+ queue "mvsendec n(mvsendec.lmod) lcparm"
+ "EXEC"
+ exit rc
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /inc rexx
+ 'pdptest alpha braVo'
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /inc rexx
+ 'mkdir exe'
+ 
+ 'copy gcc.lmod exe\gcc.lmod'
+ 
+ 'copy assert.h exe\assert.h'
+ 'copy ctype.h exe\ctype.h'
+ 'copy errno.h exe\errno.h'
+ 'copy float.h exe\float.h'
+ 'copy limits.h exe\limits.h'
+ 'copy locale.h exe\locale.h'
+ 'copy math.h exe\math.h'
+ 'copy mvssupa.h exe\mvssupa.h'
+ 'copy setjmp.h exe\setjmp.h'
+ 'copy signal.h exe\signal.h'
+ 'copy stdarg.h exe\stdarg.h'
+ 'copy stddef.h exe\stddef.h'
+ 'copy stdio.h exe\stdio.h'
+ 'copy stdlib.h exe\stdlib.h'
+ 'copy string.h exe\string.h'
+ 'copy time.h exe\time.h'
+ 'copy __memmgr.h exe\__memmgr.h'
+ 
+ 'purge pdptest.obj'
+ 'purge copyfile.obj'
+ 'purge hexdump.obj'
+ 'purge mvsunzip.obj'
+ 'purge mvsendec.obj'
+ 
+ 'copy *.obj exe\*.obj'
+ 
+ 'copy pdplink.inc exe\pdplink.inc'
+ 
+ 'copy copyfile.lmod exe\copyfile.lmod'
+ 'copy copyfile exe\copyfile'
+ 'copy hexdump.lmod exe\hexdump.lmod'
+ 'copy hexdump exe\hexdump'
+ 'copy mvsunzip.lmod exe\mvsunzip.lmod'
+ 'copy mvsunzip exe\mvsunzip'
+ 'copy mvsendec.lmod exe\mvsendec.lmod'
+ 'copy mvsendec exe\mvsendec'
+ 
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999
+ /file 1 tape vol(MFTOPC) new
+ /inc mfarc2
+ LIST=T
+ @BLD000:EXE\*
+ /END
Index: gcc/gcc/compmvs
diff -c nul gcc/gcc/compmvs:1.18
*** nul	Tue Oct 01 16:28:43 2019
--- gcc/gcc/compmvs	Sat Sep 26 14:38:04 2009
***************
*** 0 ****
--- 1,176 ----
+ #/bin/sh
+ 
+ FILES="
+   alias
+   attribs
+   bb-reorder
+   bitmap
+   builtins
+   c-aux-info
+   c-common
+   c-convert
+   c-decl
+   c-errors
+   c-format
+   c-lang
+   c-lex
+   c-objc-common
+   c-parse
+   c-pragma
+   c-semantics
+   c-typeck
+   caller-save
+   calls
+   cfg
+   cfganal
+   cfgbuild
+   cfgcleanup
+   cfglayout
+   cfgloop
+   cfgrtl
+   combine
+   conflict
+   convert
+   cppdefault
+   cpperror
+   cppexp
+   cppfiles
+   cpphash
+   cppinit
+   cpplex
+   cpplib
+   cppmacro
+   cppmain
+   cppspec
+   cse
+   cselib
+   debug
+   dependence
+   df
+   diagnostic
+   dominance
+   dwarf2asm
+   dwarf2out
+   emit-rtl
+   except
+   explow
+   expmed
+   expr
+   final
+   flow
+   fold-const
+   function
+   gcc
+   gccspec
+   gcse
+   genrtl
+   ggc-common
+   ggc-page
+   global
+   graph
+   hash
+   hashtable
+   hooks
+   ifcvt
+   insn-attrtab
+   insn-emit
+   insn-extract
+   insn-opinit
+   insn-output
+   insn-recog
+   integrate
+   jump
+   langhooks
+   lcm
+   line-map
+   lists
+   local-alloc
+   loop
+   mkdeps
+   optabs
+   params
+   predict
+   prefix
+   print-rtl
+   print-tree
+   profile
+   real
+   recog
+   regclass
+   regmove
+   regrename
+   reload
+   reload1
+   resource
+   rtl-error
+   rtl
+   rtlanal
+   sbitmap
+   sibcall
+   simplify-rtx
+   ssa-ccp
+   ssa-dce
+   ssa
+   stmt
+   stor-layout
+   stringpool
+   timevar
+   toplev
+   tree-dump
+   tree-inline
+   tree
+   unroll
+   varasm
+   varray
+   version
+   ../libiberty/xmalloc
+   ../libiberty/xstrerror
+   ../libiberty/xstrdup
+   ../libiberty/xexit
+   ../libiberty/concat
+   ../libiberty/hex
+   ../libiberty/alloca
+   ../libiberty/lbasename
+   ../libiberty/obstack
+   ../libiberty/strsignal
+   ../libiberty/safe-ctype
+   ../libiberty/splay-tree
+   ../libiberty/fibheap
+   ../libiberty/hashtab
+   ../libiberty/asprintf
+   ../libiberty/vasprintf
+   ../libiberty/getpagesize
+   ../libiberty/partition
+   config/i370/i370-c
+   config/i370/i370
+   unixio
+   ../../pdos/pdpclib/stdio
+   ../../pdos/pdpclib/stdlib
+   ../../pdos/pdpclib/ctype
+   ../../pdos/pdpclib/string
+   ../../pdos/pdpclib/time
+   ../../pdos/pdpclib/errno
+   ../../pdos/pdpclib/assert
+   ../../pdos/pdpclib/locale
+   ../../pdos/pdpclib/math
+   ../../pdos/pdpclib/setjmp
+   ../../pdos/pdpclib/signal
+   ../../pdos/pdpclib/start
+   ../../pdos/pdpclib/__memmgr
+   ../../pdos/pdpclib/mvsunzip
+   ../../pdos/pdpclib/mvsendec
+   ../../pdos/pdpclib/hexdump
+   ../../pdos/pdpclib/dssrenam
+   ../../pdos/pdpclib/copyfile
+   "
+ 
+ for file in $FILES
+ 
+ do
+ 
+ echo "Cross-Compiling - $file"
+ ./gccmvs -DUSE_MEMMGR -Os -S -ansi -pedantic-errors -DHAVE_CONFIG_H -DIN_GCC -DPUREISO $* -I ../../pdos/pdpclib -I . -I config/i370 -I ../include $file.c
+ 
+ done
+ 
+ exit
Index: gcc/gcc/compmvs.bat
diff -c nul gcc/gcc/compmvs.bat:1.25
*** nul	Tue Oct 01 16:28:43 2019
--- gcc/gcc/compmvs.bat	Sun Dec 26 09:10:28 2010
***************
*** 0 ****
--- 1,169 ----
+ call stdcompm alias.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm attribs.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm bb-reorder.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm bitmap.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm builtins.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm c-aux-info.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm c-common.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm c-convert.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm c-decl.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm c-errors.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm c-format.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm c-lang.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm c-lex.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm c-objc-common.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm c-parse.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm c-pragma.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm c-semantics.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm c-typeck.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm caller-save.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm calls.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm cfg.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm cfganal.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm cfgbuild.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm cfgcleanup.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm cfglayout.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm cfgloop.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm cfgrtl.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm combine.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm conflict.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm convert.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm cppdefault.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm cpperror.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm cppexp.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm cppfiles.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm cpphash.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm cppinit.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm cpplex.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm cpplib.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm cppmacro.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm cppmain.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm cppspec.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm cse.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm cselib.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm debug.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm dependence.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm df.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm diagnostic.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm dominance.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm dwarf2asm.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm dwarf2out.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm emit-rtl.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm except.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm explow.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm expmed.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm expr.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm final.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm flow.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm fold-const.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm function.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm gcc.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm gccspec.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm gcse.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm genrtl.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm ggc-common.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm ggc-page.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm global.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm graph.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm hash.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm hashtable.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm hooks.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm ifcvt.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm insn-attrtab.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm insn-emit.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm insn-extract.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm insn-opinit.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm insn-output.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm insn-recog.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm integrate.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm jump.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm langhooks.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm lcm.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm line-map.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm lists.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm local-alloc.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm loop.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm mkdeps.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm optabs.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm params.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm predict.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm prefix.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm print-rtl.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm print-tree.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm profile.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm real.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm recog.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm regclass.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm regmove.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm regrename.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm reload.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm reload1.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm resource.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm rtl-error.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm rtl.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm rtlanal.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm sbitmap.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm sibcall.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm simplify-rtx.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm ssa-ccp.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm ssa-dce.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm ssa.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm stmt.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm stor-layout.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm stringpool.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm timevar.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm toplev.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm tree-dump.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm tree-inline.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm tree.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm unroll.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm varasm.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm varray.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm version.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ 
+ call stdcompm ../libiberty/xmalloc.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm ../libiberty/xstrerror.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm ../libiberty/xstrdup.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm ../libiberty/xexit.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm ../libiberty/concat.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm ../libiberty/hex.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm ../libiberty/alloca.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm ../libiberty/lbasename.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm ../libiberty/obstack.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm ../libiberty/strsignal.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm ../libiberty/safe-ctype.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm ../libiberty/splay-tree.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm ../libiberty/fibheap.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm ../libiberty/hashtab.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm ../libiberty/asprintf.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm ../libiberty/vasprintf.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm ../libiberty/getpagesize.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm ../libiberty/partition.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ 
+ call stdcompm config/i370/i370-c.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm config/i370/i370.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ 
+ call stdcompm unixio.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ 
+ call stdcompm ../../pdos/pdpclib/stdio.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm ../../pdos/pdpclib/stdlib.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm ../../pdos/pdpclib/ctype.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm ../../pdos/pdpclib/string.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm ../../pdos/pdpclib/time.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm ../../pdos/pdpclib/errno.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm ../../pdos/pdpclib/assert.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm ../../pdos/pdpclib/locale.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm ../../pdos/pdpclib/math.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm ../../pdos/pdpclib/setjmp.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm ../../pdos/pdpclib/signal.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm ../../pdos/pdpclib/start.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm ../../pdos/pdpclib/__memmgr.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ 
+ call stdcompm ../../pdos/pdpclib/mvsunzip.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm ../../pdos/pdpclib/mvsendec.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm ../../pdos/pdpclib/hexdump.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm ../../pdos/pdpclib/dssrenam.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm ../../pdos/pdpclib/copyfile.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm ../../pdos/pdpclib/vseproc.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompm ../../pdos/pdpclib/vsemanip.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ 
Index: gcc/gcc/comppdos.bat
diff -c nul gcc/gcc/comppdos.bat:1.9
*** nul	Tue Oct 01 16:28:43 2019
--- gcc/gcc/comppdos.bat	Fri Jun 15 23:13:33 2018
***************
*** 0 ****
--- 1,320 ----
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors alias.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors attribs.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors bb-reorder.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors bitmap.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors builtins.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors c-aux-info.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors c-common.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors c-convert.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors c-decl.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors c-errors.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors c-format.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors c-lang.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors c-lex.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors c-objc-common.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors c-parse.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors c-pragma.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors c-semantics.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors c-typeck.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors caller-save.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors calls.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors cfg.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors cfganal.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors cfgbuild.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors cfgcleanup.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors cfglayout.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors cfgloop.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors cfgrtl.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors combine.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors conflict.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors convert.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors cppdefault.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors cpperror.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors cppexp.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors cppfiles.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors cpphash.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors cppinit.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors cpplex.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors cpplib.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors cppmacro.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors cppmain.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors cppspec.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors cse.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors cselib.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors debug.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors dependence.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors df.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors diagnostic.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors dominance.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors dwarf2asm.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors dwarf2out.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors emit-rtl.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors except.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors explow.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors expmed.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors expr.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors final.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors flow.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors fold-const.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors function.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors gcc.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors gccspec.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors gcse.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors genrtl.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors ggc-common.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors ggc-page.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors global.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors graph.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors hash.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors hashtable.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors hooks.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors ifcvt.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors insn-attrtab.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors insn-emit.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors insn-extract.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors insn-opinit.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors insn-output.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors insn-recog.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors integrate.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors jump.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors langhooks.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors lcm.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors line-map.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors lists.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors local-alloc.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors loop.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors mkdeps.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors optabs.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors params.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors predict.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors prefix.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors print-rtl.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors print-tree.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors profile.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors real.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors recog.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors regclass.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors regmove.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors regrename.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors reload.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors reload1.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors resource.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors rtl-error.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors rtl.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors rtlanal.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors sbitmap.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors sibcall.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors simplify-rtx.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors ssa-ccp.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors ssa-dce.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors ssa.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors stmt.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors stor-layout.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors stringpool.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors timevar.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors toplev.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors tree-dump.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors tree-inline.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors tree.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors unroll.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors varasm.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors varray.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors version.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors xmalloc.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors xstrerror.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors xstrdup.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors xexit.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors concat.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors hex.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors alloca.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors lbasename.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors obstack.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors strsignal.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors safe-ctype.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors splay-tree.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors fibheap.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors hashtab.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors asprintf.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors vasprintf.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors getpagesize.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors partition.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors i370-c.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors i370.c
+ gcc -Os -S -I . -DPUREISO -DIN_GCC -DHAVE_CONFIG_H -ansi -pedantic-errors unixio.c
+ 
+ gcc -Os -S -I . -DXXX_MEMMGR -ansi -pedantic-errors stdio.c
+ gcc -Os -S -I . -DXXX_MEMMGR -ansi -pedantic-errors stdlib.c
+ gcc -Os -S -I . -DXXX_MEMMGR -ansi -pedantic-errors ctype.c
+ gcc -Os -S -I . -DXXX_MEMMGR -ansi -pedantic-errors string.c
+ gcc -Os -S -I . -DXXX_MEMMGR -ansi -pedantic-errors time.c
+ gcc -Os -S -I . -DXXX_MEMMGR -ansi -pedantic-errors errno.c
+ gcc -Os -S -I . -DXXX_MEMMGR -ansi -pedantic-errors assert.c
+ gcc -Os -S -I . -DXXX_MEMMGR -ansi -pedantic-errors locale.c
+ gcc -Os -S -I . -DXXX_MEMMGR -ansi -pedantic-errors math.c
+ gcc -Os -S -I . -DXXX_MEMMGR -ansi -pedantic-errors setjmp.c
+ gcc -Os -S -I . -DXXX_MEMMGR -ansi -pedantic-errors signal.c
+ gcc -Os -S -I . -DXXX_MEMMGR -ansi -pedantic-errors start.c
+ gcc -Os -S -I . -DXXX_MEMMGR -ansi -pedantic-errors __memmgr.c
+ 
+ gcc -Os -S -I . -ansi -pedantic-errors mvsunzip.c
+ gcc -Os -S -I . -ansi -pedantic-errors mvsendec.c
+ gcc -Os -S -I . -ansi -pedantic-errors hexdump.c
+ gcc -Os -S -I . -ansi -pedantic-errors dssrenam.c
+ gcc -Os -S -I . -ansi -pedantic-errors copyfile.c
+ 
+ diff alias.s1 alias.s
+ diff attribs.s1 attribs.s
+ diff bb-reorder.s1 bb-reorder.s
+ diff bitmap.s1 bitmap.s
+ diff builtins.s1 builtins.s
+ diff c-aux-info.s1 c-aux-info.s
+ diff c-common.s1 c-common.s
+ diff c-convert.s1 c-convert.s
+ diff c-decl.s1 c-decl.s
+ diff c-errors.s1 c-errors.s
+ diff c-format.s1 c-format.s
+ diff c-lang.s1 c-lang.s
+ diff c-lex.s1 c-lex.s
+ diff c-objc-common.s1 c-objc-common.s
+ diff c-parse.s1 c-parse.s
+ diff c-pragma.s1 c-pragma.s
+ diff c-semantics.s1 c-semantics.s
+ diff c-typeck.s1 c-typeck.s
+ diff caller-save.s1 caller-save.s
+ diff calls.s1 calls.s
+ diff cfg.s1 cfg.s
+ diff cfganal.s1 cfganal.s
+ diff cfgbuild.s1 cfgbuild.s
+ diff cfgcleanup.s1 cfgcleanup.s
+ diff cfglayout.s1 cfglayout.s
+ diff cfgloop.s1 cfgloop.s
+ diff cfgrtl.s1 cfgrtl.s
+ diff combine.s1 combine.s
+ diff conflict.s1 conflict.s
+ diff convert.s1 convert.s
+ diff cppdefault.s1 cppdefault.s
+ diff cpperror.s1 cpperror.s
+ diff cppexp.s1 cppexp.s
+ diff cppfiles.s1 cppfiles.s
+ diff cpphash.s1 cpphash.s
+ diff cppinit.s1 cppinit.s
+ diff cpplex.s1 cpplex.s
+ diff cpplib.s1 cpplib.s
+ diff cppmacro.s1 cppmacro.s
+ diff cppmain.s1 cppmain.s
+ diff cppspec.s1 cppspec.s
+ diff cse.s1 cse.s
+ diff cselib.s1 cselib.s
+ diff debug.s1 debug.s
+ diff dependence.s1 dependence.s
+ diff df.s1 df.s
+ diff diagnostic.s1 diagnostic.s
+ diff dominance.s1 dominance.s
+ diff dwarf2asm.s1 dwarf2asm.s
+ diff dwarf2out.s1 dwarf2out.s
+ diff emit-rtl.s1 emit-rtl.s
+ diff except.s1 except.s
+ diff explow.s1 explow.s
+ diff expmed.s1 expmed.s
+ diff expr.s1 expr.s
+ diff final.s1 final.s
+ diff flow.s1 flow.s
+ diff fold-const.s1 fold-const.s
+ diff function.s1 function.s
+ diff gcc.s1 gcc.s
+ diff gccspec.s1 gccspec.s
+ diff gcse.s1 gcse.s
+ diff genrtl.s1 genrtl.s
+ diff ggc-common.s1 ggc-common.s
+ diff ggc-page.s1 ggc-page.s
+ diff global.s1 global.s
+ diff graph.s1 graph.s
+ diff hash.s1 hash.s
+ diff hashtable.s1 hashtable.s
+ diff hooks.s1 hooks.s
+ diff ifcvt.s1 ifcvt.s
+ diff insn-attrtab.s1 insn-attrtab.s
+ diff insn-emit.s1 insn-emit.s
+ diff insn-extract.s1 insn-extract.s
+ diff insn-opinit.s1 insn-opinit.s
+ diff insn-output.s1 insn-output.s
+ diff insn-recog.s1 insn-recog.s
+ diff integrate.s1 integrate.s
+ diff jump.s1 jump.s
+ diff langhooks.s1 langhooks.s
+ diff lcm.s1 lcm.s
+ diff line-map.s1 line-map.s
+ diff lists.s1 lists.s
+ diff local-alloc.s1 local-alloc.s
+ diff loop.s1 loop.s
+ diff mkdeps.s1 mkdeps.s
+ diff optabs.s1 optabs.s
+ diff params.s1 params.s
+ diff predict.s1 predict.s
+ diff prefix.s1 prefix.s
+ diff print-rtl.s1 print-rtl.s
+ diff print-tree.s1 print-tree.s
+ diff profile.s1 profile.s
+ diff real.s1 real.s
+ diff recog.s1 recog.s
+ diff regclass.s1 regclass.s
+ diff regmove.s1 regmove.s
+ diff regrename.s1 regrename.s
+ diff reload.s1 reload.s
+ diff reload1.s1 reload1.s
+ diff resource.s1 resource.s
+ diff rtl-error.s1 rtl-error.s
+ diff rtl.s1 rtl.s
+ diff rtlanal.s1 rtlanal.s
+ diff sbitmap.s1 sbitmap.s
+ diff sibcall.s1 sibcall.s
+ diff simplify-rtx.s1 simplify-rtx.s
+ diff ssa-ccp.s1 ssa-ccp.s
+ diff ssa-dce.s1 ssa-dce.s
+ diff ssa.s1 ssa.s
+ diff stmt.s1 stmt.s
+ diff stor-layout.s1 stor-layout.s
+ diff stringpool.s1 stringpool.s
+ diff timevar.s1 timevar.s
+ diff toplev.s1 toplev.s
+ diff tree-dump.s1 tree-dump.s
+ diff tree-inline.s1 tree-inline.s
+ diff tree.s1 tree.s
+ diff unroll.s1 unroll.s
+ diff varasm.s1 varasm.s
+ diff varray.s1 varray.s
+ diff version.s1 version.s
+ diff xmalloc.s1 xmalloc.s
+ diff xstrerror.s1 xstrerror.s
+ diff xstrdup.s1 xstrdup.s
+ diff xexit.s1 xexit.s
+ diff concat.s1 concat.s
+ diff hex.s1 hex.s
+ diff alloca.s1 alloca.s
+ diff lbasename.s1 lbasename.s
+ diff obstack.s1 obstack.s
+ diff strsignal.s1 strsignal.s
+ diff safe-ctype.s1 safe-ctype.s
+ diff splay-tree.s1 splay-tree.s
+ diff fibheap.s1 fibheap.s
+ diff hashtab.s1 hashtab.s
+ diff asprintf.s1 asprintf.s
+ diff vasprintf.s1 vasprintf.s
+ diff getpagesize.s1 getpagesize.s
+ diff partition.s1 partition.s
+ diff i370-c.s1 i370-c.s
+ diff i370.s1 i370.s
+ diff unixio.s1 unixio.s
+ diff stdio.s1 stdio.s
+ diff stdlib.s1 stdlib.s
+ diff ctype.s1 ctype.s
+ diff string.s1 string.s
+ diff time.s1 time.s
+ diff errno.s1 errno.s
+ diff assert.s1 assert.s
+ diff locale.s1 locale.s
+ diff math.s1 math.s
+ diff setjmp.s1 setjmp.s
+ diff signal.s1 signal.s
+ diff start.s1 start.s
+ diff __memmgr.s1 __memmgr.s
Index: gcc/gcc/compvse.m4
diff -c nul gcc/gcc/compvse.m4:1.94
*** nul	Tue Oct 01 16:28:43 2019
--- gcc/gcc/compvse.m4	Tue Dec 29 20:55:59 2015
***************
*** 0 ****
--- 1,1251 ----
+ * $$ JOB JNM=VSEJOB
+ * $$ LST LST=SYSLST,CLASS=A,RBM=999999
+ // JOB VSEJOB
+ *
+ *
+ * Disk layout, measured in tracks
+ * These are distinct logical files
+ * Default setup assumes that you wish to compile on the
+ * same disk as the normal, predefined disk used for syslnk
+ * Steer clear of bottom 4000, system files are there by default.
+ * Note that by default there are a lot of things cataloged
+ * in system libraries, whereas normally you would only want
+ * the final PHASEs to be put into system libraries, so you
+ * may want to change that.
+ * Space allocation is defined in a way that allows a global
+ * replace to be done.
+ *
+ *
+ * 10000,500 SPACE-ALLZIP (zip of zips)
+ * 10500,300 SPACE-SINGLEZIP (single zip under consideration)
+ * 10800,100 SPACE-SINGLEC (single C source file)
+ *
+ * 11000,500 SPACE-ASMOUT (assembler output from C compile et al)
+ * 12000,500 SPACE-OBJ (object code from above C-based assembly)
+ *
+ * 13000,1000 SPACE-SYSPUNCH (syspunch output, e.g. CIL header extract)
+ * 14000,2000 SPACE-PHASE (syslnk phase input)
+ *
+ *
+ *
+ * Standard assignments for C programs
+ *
+ // ASSGN SYS000,SYSLNK
+ // ASSGN SYS005,SYSLST
+ // ASSGN SYS007,SYSPCH
+ // OPTION DUMP
+ *
+ *
+ *
+ *
+ * First we get the zip of zips from tape.
+ *
+ // DLBL SDO1,'ALL.ZIP',0,SD
+ // EXTENT SYS000,,,,10000,500 SPACE-ALLZIP
+ // ASSGN SYS011,TAPE
+ // EXEC COPYFILE,SIZE=AUTO,PARM='-bb dd:mti1 dd:sdo1'
+ *
+ *
+ *
+ *
+ *
+ * unzip the PDPCLIB include zip file
+ *
+ // DLBL SDI1,'ALL.ZIP'
+ // DLBL SDO1,'PDPI.ZIP',0,SD
+ // EXTENT SYS000,,,,10500,300 SPACE-SINGLEZIP
+ // EXEC MVSUNZIP,SIZE=AUTO,PARM='dd:sdi1 dd:sdo1 pdpi.zip binary'
+ *
+ *
+ *
+ *
+ *
+ * extract header files
+ *
+ // DLBL IJSYSPH,'PDPPUNCH.DAT',0,SD
+ // EXTENT SYSPCH,,,,13000,1000 SPACE-SYSPUNCH
+ ASSGN SYSPCH,SYS000
+ *
+ // DLBL SDI1,'PDPI.ZIP'
+ // EXEC MVSUNZIP,SIZE=AUTO,PARM='dd:sdi1 dd:sdo1'
+ *
+ CLOSE SYSPCH,PUNCH
+ *
+ *
+ *
+ *
+ *
+ * Put header files into the CIL
+ *
+ ASSGN SYSLNK,SYS000
+ // OPTION CATAL
+ // DLBL IJSYSIN,'PDPPUNCH.DAT'
+ ASSGN SYSIPT,SYS000
+  INCLUDE
+ CLOSE SYSIPT,READER
+ // EXEC LNKEDT
+ ASSGN SYSLNK,UA
+ *
+ *
+ *
+ *
+ *
+ *
+ * Assemble the prolog/epilog macros
+ *
+ // OPTION EDECK,NODECK  
+ // DLBL IJSYSPH,'PDPPUNCH.DAT',0,SD
+ // EXTENT SYSPCH,,,,13000,1000 SPACE-SYSPUNCH
+ ASSGN SYSPCH,SYS000
+ // EXEC ASSEMBLY
+ undivert(pdpprlg.mac)dnl
+ undivert(pdpepil.mac)dnl
+          END
+ /*
+ CLOSE SYSPCH,PUNCH
+ *
+ *
+ * Put them into the assembler macro library
+ *
+ // DLBL IJSYSIN,'PDPPUNCH.DAT'
+ ASSGN SYSIPT,SYS000
+ // EXEC MAINT                                         
+ CLOSE SYSIPT,READER
+ *
+ *
+ *
+ * Also save a copy into the CIL that can be fed back to
+ * maint again later.
+ *
+ // DLBL SDI1,'PDPPUNCH.DAT'
+ // DLBL IJSYSPH,'PDPPUN2.DAT',0,SD
+ // EXTENT SYSPCH,,,,14000,2000 SPACE-SYSPUNCH
+ ASSGN SYSPCH,SYS000
+ // EXEC VSEMANIP,SIZE=AUTO,PARM='dd:sdi1 dd:out(pdpmacs)'
+ CLOSE SYSPCH,PUNCH
+ *
+ *
+ *
+ * Put copy of macros into CIL using LNKEDT
+ *
+ ASSGN SYSLNK,SYS000
+ // OPTION CATAL
+ // DLBL IJSYSIN,'PDPPUN2.DAT'
+ ASSGN SYSIPT,SYS000
+  INCLUDE
+ CLOSE SYSIPT,READER
+ // EXEC LNKEDT
+ ASSGN SYSLNK,UA
+ *
+ *
+ *
+ * Put the copy libs directly in
+ *
+ // EXEC MAINT
+  CATALS A.PDPTOP
+  BKEND
+ undivert(pdptop.mac)dnl
+  BKEND
+ /*
+ *
+ // EXEC MAINT
+  CATALS A.PDP370
+  BKEND
+ undivert(pdp370.mac)dnl
+  BKEND
+ /*
+ *
+ // EXEC MAINT
+  CATALS A.PDP380
+  BKEND
+ undivert(pdp380.mac)dnl
+  BKEND
+ /*
+ *
+ // EXEC MAINT
+  CATALS A.PDP390
+  BKEND
+ undivert(pdp390.mac)dnl
+  BKEND
+ /*
+ *
+ *
+ *
+ *
+ *
+ *
+ * Now assemble the main routine
+ *
+ * Note that GCC exceeds the limits of z/VSE so cannot be made
+ * relocatable until a separate tool is written.
+ * Until then, the 7 MB location is the one most likely to work
+ * on a z/VSE system.
+ *
+ * However, if building on a VSE/380 system, some tricks needed
+ * to be pulled to make that work, and as a result, at least for
+ * now, if this value below is changed, both VSEPARM and $JOBEXIT
+ * also need to be changed to cope with the new location.
+ *
+ // DLBL IJSYSLN,,0,SD
+ // EXTENT SYSLNK,,,,14000,1000 SPACE-PHASE
+ ASSGN SYSLNK,SYS000
+ // OPTION CATAL,NOLIST
+  PHASE GCC,+X'7000C8'
+ // EXEC ASSEMBLY
+ undivert(vsestart.asm)dnl
+ /*
+ *
+ * Now assemble the subroutines
+ *
+ // EXEC ASSEMBLY
+ undivert(start.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(stdlib.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(ctype.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(string.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(time.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(errno.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(assert.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(locale.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(math.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(setjmp.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(signal.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(__memmgr.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(stdio.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(vsesupa.asm)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(alias.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(attribs.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(bb-reorder.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(bitmap.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(builtins.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(c-aux-info.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(c-common.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(c-convert.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(c-decl.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(c-errors.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(c-format.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(c-lang.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(c-lex.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(c-objc-common.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(c-parse.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(c-pragma.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(c-semantics.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(c-typeck.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(caller-save.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(calls.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(cfg.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(cfganal.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(cfgbuild.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(cfgcleanup.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(cfglayout.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(cfgloop.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(cfgrtl.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(combine.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(conflict.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(convert.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(cppdefault.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(cpperror.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(cppexp.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(cppfiles.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(cpphash.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(cppinit.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(cpplex.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(cpplib.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(cppmacro.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(cppmain.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(cppspec.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(cse.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(cselib.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(debug.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(dependence.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(df.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(diagnostic.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(dominance.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(dwarf2asm.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(dwarf2out.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(emit-rtl.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(except.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(explow.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(expmed.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(expr.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(final.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(flow.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(fold-const.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(function.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(gcc.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(gccspec.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(gcse.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(genrtl.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(ggc-common.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(ggc-page.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(global.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(graph.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(hash.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(hashtable.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(hooks.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(ifcvt.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(insn-attrtab.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(insn-emit.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(insn-extract.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(insn-opinit.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(insn-output.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(insn-recog.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(integrate.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(jump.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(langhooks.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(lcm.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(line-map.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(lists.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(local-alloc.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(loop.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(mkdeps.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(optabs.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(params.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(predict.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(prefix.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(print-rtl.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(print-tree.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(profile.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(real.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(recog.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(regclass.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(regmove.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(regrename.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(reload.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(reload1.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(resource.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(rtl-error.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(rtl.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(rtlanal.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(sbitmap.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(sibcall.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(simplify-rtx.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(ssa-ccp.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(ssa-dce.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(ssa.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(stmt.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(stor-layout.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(stringpool.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(timevar.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(toplev.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(tree-dump.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(tree-inline.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(tree.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(unroll.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(varasm.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(varray.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(version.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(xmalloc.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(xstrerror.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(xstrdup.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(xexit.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(concat.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(hex.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(alloca.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(lbasename.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(obstack.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(strsignal.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(safe-ctype.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(splay-tree.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(fibheap.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(hashtab.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(asprintf.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(vasprintf.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(getpagesize.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(partition.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(i370-c.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(i370.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(unixio.s)dnl
+ /*
+ *
+ * Now link the whole app
+ *
+ // EXEC LNKEDT
+ *
+ ASSGN SYSLNK,UA
+ *
+ *
+ *
+ *
+ *
+ *
+ *
+ * Now run the app
+ *
+ // EXEC GCC,SIZE=AUTO,PARM='-S -o - -'
+ #include <stdio.h>
+ 
+ int main(void)
+ {
+     printf("hello, world %d\n", FILENAME_MAX);
+     return (0);
+ }
+ /*
+ *
+ *
+ *
+ *
+ * Switch to S/370 executables now
+ *
+ // EXEC MAINT
+  CATALS A.PDPTOP
+  BKEND
+ undivert(pdp370.mac)dnl
+  BKEND
+ /*
+ *
+ *
+ *
+ * unzip the PDPCLIB source zip file
+ *
+ // DLBL SDI1,'ALL.ZIP'
+ // DLBL SDO1,'PDPSRC.ZIP',0,SD
+ // EXTENT SYS000,,,,10500,300 SPACE-SINGLEZIP
+ // EXEC MVSUNZIP,SIZE=AUTO,PARM='dd:sdi1 dd:sdo1 pdpsrc.zip binary'
+ *
+ *
+ *
+ *
+ *
+ * create the proc from list of files
+ *
+ // DLBL IJSYSPH,'PDPPUNCH.DAT',0,SD
+ // EXTENT SYSPCH,,,,13000,1000 SPACE-SYSPUNCH
+ ASSGN SYSPCH,SYS000
+ // EXEC VSEPROC,SIZE=AUTO,PARM='- dd:syspunch'
+ -----
+ STDIO
+ STRING
+ STDLIB
+ CTYPE
+ ERRNO
+ LOCALE
+ MATH
+ SIGNAL
+ SETJMP
+ ASSERT
+ TIME
+ START
+ -----
+ *
+ *
+ *
+ * unzip %s.C
+ *
+ // DLBL SDI1,'PDPSRC.ZIP'
+ // DLBL SDO1,'%s.C',0,SD
+ // EXTENT SYS000,,,,10800,100 SPACE-SINGLEC
+ // EXEC MVSUNZIP,SIZE=AUTO,PARM='dd:sdi1 dd:sdo1 %s.C'
+ *
+ * Compile %s
+ *
+ // DLBL SDI1,'%s.C'
+ // DLBL IJSYSPH,'%s.S',0,SD
+ // EXTENT SYSPCH,,,,11000,500 SPACE-ASMOUT
+ ASSGN SYSPCH,SYS000
+ // EXEC GCC,SIZE=AUTO,PARM='-S -Os -o dd:syspunch dd:sdi1'
+ *
+ CLOSE SYSPCH,PUNCH                                    
+ *
+ *
+ * assemble %s
+ *
+ // DLBL IJSYSIN,'%s.S'
+ ASSGN SYSIPT,SYS000
+ // DLBL IJSYSPH,'%s.OBJ',0,SD
+ // EXTENT SYSPCH,,,,12000,500 SPACE-OBJ
+ ASSGN SYSPCH,SYS000
+ // OPTION DECK,NOEDECK
+  CATALR %s
+ // EXEC ASSEMBLY
+ *
+ CLOSE SYSPCH,PUNCH                                    
+ CLOSE SYSIPT,READER
+ *
+ *
+ *
+ // DLBL IJSYSIN,'%s.OBJ'
+ ASSGN SYSIPT,SYS000
+ // EXEC MAINT
+ CLOSE SYSIPT,READER
+ *
+ *
+ *
+ -----
+ /*
+ CLOSE SYSPCH,PUNCH
+ *
+ *
+ *
+ *
+ *
+ * Put the PROC in
+ *
+ // DLBL IJSYSIN,'PDPPUNCH.DAT'
+ ASSGN SYSIPT,SYS000
+ // EXEC MAINT
+ CLOSE SYSIPT,READER
+ *
+ *
+ *
+ *
+ *
+ * execute the proc
+ *
+ // EXEC PROC=VSEPROC
+ *
+ *
+ *
+ *
+ *
+ *
+ *
+ *
+ *
+ * unzip __memmgr.c
+ *
+ // DLBL SDI1,'PDPSRC.ZIP'
+ // DLBL SDO1,'@@MEMMGR.C',0,SD
+ // EXTENT SYS000,,,,10800,100 SPACE-SINGLEC
+ // EXEC MVSUNZIP,SIZE=AUTO,PARM='dd:sdi1 dd:sdo1 __memmgr.c'
+ *
+ * Compile __memmgr
+ *
+ // DLBL SDI1,'@@MEMMGR.C'
+ // DLBL IJSYSPH,'@@MEMMGR.S',0,SD
+ // EXTENT SYSPCH,,,,11000,500 SPACE-ASMOUT
+ ASSGN SYSPCH,SYS000
+ // EXEC GCC,SIZE=AUTO,PARM='-S -Os -o dd:syspunch dd:sdi1'
+ *
+ CLOSE SYSPCH,PUNCH                                    
+ *
+ *
+ * assemble __memmgr
+ *
+ // DLBL IJSYSIN,'@@MEMMGR.S'
+ ASSGN SYSIPT,SYS000
+ // DLBL IJSYSPH,'@@MEMMGR.OBJ',0,SD
+ // EXTENT SYSPCH,,,,12000,500 SPACE-OBJ
+ ASSGN SYSPCH,SYS000
+ // OPTION DECK,NOEDECK
+  CATALR @@MEMMGR
+ // EXEC ASSEMBLY
+ *
+ CLOSE SYSPCH,PUNCH                                    
+ CLOSE SYSIPT,READER
+ *
+ // DLBL IJSYSIN,'@@MEMMGR.OBJ'
+ ASSGN SYSIPT,SYS000
+ // EXEC MAINT
+ CLOSE SYSIPT,READER
+ *
+ *
+ *
+ *
+ *
+ *
+ *
+ *
+ *
+ * unzip vsesupa
+ *
+ // DLBL SDI1,'PDPSRC.ZIP'
+ // DLBL SDO1,'VSESUPA.ASM',0,SD
+ // EXTENT SYS000,,,,10800,100 SPACE-SINGLEC
+ // EXEC MVSUNZIP,SIZE=AUTO,PARM='dd:sdi1 dd:sdo1 vsesupa.asm'
+ *
+ *
+ * Copy vsesupa
+ *
+ // DLBL SDI1,'VSESUPA.ASM'
+ // DLBL IJSYSPH,'VSESUPA.S',0,SD
+ // EXTENT SYSPCH,,,,11000,500 SPACE-ASMOUT
+ ASSGN SYSPCH,SYS000
+ // EXEC COPYFILE,SIZE=AUTO,PARM='-tt dd:sdi1 dd:syspunch'
+ CLOSE SYSPCH,PUNCH                                    
+ *
+ *
+ *
+ * assemble vsesupa
+ *
+ // DLBL IJSYSIN,'VSESUPA.S'
+ ASSGN SYSIPT,SYS000
+ // DLBL IJSYSPH,'VSESUPA.OBJ',0,SD
+ // EXTENT SYSPCH,,,,12000,500 SPACE-OBJ
+ ASSGN SYSPCH,SYS000
+ // OPTION DECK,NOEDECK
+  CATALR VSESUPA
+ // EXEC ASSEMBLY
+ *
+ CLOSE SYSPCH,PUNCH                                    
+ CLOSE SYSIPT,READER
+ *
+ // DLBL IJSYSIN,'VSESUPA.OBJ'
+ ASSGN SYSIPT,SYS000
+ // EXEC MAINT
+ CLOSE SYSIPT,READER
+ *
+ *
+ *
+ *
+ *
+ *
+ *
+ * unzip vsestart
+ *
+ // DLBL SDI1,'PDPSRC.ZIP'
+ // DLBL SDO1,'VSESTART.ASM',0,SD
+ // EXTENT SYS000,,,,10800,100 SPACE-SINGLEC
+ // EXEC MVSUNZIP,SIZE=AUTO,PARM='dd:sdi1 dd:sdo1 vsestart.asm'
+ *
+ *
+ * Copy vsestart
+ *
+ // DLBL SDI1,'VSESTART.ASM'
+ // DLBL IJSYSPH,'VSESTART.S',0,SD
+ // EXTENT SYSPCH,,,,11000,500 SPACE-ASMOUT
+ ASSGN SYSPCH,SYS000
+ // EXEC COPYFILE,SIZE=AUTO,PARM='-tt dd:sdi1 dd:syspunch'
+ CLOSE SYSPCH,PUNCH                                    
+ *
+ *
+ *
+ * assemble vsestart
+ *
+ // DLBL IJSYSIN,'VSESTART.S'
+ ASSGN SYSIPT,SYS000
+ // DLBL IJSYSPH,'VSESTART.OBJ',0,SD
+ // EXTENT SYSPCH,,,,12000,500 SPACE-OBJ
+ ASSGN SYSPCH,SYS000
+ // OPTION DECK,NOEDECK
+  CATALR VSESTART
+ // EXEC ASSEMBLY
+ *
+ CLOSE SYSPCH,PUNCH                                    
+ CLOSE SYSIPT,READER
+ *
+ // DLBL IJSYSIN,'VSESTART.OBJ'
+ ASSGN SYSIPT,SYS000
+ // EXEC MAINT
+ CLOSE SYSIPT,READER
+ *
+ *
+ *
+ *
+ *
+ *
+ *
+ *
+ * create the proc from list of files
+ *
+ // DLBL IJSYSPH,'PDPPUNCH.DAT',0,SD
+ // EXTENT SYSPCH,,,,13000,1000 SPACE-SYSPUNCH
+ ASSGN SYSPCH,SYS000
+ // EXEC VSEPROC,SIZE=AUTO,PARM='- dd:syspunch'
+ -----
+ COPYFILE
+ MVSENDEC
+ VSEPROC
+ VSEMANIP
+ HEXDUMP
+ MVSUNZIP
+ PDPTEST
+ -----
+ *
+ * unzip %s.C
+ *
+ // DLBL SDI1,'PDPSRC.ZIP'
+ // DLBL SDO1,'%s.C',0,SD
+ // EXTENT SYS000,,,,10800,100 SPACE-SINGLEC
+ // EXEC MVSUNZIP,SIZE=AUTO,PARM='dd:sdi1 dd:sdo1 %s.C'
+ *
+ *
+ *
+ * Compile %s
+ *
+ // DLBL SDI1,'%s.C'
+ // DLBL IJSYSPH,'%s.ASM',0,SD
+ // EXTENT SYSPCH,,,,11000,500 SPACE-ASMOUT
+ ASSGN SYSPCH,SYS000
+ // EXEC GCC,SIZE=AUTO,PARM='-S -Os -o dd:syspunch dd:sdi1'
+ *
+ CLOSE SYSPCH,PUNCH                                    
+ *
+ *
+ *
+ * assemble %s
+ *
+ // DLBL IJSYSLN,,0,SD
+ // EXTENT SYSLNK,,,,14000,1000 SPACE-PHASE
+ ASSGN SYSLNK,SYS000
+ // OPTION LINK
+ // OPTION CATAL,LIST
+  PHASE %s,S+80
+ // DLBL IJSYSIN,'%s.ASM'
+ ASSGN SYSIPT,SYS000
+ // EXEC ASSEMBLY
+ CLOSE SYSIPT,READER
+ *
+ *
+ *
+ *
+ * link %s
+ *
+  INCLUDE VSESTART
+  INCLUDE STDIO
+  INCLUDE STRING
+  INCLUDE STDLIB
+  INCLUDE CTYPE
+  INCLUDE ERRNO
+  INCLUDE LOCALE
+  INCLUDE MATH
+  INCLUDE SIGNAL
+  INCLUDE SETJMP
+  INCLUDE ASSERT
+  INCLUDE TIME
+  INCLUDE START
+  INCLUDE VSESUPA
+  ENTRY @@MAIN
+ // EXEC LNKEDT
+ ASSGN SYSLNK,UA
+ *
+ *
+ *
+ -----
+ /*
+ CLOSE SYSPCH,PUNCH
+ *
+ *
+ *
+ *
+ *
+ * Put the PROC in
+ *
+ // DLBL IJSYSIN,'PDPPUNCH.DAT'
+ ASSGN SYSIPT,SYS000
+ // EXEC MAINT
+ CLOSE SYSIPT,READER
+ *
+ *
+ *
+ *
+ *
+ * execute the proc
+ *
+ // EXEC PROC=VSEPROC
+ *
+ *
+ *
+ *
+ *
+ *
+ * Now run PDPTEST
+ *
+ // EXEC PDPTEST,SIZE=AUTO,PARM='PaulEdwards was Here'
+ *
+ *
+ *
+ *
+ * Now punch the header files by executing CSERV (unusually)
+ *
+ // DLBL IJSYSPH,'PDPPUNCH.DAT',0,SD
+ // EXTENT SYSPCH,,,,13000,1000 SPACE-SYSPUNCH
+ ASSGN SYSPCH,SYS000
+ // EXEC CSERV
+  PUNCH ASSERT
+  PUNCH CTYPE
+  PUNCH ERRNO
+  PUNCH FLOAT
+  PUNCH LIMITS
+  PUNCH LOCALE
+  PUNCH MATH
+  PUNCH MVSSUPA
+  PUNCH SETJMP
+  PUNCH SIGNAL
+  PUNCH STDARG
+  PUNCH STDDEF
+  PUNCH STDIO
+  PUNCH STDLIB
+  PUNCH STRING
+  PUNCH TIME
+  PUNCH @@MEMMGR
+ /*
+ CLOSE SYSPCH,PUNCH
+ *
+ *
+ *
+ * And get the single file ready for the CIL
+ *
+ // DLBL SDI1,'PDPPUNCH.DAT'
+ // DLBL IJSYSPH,'PDPPUN2.DAT',0,SD
+ // EXTENT SYSPCH,,,,14000,2000 SPACE-PHASE
+ ASSGN SYSPCH,SYS000
+ // EXEC VSEMANIP,SIZE=AUTO,PARM='dd:sdi1 dd:out(pdpi)'
+ CLOSE SYSPCH,PUNCH
+ *
+ *
+ *
+ *
+ * Now put it in the CIL
+ *
+ ASSGN SYSLNK,SYS000
+ // OPTION CATAL
+ // DLBL IJSYSIN,'PDPPUN2.DAT'
+ ASSGN SYSIPT,SYS000
+  INCLUDE
+ CLOSE SYSIPT,READER
+ // EXEC LNKEDT
+ ASSGN SYSLNK,UA
+ *
+ *
+ *
+ *
+ *
+ *
+ *
+ *
+ *
+ *
+ * Now punch the relocatable objects by executing RSERV
+ *
+ // DLBL IJSYSPH,'PDPPUNCH.DAT',0,SD
+ // EXTENT SYSPCH,,,,13000,1000 SPACE-SYSPUNCH
+ ASSGN SYSPCH,SYS000
+ // EXEC RSERV
+  PUNCH ASSERT
+  PUNCH CTYPE
+  PUNCH ERRNO
+  PUNCH LOCALE
+  PUNCH MATH
+  PUNCH VSESUPA
+  PUNCH VSESTART
+  PUNCH START
+  PUNCH SETJMP
+  PUNCH SIGNAL
+  PUNCH STDIO
+  PUNCH STDLIB
+  PUNCH STRING
+  PUNCH TIME
+  PUNCH @@MEMMGR
+ /*
+ CLOSE SYSPCH,PUNCH
+ *
+ *
+ *
+ * And get the single file ready for the CIL
+ *
+ // DLBL SDI1,'PDPPUNCH.DAT'
+ // DLBL IJSYSPH,'PDPPUN2.DAT',0,SD
+ // EXTENT SYSPCH,,,,14000,2000 SPACE-PHASE
+ ASSGN SYSPCH,SYS000
+ // EXEC VSEMANIP,SIZE=AUTO,PARM='dd:sdi1 dd:out(pdpobj)'
+ CLOSE SYSPCH,PUNCH
+ *
+ *
+ *
+ *
+ * Now put it in the CIL
+ *
+ ASSGN SYSLNK,SYS000
+ // OPTION CATAL
+ // DLBL IJSYSIN,'PDPPUN2.DAT'
+ ASSGN SYSIPT,SYS000
+  INCLUDE
+ CLOSE SYSIPT,READER
+ // EXEC LNKEDT
+ ASSGN SYSLNK,UA
+ *
+ *
+ *
+ *
+ *
+ *
+ *
+ * Now punch the assembler copybooks using SSERV
+ *
+ // DLBL IJSYSPH,'PDPPUNCH.DAT',0,SD
+ // EXTENT SYSPCH,,,,13000,1000 SPACE-SYSPUNCH
+ ASSGN SYSPCH,SYS000
+ // EXEC SSERV
+  PUNCH PDPTOP
+  PUNCH PDP370
+  PUNCH PDP380
+  PUNCH PDP390
+ /*
+ CLOSE SYSPCH,PUNCH
+ *
+ *
+ *
+ * And get the single file ready for the CIL
+ *
+ // DLBL SDI1,'PDPPUNCH.DAT'
+ // DLBL IJSYSPH,'PDPPUN2.DAT',0,SD
+ // EXTENT SYSPCH,,,,14000,2000 SPACE-PHASE
+ ASSGN SYSPCH,SYS000
+ // EXEC VSEMANIP,SIZE=AUTO,PARM='dd:sdi1 dd:out(pdpcopy)'
+ CLOSE SYSPCH,PUNCH
+ *
+ *
+ *
+ *
+ * Now put it in the CIL
+ *
+ ASSGN SYSLNK,SYS000
+ // OPTION CATAL
+ // DLBL IJSYSIN,'PDPPUN2.DAT'
+ ASSGN SYSIPT,SYS000
+  INCLUDE
+ CLOSE SYSIPT,READER
+ // EXEC LNKEDT
+ ASSGN SYSLNK,UA
+ *
+ *
+ *
+ *
+ *
+ *
+ * Now punch the phases
+ *
+ // DLBL IJSYSPH,'PDPPUN2.DAT',0,SD
+ // EXTENT SYSPCH,,,,14000,2000 SPACE-PHASE
+ ASSGN SYSPCH,SYS000
+ // EXEC CSERV
+  PUNCH GCC
+  PUNCH COPYFILE
+  PUNCH HEXDUMP
+  PUNCH MVSENDEC
+  PUNCH MVSUNZIP
+  PUNCH VSEPROC
+  PUNCH VSEMANIP
+  PUNCH PDPI
+  PUNCH PDPOBJ
+  PUNCH PDPMACS
+  PUNCH PDPCOPY
+ /*
+ CLOSE SYSPCH,PUNCH
+ *
+ *
+ *
+ * And put it to tape
+ *
+ // DLBL SDI1,'PDPPUN2.DAT'
+ // TLBL MTO1,'HERC01.MFTOPC',0
+ // ASSGN SYS011,TAPE,VOL=MFTOPC
+ // EXEC VSEMANIP,SIZE=AUTO,PARM='dd:sdi1 dd:mto1'
+ *
+ *
+ *
+ *
+ /&
+ * $$ EOJ
Index: gcc/gcc/compwin.bat
diff -c nul gcc/gcc/compwin.bat:1.1
*** nul	Tue Oct 01 16:28:43 2019
--- gcc/gcc/compwin.bat	Thu Jul 04 16:18:05 2019
***************
*** 0 ****
--- 1,530 ----
+ del *.s
+ del *.o
+ del temp.a
+ del gcc-pdos.exe
+ 
+ call stdcompj alias.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj attribs.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj bb-reorder.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj bitmap.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj builtins.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj c-aux-info.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj c-common.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj c-convert.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj c-decl.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj c-errors.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj c-format.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj c-lang.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj c-lex.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj c-objc-common.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj c-parse.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj c-pragma.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj c-semantics.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj c-typeck.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj caller-save.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj calls.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj cfg.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj cfganal.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj cfgbuild.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj cfgcleanup.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj cfglayout.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj cfgloop.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj cfgrtl.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj combine.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj conflict.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj convert.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj cppdefault.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj cpperror.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj cppexp.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj cppfiles.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj cpphash.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj cppinit.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj cpplex.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj cpplib.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj cppmacro.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj cppmain.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj cppspec.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj cse.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj cselib.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj debug.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj dependence.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj df.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj diagnostic.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj dominance.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj dwarf2asm.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj dwarf2out.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj emit-rtl.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj except.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj explow.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj expmed.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj expr.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj final.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj flow.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj fold-const.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj function.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj gcc.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj gccspec.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj gcse.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj genrtl.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj ggc-common.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj ggc-page.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj global.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj graph.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj hash.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj haifa-sched.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj hashtable.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj hooks.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj ifcvt.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj insn-attrtab.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj insn-emit.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj insn-extract.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj insn-opinit.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj insn-output.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj insn-peep.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj insn-recog.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj integrate.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj jump.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj langhooks.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj lcm.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj line-map.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj lists.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj local-alloc.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj loop.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj mkdeps.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj optabs.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj params.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj predict.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj prefix.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj print-rtl.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj print-tree.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj profile.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj real.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj recog.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj regclass.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj regmove.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj regrename.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj reload.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj reload1.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj resource.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj rtl-error.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj rtl.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj rtlanal.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj sbitmap.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj sched-deps.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj sched-rgn.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj sched-vis.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj sibcall.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj simplify-rtx.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj ssa-ccp.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj ssa-dce.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj ssa.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj stmt.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj stor-layout.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj stringpool.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj timevar.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj toplev.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj tree-dump.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj tree-inline.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj tree.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj unroll.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj varasm.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj varray.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj version.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ 
+ call stdcompj ../libiberty/xmalloc.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj ../libiberty/xstrerror.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj ../libiberty/xstrdup.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj ../libiberty/xexit.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj ../libiberty/concat.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj ../libiberty/hex.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj ../libiberty/alloca.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj ../libiberty/lbasename.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj ../libiberty/obstack.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj ../libiberty/strsignal.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj ../libiberty/safe-ctype.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj ../libiberty/splay-tree.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj ../libiberty/fibheap.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj ../libiberty/hashtab.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj ../libiberty/asprintf.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj ../libiberty/vasprintf.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj ../libiberty/getpagesize.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj ../libiberty/partition.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ 
+ call stdcompj config/i386/i386.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj config/i386/winnt.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ 
+ call stdcompj unixio.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ 
+ call stdcompj reg-stack.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj doloop.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj sdbout.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj dbxout.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj ../libiberty/md5.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ 
+ call stdcompj ../../pdos/pdpclib/stdio.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj ../../pdos/pdpclib/stdlib.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj ../../pdos/pdpclib/ctype.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj ../../pdos/pdpclib/string.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj ../../pdos/pdpclib/time.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj ../../pdos/pdpclib/errno.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj ../../pdos/pdpclib/assert.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj ../../pdos/pdpclib/locale.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj ../../pdos/pdpclib/math.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj ../../pdos/pdpclib/setjmp.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj ../../pdos/pdpclib/signal.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj ../../pdos/pdpclib/start.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompj ../../pdos/pdpclib/__memmgr.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ 
+ rem call stdcompj ../../pdos/pdpclib/pdosst32.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ rem call stdcompj ../../pdos/pdpclib/pdossupc.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ rem call stdcompj ../../pdos/src/pos.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ 
+ call stdcompj ../../pdos/pdpclib/w32start.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ 
+ aswin -o alias.o alias.s
+ aswin -o alloca.o alloca.s
+ aswin -o asprintf.o asprintf.s
+ aswin -o assert.o assert.s
+ aswin -o attribs.o attribs.s
+ aswin -o bb-reorder.o bb-reorder.s
+ aswin -o bitmap.o bitmap.s
+ aswin -o builtins.o builtins.s
+ aswin -o c-aux-info.o c-aux-info.s
+ aswin -o c-common.o c-common.s
+ aswin -o c-convert.o c-convert.s
+ aswin -o c-decl.o c-decl.s
+ aswin -o c-errors.o c-errors.s
+ aswin -o c-format.o c-format.s
+ aswin -o c-lang.o c-lang.s
+ aswin -o c-lex.o c-lex.s
+ aswin -o c-objc-common.o c-objc-common.s
+ aswin -o c-parse.o c-parse.s
+ aswin -o c-pragma.o c-pragma.s
+ aswin -o c-semantics.o c-semantics.s
+ aswin -o c-typeck.o c-typeck.s
+ aswin -o caller-save.o caller-save.s
+ aswin -o calls.o calls.s
+ aswin -o cfg.o cfg.s
+ aswin -o cfganal.o cfganal.s
+ aswin -o cfgbuild.o cfgbuild.s
+ aswin -o cfgcleanup.o cfgcleanup.s
+ aswin -o cfglayout.o cfglayout.s
+ aswin -o cfgloop.o cfgloop.s
+ aswin -o cfgrtl.o cfgrtl.s
+ aswin -o combine.o combine.s
+ aswin -o concat.o concat.s
+ aswin -o conflict.o conflict.s
+ aswin -o convert.o convert.s
+ aswin -o cppdefault.o cppdefault.s
+ aswin -o cpperror.o cpperror.s
+ aswin -o cppexp.o cppexp.s
+ aswin -o cppfiles.o cppfiles.s
+ aswin -o cpphash.o cpphash.s
+ aswin -o cppinit.o cppinit.s
+ aswin -o cpplex.o cpplex.s
+ aswin -o cpplib.o cpplib.s
+ aswin -o cppmacro.o cppmacro.s
+ aswin -o cppmain.o cppmain.s
+ aswin -o cppspec.o cppspec.s
+ aswin -o cse.o cse.s
+ aswin -o cselib.o cselib.s
+ aswin -o ctype.o ctype.s
+ aswin -o dbxout.o dbxout.s
+ aswin -o debug.o debug.s
+ aswin -o dependence.o dependence.s
+ aswin -o df.o df.s
+ aswin -o diagnostic.o diagnostic.s
+ aswin -o doloop.o doloop.s
+ aswin -o dominance.o dominance.s
+ aswin -o dwarf2asm.o dwarf2asm.s
+ aswin -o dwarf2out.o dwarf2out.s
+ aswin -o emit-rtl.o emit-rtl.s
+ aswin -o errno.o errno.s
+ aswin -o except.o except.s
+ aswin -o explow.o explow.s
+ aswin -o expmed.o expmed.s
+ aswin -o expr.o expr.s
+ aswin -o fibheap.o fibheap.s
+ aswin -o final.o final.s
+ aswin -o flow.o flow.s
+ aswin -o fold-const.o fold-const.s
+ aswin -o function.o function.s
+ aswin -o gcc.o gcc.s
+ aswin -o gccspec.o gccspec.s
+ aswin -o gcse.o gcse.s
+ aswin -o genrtl.o genrtl.s
+ aswin -o getpagesize.o getpagesize.s
+ aswin -o ggc-common.o ggc-common.s
+ aswin -o ggc-page.o ggc-page.s
+ aswin -o global.o global.s
+ aswin -o graph.o graph.s
+ aswin -o haifa-sched.o haifa-sched.s
+ aswin -o hash.o hash.s
+ aswin -o hashtab.o hashtab.s
+ aswin -o hashtable.o hashtable.s
+ aswin -o hex.o hex.s
+ aswin -o hooks.o hooks.s
+ aswin -o i386.o i386.s
+ aswin -o ifcvt.o ifcvt.s
+ aswin -o insn-attrtab.o insn-attrtab.s
+ aswin -o insn-emit.o insn-emit.s
+ aswin -o insn-extract.o insn-extract.s
+ aswin -o insn-opinit.o insn-opinit.s
+ aswin -o insn-output.o insn-output.s
+ aswin -o insn-peep.o insn-peep.s
+ aswin -o insn-recog.o insn-recog.s
+ aswin -o integrate.o integrate.s
+ aswin -o jump.o jump.s
+ aswin -o langhooks.o langhooks.s
+ aswin -o lbasename.o lbasename.s
+ aswin -o lcm.o lcm.s
+ aswin -o line-map.o line-map.s
+ aswin -o lists.o lists.s
+ aswin -o local-alloc.o local-alloc.s
+ aswin -o locale.o locale.s
+ aswin -o loop.o loop.s
+ aswin -o math.o math.s
+ aswin -o md5.o md5.s
+ aswin -o mkdeps.o mkdeps.s
+ aswin -o obstack.o obstack.s
+ aswin -o optabs.o optabs.s
+ aswin -o params.o params.s
+ aswin -o partition.o partition.s
+ aswin -o predict.o predict.s
+ aswin -o prefix.o prefix.s
+ aswin -o print-rtl.o print-rtl.s
+ aswin -o print-tree.o print-tree.s
+ aswin -o profile.o profile.s
+ aswin -o real.o real.s
+ aswin -o recog.o recog.s
+ aswin -o reg-stack.o reg-stack.s
+ aswin -o regclass.o regclass.s
+ aswin -o regmove.o regmove.s
+ aswin -o regrename.o regrename.s
+ aswin -o reload.o reload.s
+ aswin -o reload1.o reload1.s
+ aswin -o resource.o resource.s
+ aswin -o rtl-error.o rtl-error.s
+ aswin -o rtl.o rtl.s
+ aswin -o rtlanal.o rtlanal.s
+ aswin -o safe-ctype.o safe-ctype.s
+ aswin -o sbitmap.o sbitmap.s
+ aswin -o sched-deps.o sched-deps.s
+ aswin -o sched-rgn.o sched-rgn.s
+ aswin -o sched-vis.o sched-vis.s
+ aswin -o sdbout.o sdbout.s
+ aswin -o setjmp.o setjmp.s
+ aswin -o sibcall.o sibcall.s
+ aswin -o signal.o signal.s
+ aswin -o simplify-rtx.o simplify-rtx.s
+ aswin -o splay-tree.o splay-tree.s
+ aswin -o ssa-ccp.o ssa-ccp.s
+ aswin -o ssa-dce.o ssa-dce.s
+ aswin -o ssa.o ssa.s
+ aswin -o start.o start.s
+ aswin -o stdio.o stdio.s
+ aswin -o stdlib.o stdlib.s
+ aswin -o stmt.o stmt.s
+ aswin -o stor-layout.o stor-layout.s
+ aswin -o string.o string.s
+ aswin -o stringpool.o stringpool.s
+ aswin -o strsignal.o strsignal.s
+ aswin -o time.o time.s
+ aswin -o timevar.o timevar.s
+ aswin -o toplev.o toplev.s
+ aswin -o tree-dump.o tree-dump.s
+ aswin -o tree-inline.o tree-inline.s
+ aswin -o tree.o tree.s
+ aswin -o unixio.o unixio.s
+ aswin -o unroll.o unroll.s
+ aswin -o varasm.o varasm.s
+ aswin -o varray.o varray.s
+ aswin -o vasprintf.o vasprintf.s
+ aswin -o version.o version.s
+ aswin -o winnt.o winnt.s
+ aswin -o xexit.o xexit.s
+ aswin -o xmalloc.o xmalloc.s
+ aswin -o xstrdup.o xstrdup.s
+ aswin -o xstrerror.o xstrerror.s
+ aswin -o __memmgr.o __memmgr.s
+ 
+ rem aswin -o pdosst32.o pdosst32.s
+ rem aswin -o pdossupc.o pdossupc.s
+ rem aswin -o pos.o pos.s
+ rem aswin -o support.o ../../pdos/src/support.s
+ 
+ aswin -o w32start.o w32start.s
+ jwasm -c -coff ..\..\pdos\pdpclib\winsupa.asm
+ 
+ arwin r temp.a alias.o
+ arwin r temp.a alloca.o
+ arwin r temp.a asprintf.o
+ arwin r temp.a assert.o
+ arwin r temp.a attribs.o
+ arwin r temp.a bb-reorder.o
+ arwin r temp.a bitmap.o
+ arwin r temp.a builtins.o
+ arwin r temp.a c-aux-info.o
+ arwin r temp.a c-common.o
+ arwin r temp.a c-convert.o
+ arwin r temp.a c-decl.o
+ arwin r temp.a c-errors.o
+ arwin r temp.a c-format.o
+ arwin r temp.a c-lang.o
+ arwin r temp.a c-lex.o
+ arwin r temp.a c-objc-common.o
+ arwin r temp.a c-parse.o
+ arwin r temp.a c-pragma.o
+ arwin r temp.a c-semantics.o
+ arwin r temp.a c-typeck.o
+ arwin r temp.a caller-save.o
+ arwin r temp.a calls.o
+ arwin r temp.a cfg.o
+ arwin r temp.a cfganal.o
+ arwin r temp.a cfgbuild.o
+ arwin r temp.a cfgcleanup.o
+ arwin r temp.a cfglayout.o
+ arwin r temp.a cfgloop.o
+ arwin r temp.a cfgrtl.o
+ arwin r temp.a combine.o
+ arwin r temp.a concat.o
+ arwin r temp.a conflict.o
+ arwin r temp.a convert.o
+ arwin r temp.a cppdefault.o
+ arwin r temp.a cpperror.o
+ arwin r temp.a cppexp.o
+ arwin r temp.a cppfiles.o
+ arwin r temp.a cpphash.o
+ arwin r temp.a cppinit.o
+ arwin r temp.a cpplex.o
+ arwin r temp.a cpplib.o
+ arwin r temp.a cppmacro.o
+ arwin r temp.a cppmain.o
+ arwin r temp.a cppspec.o
+ arwin r temp.a cse.o
+ arwin r temp.a cselib.o
+ arwin r temp.a ctype.o
+ arwin r temp.a dbxout.o
+ arwin r temp.a debug.o
+ arwin r temp.a dependence.o
+ arwin r temp.a df.o
+ arwin r temp.a diagnostic.o
+ arwin r temp.a doloop.o
+ arwin r temp.a dominance.o
+ arwin r temp.a dwarf2asm.o
+ arwin r temp.a dwarf2out.o
+ arwin r temp.a emit-rtl.o
+ arwin r temp.a errno.o
+ arwin r temp.a except.o
+ arwin r temp.a explow.o
+ arwin r temp.a expmed.o
+ arwin r temp.a expr.o
+ arwin r temp.a fibheap.o
+ arwin r temp.a final.o
+ arwin r temp.a flow.o
+ arwin r temp.a fold-const.o
+ arwin r temp.a function.o
+ arwin r temp.a gcc.o
+ arwin r temp.a gccspec.o
+ arwin r temp.a gcse.o
+ arwin r temp.a genrtl.o
+ arwin r temp.a getpagesize.o
+ arwin r temp.a ggc-common.o
+ arwin r temp.a ggc-page.o
+ arwin r temp.a global.o
+ arwin r temp.a graph.o
+ arwin r temp.a haifa-sched.o
+ arwin r temp.a hash.o
+ arwin r temp.a hashtab.o
+ arwin r temp.a hashtable.o
+ arwin r temp.a hex.o
+ arwin r temp.a hooks.o
+ arwin r temp.a i386.o
+ arwin r temp.a ifcvt.o
+ arwin r temp.a insn-attrtab.o
+ arwin r temp.a insn-emit.o
+ arwin r temp.a insn-extract.o
+ arwin r temp.a insn-opinit.o
+ arwin r temp.a insn-output.o
+ arwin r temp.a insn-peep.o
+ arwin r temp.a insn-recog.o
+ arwin r temp.a integrate.o
+ arwin r temp.a jump.o
+ arwin r temp.a langhooks.o
+ arwin r temp.a lbasename.o
+ arwin r temp.a lcm.o
+ arwin r temp.a line-map.o
+ arwin r temp.a lists.o
+ arwin r temp.a local-alloc.o
+ arwin r temp.a locale.o
+ arwin r temp.a loop.o
+ arwin r temp.a math.o
+ arwin r temp.a md5.o
+ arwin r temp.a mkdeps.o
+ arwin r temp.a obstack.o
+ arwin r temp.a optabs.o
+ arwin r temp.a params.o
+ arwin r temp.a partition.o
+ arwin r temp.a predict.o
+ arwin r temp.a prefix.o
+ arwin r temp.a print-rtl.o
+ arwin r temp.a print-tree.o
+ arwin r temp.a profile.o
+ arwin r temp.a real.o
+ arwin r temp.a recog.o
+ arwin r temp.a reg-stack.o
+ arwin r temp.a regclass.o
+ arwin r temp.a regmove.o
+ arwin r temp.a regrename.o
+ arwin r temp.a reload.o
+ arwin r temp.a reload1.o
+ arwin r temp.a resource.o
+ arwin r temp.a rtl-error.o
+ arwin r temp.a rtl.o
+ arwin r temp.a rtlanal.o
+ arwin r temp.a safe-ctype.o
+ arwin r temp.a sbitmap.o
+ arwin r temp.a sched-deps.o
+ arwin r temp.a sched-rgn.o
+ arwin r temp.a sched-vis.o
+ arwin r temp.a sdbout.o
+ arwin r temp.a setjmp.o
+ arwin r temp.a sibcall.o
+ arwin r temp.a signal.o
+ arwin r temp.a simplify-rtx.o
+ arwin r temp.a splay-tree.o
+ arwin r temp.a ssa-ccp.o
+ arwin r temp.a ssa-dce.o
+ arwin r temp.a ssa.o
+ arwin r temp.a start.o
+ arwin r temp.a stdio.o
+ arwin r temp.a stdlib.o
+ arwin r temp.a stmt.o
+ arwin r temp.a stor-layout.o
+ arwin r temp.a string.o
+ arwin r temp.a stringpool.o
+ arwin r temp.a strsignal.o
+ arwin r temp.a time.o
+ arwin r temp.a timevar.o
+ arwin r temp.a toplev.o
+ arwin r temp.a tree-dump.o
+ arwin r temp.a tree-inline.o
+ arwin r temp.a tree.o
+ arwin r temp.a unixio.o
+ arwin r temp.a unroll.o
+ arwin r temp.a varasm.o
+ arwin r temp.a varray.o
+ arwin r temp.a vasprintf.o
+ arwin r temp.a version.o
+ arwin r temp.a winnt.o
+ arwin r temp.a xexit.o
+ arwin r temp.a xmalloc.o
+ arwin r temp.a xstrdup.o
+ arwin r temp.a xstrerror.o
+ arwin r temp.a __memmgr.o
+ 
+ arwin r temp.a winsupa.obj
+ 
+ ldwin -s -o gcc-pdos.exe w32start.o temp.a -lkernel32 -L../../pdos/src
+ rem ldwin -r -s -e ___pdosst32 -o gcc-pdos.exe pdosst32.o temp.a
+ rem stripwin --strip-unneeded gcc-pdos.exe
Index: gcc/gcc/config.gcc
diff -c gcc/gcc/config.gcc:1.1.1.1 gcc/gcc/config.gcc:1.6
*** gcc/gcc/config.gcc:1.1.1.1	Wed Feb 15 21:22:25 2006
--- gcc/gcc/config.gcc	Fri Nov 03 16:15:22 2006
***************
*** 1101,1122 ****
  	install_headers_dir=install-headers-tar
  	use_collect2=yes
  	;;
! i370-*-opened*)			 # IBM 360/370/390 Architecture
! 	xm_defines='POSIX FATAL_EXIT_CODE=12'
! 	tm_file=i370/oe.h
  	tmake_file="i370/t-oe i370/t-i370"
  	c_target_objs="i370-c.o"
  	cxx_target_objs="i370-c.o"
  	;;
! i370-*-mvs*)
! 	xm_defines='POSIX FATAL_EXIT_CODE=12'
! 	tm_file=i370/mvs.h
! 	tmake_file="i370/t-i370"
  	c_target_objs="i370-c.o"
  	cxx_target_objs="i370-c.o"
  	;;
  i370-*-linux*)
! 	tm_file="dbxelf.h elfos.h svr4.h linux.h i370/linux.h ${tm_file}"
  	tmake_file="t-slibgcc-elf-ver t-linux"
  	# broken_install=yes
  	extra_parts="crtbegin.o crtbeginS.o crtbeginT.o crtend.o crtendS.o"
--- 1101,1156 ----
  	install_headers_dir=install-headers-tar
  	use_collect2=yes
  	;;
! i370-*-opened*)			 # IBM 360/370 Architecture
! 	xm_defines='POSIX'
! 	xm_file="i370/xm-oe.h"
! 	tm_file="i370/oe.h i370/i370.h"
  	tmake_file="i370/t-oe i370/t-i370"
  	c_target_objs="i370-c.o"
  	cxx_target_objs="i370-c.o"
  	;;
! i370-*-mvsle)
! 	xm_defines='POSIX'
! 	xm_file="i370/xm-mvs.h"
! 	tm_file="i370/mvsle.h i370/i370.h"
! 	tmake_file="i370/t-mvs i370/t-i370"
! 	c_target_objs="i370-c.o"
! 	cxx_target_objs="i370-c.o"
! 	;;
! i370-*-mvsdignus)
! 	xm_defines='POSIX'
! 	xm_file="i370/xm-mvs.h"
! 	tm_file="i370/mvsdignus.h i370/i370.h"
! 	tmake_file="i370/t-mvs i370/t-i370"
! 	c_target_objs="i370-c.o"
! 	cxx_target_objs="i370-c.o"
! 	;;
! i370-*-mvspdp)
! 	xm_defines='POSIX'
! 	xm_file="i370/xm-mvs.h"
! 	tm_file="i370/mvspdp.h i370/i370.h"
! 	tmake_file="i370/t-mvs i370/t-i370"
! 	c_target_objs="i370-c.o"
! 	cxx_target_objs="i370-c.o"
! 	;;
! i370-*-mvs38_dignus)
! 	xm_defines='POSIX'
! 	xm_file="i370/xm-mvs.h"
! 	tm_file="i370/mvs38_dignus.h i370/i370.h"
! 	tmake_file="i370/t-mvs i370/t-i370"
! 	c_target_objs="i370-c.o"
! 	cxx_target_objs="i370-c.o"
! 	;;
! i370-*-cms)
! 	xm_defines='POSIX'
! 	xm_file="i370/xm-mvs.h"
! 	tm_file="i370/cms.h i370/i370.h"
! 	tmake_file="i370/t-mvs i370/t-i370"
  	c_target_objs="i370-c.o"
  	cxx_target_objs="i370-c.o"
  	;;
  i370-*-linux*)
! 	tm_file="dbxelf.h elfos.h svr4.h linux.h i370/linux.h i370/i370.h"
  	tmake_file="t-slibgcc-elf-ver t-linux"
  	# broken_install=yes
  	extra_parts="crtbegin.o crtbeginS.o crtbeginT.o crtend.o crtendS.o"
***************
*** 2972,2984 ****
  	tmake_file=rs6000/t-rs6000
  	use_collect2=yes
  	;;
  s390-*-linux*)
! 	tm_file="s390/s390.h dbxelf.h elfos.h svr4.h linux.h s390/linux.h"
  	tmake_file="t-slibgcc-elf-ver t-linux s390/t-linux"
  	extra_parts="crtbegin.o crtend.o crtbeginS.o crtendS.o crtbeginT.o"
  	;;
  s390x-*-linux*)
! 	tm_file="s390/s390x.h s390/s390.h dbxelf.h elfos.h svr4.h linux.h s390/linux.h"
  	tm_p_file=s390/s390-protos.h
  	md_file=s390/s390.md
  	out_file=s390/s390.c
--- 3006,3026 ----
  	tmake_file=rs6000/t-rs6000
  	use_collect2=yes
  	;;
+ s390-*-opened*)			 # IBM 390 Architecture
+ 	xm_defines='POSIX'
+ 	xm_file="s390/xm-oe.h"
+ 	tm_file="s390/oe.h s390/s390.h"
+ 	tmake_file="s390/t-oe s390/t-s390"
+ 	c_target_objs="s390-c.o"
+ 	cxx_target_objs="s390-c.o"
+ 	;;
  s390-*-linux*)
! 	tm_file="dbxelf.h elfos.h svr4.h linux.h s390/linux.h s390/s390.h"
  	tmake_file="t-slibgcc-elf-ver t-linux s390/t-linux"
  	extra_parts="crtbegin.o crtend.o crtbeginS.o crtendS.o crtbeginT.o"
  	;;
  s390x-*-linux*)
! 	tm_file="dbxelf.h elfos.h svr4.h linux.h s390/linux.h s390/s390x.h s390/s390.h"
  	tm_p_file=s390/s390-protos.h
  	md_file=s390/s390.md
  	out_file=s390/s390.c
Index: gcc/gcc/config.h
diff -c nul gcc/gcc/config.h:1.16
*** nul	Tue Oct 01 16:28:43 2019
--- gcc/gcc/config.h	Tue Sep 10 22:21:52 2019
***************
*** 0 ****
--- 1,690 ----
+ #ifndef MAIN_CONFIG_INCLUDED
+ #define MAIN_CONFIG_INCLUDED
+ 
+ /* config.h.  Manually generated for use on MVS 3.8  */
+ 
+ /* The defines required for the generator files are too
+    numerous for the 100-character parameter limit on MVS,
+    so we activate them here instead. */
+ #ifdef GENFILES
+ #define NO_DETAB 1
+ #define GENERATOR_FILE 1
+ #define IN_GCC 1
+ #define PUREISO 1
+ #endif
+ 
+ #if defined(S390) || defined(I386)
+ #define SINGLE_EXECUTABLE 1
+ #define ANSI_PROTOTYPES 1
+ #define PARAMS(ARGS) ARGS
+ #define PTR void *
+ 
+ #ifndef RTX_FORWARD
+ #define RTX_FORWARD 1
+ struct rtx_def;
+ typedef struct rtx_def *rtx;
+ struct rtvec_def;
+ typedef struct rtvec_def *rtvec;
+ union tree_node;
+ typedef union tree_node *tree;
+ #endif
+ 
+ #include "unixio.h"
+ #if defined(S390)
+ #include "s390.h"
+ #include "linux.h"
+ #include "defaults.h"
+ #define ASM_APP_OFF ""
+ #define ASM_APP_ON ""
+ #elif defined(I386)
+ #include "i386.h"
+ /* #include "uwin.h" */ /* for Windows PE */
+ #include "pdos386.h" /* for a.out */
+ #include "defaults.h"
+ #endif
+ #define DEFAULT_TARGET_VERSION "1.1"
+ #if defined(S390)
+ #define DEFAULT_TARGET_MACHINE "s390"
+ #elif defined(I386)
+ #define DEFAULT_TARGET_MACHINE "i386"
+ #endif
+ #ifndef GENERATOR_FILE
+ # include "insn-constants.h"
+ # include "insn-flags.h"
+ #endif
+ #define PREFIX ""
+ #if defined(S390)
+ #define TARGET_NAME "mvs"
+ #elif defined(I386)
+ #define TARGET_NAME "pdos386"
+ #endif
+ #define ATTRIBUTE_NORETURN
+ #define getpwd() ""
+ #define make_temp_file(a) tmpnam(NULL)
+ 
+ #if defined(S390)
+ #define ASM_GENERATE_INTERNAL_LABEL(LABEL, PREFIX, NUM)			\
+   sprintf (LABEL, "*@@%s%d", PREFIX, NUM)
+ #define ASM_OUTPUT_INTERNAL_LABEL(FILE, PREFIX, NUM) 			\
+   fprintf (FILE, "@@%s%d\tEQU\t*\n", PREFIX, NUM);
+ #define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED) 			\
+ {									\
+   ASM_OUTPUT_LABEL (FILE,NAME);						\
+   ASM_OUTPUT_SKIP (FILE,SIZE);						\
+ }
+ #define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED) 			\
+ {									\
+   ASM_OUTPUT_LABEL (FILE,NAME);						\
+   ASM_OUTPUT_SKIP (FILE,SIZE);						\
+ }
+ #endif
+ 
+ #endif
+ 
+ 
+ /* Define if using alloca.c.  */
+ #undef C_ALLOCA
+ 
+ /* Define to empty if the keyword does not work.  */
+ #undef const
+ 
+ /* Define to one of _getb67, GETB67, getb67 for Cray-2 and Cray-YMP systems.
+    This function is required for alloca.c support on those systems.  */
+ #undef CRAY_STACKSEG_END
+ 
+ /* Define to the type of elements in the array set by `getgroups'.
+    Usually this is either `int' or `gid_t'.  */
+ #undef GETGROUPS_T
+ 
+ /* Define to `int' if <sys/types.h> doesn't define.  */
+ #undef gid_t
+ 
+ /* Define if you have alloca, as a function or macro.  */
+ #undef HAVE_ALLOCA
+ 
+ /* Define if you have <alloca.h> and it should be used (not on Ultrix).  */
+ #undef HAVE_ALLOCA_H
+ 
+ /* Define if you have the ANSI # stringizing operator in cpp. */
+ #undef HAVE_STRINGIZE
+ 
+ /* Define if you have <sys/wait.h> that is POSIX.1 compatible.  */
+ #undef HAVE_SYS_WAIT_H
+ 
+ /* Define if you have <vfork.h>.  */
+ #undef HAVE_VFORK_H
+ 
+ /* Define as __inline if that's what the C compiler calls it.  */
+ #undef inline
+ 
+ /* Define if your C compiler doesn't accept -c and -o together.  */
+ #undef NO_MINUS_C_MINUS_O
+ 
+ /* Define to `long' if <sys/types.h> doesn't define.  */
+ #define off_t long
+ 
+ /* Define to `int' if <sys/types.h> doesn't define.  */
+ #define pid_t int
+ 
+ /* Define to `unsigned' if <sys/types.h> doesn't define.  */
+ #undef size_t
+ 
+ /* If using the C implementation of alloca, define if you know the
+    direction of stack growth for your system; otherwise it will be
+    automatically deduced at run-time.
+  STACK_DIRECTION > 0 => grows toward higher addresses
+  STACK_DIRECTION < 0 => grows toward lower addresses
+  STACK_DIRECTION = 0 => direction of growth unknown
+  */
+ #undef STACK_DIRECTION
+ 
+ /* Define if you have the ANSI C header files.  */
+ #define STDC_HEADERS 1
+ 
+ /* Define if you can safely include both <sys/time.h> and <time.h>.  */
+ #undef TIME_WITH_SYS_TIME
+ 
+ /* Define to `int' if <sys/types.h> doesn't define.  */
+ #define uid_t int
+ 
+ /* Define vfork as fork if vfork does not work.  */
+ #undef vfork
+ 
+ /* Define if your assembler supports specifying the maximum number
+    of bytes to skip when using the GAS .p2align command.  */
+ #undef HAVE_GAS_MAX_SKIP_P2ALIGN
+ 
+ /* Define if your assembler supports .balign and .p2align.  */
+ #undef HAVE_GAS_BALIGN_AND_P2ALIGN
+ 
+ /* Define if your assembler uses the old HImode fild and fist notation.  */
+ #undef HAVE_GAS_FILDS_FISTS
+ 
+ /* Define to `int' if <sys/types.h> doesn't define.  */
+ #define ssize_t unsigned int
+ 
+ /* Define if cpp should also search $prefix/include.  */
+ #undef PREFIX_INCLUDE_DIR
+ 
+ /* Define if you have the __argz_count function.  */
+ #undef HAVE___ARGZ_COUNT
+ 
+ /* Define if you have the __argz_next function.  */
+ #undef HAVE___ARGZ_NEXT
+ 
+ /* Define if you have the __argz_stringify function.  */
+ #undef HAVE___ARGZ_STRINGIFY
+ 
+ /* Define if you have the atoll function.  */
+ #undef HAVE_ATOLL
+ 
+ /* Define if you have the atoq function.  */
+ #undef HAVE_ATOQ
+ 
+ /* Define if you have the clock function.  */
+ #undef HAVE_CLOCK
+ #define HAVE_CLOCK 1
+ 
+ /* Define if you have the dcgettext function.  */
+ #undef HAVE_DCGETTEXT
+ 
+ /* Define if you have the dup2 function.  */
+ #undef HAVE_DUP2
+ 
+ /* Define if you have the feof_unlocked function.  */
+ #undef HAVE_FEOF_UNLOCKED
+ 
+ /* Define if you have the fgets_unlocked function.  */
+ #undef HAVE_FGETS_UNLOCKED
+ 
+ /* Define if you have the fprintf_unlocked function.  */
+ #undef HAVE_FPRINTF_UNLOCKED
+ 
+ /* Define if you have the fputc_unlocked function.  */
+ #undef HAVE_FPUTC_UNLOCKED
+ 
+ /* Define if you have the fputs_unlocked function.  */
+ #undef HAVE_FPUTS_UNLOCKED
+ 
+ /* Define if you have the fwrite_unlocked function.  */
+ #undef HAVE_FWRITE_UNLOCKED
+ 
+ /* Define if you have the getcwd function.  */
+ #undef HAVE_GETCWD
+ 
+ /* Define if you have the getegid function.  */
+ #undef HAVE_GETEGID
+ 
+ /* Define if you have the geteuid function.  */
+ #undef HAVE_GETEUID
+ 
+ /* Define if you have the getgid function.  */
+ #undef HAVE_GETGID
+ 
+ /* Define if you have the getpagesize function.  */
+ #undef HAVE_GETPAGESIZE
+ 
+ /* Define if you have the getrlimit function.  */
+ #undef HAVE_GETRLIMIT
+ 
+ /* Define if you have the getrusage function.  */
+ #undef HAVE_GETRUSAGE
+ 
+ /* Define if you have the getuid function.  */
+ #undef HAVE_GETUID
+ 
+ /* Define if you have the kill function.  */
+ #undef HAVE_KILL
+ 
+ /* Define if you have the lstat function.  */
+ #undef HAVE_LSTAT
+ 
+ /* Define if you have the mempcpy function.  */
+ #undef HAVE_MEMPCPY
+ 
+ /* Define if you have the munmap function.  */
+ #undef HAVE_MUNMAP
+ 
+ /* Define if you have the nl_langinfo function.  */
+ #undef HAVE_NL_LANGINFO
+ 
+ /* Define if you have the putc_unlocked function.  */
+ #undef HAVE_PUTC_UNLOCKED
+ 
+ /* Define if you have the putenv function.  */
+ #undef HAVE_PUTENV
+ 
+ /* Define if you have the setenv function.  */
+ #undef HAVE_SETENV
+ 
+ /* Define if you have the setlocale function.  */
+ #define HAVE_SETLOCALE 1
+ 
+ /* Define if you have the setrlimit function.  */
+ #undef HAVE_SETRLIMIT
+ 
+ /* Define if you have the stpcpy function.  */
+ #undef HAVE_STPCPY
+ 
+ /* Define if you have the strcasecmp function.  */
+ #undef HAVE_STRCASECMP
+ 
+ /* Define if you have the strchr function.  */
+ #define HAVE_STRCHR 1
+ 
+ /* Define if you have the strdup function.  */
+ #undef HAVE_STRDUP
+ 
+ /* Define if you have the strsignal function.  */
+ #undef HAVE_STRSIGNAL
+ 
+ /* Define if you have the strtoul function.  */
+ #define HAVE_STRTOUL 1
+ 
+ /* Define if you have the sysconf function.  */
+ #undef HAVE_SYSCONF
+ 
+ /* Define if you have the times function.  */
+ #undef HAVE_TIMES
+ 
+ /* Define if you have the tsearch function.  */
+ #undef HAVE_TSEARCH
+ 
+ /* Define if you have the <argz.h> header file.  */
+ #undef HAVE_ARGZ_H
+ 
+ /* Define if you have the <direct.h> header file.  */
+ #undef HAVE_DIRECT_H
+ 
+ /* Define if you have the <fcntl.h> header file.  */
+ #undef HAVE_FCNTL_H
+ 
+ /* Define if you have the <langinfo.h> header file.  */
+ #undef HAVE_LANGINFO_H
+ 
+ /* Define if you have the <limits.h> header file.  */
+ #define HAVE_LIMITS_H 1
+ 
+ /* Define if you have the <locale.h> header file.  */
+ #define HAVE_LOCALE_H 1
+ 
+ /* Define if you have the <malloc.h> header file.  */
+ #undef HAVE_MALLOC_H
+ 
+ /* Define if you have the <nl_types.h> header file.  */
+ #undef HAVE_NL_TYPES_H
+ 
+ /* Define if you have the <stddef.h> header file.  */
+ #define HAVE_STDDEF_H 1
+ 
+ /* Define if you have the <stdlib.h> header file.  */
+ #define HAVE_STDLIB_H 1
+ 
+ /* Define if you have the <string.h> header file.  */
+ #define HAVE_STRING_H 1
+ 
+ /* Define if you have the <strings.h> header file.  */
+ #undef HAVE_STRINGS_H
+ 
+ /* Define if you have the <sys/file.h> header file.  */
+ #undef HAVE_SYS_FILE_H
+ 
+ /* Define if you have the <sys/param.h> header file.  */
+ #undef HAVE_SYS_PARAM_H
+ 
+ /* Define if you have the <sys/resource.h> header file.  */
+ #undef HAVE_SYS_RESOURCE_H
+ 
+ /* Define if you have the <sys/stat.h> header file.  */
+ #undef HAVE_SYS_STAT_H
+ 
+ /* Define if you have the <sys/time.h> header file.  */
+ #undef HAVE_SYS_TIME_H
+ 
+ /* Define if you have the <sys/times.h> header file.  */
+ #undef HAVE_SYS_TIMES_H
+ 
+ /* Define if you have the <time.h> header file.  */
+ #define HAVE_TIME_H 1
+ 
+ /* Define if you have the <unistd.h> header file.  */
+ #undef HAVE_UNISTD_H
+ 
+ /* Define to enable the use of a default linker. */
+ #undef DEFAULT_LINKER
+ 
+ /* Define to enable the use of a default assembler. */
+ #undef DEFAULT_ASSEMBLER
+ 
+ /* Define if you want more run-time sanity checks.  This one gets a grab
+    bag of miscellaneous but relatively cheap checks. */
+ #undef ENABLE_CHECKING
+ 
+ /* Define if you want all operations on trees (the basic data
+    structure of the front ends) to be checked for dynamic type safety
+    at runtime.  This is moderately expensive. */
+ #undef ENABLE_TREE_CHECKING
+ 
+ /* Define if you want all operations on RTL (the basic data structure
+    of the optimizer and back end) to be checked for dynamic type safety
+    at runtime.  This is quite expensive. */
+ #undef ENABLE_RTL_CHECKING
+ 
+ /* Define if you want the garbage collector to do object poisoning and
+    other memory allocation checks.  This is quite expensive. */
+ #undef ENABLE_GC_CHECKING
+ 
+ /* Define if you want the garbage collector to operate in maximally
+    paranoid mode, validating the entire heap and collecting garbage at
+    every opportunity.  This is extremely expensive. */
+ #undef ENABLE_GC_ALWAYS_COLLECT
+ 
+ /* Define if you want to use __cxa_atexit, rather than atexit, to
+    register C++ destructors for local statics and global objects.
+    This is essential for fully standards-compliant handling of
+    destructors, but requires __cxa_atexit in libc. */
+ #undef DEFAULT_USE_CXA_ATEXIT
+ 
+ /* Define if you want the C and C++ compilers to support multibyte
+    character sets for source code. */
+ #undef MULTIBYTE_CHARS
+ 
+ /* Define if your compiler understands volatile. */
+ #undef HAVE_VOLATILE
+ 
+ /* Define if your compiler supports the `long double' type. */
+ #undef HAVE_LONG_DOUBLE
+ 
+ /* Define if your compiler supports the `long long' type. */
+ #undef HAVE_LONG_LONG
+ 
+ /* Define if your compiler supports the `__int64' type. */
+ #undef HAVE___INT64
+ 
+ /* Define if the `_Bool' type is built-in. */
+ #undef HAVE__BOOL
+ #define HAVE__BOOL 0
+ #if (__GNUC__ >= 3)
+ #undef HAVE__BOOL
+ #define HAVE__BOOL 1
+ #endif
+ 
+ /* The number of bytes in type short */
+ #define SIZEOF_SHORT 2
+ 
+ /* The number of bytes in type int */
+ #define SIZEOF_INT 4
+ 
+ /* The number of bytes in type long */
+ #define SIZEOF_LONG 4
+ 
+ /* The number of bytes in type long long */
+ #undef SIZEOF_LONG_LONG
+ 
+ /* The number of bytes in type __int64 */
+ #undef SIZEOF___INT64
+ 
+ /* Define if the host execution character set is EBCDIC. */
+ #if defined(__MVS__) || defined(__CMS__) || defined(__VSE__)
+ #define HOST_EBCDIC 1
+ #endif
+ 
+ /* Always define this when using the GNU C Library */
+ #undef _GNU_SOURCE
+ 
+ /* Define if you have a working <stdbool.h> header file. */
+ #undef HAVE_STDBOOL_H
+ 
+ /* Define if you can safely include both <string.h> and <strings.h>. */
+ #undef STRING_WITH_STRINGS
+ 
+ /* Define as the number of bits in a byte, if `limits.h' doesn't. */
+ #undef CHAR_BIT
+ 
+ /* Define if the host machine stores words of multi-word integers in
+    big-endian order. */
+ #define HOST_WORDS_BIG_ENDIAN 1
+ 
+ /* Define to the floating point format of the host machine, if not IEEE. */
+ #undef HOST_FLOAT_FORMAT
+ 
+ /* Define to 1 if the host machine stores floating point numbers in
+    memory with the word containing the sign bit at the lowest address,
+    or to 0 if it does it the other way around.
+ 
+    This macro should not be defined if the ordering is the same as for
+    multi-word integers. */
+ #undef HOST_FLOAT_WORDS_BIG_ENDIAN
+ 
+ /* Define if you have a working <inttypes.h> header file. */
+ #undef HAVE_INTTYPES_H
+ 
+ /* Define if printf supports %p. */
+ #define HAVE_PRINTF_PTR 1
+ 
+ /* Define if mmap can get us zeroed pages from /dev/zero. */
+ #undef HAVE_MMAP_DEV_ZERO
+ 
+ /* Define if mmap can get us zeroed pages using MAP_ANON(YMOUS). */
+ #undef HAVE_MMAP_ANON
+ 
+ /* Define if read-only mmap of a plain file works. */
+ #undef HAVE_MMAP_FILE
+ 
+ /* Define if you have the iconv() function. */
+ #undef HAVE_ICONV
+ 
+ /* Define as const if the declaration of iconv() needs const. */
+ #undef ICONV_CONST
+ 
+ /* Define to 1 if we found this declaration otherwise define to 0. */
+ #define HAVE_DECL_GETENV 1
+ 
+ /* Define to 1 if we found this declaration otherwise define to 0. */
+ #define HAVE_DECL_ATOL 1
+ 
+ /* Define to 1 if we found this declaration otherwise define to 0. */
+ #define HAVE_DECL_SBRK 0
+ 
+ /* Define to 1 if we found this declaration otherwise define to 0. */
+ #define HAVE_DECL_ABORT 1
+ 
+ /* Define to 1 if we found this declaration otherwise define to 0. */
+ #define HAVE_DECL_ATOF 1
+ 
+ /* Define to 1 if we found this declaration otherwise define to 0. */
+ #define HAVE_DECL_GETCWD 0
+ 
+ /* Define to 1 if we found this declaration otherwise define to 0. */
+ #define HAVE_DECL_GETWD 0
+ 
+ /* Define to 1 if we found this declaration otherwise define to 0. */
+ #define HAVE_DECL_STRSIGNAL 0
+ 
+ /* Define to 1 if we found this declaration otherwise define to 0. */
+ #define HAVE_DECL_PUTC_UNLOCKED 0
+ 
+ /* Define to 1 if we found this declaration otherwise define to 0. */
+ #define HAVE_DECL_FPUTS_UNLOCKED 0
+ 
+ /* Define to 1 if we found this declaration otherwise define to 0. */
+ #define HAVE_DECL_FWRITE_UNLOCKED 0
+ 
+ /* Define to 1 if we found this declaration otherwise define to 0. */
+ #define HAVE_DECL_FPRINTF_UNLOCKED 0
+ 
+ /* Define to 1 if we found this declaration otherwise define to 0. */
+ #define HAVE_DECL_STRSTR 1
+ 
+ /* Define to 1 if we found this declaration otherwise define to 0. */
+ #define HAVE_DECL_ERRNO 1
+ 
+ /* Define to 1 if we found this declaration otherwise define to 0. */
+ #define HAVE_DECL_MALLOC 1
+ 
+ /* Define to 1 if we found this declaration otherwise define to 0. */
+ #define HAVE_DECL_REALLOC 1
+ 
+ /* Define to 1 if we found this declaration otherwise define to 0. */
+ #define HAVE_DECL_CALLOC 1
+ 
+ /* Define to 1 if we found this declaration otherwise define to 0. */
+ #define HAVE_DECL_FREE 1
+ 
+ /* Define to 1 if we found this declaration otherwise define to 0. */
+ #define HAVE_DECL_BASENAME 0
+ 
+ /* Define to 1 if we found this declaration otherwise define to 0. */
+ #define HAVE_DECL_GETOPT 0
+ 
+ /* Define to 1 if we found this declaration otherwise define to 0. */
+ #define HAVE_DECL_CLOCK 0
+ 
+ /* Define to 1 if we found this declaration otherwise define to 0. */
+ #define HAVE_DECL_GETRLIMIT 0
+ 
+ /* Define to 1 if we found this declaration otherwise define to 0. */
+ #define HAVE_DECL_SETRLIMIT 0
+ 
+ /* Define to 1 if we found this declaration otherwise define to 0. */
+ #define HAVE_DECL_GETRUSAGE 1
+ 
+ /* Define to 1 if we found this declaration otherwise define to 0. */
+ #define HAVE_DECL_TIMES 1
+ 
+ /* Define if <sys/times.h> defines struct tms. */
+ #define HAVE_STRUCT_TMS 1
+ 
+ /* Define if <time.h> defines clock_t. */
+ #undef HAVE_CLOCK_T
+ #define HAVE_CLOCK_T
+ 
+ /* Define if host mkdir takes a single argument. */
+ #undef MKDIR_TAKES_ONE_ARG
+ 
+ /* Define if you have the iconv() function. */
+ #undef HAVE_ICONV
+ 
+ /* Define as const if the declaration of iconv() needs const. */
+ #undef ICONV_CONST
+ 
+ /* Define if you have <langinfo.h> and nl_langinfo(CODESET). */
+ #undef HAVE_LANGINFO_CODESET
+ 
+ /* Define if your <locale.h> file defines LC_MESSAGES. */
+ #undef HAVE_LC_MESSAGES
+ 
+ /* Define to 1 if translation of program messages to the user's native language
+    is requested. */
+ #undef ENABLE_NLS
+ 
+ /* Define if you have the <libintl.h> header file. */
+ #undef HAVE_LIBINTL_H
+ 
+ /* Define if the GNU gettext() function is already present or preinstalled. */
+ #undef HAVE_GETTEXT
+ 
+ /* Define to use the libintl included with this package instead of any
+    version in the system libraries. */
+ #undef USE_INCLUDED_LIBINTL
+ 
+ /* Define to 1 if installation paths should be looked up in Windows32
+    Registry. Ignored on non windows32 hosts. */
+ #undef ENABLE_WIN32_REGISTRY
+ 
+ /* Define to be the last portion of registry key on windows hosts. */
+ #undef WIN32_REGISTRY_KEY
+ 
+ /* Define if your assembler supports .subsection and .subsection -1 starts
+    emitting at the beginning of your section. */
+ #undef HAVE_GAS_SUBSECTION_ORDERING
+ 
+ /* Define if your assembler supports .weak. */
+ #undef HAVE_GAS_WEAK
+ 
+ /* Define if your assembler supports .hidden. */
+ #undef HAVE_GAS_HIDDEN
+ 
+ /* Define if your assembler supports .uleb128. */
+ #undef HAVE_AS_LEB128
+ 
+ /* Define if your assembler mis-optimizes .eh_frame data. */
+ #undef USE_AS_TRADITIONAL_FORMAT
+ 
+ /* Define if your assembler supports marking sections with SHF_MERGE flag. */
+ #undef HAVE_GAS_SHF_MERGE
+ 
+ /* Define if your assembler supports explicit relocations. */
+ #undef HAVE_AS_EXPLICIT_RELOCS
+ 
+ /* Define if your assembler supports .register. */
+ #undef HAVE_AS_REGISTER_PSEUDO_OP
+ 
+ /* Define if your assembler supports -relax option. */
+ #undef HAVE_AS_RELAX_OPTION
+ 
+ /* Define if your assembler and linker support unaligned PC relative relocs. */
+ #undef HAVE_AS_SPARC_UA_PCREL
+ 
+ /* Define if your assembler and linker support unaligned PC relative relocs against hidden symbols. */
+ #undef HAVE_AS_SPARC_UA_PCREL_HIDDEN
+ 
+ /* Define if your assembler supports offsetable %lo(). */
+ #undef HAVE_AS_OFFSETABLE_LO10
+ 
+ /* Define true if the assembler supports '.long foo@GOTOFF'. */
+ #if defined(I386)
+ #define HAVE_AS_GOTOFF_IN_DATA 0
+ #else
+ #undef HAVE_AS_GOTOFF_IN_DATA
+ #endif
+ 
+ /* Define if your assembler supports dwarf2 .file/.loc directives,
+    and preserves file table indices exactly as given. */
+ #undef HAVE_AS_DWARF2_DEBUG_LINE
+ 
+ /* Define if your assembler supports the --gdwarf2 option. */
+ #undef HAVE_AS_GDWARF2_DEBUG_FLAG
+ 
+ /* Define if your assembler supports the --gstabs option. */
+ #undef HAVE_AS_GSTABS_DEBUG_FLAG
+ 
+ /* Define if your linker supports --eh-frame-hdr option. */
+ #undef HAVE_LD_EH_FRAME_HDR
+ 
+ /* Define 0/1 to force the choice for exception handling model. */
+ #undef CONFIG_SJLJ_EXCEPTIONS
+ 
+ 
+ /* Bison unconditionally undefines `const' if neither `__STDC__' nor
+    __cplusplus are defined.  That's a problem since we use `const' in
+    the GCC headers, and the resulting bison code is therefore type
+    unsafe.  Thus, we must match the bison behavior here.  */
+ 
+ #ifndef __STDC__
+ #ifndef __cplusplus
+ #undef const
+ #define const
+ #endif
+ #endif
+ 
+ /* for some reason Cygwin uses this define as well,
+    and we need to define it to stop strsignal
+    gratuitously polluting our namespace */
+ #ifdef __CYGWIN32__
+ #ifndef _STRICT_ANSI
+ #define _STRICT_ANSI
+ #endif
+ #endif
+ 
+ #if defined(TARGET_CMS)
+ #include "cms.h"
+ #elif defined(TARGET_VSE)
+ #include "vse.h"
+ #else
+ #if !defined(S390) && !defined(I386)
+ #include "mvspdp.h"
+ #endif
+ #endif
+ 
+ #endif
Index: gcc/gcc/configargs.h
diff -c nul gcc/gcc/configargs.h:1.4
*** nul	Tue Oct 01 16:28:43 2019
--- gcc/gcc/configargs.h	Wed Nov 01 19:49:24 2006
***************
*** 0 ****
--- 1,3 ----
+ /* Generated automatically. */
+ static const char configuration_arguments[] = "./configure --target=i370-ibm-mvspdp --enable-languages=c";
+ static const char thread_model[] = "single";
Index: gcc/gcc/configure
diff -c gcc/gcc/configure:1.1.1.1 gcc/gcc/configure:1.2
*** gcc/gcc/configure:1.1.1.1	Wed Feb 15 21:22:25 2006
--- gcc/gcc/configure	Fri Nov 03 16:15:22 2006
***************
*** 2980,2990 ****
  #define C(cand) { "\nformat:", cand, ":tamrof\n" }
  struct possibility table [] =
  {
    C( 3.25724264705901305206e+01), /* @@IEEEFP - IEEE 754 */
    C( 3.53802595280598432000e+18), /* D__float - VAX */
!   C( 5.32201830133125317057e-19), /* D.PDP-10 - PDP-10 - the dot is 0x13a */
!   C( 1.77977764695171661377e+10), /* IBMHEXFP - s/390 format, ascii */
!   C(-5.22995989424860458374e+10)  /* IBMHEXFP - s/390 format, EBCDIC */
  };
  EOF
  if { (eval echo configure:2991: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
--- 2980,2990 ----
  #define C(cand) { "\nformat:", cand, ":tamrof\n" }
  struct possibility table [] =
  {
+   C(-5.22995989424860458374e+10), /* IBMHEXFP - s/390 format, EBCDIC */
+   C( 1.77977764695171661377e+10), /* IBMHEXFP - s/390 format, ascii */
    C( 3.25724264705901305206e+01), /* @@IEEEFP - IEEE 754 */
    C( 3.53802595280598432000e+18), /* D__float - VAX */
!   C( 5.32201830133125317057e-19)  /* D.PDP-10 - PDP-10 - the dot is 0x13a */
  };
  EOF
  if { (eval echo configure:2991: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
***************
*** 7216,7222 ****
  	# the date string after the version number.
  	ld_ver=`$gcc_cv_ld --version 2>/dev/null | head -1`
  	if echo "$ld_ver" | grep GNU > /dev/null; then
! 		ld_vers=`echo $ld_ver | sed -n 's,^.*[ 	]\([0-9][0-9]*\.[0-9][0-9]*\(\|\.[0-9][0-9]*\(\|\.[0-9][0-9]*\)\)\)\([ 	].*\|\)$,\1,p'`
  		ld_date=`echo $ld_ver | sed -n 's,^.*\([2-9][0-9][0-9][0-9]\)[-]*\([01][0-9]\)[-]*\([0-3][0-9]\).*$,\1\2\3,p'`
  		if test 0"$ld_date" -lt 20020404; then
  			if test -n "$ld_date"; then
--- 7216,7222 ----
  	# the date string after the version number.
  	ld_ver=`$gcc_cv_ld --version 2>/dev/null | head -1`
  	if echo "$ld_ver" | grep GNU > /dev/null; then
! 		ld_vers=`echo $ld_ver | sed -n 's,^.*[ 	]\([0-9][0-9]*\.[0-9][0-9]*\(\|\.[0-9][0-9]*\)\)\([ 	].*\|\)$,\1,p'`
  		ld_date=`echo $ld_ver | sed -n 's,^.*\([2-9][0-9][0-9][0-9]\)[-]*\([01][0-9]\)[-]*\([0-3][0-9]\).*$,\1\2\3,p'`
  		if test 0"$ld_date" -lt 20020404; then
  			if test -n "$ld_date"; then
***************
*** 7578,7617 ****
  
      fi
  
!     echo $ac_n "checking for assembler offsetable %lo() support""... $ac_c" 1>&6
  echo "configure:7584: checking for assembler offsetable %lo() support" >&5
  if eval "test \"`echo '$''{'gcc_cv_as_offsetable_lo10'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    
! 	gcc_cv_as_offsetable_lo10=unknown
! 	if test "x$gcc_cv_as" != x; then
! 	    # Check if assembler has offsetable %lo()
! 	    echo "or %g1, %lo(ab) + 12, %g1" > conftest.s
! 	    echo "or %g1, %lo(ab + 12), %g1" > conftest1.s
! 	    if $gcc_cv_as -xarch=v9 -o conftest.o conftest.s \
! 		    > /dev/null 2>&1 &&
! 	       $gcc_cv_as -xarch=v9 -o conftest1.o conftest1.s \
! 		    > /dev/null 2>&1; then
! 		if cmp conftest.o conftest1.o > /dev/null 2>&1; then
! 		    gcc_cv_as_offsetable_lo10=no
  		else
! 		    gcc_cv_as_offsetable_lo10=yes
  		fi
! 	    else
! 		gcc_cv_as_offsetable_lo10=no
  	    fi
! 	    rm -f conftest.s conftest.o conftest1.s conftest1.o
! 	fi
!     
  fi
  
  echo "$ac_t""$gcc_cv_as_offsetable_lo10" 1>&6
!     if test "x$gcc_cv_as_offsetable_lo10" = xyes; then
! 	cat >> confdefs.h <<\EOF
  #define HAVE_AS_OFFSETABLE_LO10 1
  EOF
  
      fi
  
      ;;
--- 7578,7619 ----
  
      fi
  
!     if test "x$gcc_cv_as_flags64" != xno; then
! 	echo $ac_n "checking for assembler offsetable %lo() support""... $ac_c" 1>&6
  echo "configure:7584: checking for assembler offsetable %lo() support" >&5
  if eval "test \"`echo '$''{'gcc_cv_as_offsetable_lo10'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    
! 	    gcc_cv_as_offsetable_lo10=unknown
! 	    if test "x$gcc_cv_as" != x; then
! 		# Check if assembler has offsetable %lo()
! 		echo "or %g1, %lo(ab) + 12, %g1" > conftest.s
! 		echo "or %g1, %lo(ab + 12), %g1" > conftest1.s
! 		if $gcc_cv_as $gcc_cv_as_flags64 -o conftest.o conftest.s \
! 			> /dev/null 2>&1 &&
! 		   $gcc_cv_as $gcc_cv_as_flags64 -o conftest1.o conftest1.s \
! 			> /dev/null 2>&1; then
! 		    if cmp conftest.o conftest1.o > /dev/null 2>&1; then
! 			gcc_cv_as_offsetable_lo10=no
! 		    else
! 			gcc_cv_as_offsetable_lo10=yes
! 		    fi
  		else
! 		    gcc_cv_as_offsetable_lo10=no
  		fi
! 		rm -f conftest.s conftest.o conftest1.s conftest1.o
  	    fi
! 	
  fi
  
  echo "$ac_t""$gcc_cv_as_offsetable_lo10" 1>&6
! 	if test "x$gcc_cv_as_offsetable_lo10" = xyes; then
! 	    cat >> confdefs.h <<\EOF
  #define HAVE_AS_OFFSETABLE_LO10 1
  EOF
  
+ 	fi
      fi
  
      ;;
Index: gcc/gcc/copygcc.exec
diff -c nul gcc/gcc/copygcc.exec:1.11
*** nul	Tue Oct 01 16:28:43 2019
--- gcc/gcc/copygcc.exec	Sat May 26 17:20:56 2018
***************
*** 0 ****
--- 1,46 ----
+ *******************************************************************
+ *
+ * This EXEC copies all important GCC files onto a disk
+ *
+ *******************************************************************
+ &CONTROL
+ 
+ COPY GCC MODULE &1 = = &2 (REPLACE
+ COPY GCC370 MODULE &1 = = &2 (REPLACE
+ COPY GCCE EXEC &1 = = &2 (REPLACE
+ COPY GCCR EXEC &1 = = &2 (REPLACE
+ COPY GCC PARM &1 = = &2 (REPLACE
+ COPY PDPCLIB MACLIB &1 = = &2 (REPLACE
+ COPY GCCVER PARM &1 = = &2 (REPLACE
+ COPY PDPCLIB TXTLIB &1 = = &2 (REPLACE
+ COPY MKPDPC EXEC &1 = = &2 (REPLACE
+ COPY FIXCSECT EXEC &1 = = &2 (REPLACE
+ COPY PDPONE EXEC &1 = = &2 (REPLACE
+ COPY MAKE380 EXEC &1 = = &2 (REPLACE
+ COPY STDPDP PARM &1 = = &2 (REPLACE
+ COPY STD380 PARM &1 = = &2 (REPLACE
+ 
+ COPY ASSERT H &1 = = &2 (REPLACE
+ COPY CTYPE H &1 = = &2 (REPLACE
+ COPY ERRNO H &1 = = &2 (REPLACE
+ COPY FLOAT H &1 = = &2 (REPLACE
+ COPY LIMITS H &1 = = &2 (REPLACE
+ COPY LOCALE H &1 = = &2 (REPLACE
+ COPY MATH H &1 = = &2 (REPLACE
+ COPY SETJMP H &1 = = &2 (REPLACE
+ COPY SIGNAL H &1 = = &2 (REPLACE
+ COPY STDARG H &1 = = &2 (REPLACE
+ COPY STDDEF H &1 = = &2 (REPLACE
+ COPY STDIO H &1 = = &2 (REPLACE
+ COPY STDLIB H &1 = = &2 (REPLACE
+ COPY STRING H &1 = = &2 (REPLACE
+ COPY TIME H &1 = = &2 (REPLACE
+ COPY __MEMMGR H &1 = = &2 (REPLACE
+ 
+ COPY NAMCSECT MODULE &1 = = &2 (REPLACE
+ COPY MVSUNZIP MODULE &1 = = &2 (REPLACE
+ COPY HEXDUMP MODULE &1 = = &2 (REPLACE
+ COPY MVSENDEC MODULE &1 = = &2 (REPLACE
+ COPY CPYFIL MODULE &1 = = &2 (REPLACE
+ COPY PDPTEST MODULE &1 = = &2 (REPLACE
+ 
Index: gcc/gcc/cpperror.c
diff -c gcc/gcc/cpperror.c:1.1.1.1 gcc/gcc/cpperror.c:1.2
*** gcc/gcc/cpperror.c:1.1.1.1	Wed Feb 15 21:22:25 2006
--- gcc/gcc/cpperror.c	Tue May 26 00:00:47 2009
***************
*** 28,33 ****
--- 28,36 ----
  #include "cpplib.h"
  #include "cpphash.h"
  #include "intl.h"
+ #ifdef SINGLE_EXECUTABLE
+ #include "diagnostic.h"
+ #endif
  
  static void print_location PARAMS ((cpp_reader *, unsigned int, unsigned int));
  
***************
*** 129,135 ****
--- 132,143 ----
  
    print_location (pfile, line, column);
    if (is_warning)
+   {
      fputs (_("warning: "), stderr);
+ #ifdef SINGLE_EXECUTABLE
+     warningcount++;
+ #endif
+   }
  
    return 1;
  }
Index: gcc/gcc/cppfiles.c
diff -c gcc/gcc/cppfiles.c:1.1.1.1 gcc/gcc/cppfiles.c:1.22
*** gcc/gcc/cppfiles.c:1.1.1.1	Wed Feb 15 21:22:25 2006
--- gcc/gcc/cppfiles.c	Tue Dec 14 01:28:17 2010
***************
*** 551,556 ****
--- 551,596 ----
    struct include_file *file;
    char *name, *n;
  
+ #ifdef __CMS__
+     {
+         char *p;
+         const char *q;
+         char buf[FILENAME_MAX];
+ 
+         q = strrchr(fname, '/');
+         q = (q != NULL) ? q + 1 : fname;
+         if (header->type != CPP_HEADER_NAME)
+         {
+             char name[FILENAME_MAX];
+ 
+             if (CPP_OPTION (pfile, remap))
+             {
+                 path = search_from (pfile, type);
+                 if (path != NULL)
+                 {
+                     memcpy(name, path->name, path->len);
+                     name[path->len] = '\0';
+                     strcat(name, "/");
+                     strcat(name, q);
+                     p = remap_filename (pfile, name, path);
+                     p = strrchr(p, '/') + 1;
+                     q = p;
+                 }
+             }
+         }
+         strcpy(buf, q);
+         return (open_file(pfile, buf));
+     }
+ #endif
+ 
+ 
+ /* we don't expect MVS to have any include files defined,
+    at least for the standard includes. If there is, then it's
+    probably an environment like PDOS, so let it search the
+    current directory if they specified one */
+ #if defined(__MVS__) || defined(__VSE__)
+     path = CPP_OPTION (pfile, bracket_include);
+ #else
    if (IS_ABSOLUTE_PATHNAME (fname))
      return open_file (pfile, fname);
  
***************
*** 563,568 ****
--- 603,683 ----
      path = CPP_OPTION (pfile, bracket_include);
    else
      path = search_from (pfile, type);
+ #endif
+ 
+ 
+ #if defined(__MVS__) || defined(__VSE__)
+     if (path == NULL)
+     {
+         char *p;
+         const char *q;
+         char buf[FILENAME_MAX];
+         
+         strcpy(buf, "dd:");
+         strcat(buf, (header->type == CPP_HEADER_NAME) ? "sysincl" : "include");
+         strcat(buf, "(");
+         q = strrchr(fname, '/');
+         q = (q != NULL) ? q + 1 : fname;
+         if (header->type != CPP_HEADER_NAME)
+         {
+             char name[FILENAME_MAX];
+             
+             if (CPP_OPTION (pfile, remap))
+             {
+                 path = search_from (pfile, type);
+                 if (path != NULL)
+                 {
+                     memcpy(name, path->name, path->len);
+                     name[path->len] = '\0';
+                     strcat(name, "/");
+                     strcat(name, q);
+                     p = remap_filename (pfile, name, path);
+                     p = strrchr(p, '/') + 1;
+                     q = p;
+                 }
+             }
+         }
+         p = buf + strlen(buf);
+         strcat(buf, q);
+         p[8] = '\0';
+         p = strchr(buf, '.');
+         if (p != NULL)
+         {
+             *p = '\0';
+         }        
+         strcat(buf, ")");
+ #if defined(MUSIC)
+         /* on MUSIC, if the filename can't be found in a
+            MVS-like search, then as a fallback, look locally.
+            This is because the PDS routines don't cope with
+            the fact that the member is being truncated to
+            8 characters. */
+         {
+             FILE *fp;
+             
+             fp = fopen(buf, "r");
+             if (fp == NULL)
+             {
+                 strcpy(buf, q);
+             }
+             else
+             {
+                 fclose(fp);
+             }
+         }
+ #else
+         p = buf;   
+         while (*p != '\0')
+         {
+             if (*p == '-') *p = '@';
+             if (*p == '_') *p = '@';
+             p++;
+         }
+ #endif
+         return (open_file(pfile, buf));
+     }
+ #endif
+ 
  
    if (path == NULL)
      {
***************
*** 866,872 ****
--- 981,993 ----
    char *map_to;
  };
  
+ #if defined(MUSIC)
+ #define FILE_NAME_MAP_FILE "dd:include(__header)"
+ #elif defined(__MVS__) || defined(__VSE__)
+ #define FILE_NAME_MAP_FILE "dd:include(@@header)"
+ #else
  #define FILE_NAME_MAP_FILE "header.gcc"
+ #endif
  
  /* Read a space delimited string of unlimited length from a stdio
     file F.  */
***************
*** 935,940 ****
--- 1056,1064 ----
    if (*dirname)
      strcat (name, "/");
    strcat (name, FILE_NAME_MAP_FILE);
+ #if (defined(__MVS__) || defined(__CMS__) || defined(__VSE__))
+   strcpy (name, FILE_NAME_MAP_FILE);
+ #endif
    f = fopen (name, "r");
  
    /* Silently return NULL if we cannot open.  */
Index: gcc/gcc/cpphash.h
diff -c gcc/gcc/cpphash.h:1.1.1.1 gcc/gcc/cpphash.h:1.2
*** gcc/gcc/cpphash.h:1.1.1.1	Wed Feb 15 21:22:25 2006
--- gcc/gcc/cpphash.h	Wed Feb 15 21:24:28 2006
***************
*** 75,82 ****
--- 75,87 ----
    unsigned int len;
    /* We use these to tell if the directory mentioned here is a duplicate
       of an earlier directory on the search path.  */
+ #ifdef HAVE_STAT
    ino_t ino;
    dev_t dev;
+ #else
+   int ino;
+   int dev;
+ #endif
    /* Non-zero if it is a system include directory.  */
    int sysp;
    /* Mapping of file names for this directory.  Only used on MS-DOS
Index: gcc/gcc/cppinit.c
diff -c gcc/gcc/cppinit.c:1.1.1.1 gcc/gcc/cppinit.c:1.7
*** gcc/gcc/cppinit.c:1.1.1.1	Wed Feb 15 21:22:25 2006
--- gcc/gcc/cppinit.c	Tue Nov 02 01:06:37 2010
***************
*** 30,35 ****
--- 30,41 ----
  #include "cppdefault.h"
  #include "except.h"	/* for USING_SJLJ_EXCEPTIONS */
  
+ #ifndef HAVE_STAT
+ #undef S_ISDIR
+ #define S_ISDIR(a) (1)
+ #endif
+ 
+ 
  /* Predefined symbols, built-in macros, and the default include path.  */
  
  #ifndef GET_ENV_PATH_LIST
***************
*** 43,49 ****
  # define INO_T_EQ(A, B) (!memcmp (&(A), &(B), sizeof (A)))
  # define INO_T_COPY(DEST, SRC) memcpy(&(DEST), &(SRC), sizeof (SRC))
  #else
! # if (defined _WIN32 && ! defined (_UWIN)) || defined __MSDOS__
  #  define INO_T_EQ(A, B) 0
  # else
  #  define INO_T_EQ(A, B) ((A) == (B))
--- 49,56 ----
  # define INO_T_EQ(A, B) (!memcmp (&(A), &(B), sizeof (A)))
  # define INO_T_COPY(DEST, SRC) memcpy(&(DEST), &(SRC), sizeof (SRC))
  #else
! # if (defined _WIN32 && ! defined (_UWIN)) || defined __MSDOS__ \
!   || !defined HAVE_STAT
  #  define INO_T_EQ(A, B) 0
  # else
  #  define INO_T_EQ(A, B) ((A) == (B))
***************
*** 161,166 ****
--- 168,286 ----
  #undef END
  #undef TRIGRAPH_MAP
  
+ /* Irix6 "cc -n32" and OSF4 cc have problems with char foo[] = ("string");
+    I.e. a const string initializer with parens around it.  That is
+    what N_("string") resolves to, so we make no_* be macros instead.  */
+ #define no_arg N_("argument missing after %s")
+ #define no_ass N_("assertion missing after %s")
+ #define no_dir N_("directory name missing after %s")
+ #define no_fil N_("file name missing after %s")
+ #define no_mac N_("macro name missing after %s")
+ #define no_pth N_("path name missing after %s")
+ #define no_num N_("number missing after %s")
+ #define no_tgt N_("target missing after %s")
+ 
+ /* This is the list of all command line options, with the leading
+    "-" removed.  It must be sorted in ASCII collating order.  */
+ #define COMMAND_LINE_OPTIONS                                                  \
+   DEF_OPT("$",                        0,      OPT_dollar)                     \
+   DEF_OPT("+",                        0,      OPT_plus)                       \
+   DEF_OPT("-help",                    0,      OPT__help)                      \
+   DEF_OPT("-target-help",             0,      OPT_target__help)               \
+   DEF_OPT("-version",                 0,      OPT__version)                   \
+   DEF_OPT("A",                        no_ass, OPT_A)                          \
+   DEF_OPT("C",                        0,      OPT_C)                          \
+   DEF_OPT("D",                        no_mac, OPT_D)                          \
+   DEF_OPT("H",                        0,      OPT_H)                          \
+   DEF_OPT("I",                        no_dir, OPT_I)                          \
+   DEF_OPT("M",                        0,      OPT_M)                          \
+   DEF_OPT("MD",                       no_fil, OPT_MD)                         \
+   DEF_OPT("MF",                       no_fil, OPT_MF)                         \
+   DEF_OPT("MG",                       0,      OPT_MG)                         \
+   DEF_OPT("MM",                       0,      OPT_MM)                         \
+   DEF_OPT("MMD",                      no_fil, OPT_MMD)                        \
+   DEF_OPT("MP",                       0,      OPT_MP)                         \
+   DEF_OPT("MQ",                       no_tgt, OPT_MQ)                         \
+   DEF_OPT("MT",                       no_tgt, OPT_MT)                         \
+   DEF_OPT("P",                        0,      OPT_P)                          \
+   DEF_OPT("U",                        no_mac, OPT_U)                          \
+   DEF_OPT("W",                        no_arg, OPT_W)  /* arg optional */      \
+   DEF_OPT("d",                        no_arg, OPT_d)                          \
+   DEF_OPT("fleading-underscore",      0,      OPT_fleading_underscore)        \
+   DEF_OPT("fno-leading-underscore",   0,      OPT_fno_leading_underscore)     \
+   DEF_OPT("fno-operator-names",       0,      OPT_fno_operator_names)         \
+   DEF_OPT("fno-preprocessed",         0,      OPT_fno_preprocessed)           \
+   DEF_OPT("fno-show-column",          0,      OPT_fno_show_column)            \
+   DEF_OPT("fpreprocessed",            0,      OPT_fpreprocessed)              \
+   DEF_OPT("fshow-column",             0,      OPT_fshow_column)               \
+   DEF_OPT("fsigned-char",             0,      OPT_fsigned_char)               \
+   DEF_OPT("ftabstop=",                no_num, OPT_ftabstop)                   \
+   DEF_OPT("funsigned-char",           0,      OPT_funsigned_char)             \
+   DEF_OPT("h",                        0,      OPT_h)                          \
+   DEF_OPT("idirafter",                no_dir, OPT_idirafter)                  \
+   DEF_OPT("imacros",                  no_fil, OPT_imacros)                    \
+   DEF_OPT("include",                  no_fil, OPT_include)                    \
+   DEF_OPT("iprefix",                  no_pth, OPT_iprefix)                    \
+   DEF_OPT("isystem",                  no_dir, OPT_isystem)                    \
+   DEF_OPT("iwithprefix",              no_dir, OPT_iwithprefix)                \
+   DEF_OPT("iwithprefixbefore",        no_dir, OPT_iwithprefixbefore)          \
+   DEF_OPT("lang-asm",                 0,      OPT_lang_asm)                   \
+   DEF_OPT("lang-c",                   0,      OPT_lang_c)                     \
+   DEF_OPT("lang-c++",                 0,      OPT_lang_cplusplus)             \
+   DEF_OPT("lang-c89",                 0,      OPT_lang_c89)                   \
+   DEF_OPT("lang-objc",                0,      OPT_lang_objc)                  \
+   DEF_OPT("lang-objc++",              0,      OPT_lang_objcplusplus)          \
+   DEF_OPT("nostdinc",                 0,      OPT_nostdinc)                   \
+   DEF_OPT("nostdinc++",               0,      OPT_nostdincplusplus)           \
+   DEF_OPT("o",                        no_fil, OPT_o)                          \
+   DEF_OPT("pedantic",                 0,      OPT_pedantic)                   \
+   DEF_OPT("pedantic-errors",          0,      OPT_pedantic_errors)            \
+   DEF_OPT("remap",                    0,      OPT_remap)                      \
+   DEF_OPT("std=c++98",                0,      OPT_std_cplusplus98)            \
+   DEF_OPT("std=c89",                  0,      OPT_std_c89)                    \
+   DEF_OPT("std=c99",                  0,      OPT_std_c99)                    \
+   DEF_OPT("std=c9x",                  0,      OPT_std_c9x)                    \
+   DEF_OPT("std=gnu89",                0,      OPT_std_gnu89)                  \
+   DEF_OPT("std=gnu99",                0,      OPT_std_gnu99)                  \
+   DEF_OPT("std=gnu9x",                0,      OPT_std_gnu9x)                  \
+   DEF_OPT("std=iso9899:1990",         0,      OPT_std_iso9899_1990)           \
+   DEF_OPT("std=iso9899:199409",       0,      OPT_std_iso9899_199409)         \
+   DEF_OPT("std=iso9899:1999",         0,      OPT_std_iso9899_1999)           \
+   DEF_OPT("std=iso9899:199x",         0,      OPT_std_iso9899_199x)           \
+   DEF_OPT("trigraphs",                0,      OPT_trigraphs)                  \
+   DEF_OPT("v",                        0,      OPT_v)                          \
+   DEF_OPT("version",                  0,      OPT_version)                    \
+   DEF_OPT("w",                        0,      OPT_w)
+ 
+ #define DEF_OPT(text, msg, code) code,
+ enum opt_code
+ {
+   COMMAND_LINE_OPTIONS
+   N_OPTS
+ };
+ #undef DEF_OPT
+ 
+ struct cl_option
+ {
+   const char *opt_text;
+   const char *msg;
+   size_t opt_len;
+   enum opt_code opt_code;
+ };
+ 
+ #define DEF_OPT(text, msg, code) { text, msg, sizeof(text) - 1, code },
+ #ifdef HOST_EBCDIC
+ static struct cl_option cl_options[] =
+ #else
+ static const struct cl_option cl_options[] =
+ #endif
+ {
+   COMMAND_LINE_OPTIONS
+ };
+ #undef DEF_OPT
+ #undef COMMAND_LINE_OPTIONS
+ 
+ 
  /* Given a colon-separated list of file names PATH,
     add all the names to the search path for include files.  */
  static void
***************
*** 550,555 ****
--- 670,678 ----
  #else
    CPP_OPTION (pfile, signed_char) = 0;
  #endif
+ #if TARGET_MVS
+   CPP_OPTION (pfile, no_standard_includes) = 1;
+ #endif
  
    CPP_OPTION (pfile, pending) =
      (struct cpp_pending *) xcalloc (1, sizeof (struct cpp_pending));
***************
*** 1212,1329 ****
    APPEND (pend, directive, o);
  }
  
- /* Irix6 "cc -n32" and OSF4 cc have problems with char foo[] = ("string");
-    I.e. a const string initializer with parens around it.  That is
-    what N_("string") resolves to, so we make no_* be macros instead.  */
- #define no_arg N_("argument missing after %s")
- #define no_ass N_("assertion missing after %s")
- #define no_dir N_("directory name missing after %s")
- #define no_fil N_("file name missing after %s")
- #define no_mac N_("macro name missing after %s")
- #define no_pth N_("path name missing after %s")
- #define no_num N_("number missing after %s")
- #define no_tgt N_("target missing after %s")
- 
- /* This is the list of all command line options, with the leading
-    "-" removed.  It must be sorted in ASCII collating order.  */
- #define COMMAND_LINE_OPTIONS                                                  \
-   DEF_OPT("$",                        0,      OPT_dollar)                     \
-   DEF_OPT("+",                        0,      OPT_plus)                       \
-   DEF_OPT("-help",                    0,      OPT__help)                      \
-   DEF_OPT("-target-help",             0,      OPT_target__help)               \
-   DEF_OPT("-version",                 0,      OPT__version)                   \
-   DEF_OPT("A",                        no_ass, OPT_A)                          \
-   DEF_OPT("C",                        0,      OPT_C)                          \
-   DEF_OPT("D",                        no_mac, OPT_D)                          \
-   DEF_OPT("H",                        0,      OPT_H)                          \
-   DEF_OPT("I",                        no_dir, OPT_I)                          \
-   DEF_OPT("M",                        0,      OPT_M)                          \
-   DEF_OPT("MD",                       no_fil, OPT_MD)                         \
-   DEF_OPT("MF",                       no_fil, OPT_MF)                         \
-   DEF_OPT("MG",                       0,      OPT_MG)                         \
-   DEF_OPT("MM",                       0,      OPT_MM)                         \
-   DEF_OPT("MMD",                      no_fil, OPT_MMD)                        \
-   DEF_OPT("MP",                       0,      OPT_MP)                         \
-   DEF_OPT("MQ",                       no_tgt, OPT_MQ)                         \
-   DEF_OPT("MT",                       no_tgt, OPT_MT)                         \
-   DEF_OPT("P",                        0,      OPT_P)                          \
-   DEF_OPT("U",                        no_mac, OPT_U)                          \
-   DEF_OPT("W",                        no_arg, OPT_W)  /* arg optional */      \
-   DEF_OPT("d",                        no_arg, OPT_d)                          \
-   DEF_OPT("fleading-underscore",      0,      OPT_fleading_underscore)        \
-   DEF_OPT("fno-leading-underscore",   0,      OPT_fno_leading_underscore)     \
-   DEF_OPT("fno-operator-names",       0,      OPT_fno_operator_names)         \
-   DEF_OPT("fno-preprocessed",         0,      OPT_fno_preprocessed)           \
-   DEF_OPT("fno-show-column",          0,      OPT_fno_show_column)            \
-   DEF_OPT("fpreprocessed",            0,      OPT_fpreprocessed)              \
-   DEF_OPT("fshow-column",             0,      OPT_fshow_column)               \
-   DEF_OPT("fsigned-char",             0,      OPT_fsigned_char)               \
-   DEF_OPT("ftabstop=",                no_num, OPT_ftabstop)                   \
-   DEF_OPT("funsigned-char",           0,      OPT_funsigned_char)             \
-   DEF_OPT("h",                        0,      OPT_h)                          \
-   DEF_OPT("idirafter",                no_dir, OPT_idirafter)                  \
-   DEF_OPT("imacros",                  no_fil, OPT_imacros)                    \
-   DEF_OPT("include",                  no_fil, OPT_include)                    \
-   DEF_OPT("iprefix",                  no_pth, OPT_iprefix)                    \
-   DEF_OPT("isystem",                  no_dir, OPT_isystem)                    \
-   DEF_OPT("iwithprefix",              no_dir, OPT_iwithprefix)                \
-   DEF_OPT("iwithprefixbefore",        no_dir, OPT_iwithprefixbefore)          \
-   DEF_OPT("lang-asm",                 0,      OPT_lang_asm)                   \
-   DEF_OPT("lang-c",                   0,      OPT_lang_c)                     \
-   DEF_OPT("lang-c++",                 0,      OPT_lang_cplusplus)             \
-   DEF_OPT("lang-c89",                 0,      OPT_lang_c89)                   \
-   DEF_OPT("lang-objc",                0,      OPT_lang_objc)                  \
-   DEF_OPT("lang-objc++",              0,      OPT_lang_objcplusplus)          \
-   DEF_OPT("nostdinc",                 0,      OPT_nostdinc)                   \
-   DEF_OPT("nostdinc++",               0,      OPT_nostdincplusplus)           \
-   DEF_OPT("o",                        no_fil, OPT_o)                          \
-   DEF_OPT("pedantic",                 0,      OPT_pedantic)                   \
-   DEF_OPT("pedantic-errors",          0,      OPT_pedantic_errors)            \
-   DEF_OPT("remap",                    0,      OPT_remap)                      \
-   DEF_OPT("std=c++98",                0,      OPT_std_cplusplus98)            \
-   DEF_OPT("std=c89",                  0,      OPT_std_c89)                    \
-   DEF_OPT("std=c99",                  0,      OPT_std_c99)                    \
-   DEF_OPT("std=c9x",                  0,      OPT_std_c9x)                    \
-   DEF_OPT("std=gnu89",                0,      OPT_std_gnu89)                  \
-   DEF_OPT("std=gnu99",                0,      OPT_std_gnu99)                  \
-   DEF_OPT("std=gnu9x",                0,      OPT_std_gnu9x)                  \
-   DEF_OPT("std=iso9899:1990",         0,      OPT_std_iso9899_1990)           \
-   DEF_OPT("std=iso9899:199409",       0,      OPT_std_iso9899_199409)         \
-   DEF_OPT("std=iso9899:1999",         0,      OPT_std_iso9899_1999)           \
-   DEF_OPT("std=iso9899:199x",         0,      OPT_std_iso9899_199x)           \
-   DEF_OPT("trigraphs",                0,      OPT_trigraphs)                  \
-   DEF_OPT("v",                        0,      OPT_v)                          \
-   DEF_OPT("version",                  0,      OPT_version)                    \
-   DEF_OPT("w",                        0,      OPT_w)
- 
- #define DEF_OPT(text, msg, code) code,
- enum opt_code
- {
-   COMMAND_LINE_OPTIONS
-   N_OPTS
- };
- #undef DEF_OPT
- 
- struct cl_option
- {
-   const char *opt_text;
-   const char *msg;
-   size_t opt_len;
-   enum opt_code opt_code;
- };
- 
- #define DEF_OPT(text, msg, code) { text, msg, sizeof(text) - 1, code },
- #ifdef HOST_EBCDIC
- static struct cl_option cl_options[] =
- #else
- static const struct cl_option cl_options[] =
- #endif
- {
-   COMMAND_LINE_OPTIONS
- };
- #undef DEF_OPT
- #undef COMMAND_LINE_OPTIONS
- 
  /* Perform a binary search to find which, if any, option the given
     command-line matches.  Returns its index in the option array,
     negative on failure.  Complications arise since some options can be
--- 1335,1340 ----
Index: gcc/gcc/cpplex.c
diff -c gcc/gcc/cpplex.c:1.1.1.1 gcc/gcc/cpplex.c:1.5
*** gcc/gcc/cpplex.c:1.1.1.1	Wed Feb 15 21:22:25 2006
--- gcc/gcc/cpplex.c	Wed Dec 12 02:07:29 2007
***************
*** 1686,1701 ****
     the input pointer, which is just after the backslash.  LIMIT is how
     much text we have.  MASK is a bitmask for the precision for the
     destination type (char or wchar_t).  TRADITIONAL, if true, does not
!    interpret escapes that did not exist in traditional C.
  
     Handles all relevant diagnostics.  */
  unsigned int
! cpp_parse_escape (pfile, pstr, limit, mask, traditional)
       cpp_reader *pfile;
       const unsigned char **pstr;
       const unsigned char *limit;
       unsigned HOST_WIDE_INT mask;
       int traditional;
  {
    int unknown = 0;
    const unsigned char *str = *pstr;
--- 1686,1703 ----
     the input pointer, which is just after the backslash.  LIMIT is how
     much text we have.  MASK is a bitmask for the precision for the
     destination type (char or wchar_t).  TRADITIONAL, if true, does not
!    interpret escapes that did not exist in traditional C.  INSTRING, if
!    true then we are within a string.
  
     Handles all relevant diagnostics.  */
  unsigned int
! cpp_parse_escape (pfile, pstr, limit, mask, traditional, instring)
       cpp_reader *pfile;
       const unsigned char **pstr;
       const unsigned char *limit;
       unsigned HOST_WIDE_INT mask;
       int traditional;
+      int instring;
  {
    int unknown = 0;
    const unsigned char *str = *pstr;
***************
*** 1703,1720 ****
  
    switch (c)
      {
!     case '\\': case '\'': case '"': case '?': break;
!     case 'b': c = TARGET_BS;	  break;
!     case 'f': c = TARGET_FF;	  break;
!     case 'n': c = TARGET_NEWLINE; break;
!     case 'r': c = TARGET_CR;	  break;
!     case 't': c = TARGET_TAB;	  break;
!     case 'v': c = TARGET_VT;	  break;
  
      case '(': case '{': case '[': case '%':
        /* '\(', etc, are used at beginning of line to avoid confusing Emacs.
  	 '\%' is used to prevent SCCS from getting confused.  */
        unknown = CPP_PEDANTIC (pfile);
        break;
  
      case 'a':
--- 1705,1732 ----
  
    switch (c)
      {
!     case '\\': case '\'': case '"': case '?':
! #ifdef MAP_OUTCHAR
!       if (!instring)
!         c = MAP_OUTCHAR(c);
! #endif
!       break;
! 
!     case 'b': c = instring ? '\b' : TARGET_BS;	  break;
!     case 'f': c = instring ? '\f' : TARGET_FF;	  break;
!     case 'n': c = instring ? '\n' : TARGET_NEWLINE; break;
!     case 'r': c = instring ? '\r' : TARGET_CR;	  break;
!     case 't': c = instring ? '\t' : TARGET_TAB;	  break;
!     case 'v': c = instring ? '\v' : TARGET_VT;	  break;
  
      case '(': case '{': case '[': case '%':
        /* '\(', etc, are used at beginning of line to avoid confusing Emacs.
  	 '\%' is used to prevent SCCS from getting confused.  */
        unknown = CPP_PEDANTIC (pfile);
+ #ifdef MAP_OUTCHAR
+       if (!instring)
+         c = MAP_OUTCHAR(c);
+ #endif
        break;
  
      case 'a':
***************
*** 1732,1737 ****
--- 1744,1752 ----
        
      case 'u': case 'U':
        unknown = maybe_read_ucs (pfile, &str, limit, &c);
+ #ifdef MAP_OUTCHAR
+       c = MAP_OUTCHAR(c);
+ #endif
        break;
  
      case 'x':
***************
*** 1763,1768 ****
--- 1778,1787 ----
  	      i &= mask;
  	    }
  	  c = i;
+ #ifdef MAP_INCHAR
+ 	  if (instring)
+             c = MAP_INCHAR(c);
+ #endif
  	}
        break;
  
***************
*** 1787,1792 ****
--- 1806,1815 ----
  	    i &= mask;
  	  }
  	c = i;
+ #ifdef MAP_INCHAR
+ 	if (instring)
+           c = MAP_INCHAR(c);
+ #endif
        }
        break;
  
***************
*** 1883,1895 ****
  #endif
  
        if (c == '\\')
! 	c = cpp_parse_escape (pfile, &str, limit, mask, traditional);
  
! #ifdef MAP_CHARACTER
!       if (ISPRINT (c))
! 	c = MAP_CHARACTER (c);
  #endif
!       
        /* Merge character into result; ignore excess chars.  */
        if (++chars_seen <= max_chars)
  	{
--- 1906,1918 ----
  #endif
  
        if (c == '\\')
! 	c = cpp_parse_escape (pfile, &str, limit, mask, traditional, 0);
  
! #ifdef MAP_OUTCHAR
!       else
!         c = MAP_OUTCHAR (c);
  #endif
! 
        /* Merge character into result; ignore excess chars.  */
        if (++chars_seen <= max_chars)
  	{
Index: gcc/gcc/cpplib.c
diff -c gcc/gcc/cpplib.c:1.1.1.1 gcc/gcc/cpplib.c:1.4
*** gcc/gcc/cpplib.c:1.1.1.1	Wed Feb 15 21:22:25 2006
--- gcc/gcc/cpplib.c	Fri Nov 03 18:10:08 2006
***************
*** 712,718 ****
        if (c != '\\')
  	*dst++ = c;
        else
! 	*dst++ = cpp_parse_escape (pfile, (const U_CHAR **)&str, limit, mask, 0);
      }
    *dst++ = '\0';
    return result;
--- 712,718 ----
        if (c != '\\')
  	*dst++ = c;
        else
! 	*dst++ = cpp_parse_escape (pfile, (const U_CHAR **)&str, limit, mask, 0, 1);
      }
    *dst++ = '\0';
    return result;
Index: gcc/gcc/cpplib.h
diff -c gcc/gcc/cpplib.h:1.1.1.1 gcc/gcc/cpplib.h:1.5
*** gcc/gcc/cpplib.h:1.1.1.1	Wed Feb 15 21:22:25 2006
--- gcc/gcc/cpplib.h	Fri Nov 03 18:10:08 2006
***************
*** 23,29 ****
--- 23,31 ----
  #ifndef GCC_CPPLIB_H
  #define GCC_CPPLIB_H
  
+ #ifdef HAVE_SYS_TYPES_H
  #include <sys/types.h>
+ #endif
  #include "hashtable.h"
  #include "line-map.h"
  
***************
*** 581,587 ****
  extern unsigned int cpp_parse_escape	PARAMS ((cpp_reader *,
  						 const unsigned char **,
  						 const unsigned char *,
! 						 unsigned HOST_WIDE_INT, int));
  
  /* In cpphash.c */
  
--- 583,590 ----
  extern unsigned int cpp_parse_escape	PARAMS ((cpp_reader *,
  						 const unsigned char **,
  						 const unsigned char *,
! 						 unsigned HOST_WIDE_INT,
! 						 int, int));
  
  /* In cpphash.c */
  
Index: gcc/gcc/cppmacro.c
diff -c gcc/gcc/cppmacro.c:1.1.1.1 gcc/gcc/cppmacro.c:1.2
*** gcc/gcc/cppmacro.c:1.1.1.1	Wed Feb 15 21:22:25 2006
--- gcc/gcc/cppmacro.c	Wed Dec 12 16:11:54 2007
***************
*** 158,163 ****
--- 158,177 ----
  	    map = INCLUDED_FROM (&pfile->line_maps, map);
  
  	name = map->to_file;
+ #ifdef TARGET_MVS
+         /* In order to get the generated assembler consistent on
+            MVS where we don't have an input file name, we force
+            the cross-compile to generate the same name. It may
+            be better to pass an extra parameter to
+            gcc to provide a filename. Even if we could extract
+            the member name from the SYSIN DD statement, it still
+            wouldn't make the source consistent with the PC
+            filename. */
+         if (strstr(name, ".c") != NULL)
+         {
+             name = "<stdin>";
+         }
+ #endif
  	len = strlen (name);
  	buf = _cpp_unaligned_alloc (pfile, len * 4 + 1);
  	len = cpp_quote_string (buf, (const unsigned char *) name, len) - buf;
Index: gcc/gcc/cppmain.c
diff -c gcc/gcc/cppmain.c:1.1.1.1 gcc/gcc/cppmain.c:1.3
*** gcc/gcc/cppmain.c:1.1.1.1	Wed Feb 15 21:22:25 2006
--- gcc/gcc/cppmain.c	Tue Oct 31 16:45:58 2006
***************
*** 26,31 ****
--- 26,37 ----
  #include "cpplib.h"
  #include "intl.h"
  
+ #ifdef SINGLE_EXECUTABLE
+ #define main(a,b) cpp(a,b)
+ #define progname cpmprog
+ #endif
+ 
+ 
  /* Encapsulates state used to convert the stream of tokens coming from
     cpp_get_token back into a text file.  */
  struct printer
Index: gcc/gcc/cppspec.c
diff -c gcc/gcc/cppspec.c:1.1.1.1 gcc/gcc/cppspec.c:1.2
*** gcc/gcc/cppspec.c:1.1.1.1	Wed Feb 15 21:22:25 2006
--- gcc/gcc/cppspec.c	Wed Feb 15 21:24:28 2006
***************
*** 22,27 ****
--- 22,37 ----
  #include "system.h"
  #include "gcc.h"
  
+ #ifdef SINGLE_EXECUTABLE
+ #undef lang_specific_driver
+ #undef lang_specific_extra_outfiles
+ #undef lang_specific_pre_link
+ #define lang_specific_driver cpsp_lsd
+ #define lang_specific_pre_link cpsp_lspl
+ #define lang_specific_extra_outfiles cpsp_lseo
+ #endif
+ 
+ 
  /* The `cpp' executable installed in $(bindir) and $(cpp_install_dir)
     is a customized version of the gcc driver.  It forces -E; -S and -c
     are errors.  It defaults to -x c for files with unrecognized
Index: gcc/gcc/cygwin.bat
diff -c nul gcc/gcc/cygwin.bat:1.7
*** nul	Tue Oct 01 16:28:44 2019
--- gcc/gcc/cygwin.bat	Fri Nov 27 07:05:35 2009
***************
*** 0 ****
--- 1,45 ----
+ rem set this to core or standard
+ set gccname=gcc-core-3.2.3
+ 
+ rem this is the patch name
+ set gccpname=gcc-stage204
+ 
+ rem this is the name of the pdpclib archive
+ set pdpname=pdpclib
+ 
+ rm -fr work
+ md work
+ cd work
+ md pdos
+ cd pdos
+ md pdpclib
+ cd pdpclib
+ unzip ..\..\..\%pdpname%
+ cd ..\..
+ copy ..\%gccname%.tar.bz2
+ copy ..\%gccpname%.zip
+ bzip2 -d %gccname%.tar.bz2
+ tar xvf %gccname%.tar
+ del %gccname%.tar
+ unzip %gccpname%.zip
+ del %gccpname%.zip
+ ren gcc-3.2.3 gcc
+ cd gcc
+ patch -p 1 -f <..\%gccpname%.txt
+ del ..\%gccpname%.txt
+ 
+ cd gcc
+ sed 's/stdcompp/stdcompg/' stdcomp.bat >temp.bat
+ copy temp.bat stdcomp.bat
+ sed 's/rem gcc/gccreal/;s/gcc /rem gcc /;s/gccreal/gcc/' compile.bat >temp.bat
+ copy temp.bat compile.bat
+ del temp.bat
+ 
+ rem in case the cygwin is set to linefeeds, convert to cr/lf
+ zip -m -l temp compile.bat stdcomp.bat
+ unzip temp
+ del temp.zip
+ 
+ call compile
+ call compmvs -ansi -pedantic-errors
+ call zipmvs
Index: gcc/gcc/debug.c
diff -c gcc/gcc/debug.c:1.1.1.1 gcc/gcc/debug.c:1.2
*** gcc/gcc/debug.c:1.1.1.1	Wed Feb 15 21:22:25 2006
--- gcc/gcc/debug.c	Mon Aug 17 20:28:53 2009
***************
*** 18,23 ****
--- 18,38 ----
  #include "config.h"
  #include "system.h"
  #include "debug.h"
+ #include "output.h"
+ #include "flags.h"
+ 
+ static void
+ debug_source_line (line, text)
+      unsigned int line ATTRIBUTE_UNUSED;
+      const char *text ATTRIBUTE_UNUSED;
+ {
+    if (flag_debug_asm)
+    {
+        app_enable();
+        fprintf(asm_out_file, "%s %d %s\n", ASM_COMMENT_START, line, text);
+        app_disable();
+    }
+ }
  
  /* The do-nothing debug hooks.  */
  struct gcc_debug_hooks do_nothing_debug_hooks =
***************
*** 31,37 ****
    debug_nothing_int_int,	/* begin_block */
    debug_nothing_int_int,	/* end_block */
    debug_true_tree,		/* ignore_block */
!   debug_nothing_int_charstar,	/* source_line */
    debug_nothing_int_charstar,	/* begin_prologue */
    debug_nothing_int,		/* end_prologue */
    debug_nothing_void,		/* end_epilogue */
--- 46,52 ----
    debug_nothing_int_int,	/* begin_block */
    debug_nothing_int_int,	/* end_block */
    debug_true_tree,		/* ignore_block */
!   debug_source_line,	/* source_line */
    debug_nothing_int_charstar,	/* begin_prologue */
    debug_nothing_int,		/* end_prologue */
    debug_nothing_void,		/* end_epilogue */
Index: gcc/gcc/diffcms.exec
diff -c nul gcc/gcc/diffcms.exec:1.6
*** nul	Tue Oct 01 16:28:44 2019
--- gcc/gcc/diffcms.exec	Sat Sep 27 01:47:44 2008
***************
*** 0 ****
--- 1 ----
+ COMPARE &1 S &2 &1 S &3
Index: gcc/gcc/example.jcl
diff -c nul gcc/gcc/example.jcl:1.29
*** nul	Tue Oct 01 16:28:44 2019
--- gcc/gcc/example.jcl	Sun Jun 14 12:54:59 2015
***************
*** 0 ****
--- 1,70 ----
+ //GCCGEN   JOB CLASS=C,REGION=0K
+ //*
+ //* This example is for people who don't have a PROC installed
+ //* in their installation. It compiles an example C program.
+ //*
+ //CCOMP    PROC GCCPREF='GCC',PDPPREF='PDPCLIB',MEMBER='',
+ // COS1='-Os -S -ansi -pedantic-errors',
+ // COS2='-o dd:out -'
+ //*
+ //COMP     EXEC PGM=GCC,
+ // PARM='&COS1 &COS2'
+ //STEPLIB  DD DSN=&GCCPREF..LINKLIB,DISP=SHR
+ //INCLUDE  DD DSN=&PDPPREF..INCLUDE,DISP=SHR
+ //SYSINCL  DD DSN=&PDPPREF..INCLUDE,DISP=SHR
+ //OUT      DD DSN=&&TEMP,DISP=(,PASS),UNIT=SYSALLDA,
+ //            DCB=(LRECL=80,BLKSIZE=6160,RECFM=FB),
+ //            SPACE=(6160,(500,500))
+ //SYSIN    DD DSN=&PDPPREF..SOURCE(&MEMBER),DISP=SHR
+ //SYSPRINT DD SYSOUT=*
+ //SYSTERM  DD SYSOUT=*
+ //*
+ //ASM      EXEC PGM=ASMA90,
+ //            PARM='DECK,NOLIST',
+ //            COND=(4,LT,COMP)
+ //SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR,DCB=BLKSIZE=32720
+ //         DD DSN=&PDPPREF..MACLIB,DISP=SHR
+ //SYSUT1   DD UNIT=SYSALLDA,SPACE=(CYL,(20,10))
+ //SYSUT2   DD UNIT=SYSALLDA,SPACE=(CYL,(10,10))
+ //SYSUT3   DD UNIT=SYSALLDA,SPACE=(CYL,(10,10))
+ //SYSPRINT DD SYSOUT=*
+ //SYSLIN   DD DUMMY
+ //SYSGO    DD DUMMY
+ //SYSPUNCH DD DSN=&&OBJSET,UNIT=SYSALLDA,SPACE=(80,(4000,4000)),
+ //            DISP=(,PASS)
+ //SYSIN    DD DSN=&&TEMP,DISP=(OLD,DELETE)
+ //*
+ //LKED     EXEC PGM=IEWL,PARM='AMODE=31,RMODE=ANY',
+ //            COND=((4,LT,COMP),(4,LT,ASM))
+ //SYSLIN   DD DSN=&&OBJSET,DISP=(OLD,DELETE)
+ //         DD DDNAME=SYSIN
+ //SYSIN    DD DUMMY
+ //SYSLIB   DD DSN=&PDPPREF..NCALIB,DISP=SHR
+ //SYSLMOD  DD DSN=&&TEMPL(&MEMBER),DISP=(OLD,PASS)
+ //SYSUT1   DD UNIT=SYSALLDA,SPACE=(CYL,(2,1))
+ //SYSPRINT DD SYSOUT=*
+ //         PEND
+ //*
+ //S1       EXEC PGM=IEFBR14
+ //DD1      DD DSN=&&TEMPL,DISP=(NEW,PASS),UNIT=SYSALLDA,
+ //         SPACE=(CYL,(1,1,44)),DCB=(RECFM=U,LRECL=0,BLKSIZE=6144)
+ //*
+ //S2       EXEC CCOMP,MEMBER='PDPTEST'
+ //COMP.SYSIN DD *
+ #include <stdio.h>
+ 
+ int main(void)
+ {
+     printf("Greetings from Jujitsu ...\n");
+     printf("the makers of MVS/380 !!!\n");
+     return (0);
+ }
+ //LKED.SYSLMOD DD DSN=&&TEMPL(PDPTEST),DISP=(OLD,PASS)
+ //*
+ //S3       EXEC PGM=PDPTEST
+ //STEPLIB  DD DSN=&&TEMPL,DISP=(OLD,PASS)
+ //SYSIN    DD DUMMY
+ //SYSPRINT DD SYSOUT=*
+ //SYSTERM  DD SYSOUT=*
+ //*
+ //
Index: gcc/gcc/example2.jcl
diff -c nul gcc/gcc/example2.jcl:1.5
*** nul	Tue Oct 01 16:28:44 2019
--- gcc/gcc/example2.jcl	Mon Sep 30 12:42:45 2019
***************
*** 0 ****
--- 1,33 ----
+ //GCCGEN   JOB CLASS=C,REGION=0K
+ //*
+ //* This is an example of how to compile using the
+ //* proc. If your installation has not installed the
+ //* proc, you will need to execute the compiler
+ //* directly, using the other example.
+ //*
+ //S1 EXEC GCCCL,
+ //  INFILE='PDPCLIB.SOURCE(PDPTEST)',
+ //  OUTFILE='PDPCLIB.LINKLIB(PDPTEST)',
+ //*  COPTS='-DLOOP',
+ //  LOPTS='MAP,AMODE=31,RMODE=ANY'
+ //*
+ //* Note if you have multiple source files in your
+ //* project, you MAY need specific includes for them,
+ //* in which case uncomment and add them to this:
+ //*LKED.SYSIN DD DUMMY
+ //* You will also need to add an "ENTRY @@MAIN" if you
+ //* have created an intermediate NCAL for your main
+ //* program so that the linkage editor can no longer
+ //* see the original object code.
+ //*
+ //*
+ //*
+ //* Note - if you want this program to loop, uncomment
+ //* the COPTS above.
+ //*
+ //S2 EXEC PGM=PDPTEST,PARM='PaulEdwards was Here'
+ //STEPLIB  DD DSN=PDPCLIB.LINKLIB,DISP=SHR
+ //SYSIN    DD DUMMY
+ //SYSPRINT DD SYSOUT=*
+ //SYSTERM  DD SYSOUT=*
+ //
Index: gcc/gcc/except.c
diff -c gcc/gcc/except.c:1.1.1.1 gcc/gcc/except.c:1.2
*** gcc/gcc/except.c:1.1.1.1	Wed Feb 15 21:22:25 2006
--- gcc/gcc/except.c	Sun Nov 11 15:01:03 2007
***************
*** 2765,2771 ****
       void (*callback) PARAMS ((rtx));
  {
    htab_traverse (exception_handler_label_map, for_each_eh_label_1,
! 		 (void *)callback);
  }
  
  static int
--- 2765,2771 ----
       void (*callback) PARAMS ((rtx));
  {
    htab_traverse (exception_handler_label_map, for_each_eh_label_1,
! 		 (void *)&callback);
  }
  
  static int
***************
*** 2774,2780 ****
       PTR data;
  {
    struct ehl_map_entry *entry = *(struct ehl_map_entry **)pentry;
!   void (*callback) PARAMS ((rtx)) = (void (*) PARAMS ((rtx))) data;
  
    (*callback) (entry->label);
    return 1;
--- 2774,2780 ----
       PTR data;
  {
    struct ehl_map_entry *entry = *(struct ehl_map_entry **)pentry;
!   void (*callback) PARAMS ((rtx)) = *(void (**) PARAMS ((rtx))) data;
  
    (*callback) (entry->label);
    return 1;
Index: gcc/gcc/expr.c
diff -c gcc/gcc/expr.c:1.1.1.1 gcc/gcc/expr.c:1.4
*** gcc/gcc/expr.c:1.1.1.1	Wed Feb 15 21:22:25 2006
--- gcc/gcc/expr.c	Fri Nov 03 18:10:08 2006
***************
*** 2822,2828 ****
  
    if (mov_optab->handlers[(int) mode].insn_code != CODE_FOR_nothing)
      return
!       emit_insn (GEN_FCN (mov_optab->handlers[(int) mode].insn_code) (x, y));
  
    /* Expand complex moves by moving real part and imag part, if possible.  */
    else if ((class == MODE_COMPLEX_FLOAT || class == MODE_COMPLEX_INT)
--- 2822,2828 ----
  
    if (mov_optab->handlers[(int) mode].insn_code != CODE_FOR_nothing)
      return
!       emit_insn (GEN_FN2 (mov_optab->handlers[(int) mode].insn_code) (x, y));
  
    /* Expand complex moves by moving real part and imag part, if possible.  */
    else if ((class == MODE_COMPLEX_FLOAT || class == MODE_COMPLEX_INT)
Index: gcc/gcc/final.c
diff -c gcc/gcc/final.c:1.1.1.1 gcc/gcc/final.c:1.5
*** gcc/gcc/final.c:1.1.1.1	Wed Feb 15 21:22:25 2006
--- gcc/gcc/final.c	Thu Sep 29 02:28:08 2016
***************
*** 1800,1806 ****
      case INSN_OUTPUT_FORMAT_FUNCTION:
        if (insn == NULL)
  	abort ();
!       return (*(insn_output_fn) output) (recog_data.operand, insn);
  
      default:
        abort ();
--- 1800,1806 ----
      case INSN_OUTPUT_FORMAT_FUNCTION:
        if (insn == NULL)
  	abort ();
!       return (*(insn_output_fn *) &output) (recog_data.operand, insn);
  
      default:
        abort ();
***************
*** 1860,1866 ****
--- 1860,1870 ----
  #ifdef IA64_UNWIND_INFO
  	  IA64_UNWIND_EMIT (asm_out_file, insn);
  #endif
+ #if TARGET_MVS || TARGET_CMS
+ 	  if (0)
+ #else
  	  if (flag_debug_asm)
+ #endif
  	    fprintf (asm_out_file, "\t%s basic block %d\n",
  		     ASM_COMMENT_START, NOTE_BASIC_BLOCK (insn)->index);
  	  break;
Index: gcc/gcc/fixcsect.exec
diff -c nul gcc/gcc/fixcsect.exec:1.1
*** nul	Tue Oct 01 16:28:44 2019
--- gcc/gcc/fixcsect.exec	Sat Jan 17 21:38:25 2009
***************
*** 0 ****
--- 1,23 ----
+ ********************************************************
+ *
+ * Fix blank CSECTs
+ * Usage: FIXCSECT <filename> <disk> <asm name> <csect name>
+ *
+ ********************************************************
+ &CONTROL
+ 
+ &FILE = &1
+ &DISK = &2
+ &ASMNAME = &3
+ &CSECT = &4
+ 
+ FILEDEF SYSIN DISK &FILE S &DISK
+ FILEDEF SYSPRINT DISK &FILE ASSEMBLE &DISK (LRECL 80 RECFM F
+ NAMCSECT &CSECT
+ FILEDEF SYSPRINT CLEAR
+ FILEDEF SYSIN CLEAR
+ 
+ &ASMNAME &FILE
+ ERASE &FILE ASSEMBLE
+ ERASE &FILE LISTING
+ &EXIT
Index: gcc/gcc/fixifox.bat
diff -c nul gcc/gcc/fixifox.bat:1.2
*** nul	Tue Oct 01 16:28:44 2019
--- gcc/gcc/fixifox.bat	Fri Nov 16 14:54:22 2007
***************
*** 0 ****
--- 1,5 ----
+ cd config\i370
+ sed 's/\/\*\#define IFOX 1\*\//\#define IFOX 1/g' <pureiso.h >ifox.tmp
+ del pureiso.h
+ ren ifox.tmp pureiso.h
+ cd ..\..
Index: gcc/gcc/fixjcl.bat
diff -c nul gcc/gcc/fixjcl.bat:1.6
*** nul	Tue Oct 01 16:28:44 2019
--- gcc/gcc/fixjcl.bat	Thu Apr 23 23:06:10 2009
***************
*** 0 ****
--- 1,19 ----
+ call runsed stage0a.jcl
+ call runsed stage0b.jcl
+ call runsed stage0c.jcl
+ call runsed stage0d.jcl
+ call runsed stage1a.jcl
+ call runsed stage1b.jcl
+ call runsed stage2a.jcl
+ call runsed stage2b.jcl
+ call runsed stage2c.jcl
+ call runsed stage3a.jcl
+ call runsed stage3b.jcl
+ call runsed stage3c.jcl
+ call runsed stage4.jcl
+ call runsed stage4z.jcl
+ call runsed gencomp.jcl
+ call runsed example.jcl
+ call runsed gccc.prc
+ call runsed gcccl.prc
+ call runsed gccclg.prc
Index: gcc/gcc/flags.h
diff -c gcc/gcc/flags.h:1.1.1.1 gcc/gcc/flags.h:1.2
*** gcc/gcc/flags.h:1.1.1.1	Wed Feb 15 21:22:25 2006
--- gcc/gcc/flags.h	Sat Nov 07 00:53:20 2009
***************
*** 182,187 ****
--- 182,193 ----
  
  extern int profile_arc_flag;
  
+ #if IFOX
+ /* used to work around the 399 identifier limit of IFOX */
+ extern int gflags[32];
+ #endif
+ 
+ #if !IFOX
  /* Nonzero if generating info for gcov to calculate line test coverage.  */
  
  extern int flag_test_coverage;
***************
*** 197,202 ****
--- 203,209 ----
  /* Nonzero if registers should be renamed.  */
  
  extern int flag_rename_registers;
+ #endif
  
  /* Nonzero for -pedantic switch: warn about anything
     that standard C forbids.  */
***************
*** 233,238 ****
--- 240,246 ----
  
  extern int flag_pcc_struct_return;
  
+ #if !IFOX
  /* Nonzero for -fforce-mem: load memory value into a register
     before arithmetic on it.  This makes better cse but slower compilation.  */
  
***************
*** 332,337 ****
--- 340,346 ----
  /* Nonzero allows GCC to optimize sibling and tail recursive calls.  */
  
  extern int flag_optimize_sibling_calls;
+ #endif
  
  /* Nonzero means the front end generally wants `errno' maintained by math
     operations, like built-in SQRT.  */
***************
*** 351,356 ****
--- 360,366 ----
  
  extern int flag_trapping_math;
  
+ #if !IFOX
  /* 0 means straightforward implementation of complex divide acceptable.
     1 means wide ranges of inputs must work for complex divide.
     2 means C99-like requirements for complex divide (not yet implemented).  */
***************
*** 360,365 ****
--- 370,376 ----
  /* Nonzero means to run loop optimizations twice.  */
  
  extern int flag_rerun_loop_opt;
+ #endif
  
  /* Nonzero means make functions that look like good inline candidates
     go inline.  */
***************
*** 385,393 ****
--- 396,406 ----
  
  extern int flag_really_no_inline;
  
+ #if !IFOX
  /* Nonzero if we are only using compiler to check syntax errors.  */
  
  extern int flag_syntax_only;
+ #endif
  
  /* Nonzero means we should save auxiliary info into a .X file.  */
  
***************
*** 479,484 ****
--- 492,498 ----
     needed for crtstuff.c on other systems.  */
  extern int flag_inhibit_size_directive;
  
+ #if !IFOX
  /* Nonzero means place each function into its own section on those platforms
     which support arbitrary section names and unlimited numbers of sections.  */
  
***************
*** 487,492 ****
--- 501,507 ----
  /* ... and similar for data.  */
   
  extern int flag_data_sections;
+ #endif
  
  /* -fverbose-asm causes extra commentary information to be produced in
     the generated assembly code (to make it more readable).  This option
***************
*** 534,541 ****
--- 549,558 ----
     may cause large objects to be allocated dynamically.  */
  extern int flag_stack_check;
  
+ #if !IFOX
  /* Do the full regmove optimization pass.  */
  extern int flag_regmove;
+ #endif
  
  /* Instrument functions with calls at entry and exit, for profiling.  */
  extern int flag_instrument_function_entry_exit;
Index: gcc/gcc/fold-const.c
diff -c gcc/gcc/fold-const.c:1.1.1.1 gcc/gcc/fold-const.c:1.2
*** gcc/gcc/fold-const.c:1.1.1.1	Wed Feb 15 21:22:25 2006
--- gcc/gcc/fold-const.c	Thu Jul 02 02:12:49 2009
***************
*** 2207,2213 ****
  	    else
  	      low = (HOST_WIDE_INT) x;
  	    if (TREE_REAL_CST (arg1) < 0)
! 	      neg_double (low, high, &low, &high);
  	    t = build_int_2 (low, high);
  	  }
  #else
--- 2207,2213 ----
  	    else
  	      low = (HOST_WIDE_INT) x;
  	    if (TREE_REAL_CST (arg1) < 0)
! 	      neg_double (low, high, (unsigned HOST_WIDE_INT *)&low, &high);
  	    t = build_int_2 (low, high);
  	  }
  #else
Index: gcc/gcc/fudge.bat
diff -c nul gcc/gcc/fudge.bat:1.1
*** nul	Tue Oct 01 16:28:44 2019
--- gcc/gcc/fudge.bat	Sat Dec 15 19:29:28 2007
***************
*** 0 ****
--- 1,19 ----
+ rem this is useful during testing. It switches off optimization
+ rem which makes things run a LOT faster
+ 
+ sed 's/-Os/-O0/g' stage2a.jcl >temp.zzz
+ del stage2a.jcl
+ ren temp.zzz stage2a.jcl
+ 
+ sed 's/-Os/-O0/g' stage2b.jcl >temp.zzz
+ del stage2b.jcl
+ ren temp.zzz stage2b.jcl
+ 
+ sed 's/-Os/-O0/g' stage2c.jcl >temp.zzz
+ del stage2c.jcl
+ ren temp.zzz stage2c.jcl
+ 
+ sed 's/PGM=IEBCOMPR/PGM=IEFBR14/g' stage2c.jcl >temp.zzz
+ del stage2c.jcl
+ ren temp.zzz stage2c.jcl
+ 
Index: gcc/gcc/fullcms.bat
diff -c nul gcc/gcc/fullcms.bat:1.1
*** nul	Tue Oct 01 16:28:44 2019
--- gcc/gcc/fullcms.bat	Thu May 21 21:58:05 2009
***************
*** 0 ****
--- 1,4 ----
+ call withbis1
+ copy output.txt oldout.txt
+ call restmini gcccms-exe.vmarc 191
+ call withbis2
Index: gcc/gcc/fullcms1.exec
diff -c nul gcc/gcc/fullcms1.exec:1.2
*** nul	Tue Oct 01 16:28:44 2019
--- gcc/gcc/fullcms1.exec	Fri May 22 10:09:14 2009
***************
*** 0 ****
--- 1,35 ----
+ * Usage - FULLCMS1 <SRC> <EXE> <WORK>
+ 
+ * This script invokes WITHBIS2. See it for further information.
+ 
+ 
+ &SRC = A
+ &EXE = B
+ &WORK = C
+ 
+ 
+ &IF &INDEX EQ 0 &GOTO -FINARGS
+ &SRC = &1
+ &ARGS &2 &3 &4 &5 &6 &7 &8 &9
+ 
+ &IF &INDEX EQ 0 &GOTO -FINARGS
+ &EXE = &1
+ &ARGS &2 &3 &4 &5 &6 &7 &8 &9
+ 
+ &IF &INDEX EQ 0 &GOTO -FINARGS
+ &WORK = &1
+ 
+ -FINARGS
+ 
+ 
+ * Strictly, we're only expecting a blocksize of 80, but
+ * mvsunzip can handle short blocks, so we specify the max
+ FILEDEF INPUT TAP1 (LRECL 80 BLKSIZE 32720 RECFM FB
+ MVSUNZIP DD:INPUT &SRC
+ FILEDEF INPUT CLEAR
+ 
+ 
+ EXEC WITHBIS1 &SRC &EXE &WORK
+ 
+ 
+ VMARC PACK * * &EXE (TAP2 BLOCK 80
Index: gcc/gcc/fullcms2.exec
diff -c nul gcc/gcc/fullcms2.exec:1.2
*** nul	Tue Oct 01 16:28:44 2019
--- gcc/gcc/fullcms2.exec	Fri May 22 10:09:14 2009
***************
*** 0 ****
--- 1,35 ----
+ * Usage - FULLCMS2 <SRC> <EXE> <WORK>
+ 
+ * This script invokes WITHBIS2. See it for further information.
+ 
+ 
+ &SRC = A
+ &EXE = B
+ &WORK = C
+ 
+ 
+ &IF &INDEX EQ 0 &GOTO -FINARGS
+ &SRC = &1
+ &ARGS &2 &3 &4 &5 &6 &7 &8 &9
+ 
+ &IF &INDEX EQ 0 &GOTO -FINARGS
+ &EXE = &1
+ &ARGS &2 &3 &4 &5 &6 &7 &8 &9
+ 
+ &IF &INDEX EQ 0 &GOTO -FINARGS
+ &WORK = &1
+ 
+ -FINARGS
+ 
+ 
+ * Strictly, we're only expecting a blocksize of 80, but
+ * mvsunzip can handle short blocks, so we specify the max
+ FILEDEF INPUT TAP1 (LRECL 80 BLKSIZE 32720 RECFM FB
+ MVSUNZIP DD:INPUT &SRC
+ FILEDEF INPUT CLEAR
+ 
+ 
+ EXEC WITHBIS2 &SRC &EXE &WORK
+ 
+ 
+ VMARC PACK * * &EXE (TAP2 BLOCK 80
Index: gcc/gcc/fullmvs.bat
diff -c nul gcc/gcc/fullmvs.bat:1.7
*** nul	Tue Oct 01 16:28:44 2019
--- gcc/gcc/fullmvs.bat	Sat Aug 22 10:53:52 2009
***************
*** 0 ****
--- 1,24 ----
+ rem after you have updated version.c with the
+ rem latest version number, you can use this to
+ rem do a full build of GCCMVS (which includes
+ rem using (but not generating) bison and sed)
+ rem and source code-regeneration verification
+ rem It also produces the final deliverable xmits
+ 
+ call withbis
+ 
+ del gccmvs-xmit.zip
+ rm -fr xxx
+ md xxx
+ copy xmitread.txt xxx\readme.txt
+ zip -9Xmj gccmvs-xmit gccmvs.xmi xxx\readme.txt
+ zip -9X gccmvs-xmit xmit1.jcl xmit2.jcl xmit3.jcl xmit4.jcl xmit5.jcl xmitrecv.bat
+ rd xxx
+ 
+ rem we could combine the checkgen into the single job stream,
+ rem but it would require coordination with the MVS/380 build
+ rem where bison gets generated also.
+ rem We can't use the batch file directly, because that does
+ rem an unnecessary regeneration of code. fullmvs is not designed
+ rem to be used with a rebuild of bison.
+ runmvs checkgen.jcl checkgen.txt
Index: gcc/gcc/gcc.c
diff -c gcc/gcc/gcc.c:1.1.1.1 gcc/gcc/gcc.c:1.13
*** gcc/gcc/gcc.c:1.1.1.1	Wed Feb 15 21:22:25 2006
--- gcc/gcc/gcc.c	Mon Dec 13 22:49:28 2010
***************
*** 81,86 ****
--- 81,89 ----
  #include "prefix.h"
  #include "gcc.h"
  #include "flags.h"
+ #ifdef SINGLE_EXECUTABLE
+ #include "diagnostic.h"
+ #endif
  
  #ifdef HAVE_SYS_RESOURCE_H
  #include <sys/resource.h>
***************
*** 677,683 ****
  /* We don't wrap .d files in %W{} since a missing .d file, and
     therefore no dependency entry, confuses make into thinking a .o
     file that happens to exist is up-to-date.  */
! static const char *cpp_unique_options =
  "%{C:%{!E:%eGNU C does not support -C without using -E}}\
   %{nostdinc*} %{C} %{v} %{I*} %{P} %{$} %I\
   %{MD:-MD %{!o:%b.d}%{o*:%.d%*}}\
--- 680,686 ----
  /* We don't wrap .d files in %W{} since a missing .d file, and
     therefore no dependency entry, confuses make into thinking a .o
     file that happens to exist is up-to-date.  */
! static const char *cpp_unique_options = __extension__
  "%{C:%{!E:%eGNU C does not support -C without using -E}}\
   %{nostdinc*} %{C} %{v} %{I*} %{P} %{$} %I\
   %{MD:-MD %{!o:%b.d}%{o*:%.d%*}}\
***************
*** 840,845 ****
--- 843,849 ----
    {"@c",
     /* cc1 has an integrated ISO C preprocessor.  We should invoke the
        external preprocessor if -save-temps or -traditional is given.  */
+       __extension__
       "%{E|M|MM:%(trad_capable_cpp) -lang-c %{ansi:-std=c89} %(cpp_options)}\
        %{!E:%{!M:%{!MM:\
  	  %{save-temps|no-integrated-cpp:%(trad_capable_cpp) -lang-c %{ansi:-std=c89}\
***************
*** 852,860 ****
--- 856,868 ----
  	    %{!traditional:%{!ftraditional:%{!traditional-cpp:\
  		cc1 -lang-c %{ansi:-std=c89} %(cpp_unique_options) %(cc1_options)}}}}}\
          %{!fsyntax-only:%(invoke_as)}}}}", 0},
+ #if TARGET_MVS        
+   {"-", "@c", 0},
+ #else
    {"-",
     "%{!E:%e-E required when input is from standard input}\
      %(trad_capable_cpp) -lang-c %{ansi:-std=c89} %(cpp_options)", 0},
+ #endif
    {".h", "@c-header", 0},
    {"@c-header",
     "%{!E:%ecompilation of header file requested} \
***************
*** 870,875 ****
--- 878,888 ----
     "%(trad_capable_cpp) -lang-asm %(cpp_options)\
        %{!M:%{!MM:%{!E:%{!S:-o %{|!pipe:%g.s} |\n\
         as %(asm_debug) %(asm_options) %{!pipe:%g.s} %A }}}}", 0},
+ #if defined(__MVS__) || defined(__CMS__) || defined(__VSE__)
+ /* For MVS & CMS, we use an empty string to signify that
+    any file is considered to be a C file. */
+   {"", "@c", 0},
+ #endif         
  #include "specs.h"
    /* Mark end of table */
    {0, 0, 0}
***************
*** 2725,2730 ****
--- 2738,2746 ----
  static int
  execute ()
  {
+ #ifdef SINGLE_EXECUTABLE
+   int ret_code = 0;
+ #endif    
    int i;
    int n_commands;		/* # of command.  */
    char *string;
***************
*** 2834,2839 ****
--- 2850,2875 ----
        char *errmsg_fmt, *errmsg_arg;
        const char *string = commands[i].argv[0];
  
+ #ifdef SINGLE_EXECUTABLE
+      {
+          int cnt = 0;
+          
+          while (commands[i].argv[cnt] != NULL)
+          {
+              cnt++;
+          }
+          if (strcmp(string, "cpp0") == 0)
+          {
+              ret_code = cpp(cnt, commands[i].argv);
+              if (ret_code != 0) break;
+          }
+          else if (strcmp(string, "cc1") == 0)
+          {
+              ret_code = toplev_main(cnt, commands[i].argv);
+              if (ret_code != 0) break;
+          }
+       }
+ #else
        /* For some bizarre reason, the second argument of execvp() is
  	 char *const *, not const char *const *.  */
        commands[i].pid = pexecute (string, (char *const *) commands[i].argv,
***************
*** 2847,2856 ****
  
        if (commands[i].pid == -1)
  	pfatal_pexecute (errmsg_fmt, errmsg_arg);
! 
        if (string != commands[i].prog)
  	free ((PTR) string);
      }
  
    execution_count++;
  
--- 2883,2895 ----
  
        if (commands[i].pid == -1)
  	pfatal_pexecute (errmsg_fmt, errmsg_arg);
! #endif
        if (string != commands[i].prog)
  	free ((PTR) string);
      }
+ #ifdef SINGLE_EXECUTABLE
+     return (ret_code);
+ #endif    
  
    execution_count++;
  
***************
*** 3189,3194 ****
--- 3228,3234 ----
    const char *spec_lang = 0;
    int last_language_n_infiles;
    int have_c = 0;
+   int have_e = 0;
    int have_o = 0;
    int lang_n_infiles = 0;
  #ifdef MODIFY_TARGET_NAME
***************
*** 3699,3704 ****
--- 3739,3753 ----
  		}
  	      goto normal_switch;
  
+ 	    case 'E':
+ 	      if (p[1] == 0)
+ 		{
+ 		  have_e = 1;
+ 		  n_switches++;
+ 		  break;
+ 		}
+ 	      goto normal_switch;
+ 
  	    case 'o':
  	      have_o = 1;
  #if defined(HAVE_TARGET_EXECUTABLE_SUFFIX)
***************
*** 3798,3803 ****
--- 3847,3861 ----
    if (have_c && have_o && lang_n_infiles > 1)
      fatal ("cannot specify -o with -c or -S and multiple compilations");
  
+ #if TARGET_MVS || TARGET_CMS
+ #ifdef SINGLE_EXECUTABLE
+   if (have_c && lang_n_infiles > 1)
+     fatal ("cannot compile multiple files");
+   if (!have_c && !have_e && lang_n_infiles > 0)
+     fatal ("must use -S option on MVS (ie produce assembler output)");
+ #endif
+ #endif
+ 
    /* Set up the search paths before we go looking for config files.  */
  
    /* These come before the md prefixes so that we will find gcc's subcommands
***************
*** 4177,4182 ****
--- 4235,4243 ----
     sans all directory names, and basename_length is the number
     of characters starting there excluding the suffix .c or whatever.  */
  
+ #ifdef SINGLE_EXECUTABLE
+ extern
+ #endif
  const char *input_filename;
  static int input_file_number;
  size_t input_filename_length;
***************
*** 5816,5821 ****
--- 5877,5883 ----
  
    gcc_init_libintl ();
  
+ #ifdef USE_SIGNALS
    if (signal (SIGINT, SIG_IGN) != SIG_IGN)
      signal (SIGINT, fatal_error);
  #ifdef SIGHUP
***************
*** 5833,5838 ****
--- 5895,5901 ----
       receive the signal.  A different setting is inheritable */
    signal (SIGCHLD, SIG_DFL);
  #endif
+ #endif
  
    argbuf_length = 10;
    argbuf = (const char **) xmalloc (argbuf_length * sizeof (const char *));
***************
*** 6135,6141 ****
--- 6198,6208 ----
      }
  
    if (n_infiles == added_libraries)
+   {
+     printf (_("%s (GCC) %s\n"), programname, version_string);
+     display_help();
      fatal ("no input files");
+   }
  
    /* Make a place to record the compiler output file names
       that correspond to the input files.  */
***************
*** 6180,6186 ****
--- 6247,6257 ----
  	  else
  	    {
  	      value = do_spec (input_file_compiler->spec);
+ #ifdef SINGLE_EXECUTABLE
+ 	      if (value != 0)
+ #else
  	      if (value < 0)
+ #endif
  		this_file_error = 1;
  	    }
  	}
***************
*** 6263,6271 ****
--- 6334,6349 ----
        printf ("%s\n", GCCBUGURL);
      }
  
+ #ifdef SINGLE_EXECUTABLE
+ #if defined(__MVS__) || defined(__CMS__) || defined(__VSE__)
+   if ((error_count <= 0) && (warningcount > 0)) return (4);
+ #endif
+   return (error_count > 0 ? EXIT_FAILURE : EXIT_SUCCESS);
+ #else
    return (signal_count != 0 ? 2
  	  : error_count > 0 ? (pass_exit_codes ? greatest_status : 1)
  	  : 0);
+ #endif
  }
  
  /* Find the proper compilation spec for the file name NAME,
***************
*** 6391,6396 ****
--- 6469,6477 ----
  
  /* Output an error message and exit */
  
+ #ifdef SINGLE_EXECUTABLE
+ static
+ #endif
  void
  fancy_abort ()
  {
***************
*** 6410,6418 ****
    VA_CLOSE (ap);
    fprintf (stderr, "\n");
    delete_temp_files ();
!   exit (1);
  }
  
  void
  error VPARAMS ((const char *msgid, ...))
  {
--- 6491,6502 ----
    VA_CLOSE (ap);
    fprintf (stderr, "\n");
    delete_temp_files ();
!   exit (FATAL_EXIT_CODE);
  }
  
+ #ifdef SINGLE_EXECUTABLE
+ static
+ #endif
  void
  error VPARAMS ((const char *msgid, ...))
  {
Index: gcc/gcc/gcc.h
diff -c gcc/gcc/gcc.h:1.1.1.1 gcc/gcc/gcc.h:1.2
*** gcc/gcc/gcc.h:1.1.1.1	Wed Feb 15 21:22:25 2006
--- gcc/gcc/gcc.h	Wed Feb 15 21:24:29 2006
***************
*** 26,37 ****
  /* These are exported by gcc.c.  */
  extern int do_spec PARAMS ((const char *));
  extern void record_temp_file PARAMS ((const char *, int, int));
! extern void fancy_abort PARAMS ((void)) ATTRIBUTE_NORETURN;
  extern const char *input_filename;
  extern size_t input_filename_length;
  extern void fatal PARAMS ((const char *, ...))
       ATTRIBUTE_PRINTF_1 ATTRIBUTE_NORETURN;
! extern void error PARAMS ((const char *, ...)) ATTRIBUTE_PRINTF_1;
  extern void pfatal_with_name PARAMS ((const char *)) ATTRIBUTE_NORETURN;
  extern void set_input PARAMS ((const char *));
  
--- 26,47 ----
  /* These are exported by gcc.c.  */
  extern int do_spec PARAMS ((const char *));
  extern void record_temp_file PARAMS ((const char *, int, int));
! #ifdef SINGLE_EXECUTABLE
! static
! #else
! extern
! #endif
! void fancy_abort PARAMS ((void)) ATTRIBUTE_NORETURN;
  extern const char *input_filename;
  extern size_t input_filename_length;
  extern void fatal PARAMS ((const char *, ...))
       ATTRIBUTE_PRINTF_1 ATTRIBUTE_NORETURN;
! #ifdef SINGLE_EXECUTABLE
! static
! #else
! extern
! #endif
! void error PARAMS ((const char *, ...)) ATTRIBUTE_PRINTF_1;
  extern void pfatal_with_name PARAMS ((const char *)) ATTRIBUTE_NORETURN;
  extern void set_input PARAMS ((const char *));
  
Index: gcc/gcc/gcc.parm
diff -c nul gcc/gcc/gcc.parm:1.4
*** nul	Tue Oct 01 16:28:45 2019
--- gcc/gcc/gcc.parm	Tue Jun 02 14:21:18 2009
***************
*** 0 ****
--- 1 ----
+ -o dd:out - -S -ansi
Index: gcc/gcc/gccaall.exec
diff -c nul gcc/gcc/gccaall.exec:1.8
*** nul	Tue Oct 01 16:28:45 2019
--- gcc/gcc/gccaall.exec	Thu Aug 20 19:01:53 2009
***************
*** 0 ****
--- 1,19 ----
+ *******************************************************************
+ *
+ * This EXEC assembles all the assembler files that constitute the
+ * GCC executable.
+ * Usage: GCCAALL <DISK>
+ *
+ *******************************************************************
+ &CONTROL
+ 
+ &DISK = &1
+ &ASMNAME = ASMAHL
+ 
+ GLOBAL MACLIB OSMACRO DMSGPI PDPCLIB
+ 
+ * Rename pdpclib assembler files to same format
+ * name as GCC assembler files
+ COPY * ASM &DISK = S = (REPLACE
+ 
+ EXEC ITERGCC GCCAONE Y Y Y Y &DISK &ASMNAME
Index: gcc/gcc/gccaone.exec
diff -c nul gcc/gcc/gccaone.exec:1.6
*** nul	Tue Oct 01 16:28:45 2019
--- gcc/gcc/gccaone.exec	Thu Aug 20 19:01:53 2009
***************
*** 0 ****
--- 1,27 ----
+ *******************************************************************
+ *
+ * This EXEC assembles a single assembler (S) file
+ * Usage: GCCAAONE <FILE> <DISK> [ASMNAME]
+ *
+ *******************************************************************
+ &CONTROL
+ 
+ &ASMNAME = ASSEMBLE
+ 
+ &FILE = &1
+ &DISK = &2
+ 
+ &IF &INDEX < 3 &GOTO -NOASMNM
+ &ASMNAME = &3
+ -NOASMNM
+ 
+ * Create temporary file in F instead of V format for
+ * the assembler, and use normal name for assembler
+ * files
+ COPY &FILE S &DISK = ASSEMBLE &DISK (RECFM F LRECL 80 REPLACE
+ 
+ * Assemble
+ &ASMNAME &FILE (NOLIST
+ 
+ * Delete temporary file
+ ERASE &FILE ASSEMBLE &DISK
Index: gcc/gcc/gccc.prc
diff -c nul gcc/gcc/gccc.prc:1.5
*** nul	Tue Oct 01 16:28:45 2019
--- gcc/gcc/gccc.prc	Thu Oct 29 23:59:22 2009
***************
*** 0 ****
--- 1,18 ----
+ //GCCC    PROC PDPPREF='PDPCLIB',GCCPREF='GCC',INFILE='',
+ //         COPTS='-S',
+ // COS1='-ansi -pedantic-errors',
+ // COS2='-o dd:out -'
+ //*
+ //COMP     EXEC PGM=GCC,
+ // PARM='&COPTS &COS1 &COS2'
+ //STEPLIB  DD DSN=&GCCPREF..LINKLIB,DISP=SHR
+ //*
+ //* INCLUDE SHOULD HAVE YOUR OWN HEADERS ADDED
+ //*
+ //INCLUDE  DD DSN=&PDPPREF..INCLUDE,DISP=SHR,DCB=BLKSIZE=32720
+ //SYSINCL  DD DSN=&PDPPREF..INCLUDE,DISP=SHR,DCB=BLKSIZE=32720
+ //SYSIN    DD DSN=&INFILE,DISP=SHR
+ //OUT      DD SYSOUT=*
+ //SYSPRINT DD SYSOUT=*
+ //SYSTERM  DD SYSOUT=*
+ //*
Index: gcc/gcc/gcccall.exec
diff -c nul gcc/gcc/gcccall.exec:1.4
*** nul	Tue Oct 01 16:28:45 2019
--- gcc/gcc/gcccall.exec	Sat Sep 27 01:47:45 2008
***************
*** 0 ****
--- 1,12 ----
+ *******************************************************************
+ *
+ * This EXEC compiles all the C files that constitute the
+ * GCC executable.
+ * Usage: GCCCALL <DISK>
+ *
+ *******************************************************************
+ &CONTROL
+ 
+ &DISK = &1
+ 
+  EXEC ITERGCC GCCCONE Y Y N Y &DISK
Index: gcc/gcc/gcccl.prc
diff -c nul gcc/gcc/gcccl.prc:1.19
*** nul	Tue Oct 01 16:28:45 2019
--- gcc/gcc/gcccl.prc	Sat Sep 14 03:50:58 2019
***************
*** 0 ****
--- 1,44 ----
+ //GCCCL   PROC PDPPREF='PDPCLIB',GCCPREF='GCC',INFILE='',
+ //         OUTFILE='',COPTS='',LOPTS='MAP,AMODE=31,RMODE=ANY',
+ // COS1='-S -ansi -pedantic-errors',
+ // COS2='-o dd:out -'
+ //*
+ //COMP     EXEC PGM=GCC,
+ // PARM='&COS1 &COPTS &COS2'
+ //STEPLIB  DD DSN=&GCCPREF..LINKLIB,DISP=SHR
+ //*
+ //* INCLUDE SHOULD HAVE YOUR OWN HEADERS ADDED
+ //*
+ //INCLUDE  DD DSN=&PDPPREF..INCLUDE,DISP=SHR,DCB=BLKSIZE=32720
+ //SYSINCL  DD DSN=&PDPPREF..INCLUDE,DISP=SHR,DCB=BLKSIZE=32720
+ //SYSIN    DD DSN=&INFILE,DISP=SHR
+ //OUT      DD DSN=&&TEMP,DISP=(,PASS),UNIT=SYSALLDA,
+ //            DCB=(LRECL=80,BLKSIZE=6160,RECFM=FB),
+ //            SPACE=(6160,(500,500))
+ //SYSPRINT DD SYSOUT=*
+ //SYSTERM  DD SYSOUT=*
+ //*
+ //ASM      EXEC PGM=ASMA90,
+ //            PARM='DECK,NOLIST',
+ //            COND=(4,LT,COMP)
+ //SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR,DCB=BLKSIZE=32720
+ //         DD DSN=&PDPPREF..MACLIB,DISP=SHR
+ //SYSUT1   DD UNIT=SYSALLDA,SPACE=(CYL,(20,10))
+ //SYSUT2   DD UNIT=SYSALLDA,SPACE=(CYL,(10,10))
+ //SYSUT3   DD UNIT=SYSALLDA,SPACE=(CYL,(10,10))
+ //SYSPRINT DD SYSOUT=*
+ //SYSLIN   DD DUMMY
+ //SYSGO    DD DUMMY
+ //SYSPUNCH DD DSN=&&OBJSET,UNIT=SYSALLDA,SPACE=(80,(4000,4000)),
+ //            DISP=(,PASS)
+ //SYSIN    DD DSN=&&TEMP,DISP=(OLD,DELETE)
+ //*
+ //LKED     EXEC PGM=IEWL,PARM='&LOPTS',
+ //            COND=((4,LT,COMP),(4,LT,ASM))
+ //SYSLIN   DD DSN=&&OBJSET,DISP=(OLD,DELETE)
+ //         DD DDNAME=SYSIN
+ //SYSIN    DD DUMMY
+ //SYSLIB   DD DSN=&PDPPREF..NCALIB,DISP=SHR
+ //SYSLMOD  DD DSN=&OUTFILE,DISP=SHR
+ //SYSUT1   DD UNIT=SYSALLDA,SPACE=(CYL,(2,1))
+ //SYSPRINT DD SYSOUT=*
Index: gcc/gcc/gccclg.prc
diff -c nul gcc/gcc/gccclg.prc:1.15
*** nul	Tue Oct 01 16:28:45 2019
--- gcc/gcc/gccclg.prc	Sat Sep 14 03:50:58 2019
***************
*** 0 ****
--- 1,50 ----
+ //GCCCLG  PROC PDPPREF='PDPCLIB',GCCPREF='GCC',INFILE='',
+ //         COPTS='',LOPTS='MAP,AMODE=31,RMODE=ANY',
+ // COS1='-S -ansi -pedantic-errors',
+ // COS2='-o dd:out -'
+ //*
+ //COMP     EXEC PGM=GCC,COND=(4,LT),
+ // PARM='&COS1 &COPTS &COS2'
+ //STEPLIB  DD DSN=&GCCPREF..LINKLIB,DISP=SHR
+ //*
+ //* INCLUDE SHOULD HAVE YOUR OWN HEADERS ADDED
+ //*
+ //INCLUDE  DD DSN=&PDPPREF..INCLUDE,DISP=SHR,DCB=BLKSIZE=32720
+ //SYSINCL  DD DSN=&PDPPREF..INCLUDE,DISP=SHR,DCB=BLKSIZE=32720
+ //SYSIN    DD DSN=&INFILE,DISP=SHR
+ //OUT      DD DSN=&&TEMP,DISP=(,PASS),UNIT=SYSALLDA,
+ //            DCB=(LRECL=80,BLKSIZE=6160,RECFM=FB),
+ //            SPACE=(6160,(500,500))
+ //SYSPRINT DD SYSOUT=*
+ //SYSTERM  DD SYSOUT=*
+ //*
+ //ASM      EXEC PGM=ASMA90,
+ //            PARM='DECK,NOLIST',
+ //            COND=(4,LT,COMP)
+ //SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR,DCB=BLKSIZE=32720
+ //         DD DSN=&PDPPREF..MACLIB,DISP=SHR
+ //SYSUT1   DD UNIT=SYSALLDA,SPACE=(CYL,(20,10))
+ //SYSUT2   DD UNIT=SYSALLDA,SPACE=(CYL,(10,10))
+ //SYSUT3   DD UNIT=SYSALLDA,SPACE=(CYL,(10,10))
+ //SYSPRINT DD SYSOUT=*
+ //SYSLIN   DD DUMMY
+ //SYSGO    DD DUMMY
+ //SYSPUNCH DD DSN=&&OBJSET,UNIT=SYSALLDA,SPACE=(80,(200,200)),
+ //            DISP=(,PASS)
+ //SYSIN    DD DSN=&&TEMP,DISP=(OLD,DELETE)
+ //*
+ //LKED     EXEC PGM=IEWL,PARM='&LOPTS',
+ //         COND=((4,LT,COMP),(4,LT,ASM))
+ //SYSLIN   DD DSN=&&OBJSET,DISP=(OLD,DELETE)
+ //         DD DDNAME=SYSIN
+ //SYSIN    DD DUMMY
+ //SYSLIB   DD DSN=&PDPPREF..NCALIB,DISP=SHR
+ //SYSUT1   DD UNIT=SYSALLDA,SPACE=(CYL,(2,1))
+ //SYSPRINT DD SYSOUT=*
+ //SYSLMOD  DD   DSN=&&GOSET(GO),UNIT=SYSALLDA,SPACE=(1024,(50,20,1)),
+ //   DISP=(MOD,PASS)
+ //GO       EXEC PGM=*.LKED.SYSLMOD,
+ //         COND=((4,LT,COMP),(4,LT,ASM),(4,LT,LKED))
+ //SYSPRINT DD SYSOUT=*
+ //SYSTERM  DD SYSOUT=*
+ //SYSIN    DD DUMMY
Index: gcc/gcc/gcccms.txt
diff -c nul gcc/gcc/gcccms.txt:1.19
*** nul	Tue Oct 01 16:28:45 2019
--- gcc/gcc/gcccms.txt	Fri Aug 21 00:25:40 2009
***************
*** 0 ****
--- 1,421 ----
+ Release Notes for GCCCMS
+ ------------------------
+ 
+ This document explains what needs to be done to get GCCMVS from:
+ 
+ http://gccmvs.sourceforge.net
+ 
+ to run on VM/CMS. The code is designed to work on VM/370,
+ VM/380, VM/XA and z/VM. You just need to set the
+ appropriate configuration before building.
+ 
+ Note that when used on an non XA capable version of CMS,
+ only the 24-bit version of the module is created. Otherwise,
+ an RMODE 24 AMODE 31 module (ie XA-style) is produced as
+ well. Sites running z/VM, but without the High Level Assembler
+ (or compatible product) need a modified version of IFOX 
+ (see below) which increases the number of externals allowed.
+ 
+ The notes for the MVS version of the compiler (gccmvs.txt)
+ should be read in conjunction with this document. In particlar
+ the section on conversion from ASCII to EBCDIC is relevant to VM.
+ 
+ 
+ Overview of changes for VM/CMS
+ ------------------------------
+ 
+ Note that you will probably need to put:
+ SET LDRTBLS 25
+ or similar in your PROFILE EXEC etc to provide the resources
+ that GCC requires.
+ 
+ While you're doing that, you should probably add "PDPCLIB"
+ to your "GLOBAL TXTLIB" command, preferably at the front.
+ 
+ The changes to the main GCC code in GCCMVS to support CMS
+ are fairly minimal, mainly confined to include file processing.
+ 
+ However, the changes to PDPCLIB (the C runtime library) are
+ more extensive. An old version of the MVS assembler interface
+ was used as a base, and similarities remain between the MVS
+ and CMS versions. The main differences are:
+ 
+ 1) The CMS assembler only supports the OS/MFT (OS/360) macro 
+    formats. The GCCMVS run time uses some OS/MVS macros, which 
+    had to be changed back to the MFT versions.
+ 
+ 2) The conventions for passing command line parameters to CMS 
+    programs is different to that in OS.
+ 
+ 3) The low storage layout is different (PSA macro in OS, NUCON in CMS).
+ 
+ 4) CMS execs are needed to replace the PROCS and JCL files used in GCCMVS.
+ 
+ In addition, two changes to CMS are required to build GCC on VM/370. 
+ These are as follows:
+ 
+ 1) The IFOX assembler needs modifying to allow more than 256 
+ externals per program. (this change is also required for z/VM
+ users still using the IFOX assembler).
+ 
+ 2) The CMS loader needs modifying to allow more than 256 externals 
+ per load module.
+ 
+ Neither of these changes are included with this distribution. Both 
+ may be found in the "files" section of the Yahoo H390-VM "e-group". 
+ Note that if you are using VM/380 or the VM/370 Sixpack, these
+ changes are already included.
+ 
+ 
+ Installing the compiler on VM
+ -----------------------------
+ 
+ To install from scratch you need to cross-compile from another 
+ platform. Scripts are provided for MS Windows and Linux. 
+ 
+ First of all you need to get the source code by:
+ 
+ 1. Downloading the GCC base code (as per GCCMVS).
+ 
+ 2. Downloading the MVS & CMS patch and applying it (as per GCCMVS).
+ 
+ 
+ You then need to set the configuration properly.
+ 
+ There are 4 distinct CMS programming environments possible:
+ 
+ 1. VM/370 where everything is 24-bit. This is the S370
+ environment.
+ 
+ 2. z/VM with native CMS macros where it is possible to write
+ 31-bit executables that reside above the 16 MB line. Since
+ PDPCLIB uses MVS emulation macros which can't handle being
+ run from above the line, this environment isn't yet available.
+ If this changes in the future, this would be the S390
+ environment.
+ 
+ 3. VM/380 where 31-bit executables can be created, but they
+ must reside below the line and they can only obtain a single
+ chunk of ATL memory (current restriction). This is the S380
+ environment.
+ 
+ 4. VM/XA where 31-bit capability exists, but I/O macros
+ necessitate that the executable must reside below the line.
+ z/VM users fall into this category. This is also the S380
+ environment.
+ 
+ 
+ The differences between categories 3 and 4 are as follows:
+ 
+ 1. VM/XA can get control in 31-bit mode, not requiring
+ an AMODE switch.
+ 
+ 2. VM/XA can make multiple ATL memory requests.
+ 
+ 3. VM/XA will remain in 31-bit mode after an SVC 202 call.
+ 
+ 
+ Rather than create another flavor of the code, PDPCLIB
+ was written such that S380 mode:
+ 
+ 1. Detects whether it was called in 31-bit or 24-bit mode
+ and switches to 31-bit mode if not already in that. This
+ code is in cmsstart.asm and could potentially be removed.
+ 
+ 2. Uses an internal heap manager (memmgr) so that only a
+ single request for a chunk of 31-bit memory is made. This
+ is faster than repeatedly calling the operating system
+ anyway, but can be reversed out by not defining USE_MEMMGR
+ in stdcompm.bat and stdcomp.parm.
+ 
+ 3. Switches to 24-bit mode prior to calling SVC 202. This
+ can be reversed out in cmssupa.asm if required for some
+ reason. The technical reason why this is required is
+ because the version of CMS used in VM/380 runs in BC mode
+ so cannot preserve the AMODE flag over an SVC call itself -
+ instead Hercules/380 has been coded to detect a PSW being
+ loaded and if it matches the last known transition, the
+ AMODE is set based on that, which doesn't work with SVC 202
+ because the SVC doesn't return to the same point.
+ 
+ 
+ You need to decide what mode:
+ 
+ 1. You want the GCC executable to be.
+ 
+ 2. You want executables produced by GCC to be.
+ 
+ 
+ The execs are set up by default to produce a S/380 GCC
+ executable using memmgr (which will thus work on both
+ VM/380 and z/VM), and the executables subsequently
+ produced are S/370 (which will thus work anywhere).
+ 
+ If you are using z/VM you have the option of switching
+ off memmgr for the GCC module by getting rid of USE_MEMMGR 
+ in stdcompm.bat and stdcomp.parm. You may wish to do this
+ to create a more flexible module that uses up less storage
+ for small compiles, and for really huge compiles, will
+ not exhaust the fixed limit that memmgr has. Neither
+ thing is likely to be a genuine concern, so the default
+ setup should be fine.
+ 
+ On every version of VM, you have the option of using a
+ S/370 version of GCC, and it will still work for most
+ practical uses. It won't compile very large programs
+ with full optimization though (such as some of the GCC
+ source code itself) since it exceeds the 16 MB limit.
+ However, if you wish to do this, then overwrite pdptop.mac
+ with pdp370.mac and switch off USE_MEMMGR in stdcompm.bat
+ and stdcomp.parm and set ALL370 to 1 in compile.exec.
+ Also you may need to change all occurrences of the
+ maclib DMSGPI to CMSLIB.
+ 
+ On VM/380 and z/VM you have the option of getting GCC
+ to produce S/380 modules. This is done by setting BLD to
+ 380 in compile.exec and defining USE_MEMMGR in stdpdp.parm.
+ On z/VM you can skip this last step, ie don't change
+ stdpdp.parm, and you can produce VM/XA modules without
+ the use of a heap manager (this will produce executables
+ that typically use less memory but have the ability to
+ use larger amounts of memory if required).
+ 
+ 
+ Once you have made the changes you require for your
+ environment, you are ready to build everything. The
+ "allcms.bat" file may be useful to do that in some
+ circumstances. But the documentation below is for
+ the individual steps.
+ 
+ 
+ As mentioned, you need an assembler that can handle more
+ than 256 externals. By default it is assumed that you are
+ using ASMAHL (High Level Assembler) which fits that purpose.
+ If instead you are using ASSEMBLE (Assembler/XF aka IFOX00)
+ you need to modify gccaall.exec to specify that as your
+ assembler name. Also you should modify gcce.exec and
+ gccr.exec
+ 
+ 
+ Now you can build the cross-compiler using "compile.bat"
+ (or "compile" under Unix). This will produce a version of GCC 
+ that can produce 370 assembler on Windows. You need to pass a 
+ parameter to compile.bat of -DTARGET_CMS, ie:
+ 
+ compile -DTARGET_CMS
+ 
+ Now use compmvs.bat (compmvs in Unix) to create a set of 
+ assembler source file containing the CMS version of GCC, ie:
+ 
+ compmvs -DTARGET_CMS
+ 
+ Don't worry about the fact that the executable is called
+ gccmvs.exe and the batch file is also called mvs.  The
+ name is shared, but they are different.
+ 
+ 
+ You now need to bundle up all the source (assembler, C,
+ headers, execs, parms) and transfer it to VM. There are
+ a lot of different ways you can accomplish this and it
+ is beyond the scope of the GCCCMS install to specify how
+ to do this.
+ 
+ However, one example method is explained here.
+ 
+ zipmvs.bat (zipmvs in Unix) will zip up all the important
+ source code. These zip files can then be unzipped into a
+ single directory and then rezipped to produce a convenient
+ single zip file. Should be zipped with no compression
+ though (zip -0).
+ 
+ If you have cygwin (or real Unix) you can run the "cmsutil"
+ batch file to generate a text file which can then be
+ transferred via the card reader (you will need to add a
+ "USERID GCCCMS" or similar (without quotes) to the first
+ line of the file if you are using VM/370 or VM/380. This
+ file can then be assigned to the card reader and then a
+ "readcard * *" can be done, followed by "cmsutil" and you
+ will end up with an mvsunzip module. VM/380 comes with
+ this already done and you can see the technique already
+ done too.
+ 
+ So now that you have the mvsunzip module and the zip
+ file, you can marry them together.
+ 
+ On z/VM you will probably use ind$file to transfer the
+ zip file in binary mode. On VM/370 and VM/380 under
+ Hercules you will probably use a TDF tape file and
+ point to the zip file. Then run:
+ 
+ mvsunzip dd:hrcin a
+ 
+ assuming your tape is on filedef HRCIN and you are
+ extracting to the A disk.
+ 
+ Next let's discuss disks. GCCCMS is designed to be built
+ in a "standard build environment" (used by other programs)
+ which consists of 3 disks.
+ 
+ 1. All the source code and building.
+ 2. The final executables designed to eventually be installed on the Y drive.
+ 3. A work disk.
+ 
+ These are typically A, B and C.
+ 
+ The EXEC "COMPILE" (and its front-end, "ALLCMS"), takes 
+ those 3 letters as parameters. If for some reason you only 
+ have one disk, you can set them all to A, in which case the
+ executables won't be separately copied to B, and there 
+ won't be an assembler verification (which is what the work 
+ disk is used for in the case of GCCCMS's build exec).
+ 
+ To build GCC, the first disk (let's assume A - and because
+ other commands assume A, this is likely to be the only
+ option that works fully) needs to be at least 46 MB in size. 
+ VM/370 allows a disk up to about 52 MB, so it's probably 
+ best to just define the max.
+ 
+ The B disk needs to be about 7 MB in size, mainly for the
+ GCC and GCC370 modules.
+ 
+ The C disk needs to be about 18 MB in size - it contains a
+ copy of the generated assembly code.
+ 
+ 
+ On VM/380 (and some VM/370) you will find disks suitable
+ for compiling GCC that are set up under a GCCCMS userid.
+ The 291, 391 and 491 disks are set to the maximum (52 MB)
+ allowed.
+ 
+ 
+ Also note that for full integrity, you can use bison and
+ sed to generate the generated file. The batch file "fullcms"
+ is used to do this, and is what is used prior to a release.
+ 
+ 
+ 
+ Using the compiler
+ ------------------
+ 
+ The run time has a number of differences to the GCCMVS compiler.
+ 
+ 1) As VM parameter passing is (at least on VM/370) all upper 
+ case, 8-byte tokens a facility exists to read the parameters 
+ from OS DD name SYSPARM. Simply define this file and the
+ command line will be picked up from the first line of that
+ file. Another facility available is to provide a command line
+ at the same time as defining a dummy SYSPARM, and it will go
+ into special processing. This means (unless the first parameter
+ is "_+") lowercasing everything, eliminating the space gaps
+ (spaces require a _ before them to be preserved) except for
+ characters prefixed with a "_" which will be uppercased (or
+ if "_+" was specified at the beginning - lowercased).
+ 
+ 2) If you omit the "DD:" from the front of a filename passed 
+ to the I/O open routines the run-time code will assume it has 
+ been passed a CMS file name. If the name contains a "." it 
+ will be assumed it seperates the filename and filetype. As the
+ code still uses OS emulation SVC202 is used to issue a "filedef" 
+ command to define the file to the code.
+ 
+ To compile, assemble and link a program "TEST C A" use the 
+ following commands:
+ 
+ GCCE TEST C A
+ LOAD TEST (NOAUTO
+ GENMOD TEST
+ TEST
+ 
+ (note that this relies on the GLOBAL TXTLIB having PDPCLIB
+ in it so that it can resolve the externals)
+ 
+ 
+ 
+ Version
+ -------
+ 
+ To find out version, you can go:
+ 
+ GCC --version
+ 
+ 
+ 
+ Support
+ -------
+ 
+ Try asking a generic GCC question here:
+ 
+ http://tech.groups.yahoo.com/group/hercules-os380/
+ 
+ If your question is more VM-related than GCC-related,
+ a broader range of VM expertise is available here:
+ 
+ http://tech.groups.yahoo.com/group/H390-VM/
+ 
+ The main people who contributed to and are familiar with 
+ GCCCMS are Dave Wade, Paul Edwards and Robert O'Hara.
+ 
+ 
+ 
+ z/VM example
+ ------------
+ 
+ Example of using ind$file via c3270.
+ 
+ "cmsutil" is run to create a file like this on the PC
+ (note that there is no userid):
+ 
+ :READ FILE1 EXEC A
+ fdfdfd
+ :READ FILE2 ASSEMBLE A
+ defkkd
+ 
+ convert to binary format, e.g:
+ 
+ loc2ebc cmsutil.txt cmsutil.card 80
+ 
+ log on to z/VM with c3270
+ 
+ Get into c3270 command mode with ctrl-]
+ 
+ transfer file with:
+ 
+ c3270> transfer localfile=cmsutil.card "hostfile=cmsutil card" 
+ direction=send mode=binary exist=replace
+ 
+ (note that text mode didn't seem to work for me)
+ 
+ enter to get back to z/vm
+ 
+ SPOOL PUN *
+ PUNCH CMSUTIL CARD (NOH
+ 
+ readcard * * (nop replace
+ 
+ 
+ Compile the utilities by going:
+ 
+ cmsutil
+ 
+ Then back on the PC use "allcms" to create all.zip,
+ encode it to be printable characters, then convert it
+ to EBCDIC. This is done to avoid problems with the CR
+ being stripped by the file transfer (it seems that c3270
+ reads files in text mode regardless).
+ 
+ Then transfer the encoded binary up
+ 
+ c3270> transfer localfile=xfer.card "hostfile=xfer card b"
+ direction=send mode=binary exist=replace
+ 
+ edit runspool exec to fix drive numbers
+ 
+ access 191 d
+ 
+ Then:
+ 
+ runspool
+ 
+ (although it's better to rename this script so that
+ you don't lose your drive letter changes and end up
+ with a disaster).
Index: gcc/gcc/gcccone.exec
diff -c nul gcc/gcc/gcccone.exec:1.10
*** nul	Tue Oct 01 16:28:45 2019
--- gcc/gcc/gcccone.exec	Sat May 26 17:20:39 2018
***************
*** 0 ****
--- 1,30 ----
+ *******************************************************************
+ *
+ * This EXEC compiles a single C file
+ * Usage: GCCCONE <FILE> <DISK>
+ *
+ *******************************************************************
+ &CONTROL
+ 
+ &FILE = &1
+ &DISK = &2
+ 
+ FILEDEF SYSPRINT TERM (LRECL 80
+ FILEDEF SYSPARM DISK STDCOMP PARM &DISK
+ FILEDEF OUT DISK &FILE WORK &DISK (LRECL 2000 RECFM V
+ FILEDEF SYSIN DISK &FILE C &DISK
+ GCC
+ 
+ *
+ * NOW RENAME OUTPUT FILE IF GCC WORKED
+ *
+ &IF &RETCODE NE 0 &EXIT &RETCODE
+ STATE &FILE S &DISK
+ &IF &RETCODE NE 0 &GOTO -COPYFILE
+ ERASE &FILE S &DISK
+ -COPYFILE
+ RENAME &FILE WORK &DISK = S =
+ FILEDEF SYSPRINT CLEAR
+ FILEDEF SYSPARM CLEAR
+ FILEDEF OUT CLEAR
+ FILEDEF SYSIN CLEAR
Index: gcc/gcc/gccdos.txt
diff -c nul gcc/gcc/gccdos.txt:1.9
*** nul	Tue Oct 01 16:28:45 2019
--- gcc/gcc/gccdos.txt	Wed Sep 18 07:32:34 2019
***************
*** 0 ****
--- 1,23 ----
+ To build GCC for 32-bit MSDOS (aka PDOS/386),
+ you need to change gencomp.bat and stdcompp.bat
+ (just at the top) then run gencomp to generate
+ new insn* files, then you need to run compilei.bat
+ to generate the cross-compiler. Ignore the
+ error about compiling winnt.c. Then you can
+ optionally run comp386.bat if you want to build
+ a native PDOS/386 compiler (a.out).
+ 
+ To build GCC for 32-bit Windows, you need to
+ change config.h like this:
+ 
+ #include "uwin.h" /* for Windows PE */
+ /* #include "pdos386.h" */ /* for a.out */
+ 
+ And then do the above steps, except:
+ 1. Rename the built gcc386.exe to gccwin.exe
+ after running compilei
+ 2. Run compwin instead of comp386
+ 3. Rename the built gcc-pdos.exe to gccwin.exe
+ 4. Run compwin again and the new gcc-pdos.exe
+ should be nearly identical to gccwin.exe, and
+ you can rename gcc-pdos.exe to gccwin.exe
Index: gcc/gcc/gcce.exec
diff -c nul gcc/gcc/gcce.exec:1.3
*** nul	Tue Oct 01 16:28:45 2019
--- gcc/gcc/gcce.exec	Thu Aug 20 19:01:53 2009
***************
*** 0 ****
--- 1,143 ----
+ ***************************************************************
+ *
+ * Wrapper EXEC to run GCC and then assemble the output
+ *
+ * Format is :-
+ *
+ *  GCCE <fn> <ft> <fm> <( <NOASM> <PARM fn> >
+ *
+ * Where fn, ft and fm specify a file to be compiled
+ *
+ * NOASM overrides the default behaviour and does not call the assembler
+ *
+ * PARM fb  specifies an PARM file containg arguments to be passed to GCC
+ *          By default GCC PARM is used.
+ *
+ *
+ ***************************************************************
+ &CONTROL OFF NOMSG
+ &FT = C
+ &FM = A
+ &ASM = ASM
+ &PARM = GCC
+ &ASMNAME = ASMAHL
+ 
+ GLOBAL MACLIB OSMACRO DMSGPI PDPCLIB
+ 
+ *
+ * CHECK WE HAVE A FILE NAME
+ *
+ &IF &INDEX EQ 0 &GOTO -NOARGS
+ &IF &1 EQ &LITERAL ( &GOTO -NOARGS
+ &FN = &1
+ &ARGS &2 &3 &4 &5 &6 &7 &8
+ *
+ * NOW GET A FILE TYPE
+ *
+ &IF &INDEX EQ 0 &GOTO -COMPILE
+ &IF &1 EQ &LITERAL ( &GOTO -PARMS
+ &FT = &1
+ &ARGS &2 &3 &4 &5 &6 &7 &8 &9
+ *
+ * NOW CHECK FOR A FILE MODE
+ *
+ &IF &INDEX EQ 0 &GOTO -COMPILE
+ &IF &1 EQ &LITERAL ( &GOTO -PARMS
+ &FM = &1
+ &ARGS &2 &3 &4 &5 &6 &7 &8 &9
+ *
+ * NOW LOOP AND EXTRACT THE PARMS
+ *
+ -PARMS
+ &IF &INDEX EQ 0 &GOTO -COMPILE
+ &IF &1 NE &LITERAL ( &GOTO -NOBRACK
+ &ARGS &2 &3 &4 &5 &6 &7
+ &LOOP -NEXTPRM &INDEX
+ &IF &INDEX EQ 0 &GOTO -COMPILE
+ *
+ * FIRST CHECK FOR <PARM FN>
+ *
+ &IF &1 NE PARM &GOTO -NOFILE
+ &IF &INDEX EQ 1 &GOTO -BADPARM
+ &PARM = &2
+ &ARGS &3 &4 &5 &6 &7 &8
+ &GOTO -NEXTPRM
+ -NOFILE
+ *
+ * NOW CHECK FOR NOASM
+ *
+ &IF &1 NE NOASM &GOTO -BADPARM
+ &ASM = NOASM
+ &ARGS &1 &2 &3 &4 &5 &6 &7 &8
+ -NEXTPRM
+ *
+ * NOW SET UP FOR GCC
+ *
+ -COMPILE
+ STATE &FN &FT &FM
+ &IF &RETCODE NE 0 &GOTO -NOSRC
+ *
+ * SOURCE FILE EXISTS - ISSUES FILEDEFS
+ *
+ FILEDEF SYSPRINT TERM (LRECL 80
+ FILEDEF SYSPARM DISK &PARM PARM *
+ FILEDEF OUT DISK &FN WORK &FM (LRECL 80 RECFM F
+ FILEDEF SYSIN DISK &FN C &FM
+ &NAME = &CONCAT  &FN .C
+ GCC
+ *
+ * NOW RENAME OUTPUT FILE IF GCC WORKED
+ *
+ &MYRC = &RETCODE
+ FILEDEF SYSPRINT CLEAR
+ FILEDEF SYSPARM CLEAR
+ FILEDEF OUT CLEAR
+ FILEDEF SYSIN CLEAR
+ &IF &MYRC GT 4 &EXIT &MYRC
+ STATE &FN ASSEMBLE &FM
+ &IF &RETCODE NE 0 &GOTO -COPYFILE
+ ERASE &FN ASSEMBLE &FM
+ -COPYFILE
+ RENAME &FN WORK &FM = ASSEMBLE =
+ &IF &ASM EQ NOASM &EXIT
+ &CONTROL
+ &ASMNAME &FN
+ &CONTROL OFF NOMSG
+ ERASE &FN ASSEMBLE &FM
+ ERASE &FN LISTING &FM
+ &EXIT
+ *
+ * ERROR MESSAGES GO HERE
+ *
+ -NOARGS
+ *
+ * NO PARAMS - TYPE SOME BASIC INFO
+ *
+ &BEGTYPE
+ ********************************************************
+ *
+ * EXEC to run GCC and then assemble the output
+ *
+ * Format is :-
+ *
+ *  GCCE <fn> <ft> <fm> <( <NOASM> <PARM fn> >
+ *
+ * Where fn, ft and fm specify a file to be compiler
+ *
+ * NOASM overrides the default behaviour and does not call the assembler
+ *
+ * PARM fb  specifies an alternative PARM file containg arguments to pass to GCC
+ *          by default GCC PARM is used.
+ *
+ ***************************************************************
+ &ENDTYPE
+ &EXIT 4
+ -NOBRACK
+ &TYPE ARGS MUST START WITH A &LITERAL (
+ &EXIT 4
+ -BADPARM
+ &TYPE PARM OPTION MUST HAVE A FILENAME
+ &EXIT 4
+ -NOSRC
+ &TYPE SOURCE FILE  ' &FN &FT &FM ' NOT FOUND
+ &EXIT 4
Index: gcc/gcc/gcclink.exec
diff -c nul gcc/gcc/gcclink.exec:1.6
*** nul	Tue Oct 01 16:28:45 2019
--- gcc/gcc/gcclink.exec	Thu May 21 21:56:59 2009
***************
*** 0 ****
--- 1,201 ----
+ ****************************************************************
+ *
+ * This exec links all object together to create GCC MODULE.
+ * It also produces a GCC MAP for debugging purposes
+ * Usage: GCCLINK <DISK> <MODULE_NAME>
+ *
+ *******************************************************************
+ 
+ &DISK = A
+ &MODULE = GCC
+ 
+ 
+ &IF &INDEX EQ 0 &GOTO -FINARGS
+ &DISK = &1
+ &ARGS &2 &3 &4 &5 &6 &7 &8 &9
+ 
+ &IF &INDEX EQ 0 &GOTO -FINARGS
+ &MODULE = &1
+ 
+ -FINARGS
+ 
+ 
+ &CONTROL CMS MSG
+ &BEGTYPE
+ 
+ LOADING GCC MAIN MODULE...
+ 
+ &ENDTYPE
+ &STACK HT
+ LOAD    CMSSTART (NOLIBE NOAUTO
+ INCLUDE START (NOLIBE NOAUTO
+ INCLUDE CMSSUPA (NOLIBE NOAUTO
+ INCLUDE STDIO (NOLIBE NOAUTO
+ INCLUDE STDLIB (NOLIBE NOAUTO
+ INCLUDE CTYPE (NOLIBE NOAUTO
+ INCLUDE STRING (NOLIBE NOAUTO
+ INCLUDE TIME (NOLIBE NOAUTO
+ INCLUDE ERRNO (NOLIBE NOAUTO
+ INCLUDE ASSERT (NOLIBE NOAUTO
+ INCLUDE LOCALE (NOLIBE NOAUTO
+ INCLUDE MATH (NOLIBE NOAUTO
+ INCLUDE SETJMP (NOLIBE NOAUTO
+ INCLUDE SIGNAL (NOLIBE NOAUTO
+ INCLUDE ALIAS (NOLIBE NOAUTO
+ INCLUDE ATTRIBS (NOLIBE NOAUTO
+ INCLUDE BB-REORD (NOLIBE NOAUTO
+ INCLUDE BITMAP (NOLIBE NOAUTO
+ INCLUDE BUILTINS (NOLIBE NOAUTO
+ INCLUDE C-AUX-IN (NOLIBE NOAUTO
+ INCLUDE C-COMMON (NOLIBE NOAUTO
+ INCLUDE C-CONVER (NOLIBE NOAUTO
+ INCLUDE C-DECL (NOLIBE NOAUTO
+ INCLUDE C-ERRORS (NOLIBE NOAUTO
+ INCLUDE C-FORMAT (NOLIBE NOAUTO
+ INCLUDE C-LANG (NOLIBE NOAUTO
+ INCLUDE C-LEX (NOLIBE NOAUTO
+ INCLUDE C-OBJC-C (NOLIBE NOAUTO
+ INCLUDE C-PARSE (NOLIBE NOAUTO
+ INCLUDE C-PRAGMA (NOLIBE NOAUTO
+ INCLUDE C-SEMANT (NOLIBE NOAUTO
+ INCLUDE C-TYPECK (NOLIBE NOAUTO
+ INCLUDE CALLER-S (NOLIBE NOAUTO
+ INCLUDE CALLS (NOLIBE NOAUTO
+ INCLUDE CFG (NOLIBE NOAUTO
+ INCLUDE CFGANAL (NOLIBE NOAUTO
+ INCLUDE CFGBUILD (NOLIBE NOAUTO
+ INCLUDE CFGCLEAN (NOLIBE NOAUTO
+ INCLUDE CFGLAYOU (NOLIBE NOAUTO
+ INCLUDE CFGLOOP (NOLIBE NOAUTO
+ INCLUDE CFGRTL (NOLIBE NOAUTO
+ INCLUDE COMBINE (NOLIBE NOAUTO
+ INCLUDE CONFLICT (NOLIBE NOAUTO
+ INCLUDE CONVERT (NOLIBE NOAUTO
+ INCLUDE CPPDEFAU (NOLIBE NOAUTO
+ INCLUDE CPPERROR (NOLIBE NOAUTO
+ INCLUDE CPPEXP (NOLIBE NOAUTO
+ INCLUDE CPPFILES (NOLIBE NOAUTO
+ INCLUDE CPPHASH (NOLIBE NOAUTO
+ INCLUDE CPPINIT (NOLIBE NOAUTO
+ INCLUDE CPPLEX (NOLIBE NOAUTO
+ INCLUDE CPPLIB (NOLIBE NOAUTO
+ INCLUDE CPPMACRO (NOLIBE NOAUTO
+ INCLUDE CPPMAIN (NOLIBE NOAUTO
+ INCLUDE CPPSPEC (NOLIBE NOAUTO
+ INCLUDE CSE (NOLIBE NOAUTO
+ INCLUDE CSELIB (NOLIBE NOAUTO
+ INCLUDE DEBUG (NOLIBE NOAUTO
+ INCLUDE DEPENDEN (NOLIBE NOAUTO
+ INCLUDE DF (NOLIBE NOAUTO
+ INCLUDE DIAGNOST (NOLIBE NOAUTO
+ INCLUDE DOMINANC (NOLIBE NOAUTO
+ INCLUDE DWARF2AS (NOLIBE NOAUTO
+ INCLUDE DWARF2OU (NOLIBE NOAUTO
+ INCLUDE EMIT-RTL (NOLIBE NOAUTO
+ INCLUDE EXCEPT (NOLIBE NOAUTO
+ INCLUDE EXPLOW (NOLIBE NOAUTO
+ INCLUDE EXPMED (NOLIBE NOAUTO
+ INCLUDE EXPR (NOLIBE NOAUTO
+ INCLUDE FINAL (NOLIBE NOAUTO
+ INCLUDE FLOW (NOLIBE NOAUTO
+ INCLUDE FOLD-CON (NOLIBE NOAUTO
+ INCLUDE FUNCTION (NOLIBE NOAUTO
+ INCLUDE GCC (NOLIBE NOAUTO
+ INCLUDE GCCSPEC (NOLIBE NOAUTO
+ INCLUDE GCSE (NOLIBE NOAUTO
+ INCLUDE GENRTL (NOLIBE NOAUTO
+ INCLUDE GGC-COMM (NOLIBE NOAUTO
+ INCLUDE GGC-PAGE (NOLIBE NOAUTO
+ INCLUDE GLOBAL (NOLIBE NOAUTO
+ INCLUDE GRAPH (NOLIBE NOAUTO
+ INCLUDE HASH (NOLIBE NOAUTO
+ INCLUDE HASHTABL (NOLIBE NOAUTO
+ INCLUDE HOOKS (NOLIBE NOAUTO
+ INCLUDE IFCVT (NOLIBE NOAUTO
+ INCLUDE INSN-ATT (NOLIBE NOAUTO
+ INCLUDE INSN-EMI (NOLIBE NOAUTO
+ INCLUDE INSN-EXT (NOLIBE NOAUTO
+ INCLUDE INSN-OPI (NOLIBE NOAUTO
+ INCLUDE INSN-OUT (NOLIBE NOAUTO
+ INCLUDE INSN-REC (NOLIBE NOAUTO
+ INCLUDE INTEGRAT (NOLIBE NOAUTO
+ INCLUDE JUMP (NOLIBE NOAUTO
+ INCLUDE LANGHOOK (NOLIBE NOAUTO
+ INCLUDE LCM (NOLIBE NOAUTO
+ INCLUDE LINE-MAP (NOLIBE NOAUTO
+ INCLUDE LISTS (NOLIBE NOAUTO
+ INCLUDE LOCAL-AL (NOLIBE NOAUTO
+ INCLUDE LOOP (NOLIBE NOAUTO
+ INCLUDE MKDEPS (NOLIBE NOAUTO
+ INCLUDE OPTABS (NOLIBE NOAUTO
+ INCLUDE PARAMS (NOLIBE NOAUTO
+ INCLUDE PREDICT (NOLIBE NOAUTO
+ INCLUDE PREFIX (NOLIBE NOAUTO
+ INCLUDE PRINT-RT (NOLIBE NOAUTO
+ INCLUDE PRINT-TR (NOLIBE NOAUTO
+ INCLUDE PROFILE (NOLIBE NOAUTO
+ INCLUDE REAL (NOLIBE NOAUTO
+ INCLUDE RECOG (NOLIBE NOAUTO
+ INCLUDE REGCLASS (NOLIBE NOAUTO
+ INCLUDE REGMOVE (NOLIBE NOAUTO
+ INCLUDE REGRENAM (NOLIBE NOAUTO
+ INCLUDE RELOAD (NOLIBE NOAUTO
+ INCLUDE RELOAD1 (NOLIBE NOAUTO
+ INCLUDE RESOURCE (NOLIBE NOAUTO
+ INCLUDE RTL-ERRO (NOLIBE NOAUTO
+ INCLUDE RTL (NOLIBE NOAUTO
+ INCLUDE RTLANAL (NOLIBE NOAUTO
+ INCLUDE SBITMAP (NOLIBE NOAUTO
+ INCLUDE SIBCALL (NOLIBE NOAUTO
+ INCLUDE SIMPLIFY (NOLIBE NOAUTO
+ INCLUDE SSA-CCP (NOLIBE NOAUTO
+ INCLUDE SSA-DCE (NOLIBE NOAUTO
+ INCLUDE SSA (NOLIBE NOAUTO
+ INCLUDE STMT (NOLIBE NOAUTO
+ INCLUDE STOR-LAY (NOLIBE NOAUTO
+ INCLUDE STRINGPO (NOLIBE NOAUTO
+ INCLUDE TIMEVAR (NOLIBE NOAUTO
+ INCLUDE TOPLEV (NOLIBE NOAUTO
+ INCLUDE TREE-DUM (NOLIBE NOAUTO
+ INCLUDE TREE-INL (NOLIBE NOAUTO
+ INCLUDE TREE (NOLIBE NOAUTO
+ INCLUDE UNROLL (NOLIBE NOAUTO
+ INCLUDE VARASM (NOLIBE NOAUTO
+ INCLUDE VARRAY (NOLIBE NOAUTO
+ INCLUDE VERSION (NOLIBE NOAUTO
+ INCLUDE XMALLOC (NOLIBE NOAUTO
+ INCLUDE XSTRERRO (NOLIBE NOAUTO
+ INCLUDE XSTRDUP (NOLIBE NOAUTO
+ INCLUDE XEXIT (NOLIBE NOAUTO
+ INCLUDE CONCAT (NOLIBE NOAUTO
+ INCLUDE HEX (NOLIBE NOAUTO
+ INCLUDE ALLOCA (NOLIBE NOAUTO
+ INCLUDE LBASENAM (NOLIBE NOAUTO
+ INCLUDE OBSTACK (NOLIBE NOAUTO
+ INCLUDE STRSIGNA (NOLIBE NOAUTO
+ INCLUDE SAFE-CTY (NOLIBE NOAUTO
+ INCLUDE SPLAY-TR (NOLIBE NOAUTO
+ INCLUDE FIBHEAP (NOLIBE NOAUTO
+ INCLUDE HASHTAB (NOLIBE NOAUTO
+ INCLUDE ASPRINTF (NOLIBE NOAUTO
+ INCLUDE VASPRINT (NOLIBE NOAUTO
+ INCLUDE GETPAGES (NOLIBE NOAUTO
+ INCLUDE PARTITIO (NOLIBE NOAUTO
+ INCLUDE I370-C (NOLIBE NOAUTO
+ INCLUDE I370 (NOLIBE NOAUTO
+ INCLUDE __MEMMGR (NOLIBE NOAUTO
+ &STACK RT
+ INCLUDE UNIXIO (NOLIBE NOAUTO
+ &IF &RETCODE NE 0 &GOTO -MISSING
+ GENMOD &MODULE
+ COPY LOAD MAP &DISK GCC MAP &DISK (REPLACE
+ ERASE LOAD MAP &DISK
+ &EXIT
+ -MISSING
+ &BEGTYPE
+ *
+ * GCC MODULE note generated
+ * Problem with load - check all TEXT decks are present
+ *
+ &ENDTYPE
+ &EXIT 4
Index: gcc/gcc/gccmus.txt
diff -c nul gcc/gcc/gccmus.txt:1.1
*** nul	Tue Oct 01 16:28:45 2019
--- gcc/gcc/gccmus.txt	Wed Apr 28 00:40:02 2010
***************
*** 0 ****
--- 1,123 ----
+ Release Notes for GCCMUS
+ ------------------------
+ 
+ This document explains what needs to be done to get GCCMVS from:
+ 
+ http://gccmvs.sourceforge.net
+ 
+ to run on MUSIC/SP demo.
+ 
+ The notes for the MVS version of the compiler (gccmvs.txt)
+ should be read in conjunction with this document. In particlar
+ the section on conversion from ASCII to EBCDIC is relevant to
+ MUSIC/SP.
+ 
+ 
+ 
+ Miscellaneous notes about MUSIC/SP
+ ----------------------------------
+ 
+ The original MUSIC/SP port was done by Dave Edwards, but
+ he unfortunately died, so Paul Edwards (no relation)
+ picked it up some time later, with assistance mainly
+ from Fausto Saporito.
+ 
+ Dave's documentation for the newly-available ATL memory
+ was scant, and currently the ATL address is simply
+ hardcoded as 0x2000000 (32 MB), since it appears that
+ it is not available via a GETMAIN etc call.
+ 
+ Running under Hercules is much faster than running under
+ SIM390. Also Hercules provides tape facilities which are
+ not available on SIM390, and the build procedure is based
+ around this. Testing is normally done under Hercules/380
+ which has tape enhancements.
+ 
+ The build procedure is basically reliant on the existence
+ of a MUSIC/390, which is an enhancement to MUSIC/SP Demo,
+ containing e.g. additional macro options.
+ 
+ MUSIC/390 as its name implies runs on a standard S/390
+ machine. However, the code model is S/380 (RMODE 24,
+ AMODE 31).
+ 
+ MUSIC/SP by default pages intensely. This in turn appears
+ to invoke a presumed bug in Hercules. Changing MAXRRS
+ from 2000 to 4000 ends the paging, allowing GCC to rebuild
+ itself on MUSIC/390.
+ 
+ The port is effectively complete, just waiting for someone
+ to finalize scripts etc to do normal compilation, and
+ putting things into a library to link with, and testing
+ the mfarc (and formally producing MUSIC/390). The 
+ technology itself is proven.
+ 
+ The GCCMUS compiler simply reuses the MVS version, so there
+ is currently no special __MUSIC__ define to use.  You can
+ define one yourself as a parameter, or define a MUSIC, as
+ you wish. The long-term intention is to have a __MUSIC__.
+ 
+ 
+ 
+ Building
+ --------
+ 
+ To install from scratch you need to cross-compile from another 
+ platform. Scripts are provided for MS Windows.
+ 
+ First of all you need to get the source code by:
+ 
+ 1. Downloading the GCC base code (as per GCCMVS).
+ 
+ 2. Downloading the GCCMVS patch and applying it (as per GCCMVS).
+ 
+ 
+ You then need to set the configuration properly.
+ 
+ There are 2 distinct MUSIC/SP programming environments possible:
+ 
+ 1. Normal 24-bit. This is the S370 environment.
+ 
+ 2. RMODE 24, AMODE 31 with a chunk of ATL memory available for
+ you to manage yourself. This is the S380 environment using
+ MEMMGR.
+ 
+ 
+ You can build the cross-compiler and then produce the
+ assembler code and then have that transferred via tape
+ to MUSIC/390 by running the "allmus.bat" file (after
+ inspecting it for any required modifications).
+ 
+ Don't worry about the fact that the executable is called
+ gccmvs.exe and the batch file is also called mvs.  The
+ name is shared, but they are different.
+ 
+ 
+ 
+ Version
+ -------
+ 
+ To find out version, you can go:
+ 
+ /parm --version
+ /load xmon
+ gcc n(gcc.lmod) lcparm
+ 
+ 
+ 
+ Support
+ -------
+ 
+ Try asking a generic GCC question here:
+ 
+ http://tech.groups.yahoo.com/group/hercules-os380/
+ 
+ If your question is more MUSIC-related than GCC-related,
+ a broader range of MUSIC/SP expertise is available here:
+ 
+ http://tech.groups.yahoo.com/group/H390-music/
+ 
+ and sometimes
+ 
+ http://tech.groups.yahoo.com/group/musicspdemo/
+ 
Index: gcc/gcc/gccmvs.txt
diff -c nul gcc/gcc/gccmvs.txt:1.178
*** nul	Tue Oct 01 16:28:45 2019
--- gcc/gcc/gccmvs.txt	Tue Jan 08 20:28:58 2019
***************
*** 0 ****
--- 1,1025 ----
+ GCC and PDPCLIB for z/OS and MVS/380
+ ------------------------------------
+ 
+ This is a port of GCC version 3.2.3 to MVS (all versions
+ of MVS, from z/OS down to 3.8j plus MVS/380). GCC 3.2.3
+ doesn't ship with a C runtime library suitable for use
+ on an MVS environment, so for that, PDPCLIB is included,
+ to provide a complete solution to all your programming
+ needs. So long as you only need an ISO C90 (ANSI C89)
+ compiler, anyway!
+ 
+ Although GCC originated on an ASCII Unix environment,
+ this MVS version of GCC is completely unrelated to that
+ environment. It is an MVS EBCDIC compiler throughout. 
+ Built on MVS, using only tools that are also available
+ on MVS. It does not need or use a USS environment.
+ And if you obtain the base tools and source from an EBCDIC
+ environment, you need never see anything in ASCII ever.
+ 
+ The same can be said of the C runtime library. Although
+ there is an ASCII Windows version of PDPCLIB available
+ too, the MVS version was written for MVS, not Windows.
+ 
+ So too is the case with 24-bit support. Although MVS
+ 3.8j (24-bit) is a supported environment, every fullword
+ of the provided GCC is purely 32-bit, and both GCC
+ and the modules it produces will work on MVS 3.8j as
+ 24-bit, MVS/XA and above as 31-bit, above the line as
+ well, and on MVS/380 you can actually run in AM32
+ and address up to 4 GiB of memory if your machine is
+ appropriately configured.
+ 
+ Nor does the fact that GCC is copyrighted with a variety
+ of licencing conditions (see the COPYING file in the
+ GCC base source code) impact on your commercial use of
+ load modules you compile with GCC. Every byte of
+ PDPCLIB is public domain (no code is accepted otherwise).
+ Thus every byte of your executable is either your own
+ work, thus copyrighted by you and you alone, or it was
+ from PDPCLIB, and thus can be used as freely as you
+ can use Shakespeare's "Hamlet". There is absolutely no
+ licencing restriction. No crediting. Nothing. No
+ restriction on modification. No requirements on you to
+ do anything if you modify it. No restriction on selling
+ it, with or without modification. And no need to ask
+ permission - it is already granted.
+ 
+ In principle, GCC will work with C runtime libraries
+ other than PDPCLIB (e.g. Dignus is a defined GCC target,
+ and was the base for the PDPCLIB target, since GCC 3.2.3
+ was generating nice, flexible code for that target).
+ Also in principle, PDPCLIB will work with compilers other 
+ than GCC, and indeed, the first time PDPCLIB worked on
+ MVS, it was after having been compiled by C/370. In practice,
+ GCC's MVS target and PDPCLIB have matured, and continue
+ to mature, hand in hand.  This combined product is
+ known as "GCCMVS" in the MVS environment, "GCCCMS"
+ in the CMS environment, "GCCVSE" in the VSE environment
+ and "GCCMUS" in the MUSIC/SP environment.
+ 
+ 
+ 
+ QUICK START
+ -----------
+ 
+ Run GCC.JCL(EXAMPLE) to make sure it works.
+ 
+ 
+ 
+ OBTAINING
+ ---------
+ 
+ The normal way for a z/OS user (systems or application
+ programmer) to obtain GCCMVS is via an XMIT tape downloaded
+ from the sourceforge website:
+ 
+ http://gccmvs.sourceforge.net
+ 
+ The normal way for an MVS/380 user to obtain GCCMVS is to 
+ simply wait for a new version of either to be released, 
+ which normally comes with the version of the compiler that
+ was latest at the time of release.
+ 
+ However, the XMIT can also be used on MVS/380 (and indeed,
+ MVS 3.8j).
+ 
+ But probably the most convenient way of obtaining it is
+ from the "SEASIK" DFDSS dump, which contains a number of
+ freeware products.
+ 
+ If you prefer, the compiler can also be produced by
+ building it from scratch from source code. When it is done
+ this way, it is done on the assumption that the MVS
+ system does not already have a C compiler or tools
+ available, and will thus do a cross-compile (on an ASCII
+ machine). This is a very involved process, although it is
+ usually done in an automated manner.
+ 
+ 
+ 
+ DATASETS
+ --------
+ 
+ The following datasets are included in the XMIT:
+ 
+ required:
+ GCC.LINKLIB - the compiler
+ PDPCLIB.NCALIB - the C runtime library binaries
+ PDPCLIB.INCLUDE - the C header files
+ PDPCLIB.MACLIB - assembler support files
+ 
+ optional:
+ GCC.PROCLIB - compile procedure
+ GCC.JCL - compile JCL
+ PDPCLIB.LINKLIB - some useful utilities
+ GCC.DOC - documentation for the C compiler
+ PDPCLIB.DOC - documentation for the C runtime library
+ GCC.SOURCE - complete source code for C compiler
+ GCC.INCLUDE - header files for C compiler
+ PDPCLIB.SOURCE - complete source code for the C runtime library
+ GCC.S2 - assembler code (stage 2 output) used to build GCC load module
+ 
+ 
+ 
+ BUILDING FROM SOURCE
+ --------------------
+ 
+ There are at least 5 different things you could do that 
+ could be described as "building from source code", and
+ it depends on what you are trying to achieve that would
+ determine which, if any, of these you would choose:
+ 
+ 1. Using assembler, simply set PDPTOP in PDPCLIB.MACLIB
+ to be the version you want (S/390, S/380 or S/370) then
+ reassemble the code in GCC.S2 using the STAGE1A and 
+ STAGE1B JCL to produce the GCC load module. In STAGE1B, 
+ you should rename "MODULE" from "STAGE1" to "GCC". After
+ doing that, you have another opportunity to change
+ PDPTOP, for what you want your own executables to come
+ out as. Then on z/OS submit STAGE4 to compile the C runtime 
+ library.  MVS 3.8j and MVS/380 users should use STAGE4Z 
+ instead.
+ 
+ 2. Compile the C code in GCC.SOURCE by running through
+ the STAGE2 and STAGE3 jobs, using the provided GCC
+ executable. Then run STAGE4.
+ 
+ 3. Same as 2, except use BISON and SED to generate some
+ of the C code which is actually generated code.
+ 
+ 4. Take the ASCII patch file, and the ASCII base gcc 3.2.3,
+ build a cross compiler, generate the assembler, put that
+ on MVS, then run stages 1 to 3 to build the executable
+ with verification. This is what is described at length
+ below. This is a non-trivial task.
+ 
+ 5. Do number 4, then with the newly-built compiler, go
+ and build BISON and SED, then compile the compiler again,
+ this time using the tools, and then verify that all
+ generated code is as expected. This is what the MVS/380
+ build used to do.
+ 
+ 
+ 
+ THREE STAGES
+ ------------
+ 
+ Compilers are normally built in 3 stages.
+ 
+ STAGE 1 - using a compiler from another vendor, or from
+ an earlier version of your own compiler, or using a
+ cross-compiler, compile your new compiler.
+ 
+ STAGE 2 - using your just-built new compiler, recompile
+ your compiler again, to produce a new module. This new
+ module will most likely be significantly different from
+ the previous one, because it used your own compiler,
+ rather than another vendor's, so will have generated
+ different code, even though both sets of code work fine.
+ 
+ STAGE 3 - using your NEW just-built module, once again
+ recompile everything to produce a new module. This new
+ module should be identical to the one you used (although
+ there may be timestamp differences, depending on your
+ build environment). If it isn't, it means that there's 
+ a bug in your compiler that is affecting the compiler itself.
+ 
+ 
+ 
+ OBTAINING BASE SOURCE
+ ---------------------
+ 
+ GCCMVS is simply a patch of around 190k (zipped) on 
+ top of standard GCC 3.2.3. Standard GCC 3.2.3 can be 
+ obtained from:
+ ftp.gnu.org/gnu/gcc/gcc-3.2.3/gcc-3.2.3.tar.bz2
+ File is dated 2003-04-23 00:00 and is 
+ 20,662,887 bytes in size.
+ 
+ However, you would probably be better off with the smaller:
+ ftp.gnu.org/gnu/gcc/gcc-3.2.3/gcc-core-3.2.3.tar.bz2
+ File is dated 2003-04-23 00:00 and is 
+ 10,324,429 bytes in size.
+ Note that if you use this core file, there are 6
+ files in the patch that won't get applied (you'll
+ see an error during the patch), but they aren't
+ important, and don't interfere with the running of
+ the scripts (ie it won't prompt you).
+ 
+ The official place to obtain the GCCMVS patch from is:
+ http://gccmvs.sourceforge.net
+ 
+ GCCCMS (GCC for CMS) is part of the same product,
+ and you can read gcccms.txt for further information.
+ Read gccvse.txt for further information about the
+ VSE port. Read gccmus.txt for further information
+ about the MUSIC port.
+ 
+ Note that at the moment there is a separate, but
+ similar, product - GCC for USS on OS/390, z/OS,
+ maintained by David Pitts, which is available from here:
+ http://www.cozx.com/dpitts/gcc.html
+ A lot of code is shared between the two projects, but
+ not all. The code may coalesce in the future.
+ 
+ Also note that if you are using MUSIC/SP, there is
+ an older port to MUSIC produced by Dave Edwards (RIP),
+ and available here:
+ http://webpages.mcgill.ca/staff/group3/dedwar1/web/gccmu10.zip
+ There are some minor code changes in it, and the compiler
+ is way out of date.
+ 
+ 
+ You will also need to obtain PDPCLIB.  The official
+ place to get PDPCLIB from is:
+ http://pdos.sourceforge.net
+ 
+ 
+ 
+ PREPARING INITIAL SOURCE
+ ------------------------
+ 
+ If you obtain GCCMVS in source code form, then
+ you need the following tools:
+ 
+ 1. The "patch" utility (Unix standard).
+ 
+ 2. a C compiler (by default, gcc for windows with
+ pdpclib for windows is used (which also requires a
+ "make" which supports spaces, such as the one from
+ Borland C++, or else you need to change all spaces to 
+ tabs in the makefile), but you can use C compilers 
+ other than gcc, and you can use standard gcc without
+ pdpclib for windows too).
+ 
+ 3. Miscellaneous decompression tools such as bzip2
+ and tar (normally you get these by installing Cygwin).
+ 
+ So do the following (note that all these commands
+ and the rest of the process is contained in cygwin.bat
+ as an EXAMPLE of what you MIGHT want to do if you had
+ a standard cygwin install and wanted to be up and
+ running as quickly as possible, and allmvs.bat MIGHT,
+ after modification, be used for someone doing a gcc/pdpclib 
+ win32 build (this is the combination that is exercised
+ in development) - and you can see this being done in the
+ build scripts for MVS/380):
+ 
+ bzip2 -d gcc-3.2.3.tar.bz2
+ tar xvf gcc-3.2.3.tar
+ ren gcc-3.2.3 gcc
+ cd gcc
+ patch -p 1 -f <patch.txt (whatever the patch file is called)
+ 
+ Note that this file that you are reading right now is
+ called gccmvs.txt and after you've applied the patch,
+ you can switch to reading the gccmvs.txt that just got
+ produced. Just in case the one you are reading now is
+ out of date.
+ 
+ For your information, some of the files in
+ the gccmvs patch were originally obtained by doing:
+ ./configure --target=i370-ibm-mvspdp --enable-languages=c
+ but you should NOT do that, otherwise you will
+ overwrite various working source files with
+ non-working ones.
+ 
+ 
+ You will also need to extract PDPCLIB. You should
+ create a dummy "pdos" directory, and create a "pdpclib"
+ directory under that (which is where all the PDPCLIB
+ files should go), and then place "pdos" and "gcc" at the
+ same level, so you end up with a structure like this:
+ 
+ gcc/include
+ gcc/gcc
+ gcc/libiberty
+ pdos/pdpclib
+ 
+ It needs to be like this because the compile scripts
+ assume these relative paths and names.
+ 
+ 
+ 
+ COMPILING CROSS-COMPILER
+ ------------------------
+ 
+ Then, assuming you are doing this from a DOS
+ prompt, change to the gcc/gcc directory and go:
+ 
+ gencomp (this step is actually optional, as the
+ source files it generates are actually already
+ part of the patch, so you're probably better off
+ omitting this step, and it assumes you are using
+ gcc as your compiler).
+ 
+ compile
+ 
+ which will create an executable called gccmvs.exe
+ on Windows, or gccmvs on Unix.
+ 
+ First problem - by default, "compile.bat" is set up
+ to compile using gcc/pdpclib-win32. You can easily
+ change this to use some other compiler, but if you
+ want to use the default, it requires you to actually
+ build pdpclib-win32 according to the instructions
+ included in pdpclib.txt in the pdpclib directory.
+ The advantage of using pdpclib-win32 is that it means
+ that the C runtime library you use for the PC is the
+ same/similar to that which is being used on the
+ mainframe, so if you were to hit a bug, you will find
+ out the problem on the PC before you get to the
+ mainframe. Another advantage is that it bypasses the
+ buggy newlib headers which pollute the namespace with
+ Unix rubbish which sometimes causes problems.
+ 
+ 
+ 
+ CHOOSING TARGET ENVIRONMENT
+ ---------------------------
+ 
+ There are actually 3 distinct architectures supported:
+ S/370
+ S/380
+ S/390
+ 
+ The pdptop macro determines which one will be used.
+ Normally, and by default, the S/380 version is used,
+ and there is no real reason not to use it. The
+ S/380 flavor is designed to passively accept whatever
+ AMODE and RMODE the module is set to - normally
+ AM31/RM31, and will behave nicely on z/OS.
+ 
+ However, there is an issue if you try to run the
+ module on MVS/XA. Some time during MVS/ESA, IBM provided 31-bit
+ versions of the "PUT" etc macro (and supporting infrastructure)
+ so that you could actually have a clean AMODE 31, RMODE ANY
+ executable. Prior to that time, any executable that needed to
+ call "PUT" needed to be RMODE 24 and switch to AMODE 24 before
+ calling "PUT", then it could switch back to AMODE 31. ie it was
+ a hybrid of sorts.
+ 
+ As such, if you wish to run on MVS/XA, what you need
+ is a module that switches to AM24 before calling "PUT"
+ etc. The S/380 module will automatically do that if
+ you mark the module as AM31/RM24. You don't need to
+ recompile your module. Note that S/370 hardware
+ doesn't have the "BSM" instruction so can't switch
+ AMODE. In order to still run on MVS 3.8j, the S/380
+ module will not attempt to switch to AM24 if it is
+ already running in AM24, as is the only choice on
+ MVS 3.8j. What this means is that one single module
+ will work optimally in all environments. You just
+ need to use the "PDS" utility to mark the module
+ as RM24 if you are running on MVS/XA. You don't need
+ to do that if running on MVS 3.8j because the AMODE
+ and RMODE flags will be ignored. On MVS/380 at time
+ of writing, modules are never loaded ATL, even if
+ they are marked RMANY, so there is no need to use
+ the "PDS" utility there either. In the S/380 model,
+ GETMAIN with LOC=ANY is used to obtain ATL memory
+ for application usage. Note that this parameter is
+ ignored when run on MVS 3.8j.
+ 
+ Now the difference with S/390 is that there is no
+ step-down (to AM24) logic, and memory is obtained
+ with a default LOC=RES, and so long as the module
+ was loaded ATL, you will get ATL memory for your
+ application. The module is technically ANY/ANY as
+ when running it doesn't use features that don't exist
+ in MVS 3.8j, such as GETMAIN LOC=ANY.
+ 
+ The difference with S/370 is that you can use it
+ in an environment with an assembler with no BSM.
+ The resulting module can only be run as AM24 as
+ macros like PUT are not 31-bit clean on an
+ unmodified MVS 3.8j.
+ 
+ For full integrity on S/380 or S/390 you can also run gencomp,
+ so you need to change gencomp.jcl to replace occurrences
+ of "BISON" and "SED" to whatever you have called
+ your installation libraries for those two products. The script
+ "withbis" will do a full build assuming bison is available,
+ and that is normally called via "fullmvs" to package GCCMVS
+ ready for distribution. Note that the building of MVS/380
+ previously did all these steps to create a pure mainframe
+ product.
+ 
+ 
+ 
+ GENERATING ASSEMBLER
+ --------------------
+ 
+ Now run the "compmvs" script.
+ 
+ (unless you want to use the unmodified IFOX on MVS 3.8, in which 
+ case go "compmvs -DIFOX")
+ 
+ This will generate S/370 assembler code (clean, 32-bit
+ assembler).
+ 
+ You now need to get all the stuff up onto the mainframe.
+ 
+ This is your big chance to screw things up.
+ You need to transfer these files with the
+ same ASCII to EBCDIC translation that GCCMVS
+ expects.  Easiest to stuff up are the following:
+ 
+ | x'4f'
+ ^ x'5f'
+ [ x'ad'
+ ] x'bd'
+ 
+ If you actually try transferring this file you
+ are reading now to the mainframe, and do a
+ search on "screw" and put "hex on", you can
+ see how successful you are likely to be. However,
+ there are ways to avoid bad translation tables,
+ and having to deal with so many files as well.
+ 
+ For example you could use the "mvsunzip" and
+ "mvsendec" tools that come with PDPCLIB. These allow
+ you to zip up code (but without compression), encode
+ into printable hex (translate tables are never so bad
+ that they can't handle A-F and 0-9), and then reverse
+ the process on the mainframe. However, to reverse
+ the process, you still need to get those utilities
+ onto the mainframe in the first place. For that,
+ if you have m4 installed, you can run the "makeutil"
+ script to produce a convenient batch job that
+ compiles these basic utilities.
+ 
+ All such file transfer methods are beyond the scope
+ of GCCMVS. The example (stress - example) jobs below
+ assume an emulated tape is being used. This is a
+ convenient method for MVS/380 users.
+ 
+ The JCL is all set up to use particular prefixes in
+ proc statements - GCCPREF and PDPPREF.  Thus they 
+ all need to be changed, as well as any JOBCARD 
+ changes your installation requires, unless you're
+ happy with the defaults of "GCC" and "PDPCLIB". jcl, 
+ m4 and prc files all need to be changed.
+ 
+ It is recommended that you spend the time to automate
+ the process of changing the jobcard so that you can
+ rerun these jobs again and again. You could set up an
+ edit macro in ISPF or you could make use of the
+ "fixjcl" batch file on the PC to make the changes. Note
+ that on your jobcard, you don't need REGION=0K, you can
+ get by with something like REGION=50M, or maybe even as
+ low as 25M, depending on a few things.
+ 
+ 
+ 
+ RUNNING JOBS ON MVS
+ -------------------
+ 
+ You probably want to run stage0a.jcl to create high-level
+ aliases for GCC and PDPCLIB. The exception is if you do
+ not have authority to create new aliases, and wish instead
+ to run the compiler out of your own libraries. In which
+ case you would be using a high-level prefix of perhaps
+ "userid.GCC" and "userid.PDPCLIB" instead, and thus no
+ aliases are required. Note that the compile JCL also expects
+ a 'SYS1.MODGEN' to exist. This doesn't exist on TK3, so
+ you will either need to create an alias for it, or modify
+ the JCL to replace MODGEN with AMODGEN.
+ 
+ Next run stage0b.jcl to allocate the datasets which will
+ eventually store the source code etc from the PC.
+ 
+ The next steps are an example of how to get the source
+ code from the PC to mainframe. It uses zip on the PC
+ side, and minizip on the host side, and emulated tape
+ inbetween. Replace these steps with whatever your site
+ uses.
+ 
+ In order to get minizip onto the host if it isn't
+ already there, you can run "makeutil", which is
+ called by "bootstrap". Assuming the pre-existence of
+ minizip, or something similar, zip up all the source
+ code etc to go to the mainframe by running "zipmvs".
+ Note that for for complete integrity on a 31-bit 
+ system, it would be good if you edited zipmvs.bat and 
+ removed all those "rem" statements down the bottom. This 
+ will prevent you from uploading the generated source,
+ and force gencomp to generate them instead. The script
+ "withbis" will do this automatically.
+ 
+ stage0c.jcl is then used to transfer the zip file up.
+ 
+ stage0d.jcl then executes minizip to unzip the zip files.
+ 
+ That ends the involvement of the PC, as everything is
+ now on the host.
+ 
+ 
+ 
+ BUILDING STAGE1
+ ---------------
+ 
+ Run the JCL from GCC.JCL(STAGE1A) and GCC.JCL(STAGE1B).
+ This will create the stage1 executable, which is a 
+ working gccmvs, the only disadvantage of which is that
+ it was compiled on the PC instead of the mainframe.
+ 
+ If you had another vendor's compiler, or an old version
+ of GCCMVS, you could have built this on the host in
+ the first place.
+ 
+ 
+ 
+ GENERATED FILES
+ ---------------
+ 
+ For complete integrity on a 31-bit system,
+ you can run GCC.JCL(GENCOMP), which will
+ regenerate all the generated source files.
+ This assumes that you have bison and sed
+ available. If you don't have them, you can
+ compile them using the stage1 executable,
+ and you can temporarily rename stage1 to gcc.
+ If you already have old copies of bison, sed
+ and gcc, there is no need to recompile them
+ now with stage1. That step happens later.
+ 
+ 
+ 
+ BUILDING STAGE2
+ ---------------
+ 
+ Next run GCC.JCL(STAGE2A-C).  Making use of
+ the just-compiled STAGE1, it will compile from
+ source code the entire gccmvs suite, this
+ time to create an executable called STAGE2.
+ 
+ Note for MVS 3.8j users: Due to memory requirements,
+ you cannot build a stage2 compiler. You should
+ instead just rename this STAGE1 compiler to GCC,
+ copy it to GCC.LINKLIB, then pick up again in
+ STAGE4(Z).
+ 
+ 
+ 
+ BUILDING STAGE3
+ ---------------
+ 
+ It so happens that the process used to build the stage1
+ compiler, being from the same vendor, has generated
+ identical code to that produced in stage2. So, it is
+ possible to compare the stage1 and stage2 executables,
+ without needing to go to stage3. As such, stage2d is
+ designed to do the comparison prematurely, and avoid
+ the need for STAGE3.
+ 
+ If that is not your situation, you will now need to
+ run the STAGE3(A-C) jobs, which will compare with the
+ output of STAGE2.  The other situation where you
+ will need to run STAGE3 is if you ran GENCOMP, as
+ the source code will have changed slightly as a
+ result of that.
+ 
+ When STAGE3C completes, it verifies the integrity
+ of the compiler output, then produces a GCC module.
+ During that process, a GCC.S2 file is produced
+ containing the generated assembler. This can then
+ be transported to any other system, even MVS 3.8j
+ with memory constraints, to produce a perfectly
+ viable C compiler, just by reassembly.
+ 
+ Note that if the executables STAGE2 and GCC (aka
+ STAGE3) were not identical, then there is a compiler
+ bug somewhere that is affecting the integrity of
+ the compiler itself.
+ 
+ 
+ 
+ FINALIZING
+ ----------
+ 
+ Now run GCC.JCL(STAGE4). MVS 3.8j and MVS/380 users
+ should run STAGE4Z instead, because of the 15 alias
+ restriction on these systems. This will compile
+ PDPCLIB, the C runtime library. You have the option
+ of changing PDPTOP to choose a different architecture
+ to target for your own executables.
+ 
+ Now clean up all the intermediate datasets by
+ submitting STAGE5A.
+ 
+ Then (optionally) compile some useful utilities from
+ PDPCLIB by submitting STAGE5B.
+ 
+ Now if you're a systems programmer, you can choose to
+ install the procs in GCC.PROCLIB into SYS1.PROCLIB
+ etc, after modifying them to your site's requirements.
+ Submit STAGE5C to do that.
+ 
+ STAGE6.JCL is not required to be run. It is only
+ used in circumstances where you want to dump the
+ datasets to tape and then reload them.
+ 
+ 
+ Congratulations, you now have GCCMVS fully installed.
+ 
+ You can now compile your own C programs by
+ running the example jcl found in GCC.JCL(EXAMPLE),
+ or if you have installed the procs, then EXAMPLE2.
+ 
+ 
+ 
+ BISON and SED
+ -------------
+ 
+ For complete integrity on a 31-bit system,
+ you should now go and recompile bison and sed,
+ then rename your GCC.SOURCE and GCC.INCLUDE
+ to ".OLD" datasets, repopulate them (from the
+ zip files), then run GENCOMP (to repopulate
+ the generated source files), and then confirm
+ that the source and include haven't changed
+ with your new compiler by comparing with the
+ old datasets. The MVS/380 build scripts do this
+ as part of the process, by running the "withbis"
+ script. However, the integrity of the tools is
+ outside the scope of GCC proper.
+ 
+ 
+ 
+ 
+ CREDITS
+ -------
+ 
+ Everyone who worked on GCC in areas besides i370
+   and to the people out there who contribute the
+   odd fix that they developed.
+ Jan Stein for the original i370 machine definition
+ Dave Pitts for doing the port to OS/390 USS,
+   without which the further work could not have
+   been done.
+ Linas Vepstas for a slew of bug fixes and enhancements
+   made during his port of Linux to S/370.
+ Paul Edwards for doing the port to native (ie
+   non-USS) MVS 3.8, MVS/XA, OS/390, Z/OS, MVS/380
+   as well as getting GCC to be able to compile 
+   itself on the mainframe (previously it was 
+   only compilable by IBM's C compiler).
+ Phil Roberts for testing & debugging & releasing
+   the native MVS port created by Paul Edwards. The 
+   product wouldn't exist without Phil's work either.
+ Dave Wade for fixing the last compiler bug that
+   was preventing GCC from compiling itself on the
+   mainframe, and also for doing the VM/CMS port.
+   And various other bug fixes and improvements to
+   PDPCLIB as well.
+ Chris Langford and Dave Jones for the prolog/epilog
+   macros.
+ Dave Edwards (RIP) for doing the MUSIC/SP port and 
+   fixing various bugs in PDPCLIB in the process.
+ Tim Pinkanawa for writing the HTML documentation.
+ Tim Holloway for figuring out where to put the code
+   to get the static function names unique so that
+   the final problem stopping the compiler from
+   being C90 compliant was fixed.
+ Robert O'Hara for getting EPLIST support in PDPCLIB
+   working on CMS and providing the mods to VM/380
+   required to get 31-bit GCCCMS binary compatible
+   between VM/380 and z/VM.
+ Gerhard Postpischil for providing the mods to MVS/380
+   required to get 31-bit GCCMVS binary compatible
+   between MVS/380 and z/OS so that we could build
+   GCCMVS on a free system. Also for the final functions
+   missing in PDPCLIB for C90 conformance for MVS and
+   for the virtual rewrite of mvssupa.asm. Also for
+   writing the SVC 120 intercept on MVS/380 which
+   allowed GCC to be built nicely.
+ Scott Cosel for the XMIT JCL which enabled a nice
+   package to be produced for z/OS users. Also for
+   producing a real 31-bit z/OS executable using
+   GCCMVS on z/OS and putting that in XMIT format to
+   truly test MVS/380. Also for other testing.
+ Tony Harminc for assistance in getting integer divide
+   working properly.
+ Ulrich Weigand for providing direction on tying up some
+   loose ends, especially getting rid of some warnings from
+   gencomp.
+ Fausto Saporito for his work on making the MUSIC/SP port
+   native.
+ Fran Hensler, Bruce Smith, Bill Carlborg, Louis Millon,
+   Michel Beaulieu and others for assistance and code
+   for the z/VSE port.
+ 
+ 
+ 
+ VERSION
+ -------
+ 
+ See version.c for the version number.
+ 
+ 
+ 
+ SUPPORT
+ -------
+ 
+ PDPCLIB is separately maintained by Paul Edwards,
+ and support is generally forthcoming for that.
+ Certainly submission of *public domain* (ie NOT
+ GPL) bug fixes/enhancements are welcome.
+ 
+ Support for most common GCC problems is generally
+ available also.
+ 
+ The usual place to get support for either thing is
+ the hercules-os380 Yahoo group at:
+ 
+ http://tech.groups.yahoo.com/group/hercules-os380/
+ 
+ If your question is more MVS-related than GCC-related,
+ there are a number of other MVS forums linked from
+ os380.
+ 
+ 
+ 
+ TECHNICAL NOTES
+ ---------------
+ 
+ Technical notes about executables created in this manner plus 
+ other issues:
+ 
+ 1. A "hello, world" program is approximately 82k in size.
+ 
+ 2. The memory requirements (not including the
+ space for the executable) for a "hello, world"
+ program are around 350k, assuming the default
+ stack size of 256k is being used in mvsstart.asm (and
+ the rest is mainly because the 3 standard files all
+ use 32k buffers, so that's 96k + 256k = around 350k.
+ 
+ 3. PDPCLIB is designed to conform to the ISO/IEC 
+ 9899:1990 (aka ANSI X3.159-1989) standard, and there
+ are no extensions (like "open", "chmod" etc
+ found on other operating systems or compilers).
+ 
+ 4. What PDPCLIB on MVS is primarily designed for,
+ is fast processing of binary, fixed block datasets,
+ and also for text processing, via fgets, from
+ variable length records.  Or if you want to write a 
+ utility to traverse MVS control blocks, you 
+ can use it for that sort of thing.  When operating
+ on binary, fixed-length records, the path from
+ fwrite to the "PUT" macro is very short indeed.
+ The path from fputs to the "PUT" macro is pretty
+ short too.
+ 
+ 5. The files that PDPCLIB operates on can be of
+ any format. PDPCLIB will adjust to whatever
+ DCB information is specified, and provide
+ sensible defaults when none is present.
+ 
+ 6. The executables that are produced can be run
+ as both TSO command processor or in batch.  The
+ parameter parsing will handle either method of
+ invocation.
+ 
+ 7. N/A.
+ 
+ 8. PDPCLIB makes no attempt to operate on VSAM
+ datasets. It will also refuse any attempt
+ to open a file in update or append mode, and random
+ access will usually be unacceptably slow due to
+ the constant reopening of the file. The design of 
+ RECFM=U handling is to allow the "copyfile" utility
+ (part of PDPCLIB) to be able to do a binary copy 
+ from a VB file, to a U file, to an FB file, back to 
+ a VB file, and have the files still be identical.
+ 
+ 9. Note that the "-g -dA" option can be used to get
+ source file line numbers inserted into the assembler
+ file.
+ 
+ 10. The compiler generates excessive instructions,
+ reloading the base register at every single label.
+ The smarts are already in the code generator to
+ avoid this, it's just that they're not quite smart
+ enough, so needed to be disabled! Search for do_spec_1
+ in i370.c to see the problem. An exception has been
+ made for functions that fit in a single page. This
+ gets around the vast majority of the problem.
+ 
+ 11. You need to have an assembler capable of handling
+ more than 400 externals. If you are using the (very
+ old) IBM-supplied IFOX, then you need to apply this
+ patch:
+ http://www.prycroft6.com.au/vs2mods/download/asmxfesd.zip
+ If you really must use an unmodified IFOX, you can
+ compile with "-DIFOX" which will disable some externals
+ that you may be able to do without. It is not recommended
+ or supported.
+ 
+ 12. The compiler requires approximately 20 MB of memory to
+ compile everything optimized, on top of the GCC executable
+ itself (3 MB). Specifically FOLD@CON won't build with only
+ 19 MB of memory for data. This means you can't complete the
+ normal build process on any S/370 machine. However, switching
+ off optimization on that module will get the total memory 
+ requirements down to about 14 MB, which means that it is
+ within the ability of VM/370 to compile either all unoptimized
+ or with just the largest 3 unoptimized. However, even getting
+ rid of TSO and VTAM won't give you a 14 MB total under MVS 3.8j.
+ Fixing the excessive base register reloads in gcc would make a 
+ bit more memory available. Perhaps a proper alloca() would
+ make a difference too. It's all fairly academic though when
+ compilation on z/OS, MVS/380 or the PC will get around all
+ such problems.
+ 
+ 13. Note that the source and include files are generally
+ stored in VB files, except for the bits with assembler in
+ it, which need to be FB80.
+ 
+ 14. When importing a new release it is necessary
+ to allow c-parse.c to be imported. This is set to 
+ ignore in .cvsignore. We have a local modification
+ to c-parse.c that allows it to handle both ASCII
+ and EBCDIC. But there is actually no need to use
+ this modified c-parse.c, as a version that works
+ on EBCDIC can be generated using bison on an
+ EBCDIC host, and that is in fact what the "gencomp"
+ JCL does. But if you don't have bison, you will need
+ this modification. While updating .cvsignore, it
+ is also best to get rid of the genrtl.c and genrtl.h
+ from there, to allow them to be imported if they exist.
+ 
+ 15. Most generated files are generated by "gencomp".
+ But some unimportant ones were generated by using
+ "configure" and "make".
+ The command to run configure is:
+ ./configure --target=i370-ibm-mvspdp --enable-languages=c
+ But be careful, as this will overwrite some files that
+ have been created by hand, and you don't want that.
+ 
+ 16. Since the S/370 target as it stands doesn't dedicate
+ a register for a frame pointer, the stack pointer and
+ frame pointer are both set to R13. As such, alloca() can't
+ allocate space on the stack. So, it was necessary to modify
+ the builtin_alloca() function to stop it from allocating
+ space and letting it call alloca() instead. This could
+ all be changed, but would add an additional complexity.
+ 
+ 17. The assembler code generated by gccmvs when run on the
+ PC is slightly different (even when the same parameters
+ are used for code generation) from that when run on the
+ mainframe, if -O2 is used instead of -Os. But functionally 
+ equivalent. This non-deterministic nature of the compiler 
+ is disconcerting. It seems to not always allocate registers 
+ consistently. This has been traced to floating point code
+ in predict.c and local-alloc.c which is sensitive to the
+ very small changes in floating point representation. This
+ should be changed to include deltas when comparing floating
+ point values. Here's an example of what's happening:
+ 
+ *** c-lex.s Mon Jan 14 20:48:35 2008
+ --- temp.dat Mon Jan 14 21:14:04 2008
+ ***************
+ *** 1328,1335 ****
+            SLR   15,15
+            STC   15,0(3,4)
+            SLR   6,6
+ -          LR    9,6
+            LR    8,6
+            L     2,192(13)
+            CLR   2,5
+            BNL   L303
+ --- 1328,1335 ----
+            SLR   15,15
+            STC   15,0(3,4)
+            SLR   6,6
+            LR    8,6
+ +          LR    9,6
+            L     2,192(13)
+            CLR   2,5
+            BNL   L303
+ 
+ 
+ 18. builtins have all been switched off in the compiler
+ by default (ie -fno-builtin), as they can sometimes 
+ generate bad code. Instead, the header file is used to
+ selectively enable working builtins.
+ 
+ 19. Versions of GCCMVS up to and including 3.2.3 MVS 6.0 
+ should be considered betas because of the compiler bugs that
+ they contained. With the elimination of those bugs, GCCMVS
+ is now of acceptable quality.
+ 
+ 20. nostdinc is on by default so that you have to
+ specify where you get your include files from on
+ the compile command line. There might be a better
+ way of doing this rather than setting no_standard_includes
+ in cppinit.c
+ 
+ 21. We should look at making "configure" and "make"
+ work for the mvspdp target, so that people on Unix
+ don't need to use our custom-made scripts. They currently 
+ work, but the detab routines are bypassed.
+ 
+ 22. PDPCLIB should be changed to read data a block
+ at a time rather than a record at a time. This will
+ allow us to efficiently process datasets with an
+ LRECL of 1, which fits the C paradigm more accurately.
+ 
+ 23. We should consider having a utility to compare two 
+ executables so that we can see that the stage2 and stage3 
+ executables are identical. A utility to do this can be 
+ written as follows: BLDL each to find the length.
+ If lengths are equal, GETMAIN the space for it twice.
+ Load the first load module in the first GETMAINed space.
+ Copy it to the second GETMAINed space with MVCL.
+ Load the second load module to the first GETMAINed space.
+ Compare the two GETMAINed spaces with CLCL. We currently
+ compare assembler instead, which should be just as good.
+ Not sure if 2 IEBCOPY unloads could be compared instead.
+ 
+ 24. Because MVS 3.8 has a limitation of 15 aliases in the linker
+ (and presumably elsewhere), the same module is linked multiple
+ times, to ensure all aliases can be created. This opens up the
+ possibility of some object code being out of date if someone
+ links one of the modules manually without doing the other required
+ links as per STAGE4Z. The alternative is to add more than 15
+ aliases via other means, but no-one has explained why there is
+ a 15 alias limit in the first place, so we don't know what the
+ ramifications of doing that are.
+ 
+ 25. If you are using a compiler that gives you an error when you
+ compile vasprintf.c, then add a define in the compile command to
+ define VALIST_NOT_PTR, and that should get around the problem.
+ See stdcompw.bat for an example. The gcc code is basically not 100%
+ C90-compliant as it depends on the implementation of va_list.
+ 
+ 26. With -pedantic-errors switched on we get slightly different
+ and seemingly slightly less efficient code generated. This was
+ not expected. pedantic-errors is desirable to aid portability.
+ 
+ 27. I added the __extension__ keyword to genoutput.c because
+ I couldn't see how to get rid of the pedantic error.  This should
+ be replaced with something better.
+ 
+ 28. #pragma map() and linkage exist, but don't currently
+ have any effect. TARGET_ALIASES would need to be switched
+ on for map to start having an effect.
+ Syntax is like this:
+ #pragma map(finalize_buffer, "FIN@BUF")
+ GCC already has:
+ #pragma redefined_extname oldname newname
+ but that's not what is normally used for MVS. And it doesn't
+ have any effect either! Probably because of the name
+ grunging being done in GCCMVS unconditionally to trunc to 8
+ characters and convert abnormal characters into '@' and
+ uppercasing.
+ 
+ 29. Failed compiles on the PC don't clean up after an error,
+ so you can have a partially-produced .s file which causes much
+ confusion later when you have missing externals.
+ 
+ 30. makeutil.bat has been provided to put some useful
+ utilities into a single JCL stream for convenient transfer.
+ 
+ 31. GCC when compiling a program with "main()" in it, will
+ generate code for an entry point for the entire executable.
+ This entry point is called @@MAIN and is different from
+ MAIN. @@MAIN will then call @@CRT0 which will eventually
+ call MAIN.  @@CRT0 returns directly to the OS from there,
+ and in fact, if @@CRT0 is forced to be the entry point,
+ it will still work fine too. @@MAIN was introduced so that
+ the linker can automatically resolve things. However, that
+ bit of the automatic resolution will only work if you
+ pass the object code with @@MAIN directly to the linker,
+ rather than first of all creating an NCAL and then passing
+ that to the linker. If you wish to create NCALs, then you
+ will need to put an "ENTRY @@MAIN" in yourself for the
+ linkage editor control statements. Unfortunately this setup
+ has the side-effect that the entry point of modules by default
+ is not 0, which while perfectly technically valid, is a bit
+ annoying.
+ 
+ 32. The calling convention is slightly different in GCC
+ compared to IBM C. Integers are passed by value rather than
+ reference. This is normally not visible, but we should
+ consider making this the same as IBM C and perhaps follow
+ the LE specs.
+ 
+ 33. This file and all compile scripts etc should probably
+ be moved into the "config/i370" directory, but for now it
+ is more convenient to leave them where they are.
+ 
+ 34. GCCMVS emits MVCL/CLCL for a memcpy/memcmp and thus
+ programs that expect to operate on buffers of size 16 MiB
+ or above will not work. If you need greater than 16 MiB
+ you need to either disable the builtins in string.h or
+ modify your code to use (memcpy) instead of memcpy, to
+ force the memcpy function in string.c to be called.
+ 
+ 35. In PDPCLIB, some GETMAINs are conditional and some are
+ unconditional, so if you run out of memory, you will get
+ inconsistent behavior (ie sometimes ABEND, sometimes an
+ error return code to the application).
Index: gcc/gcc/gccr.exec
diff -c nul gcc/gcc/gccr.exec:1.2
*** nul	Tue Oct 01 16:28:45 2019
--- gcc/gcc/gccr.exec	Thu Aug 20 19:01:54 2009
***************
*** 0 ****
--- 1,121 ----
+ /* REXX EXEC TO COMPILE GCC PROGRAM DAVE WADE 24-APRIL-2006 */
+ /*
+    This exec is in the Public Domain and may be freely re-used
+    without reference to the author. It is however provided AS-IS
+    and without any warranty of fitness for any purpose.
+ 
+    It will overwrite files without reference to the user and
+    may compile the wrong code.
+ */
+ /*
+   Format of the EXEC is
+ 
+       GCC fn ft fm ( gcc_options
+ 
+   Where:-
+ 
+       "fn ft fm" Is a source file.
+ 
+       If "ft" is omitted it is assumed to be "C"
+       If "fm" is omitted it is assumed to be "A"
+ 
+ 
+       gcc_options are the "standard" GCC options.
+ 
+       Entering "GCC" with no options will list the GCC options.
+ */
+ /*
+   EXTRACT THE COMMAND OPTIONS
+ */
+ /* CE R */
+ ADDRESS COMMAND
+ 
+ PARSE ARG cfile "(" gccopts
+ PARSE UPPER VAR cfile cfn cft cfm
+ /*
+   If no file-name invoke the compiler with just the
+   option string. If the option string is also null
+   do "gcc --help"
+ */
+ 
+ If cfn = "" Then Do
+  Say "Format of this EXEC is"
+  Say " "
+  Say "   GCCR fn ft fm ( gcc_options"
+  Say " "
+  if gccopts = "" then gccopts = "--help"
+  Address CMS  'Pipe (end ?)'  ,
+     'var GCCOPTS'  ,
+     '| > $GCC$ $PARM$ A2'
+  "FILEDEF SYSPARM DISK $GCC$ $PARM$ A"
+  "GCC"
+  return
+ End
+ /*
+   We have at least a file name
+ 
+ */
+ If cft = "" Then cft = "C"
+ /*
+   check for a file mode.
+ */
+ 
+ If cfm = "" Then Do               /*  no file mode */
+  "STATE" cfn cft "*"              /*  check that the file exists */
+  If rc <> 0 Then Do               /* nope exit with grace */
+   Say "Input File <"cfn cft cfm"> Not Found"
+   return 28
+  End
+  "FILEDEF SYSIN DISK" cfn cft "*"
+  "FILEDEF OUT  DISK" cfn "$WORK$ A (LRECL 80 RECFM F"
+  wfm = "A"
+ End
+ Else Do                           /* we have a file mode */
+  "STATE" cfn cft cfm              /*  check that the file exists */
+  If rc <> 0 Then Do               /* nope exit with grace */
+   Say "Input File <"cfn cft cfm"> Not Found"
+   return 28
+  End
+  "FILEDEF SYSIN DISK" cfn cft "*" /* define input */
+  "STATEW" cfn cft cfm             /* is it a writable disk */
+  if rc = 0 Then Do                /* yes - work file on the same disk*/
+    "FILEDEF OUT  DISK" cfn "$WORK$" cfm "(LRECL 80 RECFM F"
+    wfm = cfm
+  End
+  Else Do                          /* nop pop on "A" disk */
+    "FILEDEF OUT  DISK" cfn "$WORK$ A (LRECL 80 RECFM F"
+    wfm = "A"
+  End
+ End /* input and work files defined */
+ /* now create options file */
+ gccopts = "-o dd:out - -S" gccopts /* put files on options */
+  "EXECIO 1 DISKW $GCC$ $PARM$ A2 1 V (FINIS VAR GCCOPTS"
+  "FILEDEF SYSPARM DISK $GCC$ $PARM$ A"
+ /*
+   Now run the compiler reading options from sysparm
+ */
+ Say "Starting GCC Options = <"gccopts">"
+ "GCC"
+ if RC <>0 then do
+    say 'error in GCC compile step'
+    say 'RC:' rc
+    return -4
+ end
+ /* now rename from S to ASSEMBLE */
+ address cms  ,
+     'PIPE (end ?)' ,
+       '<' cfn '$WORK$' wfm  ,
+       '| >' cfn 'ASSEMBLE' wfm 'F'
+ "ERASE" cfn "$WORK$" wfm
+ "FI OUT CLEAR"
+ "FI SYSPARM CLEAR"
+ "FI SYSIN CLEAR"
+ Say "Assembling code"
+ /*  we need the OSMACRO maclib for the SAVE and RETURN macros  */
+ "GL MACLIB OSMACRO PDPCLIB"
+ "ASMAHL" cfn
+ if RC <>0 then do
+    say 'error in ASMAHL step'
+    say 'RC:' rc
+    return -8
+ end
Index: gcc/gcc/gccver.parm
diff -c nul gcc/gcc/gccver.parm:1.1
*** nul	Tue Oct 01 16:28:45 2019
--- gcc/gcc/gccver.parm	Mon Jul 28 21:57:43 2008
***************
*** 0 ****
--- 1 ----
+ --version
Index: gcc/gcc/gccvse.txt
diff -c nul gcc/gcc/gccvse.txt:1.22
*** nul	Tue Oct 01 16:28:45 2019
--- gcc/gcc/gccvse.txt	Sat Jan 01 11:45:37 2011
***************
*** 0 ****
--- 1,418 ----
+ Release Notes for GCCVSE
+ ------------------------
+ 
+ This document explains what needs to be done to get GCCMVS from:
+ 
+ http://gccmvs.sourceforge.net
+ 
+ to run on z/VSE (or VSE/380). The code is designed to work on
+ DOS/VS through to z/VSE. You just need to set the
+ appropriate configuration before building.
+ 
+ The notes for the MVS version of the compiler (gccmvs.txt)
+ should be read in conjunction with this document. In particlar
+ the section on conversion from ASCII to EBCDIC is relevant to VSE.
+ That file is contained within the source code patch, and
+ you should obtain that, and the base source code, where
+ the COPYING file is, to read the license, as these are all
+ considered to be part of the same package, broken up for
+ convenience).
+ 
+ 
+ 
+ Installing
+ ----------
+ 
+ Assuming you wish to use the shipped executables directly,
+ the process is as follows.
+ 
+ GCCVSE is shipped as object code which was punched with
+ CSERV. To reverse that process, you need to invoke LNKEDT.
+ Getting the object code onto disk (via e.g. ftp, emulated
+ tape) is outside the scope of this document. The sample
+ instvse.jcl (and the example instvse.bat that invokes that
+ on a Windows system running VSE/380) is set up by default
+ to read from a RECFM=FB,LRECL=80,BLKSIZE=3440 (RECFM=F
+ also fine) tape using OBJMAINT (which deblocks it if it
+ was blocked).
+ 
+ Once the object code is on disk, it is fed straight into
+ LNKEDT which catalogs all the phases, plus some
+ pseudo-phases. More JCL and (just-loaded) utilities 
+ extract the pseudo-phases and convert them into relocatable
+ object, macros, and copybooks.
+ 
+ 
+ 
+ Using
+ -----
+ 
+ Here is some example JCL. Your source code must be in one
+ of the formats currently supported by PDPCLIB, e.g. F80
+ and coming from SYSIPT. Header files will need to be put
+ into the CIL in the same manner stdio.h etc are.
+ 
+ 
+ * $$ JOB JNM=VSEJOB
+ * $$ LST LST=SYSLST,CLASS=A,RBM=999999
+ // JOB VSEJOB
+ *
+ *
+ * Compile a sample C program.
+ *
+ *
+ * This job allocates space as follows:
+ * 10000,100 SPACE-SYSPCH
+ * 11000,100 SPACE-SYSLNK
+ *
+ *
+ *
+ 
+ * Standard assignments for C programs
+ *
+ // ASSGN SYS000,SYSLNK
+ // ASSGN SYS005,SYSLST
+ // ASSGN SYS007,SYSPCH
+ *
+ *
+ * Compile zztest
+ *
+ // DLBL IJSYSPH,'ZZTEST.ASM',0,SD
+ // EXTENT SYSPCH,,,,10000,100 SPACE-SYSPCH
+ ASSGN SYSPCH,SYS000
+ // EXEC GCC,SIZE=AUTO,PARM='-S -o dd:syspunch -'
+ #include <stdio.h>
+ 
+ int main(int argc, char **argv)
+ {
+     int x;
+     
+     printf("Hi %s. This is a test of GCCVSE\n", *(argv + 1));
+     return (0);
+ }
+ /*
+ CLOSE SYSPCH,PUNCH
+ *
+ *
+ * assemble zztest
+ *
+ // DLBL IJSYSLN,,0,SD
+ // EXTENT SYSLNK,,,,11000,100 SPACE-SYSLNK
+ ASSGN SYSLNK,SYS000
+ // OPTION LINK
+ // OPTION CATAL,LIST
+  PHASE ZZTEST,S+80
+ // DLBL IJSYSIN,'ZZTEST.ASM'
+ ASSGN SYSIPT,SYS000
+ // EXEC ASSEMBLY
+ CLOSE SYSIPT,READER
+ *
+ *
+ *
+ *
+ *
+ *
+ * Now link the whole app
+ *
+  INCLUDE VSESTART
+  INCLUDE STDIO
+  INCLUDE STRING
+  INCLUDE STDLIB
+  INCLUDE CTYPE
+  INCLUDE ERRNO
+  INCLUDE LOCALE
+  INCLUDE MATH
+  INCLUDE SIGNAL
+  INCLUDE SETJMP
+  INCLUDE ASSERT
+  INCLUDE TIME
+  INCLUDE START
+  INCLUDE VSESUPA
+ // EXEC LNKEDT
+ *
+ *
+ * Now run ZZTEST
+ *
+ // EXEC ZZTEST,SIZE=AUTO,PARM='Fred'
+ /*
+ *
+ *
+ *
+ /&
+ * $$ EOJ
+ 
+ 
+ 
+ 
+ 
+ Miscellaneous notes about VSE
+ -----------------------------
+ 
+ The attempt to get GCCVSE to self-recompile on VSE has
+ not yet been done.
+ 
+ The DOS/VS linker cannot handle blank CSECTs because of a
+ bug in the linkage editor, which is fixed in VSE/380. So
+ you may find it difficult to build on an unpatched DOS/VS
+ (you can use NAMCSECT to name CSECTs), but you can still 
+ run on it.
+ 
+ Both DOS/VS and z/VSE have a restriction on the number of
+ relocatable items. GCC exceeds this by a small amount, so
+ you get this problem:
+ 
+ 2188I TOO MANY RLD ITEMS, ONLY 65534 ITEMS ARE ALLOWED
+ PHASE(S) NOT CATALOGED DUE TO ERROR
+ 
+ On DOS/VS things are worse - the same restriction exists,
+ but there is no error message - it just clobbers storage
+ (ie a bug) and then fails to catalog the executable.
+ 
+ The problem can be circumvented by making the module
+ non-relocatable, with this statement:
+ 
+  PHASE GCC,+X'7000C8'
+   
+ which you can see in compvse.m4 (the precursor to alljcl.jcl).
+ 
+ Although the GCC executable is not relocatable, it is still
+ perfectly fine for creating new relocatable programs. The
+ address of approx 7 MB should be valid in most z/VSE systems.
+ If you find it isn't, you will need to recompile from
+ source.
+ 
+ Here is the underlying technical problem (courtesy of Bill Carlborg):
+ 
+ It was interesting tracking this one down. Originally in using the relocating
+ loader the linkage editor only allowed 255 relocatable items per phase. In R34
+ they raised the number to 400. The LE reserves space at the end of its code for
+ the 400 entries before it sets up space for another table of external names. So
+ there's space in the LE for 400. But IBM never checked if they ran out of room.
+ So we got the old buffer or table overflow problem causing the kaboom. I guess
+ they figured nobody would ever hit the limit, and I've never seen it happen
+ until now. The problem is complicated in this case because we only have one
+ phase. Usually such programs under DOS/VS were multiple phases. I started
+ patching the LE raising the number up to 10000 but it still wasn't enough room. 
+ Then I ran into halfword number limitations. So I patched the LE to use
+ fullword numbers instead of halfword numbers. Raised the number to 64000,
+ still wasn't enough room. Finally by giving the table a size of 256K (about
+ 85000 items) instead of 1200 bytes (for 400 items) it did catalog. Of course
+ that means with the patches the LE will always need a partition of more than
+ 300K to run. Then we hit the next wall. With that many entries needing to be
+ relocated it would require more CIL records at the end of the phase to hold the
+ relocatable dictionary. Specifically in this case I'm guessing about an
+ additional 257 1K CIL records. The CI directory entry has a field for the
+ number of CIL records holding the relocatable dictionary. Guess what, it's only
+ one byte, max number of 255. Not big enough. So the loader sees in the
+ directory entry there are only 2 CIL records holding relocatable information. 
+ That's not gonna work. Okay, I'm done. Either the program needs to become
+ multi-phase or have fewer relocatable items or ACTION NOREL becomes the
+ permanent solution.
+ 
+ 
+ One more thing that should be done is allow at least
+ 60 MB above the 16 MB line, as that is the normal way
+ that GCC operates. This behaviour can be changed by
+ compiling without USE_MEMMGR (see stdcompd.bat).
+ 
+ 
+ The compiler asserts __VSE__ for conditional compilation.
+ 
+ 
+ The compiler is dependent on PDPCLIB, which allows
+ parameters in the following manner:
+ 
+ 1. If a PARM= is supplied, it will be used.
+ 2. Otherwise, if a SYSPARM is provided, it will be used.
+ 3. SYSPARM only allows 8 characters, so if it is set to
+ "?" then special processing will be invoked.
+ 4. If the UPSI has the first bit set to 1, then the first
+ line of SYSIPT will be treated as the parameter.
+ 5. The other UPSI bits are not yet defined so should be
+ explicitly set to 0.
+ 
+ 
+ stdin comes from SYSIPT.
+ stdout goes to SYSLST.
+ stderr goes to SYS005 which needs to be manually
+   assigned to something - usually SYSLST also.
+ 
+ 
+ PDPCLIB's VSE implementation is somewhat limited, but still
+ very useful. If you want to read from a tape, you have
+ to use a ddname of MTI1 (ie "dd:mti1"). "dd:syspunch" is
+ also recognized as being for the punch. Disk and tape 
+ files are expected to be RECFM=U. When reading from
+ disk files, the maximum blocksize will be accepted, but
+ on output, 6480 is always used, to provide a multiple of
+ both 80 and 81, which may be useful to some applications.
+ sysin (stdin) is F80 and assigned to SYSIPT, and sysprint 
+ (stdout) is F121 (including automatically-inserted, mandatory 
+ control character) and assigned to SYSLST, and both are
+ device-independent. systerm (stderr) is F80 and goes to 
+ whatever is assigned to SYS005, usually syslst.
+ 
+ Modules are typically built with a PHASE statement of
+ S+80 so that if they are executed on a DOS/VS system
+ (which has a loader that doesn't automatically provide
+ room for this), they will still be able to cope with
+ labelled tapes. The "S" rather than "*" provides
+ consistency when doing multiple links.
+ 
+ When a nominal attempt to write to a library member is done,
+ the C library will translate this into automatic punching of
+ object code which can be fed into LNKEDT to put the data
+ into the CIL. This is automatically fetched when a read
+ attempt is done. No attempt has yet been made to allow
+ similar behaviour (except BKEND/MAINT) for writing to other 
+ library types (current plan is for the DDNAME to codify the 
+ desired library type).
+ 
+ File access is done via DDNAMEs of the form dd:ddname,
+ where ddname is defined in JCL.
+ 
+ There is a concept of a "default disk" which is SYS000,
+ to reduce the amount of JCL needed to be written. All
+ normal files come from there by default.
+ 
+ The entry point is always @@MAIN (which just calls @@CRT0),
+ and normally you would not need to explicitly set that,
+ it should be automatically set.
+ 
+ 
+ 
+ 
+ Building
+ --------
+ 
+ To install from scratch you need to cross-compile from another 
+ platform. Scripts are provided for Windows.
+ 
+ First of all you need to get the source code by:
+ 
+ 1. Downloading the GCC base code (as per GCCMVS).
+ 
+ 2. Downloading the GCCMVS patch and applying it (as per GCCMVS).
+ 
+ 
+ You then need to set the configuration properly.
+ 
+ There are 4 distinct VSE programming environments possible:
+ 
+ 1. DOS/VS where everything is 24-bit. This is the S370
+ environment.
+ 
+ 2. z/VSE where it is possible to write 31-bit executables 
+ that reside above the 16 MB line. This is the S390
+ environment.
+ 
+ 3. VSE/380 where 31-bit executables can be created, but they
+ must reside below the line and they can only obtain a single
+ chunk of ATL memory (current restriction). This is the S380
+ environment.
+ 
+ 4. VSE/XA where 31-bit capability exists, but I/O macros
+ necessitate that the executable must reside below the line.
+ This is also the S380 environment (the only difference is
+ that use of MEMMGR is not mandatory).
+ 
+ 
+ The differences between categories 3 and 4 are as follows:
+ 
+ 1. VSE/XA can get control in 31-bit mode, not requiring
+ an AMODE switch.
+ 
+ 2. VSE/XA can make multiple ATL memory requests.
+ 
+ 
+ Rather than create another flavor of the code, PDPCLIB
+ was written such that S380 mode:
+ 
+ 1. Detects whether it was called in 31-bit or 24-bit mode
+ and switches to 31-bit mode if not already in that. This
+ code is in vsestart.asm and could potentially be removed.
+ 
+ 2. Uses an internal heap manager (memmgr) so that only a
+ single request for a chunk of 31-bit memory is made. This
+ is faster than repeatedly calling the operating system
+ anyway, but can be reversed out by not defining USE_MEMMGR
+ in stdcompd.bat.
+ 
+ 
+ You can build the cross-compiler and then produce the
+ assembler code that can be transferred to VSE by using
+ the "allvse.bat" file (after inspecting it for any
+ required modifications). However, that batch file relies
+ on the existence of other VSE-based programs, which
+ are built by "vseutil.bat". Although those utilities 
+ are at least nominally optional.
+ 
+ Don't worry about the fact that the executable is called
+ gccmvs.exe and the batch file is also called mvs.  The
+ name is shared, but they are different. The executable
+ is manually renamed from gccmvs.exe to gccvse.exe before
+ shipment.
+ 
+ At time of writing, precompiled binaries were only available
+ as part of the VSE/380 distribution:
+ http://mvs380.sourceforge.net
+ 
+ 
+ 
+ 
+ Version
+ -------
+ 
+ To find out version, you can go:
+ 
+ EXEC GCC,PARM='--version'
+ 
+ 
+ 
+ Support
+ -------
+ 
+ Try asking a generic GCC question here:
+ 
+ http://tech.groups.yahoo.com/group/hercules-os380/
+ 
+ If your question is more VSE-related than GCC-related,
+ a broader range of VSE expertise is available here:
+ 
+ http://tech.groups.yahoo.com/group/H390-DOSVS/
+ 
+ 
+ 
+ Future direction
+ ----------------
+ 
+ * Get GCCVSE to self-recompile on VSE/380
+ 
+ * Write and then use a utility to make an executable self-relocating
+ 
+ * Build from minizip (compressed) input
+ 
+ * PDPCLIB should recognize long DDNAMEs like sdi2fb133 and adjust
+ LRECL appropriately.
+ 
+ * PDPCLIB should be able to deblock fb files.
+ 
+ * PDPCLIB should generate BKEND output when writing to f80 library.
+ 
+ * Make use of private libraries instead of putting everything
+ directly into system libraries.
+ 
+ * Get autolink working.
+ 
+ * PDPCLIB should read from a DDNAME such as SYSDIR whenever an
+ attempt is made to read a nominal PDS. Perhaps a member name
+ of '*' signifies a PDS directory read. That way minizip can
+ get an MVS-style member list and start reading things like
+ header files from the CIL.
+ 
+ * PDPCLIB should probably be using LOAD rather than CDLOAD
+ to use less memory. But that would require 24-bit storage
+ to be obtained, so malloc wouldn't necessarily be appropriate.
+ 
+ * Produce a 24-bit executable.
+ 
Index: gcc/gcc/gccxat.exec
diff -c nul gcc/gcc/gccxat.exec:1.1
*** nul	Tue Oct 01 16:28:45 2019
--- gcc/gcc/gccxat.exec	Mon Nov 20 10:48:30 2006
***************
*** 0 ****
--- 1,34 ----
+ *
+ *
+ * EXEC EXEC TO ROUGHLY THE VERSION OF CMS IN USE
+ *
+ * AS VM/370 DOES NOT UNDERSTAND YET UNDERSTAND (STACK
+ * WE NEED TO CHECK IF THE INFO HAS BEEN STACKED
+ * IF NOTHING IS STACKED ASSUME VM/370
+ *
+ * BUGS:-
+ * CURRENTLY ASSUME STACK IS EMPTY WHEN WE START
+ * STACK IS ALWAYS EMPTY ON RETURN
+ *
+ *
+ * WRITTEN BY DAVE WADE,G4UGM@HOTMAIL.COM
+ * RELEASED INTO THE PUBLIC DOMAIN
+ * USE AT YOUR OWN RISK
+ *
+ &CONTROL OFF
+ &STACK HT
+ QUERY CMSLEVEL ( STACK
+ &STACK RT
+ &FRED = &READFLAG
+ *TYPE &FRED
+ &IF &FRED EQ CONSOLE &GOTO -VM370
+ &READ VARS &CMS &LEVEL &LVL
+ *TYPE CMS Level &LVL
+ &IF &LVL EQ 6, &GOTO -VM370
+ *TYPE VM XA
+ DESBUF
+ &EXIT 1
+ -VM370
+ DESBUF
+ *TYPE VM/370
+ &EXIT 0
Index: gcc/gcc/gcov-io.h
diff -c gcc/gcc/gcov-io.h:1.1.1.1 gcc/gcc/gcov-io.h:1.3
*** gcc/gcc/gcov-io.h:1.1.1.1	Wed Feb 15 21:22:25 2006
--- gcc/gcc/gcov-io.h	Tue Oct 31 15:05:31 2006
***************
*** 22,28 ****
--- 22,30 ----
  #ifndef GCC_GCOV_IO_H
  #define GCC_GCOV_IO_H
  #include <stdio.h>
+ #ifdef HAVE_SYS_TYPES_H
  #include <sys/types.h>
+ #endif
  
  static int __fetch_long	PARAMS ((long *, char *, size_t)) ATTRIBUTE_UNUSED;
  static int __read_long  PARAMS ((long *, FILE *, size_t)) ATTRIBUTE_UNUSED;
Index: gcc/gcc/gencheck.h
diff -c nul gcc/gcc/gencheck.h:1.3
*** nul	Tue Oct 01 16:28:45 2019
--- gcc/gcc/gencheck.h	Wed Nov 01 19:45:52 2006
***************
*** 0 ****
--- 1 ----
+ /* empty file */
Index: gcc/gcc/gencomp.bat
diff -c nul gcc/gcc/gencomp.bat:1.21
*** nul	Tue Oct 01 16:28:45 2019
--- gcc/gcc/gencomp.bat	Mon Jun 18 04:17:51 2018
***************
*** 0 ****
--- 1,135 ----
+ rem set mdfile=./config/i386/i386.md
+ rem set mdfile=./config/s390/s390.md
+ set mdfile=./config/i370/i370.md
+ 
+ del *.o
+ ren gencomp.exec gencomp.save
+ del gen*.exe
+ ren gencomp.save gencomp.exec
+ del libiberty.a
+ del autos.zip
+ 
+ zip -0 -m -@ -X autos.zip <genfiles.txt
+ unzip autos config.h auto-host.h hconfig.h configargs.h tm_p.h multilib.h gencheck.h options.h specs.h
+ 
+ call stdcompz ..\libiberty\xmalloc.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompz ..\libiberty\xstrerror.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompz ..\libiberty\xstrdup.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompz ..\libiberty\xexit.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompz ..\libiberty\concat.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompz ..\libiberty\hex.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompz ..\libiberty\alloca.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompz ..\libiberty\lbasename.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompz ..\libiberty\obstack.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompz ..\libiberty\strsignal.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompz ..\libiberty\safe-ctype.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompz ..\libiberty\splay-tree.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompz ..\libiberty\fibheap.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompz ..\libiberty\hashtab.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompz ..\libiberty\asprintf.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompz ..\libiberty\vasprintf.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompz ..\libiberty\getpagesize.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompz ..\libiberty\partition.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ 
+ ar rc libiberty.a *.o
+ ranlib libiberty.a
+ 
+ call stdcompz gengenrtl.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ 
+ gcc -nostdlib -o gengenrtl.exe gengenrtl.o libiberty.a ../../pdos/pdpclib/pdpwin32.a -lkernel32 -lgcc
+ 
+ gengenrtl -h >genrtl.h
+ gengenrtl >genrtl.c
+ 
+ call stdcompz gencheck.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ 
+ gcc -nostdlib -o gencheck.exe gencheck.o libiberty.a ../../pdos/pdpclib/pdpwin32.a -lkernel32 -lgcc
+ 
+ gencheck >tree-check.h
+ 
+ call stdcompz bitmap.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompz print-rtl.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompz rtl.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ 
+ call stdcompz errors.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompz read-rtl.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompz ggc-none.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ call stdcompz gensupport.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ 
+ call stdcompz genflags.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ 
+ gcc -nostdlib -o genflags.exe genflags.o rtl.o read-rtl.o bitmap.o ggc-none.o gensupport.o print-rtl.o errors.o libiberty.a ../../pdos/pdpclib/pdpwin32.a -lkernel32 -lgcc
+ 
+ genflags %mdfile% >insn-flags.h
+ 
+ call stdcompz genconstants.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ 
+ gcc -nostdlib -o genconstants.exe genconstants.o rtl.o read-rtl.o bitmap.o ggc-none.o gensupport.o errors.o libiberty.a ../../pdos/pdpclib/pdpwin32.a -lkernel32 -lgcc
+ 
+ genconstants %mdfile% >insn-constants.h
+ 
+ call stdcompz genpreds.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ 
+ gcc -nostdlib -o genpreds.exe genpreds.o libiberty.a ../../pdos/pdpclib/pdpwin32.a -lkernel32 -lgcc
+ 
+ genpreds >tm-preds.h
+ 
+ call stdcompz genconfig.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ 
+ gcc -nostdlib -o genconfig.exe genconfig.o rtl.o read-rtl.o bitmap.o ggc-none.o gensupport.o print-rtl.o errors.o libiberty.a ../../pdos/pdpclib/pdpwin32.a -lkernel32 -lgcc
+ 
+ genconfig %mdfile% >insn-config.h
+ 
+ call stdcompz gencodes.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ 
+ gcc -nostdlib -o gencodes.exe gencodes.o rtl.o read-rtl.o bitmap.o ggc-none.o gensupport.o print-rtl.o errors.o libiberty.a ../../pdos/pdpclib/pdpwin32.a -lkernel32 -lgcc
+ 
+ gencodes %mdfile% >insn-codes.h
+ 
+ call stdcompz genattr.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ 
+ gcc -nostdlib -o genattr.exe genattr.o rtl.o read-rtl.o bitmap.o ggc-none.o gensupport.o print-rtl.o errors.o libiberty.a ../../pdos/pdpclib/pdpwin32.a -lkernel32 -lgcc
+ 
+ genattr %mdfile% >insn-attr.h
+ 
+ call stdcompz genattrtab.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ 
+ gcc -nostdlib -o genattrtab.exe genattrtab.o rtl.o read-rtl.o bitmap.o ggc-none.o gensupport.o print-rtl.o errors.o libiberty.a ../../pdos/pdpclib/pdpwin32.a -lkernel32 -lgcc
+ 
+ genattrtab %mdfile% >insn-attrtab.c
+ 
+ call stdcompz genemit.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ 
+ gcc -nostdlib -o genemit.exe genemit.o rtl.o read-rtl.o bitmap.o ggc-none.o gensupport.o print-rtl.o errors.o libiberty.a ../../pdos/pdpclib/pdpwin32.a -lkernel32 -lgcc
+ 
+ genemit %mdfile% >insn-emit.c
+ 
+ call stdcompz genextract.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ 
+ gcc -nostdlib -o genextract.exe genextract.o rtl.o read-rtl.o bitmap.o ggc-none.o gensupport.o print-rtl.o errors.o libiberty.a ../../pdos/pdpclib/pdpwin32.a -lkernel32 -lgcc
+ 
+ genextract.exe %mdfile% >insn-extract.c
+ 
+ call stdcompz genopinit.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ 
+ gcc -nostdlib -o genopinit.exe genopinit.o rtl.o read-rtl.o bitmap.o ggc-none.o gensupport.o print-rtl.o errors.o libiberty.a ../../pdos/pdpclib/pdpwin32.a -lkernel32 -lgcc
+ 
+ genopinit %mdfile% >insn-opinit.c
+ 
+ call stdcompz genoutput.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ 
+ gcc -nostdlib -o genoutput.exe genoutput.o rtl.o read-rtl.o bitmap.o ggc-none.o gensupport.o print-rtl.o errors.o libiberty.a ../../pdos/pdpclib/pdpwin32.a -lkernel32 -lgcc
+ 
+ genoutput %mdfile% >insn-output.c
+ 
+ call stdcompz genpeep.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ 
+ gcc -nostdlib -o genpeep.exe genpeep.o rtl.o read-rtl.o bitmap.o ggc-none.o gensupport.o print-rtl.o errors.o libiberty.a ../../pdos/pdpclib/pdpwin32.a -lkernel32 -lgcc
+ 
+ genpeep %mdfile% >insn-peep.c
+ 
+ call stdcompz genrecog.c %1 %2 %3 %4 %5 %6 %7 %8 %9
+ 
+ gcc -nostdlib -o genrecog.exe genrecog.o rtl.o read-rtl.o bitmap.o ggc-none.o gensupport.o print-rtl.o errors.o libiberty.a ../../pdos/pdpclib/pdpwin32.a -lkernel32 -lgcc
+ 
+ genrecog %mdfile% >insn-recog.c
Index: gcc/gcc/gencomp.exec
diff -c nul gcc/gcc/gencomp.exec:1.13
*** nul	Tue Oct 01 16:28:45 2019
--- gcc/gcc/gencomp.exec	Thu Aug 20 19:01:54 2009
***************
*** 0 ****
--- 1,605 ----
+ * Usage - GENCOMP <SRC>
+ 
+ * This script compiles and builds the generated files
+ 
+ &SRC = &1
+ 
+ 
+ EXEC GCCE XMALLOC C &SRC (PARM GENCOMP
+ EXEC GCCE XSTRERRO C &SRC (PARM GENCOMP
+ EXEC GCCE XSTRDUP C &SRC (PARM GENCOMP
+ EXEC GCCE XEXIT C &SRC (PARM GENCOMP
+ EXEC GCCE CONCAT C &SRC (PARM GENCOMP
+ EXEC GCCE HEX C &SRC (PARM GENCOMP
+ EXEC GCCE ALLOCA C &SRC (PARM GENCOMP
+ EXEC GCCE LBASENAM C &SRC (PARM GENCOMP
+ EXEC GCCE OBSTACK C &SRC (PARM GENCOMP
+ EXEC GCCE STRSIGNA C &SRC (PARM GENCOMP
+ EXEC GCCE SAFE-CTY C &SRC (PARM GENCOMP
+ EXEC GCCE SPLAY-TR C &SRC (PARM GENCOMP
+ EXEC GCCE FIBHEAP C &SRC (PARM GENCOMP
+ EXEC GCCE HASHTAB C &SRC (PARM GENCOMP
+ EXEC GCCE ASPRINTF C &SRC (PARM GENCOMP
+ EXEC GCCE VASPRINT C &SRC (PARM GENCOMP
+ EXEC GCCE GETPAGES C &SRC (PARM GENCOMP
+ EXEC GCCE PARTITIO C &SRC (PARM GENCOMP
+ 
+ 
+ EXEC GCCE GENGENRT C &SRC (PARM GENCOMP
+ 
+ &STACK HT
+ LOAD GENGENRT (NOAUTO NOLIBE NOMAP
+  INCLUDE XMALLOC (NOLIBE NOAUTO
+  INCLUDE XSTRERRO (NOLIBE NOAUTO
+  INCLUDE XSTRDUP (NOLIBE NOAUTO
+  INCLUDE XEXIT (NOLIBE NOAUTO
+  INCLUDE CONCAT (NOLIBE NOAUTO
+  INCLUDE HEX (NOLIBE NOAUTO
+  INCLUDE ALLOCA (NOLIBE NOAUTO
+  INCLUDE LBASENAM (NOLIBE NOAUTO
+  INCLUDE OBSTACK (NOLIBE NOAUTO
+  INCLUDE STRSIGNA (NOLIBE NOAUTO
+  INCLUDE SAFE-CTY (NOLIBE NOAUTO
+  INCLUDE SPLAY-TR (NOLIBE NOAUTO
+  INCLUDE FIBHEAP (NOLIBE NOAUTO
+  INCLUDE HASHTAB (NOLIBE NOAUTO
+  INCLUDE ASPRINTF (NOLIBE NOAUTO
+  INCLUDE VASPRINT (NOLIBE NOAUTO
+  INCLUDE GETPAGES (NOLIBE NOAUTO
+ &STACK RT
+ INCLUDE PARTITIO (NOAUTO
+ 
+ GENMOD GENGENRT
+ 
+ FILEDEF SYSPRINT DISK GENRTL H &SRC (LRECL 2000 RECFM V
+ GENGENRT -h
+ FILEDEF SYSPRINT CLEAR
+ 
+ FILEDEF SYSPRINT DISK GENRTL C &SRC (LRECL 2000 RECFM V
+ GENGENRT
+ FILEDEF SYSPRINT CLEAR
+ 
+ 
+ EXEC GCCE GENCHECK C &SRC (PARM GENCOMP
+ 
+ &STACK HT
+ LOAD GENCHECK (NOAUTO NOLIBE NOMAP
+  INCLUDE XMALLOC (NOLIBE NOAUTO
+  INCLUDE XSTRERRO (NOLIBE NOAUTO
+  INCLUDE XSTRDUP (NOLIBE NOAUTO
+  INCLUDE XEXIT (NOLIBE NOAUTO
+  INCLUDE CONCAT (NOLIBE NOAUTO
+  INCLUDE HEX (NOLIBE NOAUTO
+  INCLUDE ALLOCA (NOLIBE NOAUTO
+  INCLUDE LBASENAM (NOLIBE NOAUTO
+  INCLUDE OBSTACK (NOLIBE NOAUTO
+  INCLUDE STRSIGNA (NOLIBE NOAUTO
+  INCLUDE SAFE-CTY (NOLIBE NOAUTO
+  INCLUDE SPLAY-TR (NOLIBE NOAUTO
+  INCLUDE FIBHEAP (NOLIBE NOAUTO
+  INCLUDE HASHTAB (NOLIBE NOAUTO
+  INCLUDE ASPRINTF (NOLIBE NOAUTO
+  INCLUDE VASPRINT (NOLIBE NOAUTO
+  INCLUDE GETPAGES (NOLIBE NOAUTO
+ &STACK RT
+ INCLUDE PARTITIO (NOAUTO
+ 
+ GENMOD GENCHECK
+ 
+ FILEDEF SYSPRINT DISK TREE-CHE H &SRC (LRECL 2000 RECFM V
+ GENCHECK
+ FILEDEF SYSPRINT CLEAR
+ 
+ 
+ EXEC GCCE BITMAP C &SRC (PARM GENCOMP
+ EXEC GCCE PRINT-RT C &SRC (PARM GENCOMP
+ EXEC GCCE RTL C &SRC (PARM GENCOMP
+ EXEC GCCE ERRORS C &SRC (PARM GENCOMP
+ EXEC GCCE READ-RTL C &SRC (PARM GENCOMP
+ EXEC GCCE GGC-NONE C &SRC (PARM GENCOMP
+ EXEC GCCE GENSUPPO C &SRC (PARM GENCOMP
+ 
+ 
+ EXEC GCCE GENFLAGS C &SRC (PARM GENCOMP
+ 
+ &STACK HT
+ LOAD GENFLAGS (NOAUTO NOLIBE NOMAP
+  INCLUDE XMALLOC (NOLIBE NOAUTO
+  INCLUDE XSTRERRO (NOLIBE NOAUTO
+  INCLUDE XSTRDUP (NOLIBE NOAUTO
+  INCLUDE XEXIT (NOLIBE NOAUTO
+  INCLUDE CONCAT (NOLIBE NOAUTO
+  INCLUDE HEX (NOLIBE NOAUTO
+  INCLUDE ALLOCA (NOLIBE NOAUTO
+  INCLUDE LBASENAM (NOLIBE NOAUTO
+  INCLUDE OBSTACK (NOLIBE NOAUTO
+  INCLUDE STRSIGNA (NOLIBE NOAUTO
+  INCLUDE SAFE-CTY (NOLIBE NOAUTO
+  INCLUDE SPLAY-TR (NOLIBE NOAUTO
+  INCLUDE FIBHEAP (NOLIBE NOAUTO
+  INCLUDE HASHTAB (NOLIBE NOAUTO
+  INCLUDE ASPRINTF (NOLIBE NOAUTO
+  INCLUDE VASPRINT (NOLIBE NOAUTO
+  INCLUDE GETPAGES (NOLIBE NOAUTO
+  INCLUDE PARTITIO (NOLIBE NOAUTO
+  INCLUDE RTL (NOLIBE NOAUTO
+  INCLUDE READ-RTL (NOLIBE NOAUTO
+  INCLUDE BITMAP (NOLIBE NOAUTO
+  INCLUDE GGC-NONE (NOLIBE NOAUTO
+  INCLUDE GENSUPPO (NOLIBE NOAUTO
+  INCLUDE PRINT-RT (NOLIBE NOAUTO
+ &STACK RT
+ INCLUDE ERRORS (NOAUTO
+ 
+ GENMOD GENFLAGS
+ 
+ FILEDEF SYSPRINT DISK INSN-FLA H &SRC (LRECL 2000 RECFM V
+ GENFLAGS "I370 MD"
+ FILEDEF SYSPRINT CLEAR
+ 
+ 
+ EXEC GCCE GENCONST C &SRC (PARM GENCOMP
+ 
+ &STACK HT
+ LOAD GENCONST (NOAUTO NOLIBE NOMAP
+  INCLUDE XMALLOC (NOLIBE NOAUTO
+  INCLUDE XSTRERRO (NOLIBE NOAUTO
+  INCLUDE XSTRDUP (NOLIBE NOAUTO
+  INCLUDE XEXIT (NOLIBE NOAUTO
+  INCLUDE CONCAT (NOLIBE NOAUTO
+  INCLUDE HEX (NOLIBE NOAUTO
+  INCLUDE ALLOCA (NOLIBE NOAUTO
+  INCLUDE LBASENAM (NOLIBE NOAUTO
+  INCLUDE OBSTACK (NOLIBE NOAUTO
+  INCLUDE STRSIGNA (NOLIBE NOAUTO
+  INCLUDE SAFE-CTY (NOLIBE NOAUTO
+  INCLUDE SPLAY-TR (NOLIBE NOAUTO
+  INCLUDE FIBHEAP (NOLIBE NOAUTO
+  INCLUDE HASHTAB (NOLIBE NOAUTO
+  INCLUDE ASPRINTF (NOLIBE NOAUTO
+  INCLUDE VASPRINT (NOLIBE NOAUTO
+  INCLUDE GETPAGES (NOLIBE NOAUTO
+  INCLUDE PARTITIO (NOLIBE NOAUTO
+  INCLUDE RTL (NOLIBE NOAUTO
+  INCLUDE READ-RTL (NOLIBE NOAUTO
+  INCLUDE BITMAP (NOLIBE NOAUTO
+  INCLUDE GGC-NONE (NOLIBE NOAUTO
+  INCLUDE GENSUPPO (NOLIBE NOAUTO
+ &STACK RT
+ INCLUDE ERRORS (NOAUTO
+ 
+ GENMOD GENCONST
+ 
+ FILEDEF SYSPRINT DISK I-CONSTA H &SRC (LRECL 2000 RECFM V
+ GENCONST "I370 MD"
+ FILEDEF SYSPRINT CLEAR
+ 
+ 
+ EXEC GCCE GENPREDS C &SRC (PARM GENCOMP
+ 
+ &STACK HT
+ LOAD GENPREDS (NOAUTO NOLIBE NOMAP
+  INCLUDE XMALLOC (NOLIBE NOAUTO
+  INCLUDE XSTRERRO (NOLIBE NOAUTO
+  INCLUDE XSTRDUP (NOLIBE NOAUTO
+  INCLUDE XEXIT (NOLIBE NOAUTO
+  INCLUDE CONCAT (NOLIBE NOAUTO
+  INCLUDE HEX (NOLIBE NOAUTO
+  INCLUDE ALLOCA (NOLIBE NOAUTO
+  INCLUDE LBASENAM (NOLIBE NOAUTO
+  INCLUDE OBSTACK (NOLIBE NOAUTO
+  INCLUDE STRSIGNA (NOLIBE NOAUTO
+  INCLUDE SAFE-CTY (NOLIBE NOAUTO
+  INCLUDE SPLAY-TR (NOLIBE NOAUTO
+  INCLUDE FIBHEAP (NOLIBE NOAUTO
+  INCLUDE HASHTAB (NOLIBE NOAUTO
+  INCLUDE ASPRINTF (NOLIBE NOAUTO
+  INCLUDE VASPRINT (NOLIBE NOAUTO
+  INCLUDE GETPAGES (NOLIBE NOAUTO
+ &STACK RT
+ INCLUDE PARTITIO (NOAUTO
+ 
+ GENMOD GENPREDS
+ 
+ FILEDEF SYSPRINT DISK TM-PREDS H &SRC (LRECL 2000 RECFM V
+ GENPREDS
+ FILEDEF SYSPRINT CLEAR
+ 
+ 
+ EXEC GCCE GENCONFI C &SRC (PARM GENCOMP
+ 
+ &STACK HT
+ LOAD GENCONFI (NOAUTO NOLIBE NOMAP
+  INCLUDE XMALLOC (NOLIBE NOAUTO
+  INCLUDE XSTRERRO (NOLIBE NOAUTO
+  INCLUDE XSTRDUP (NOLIBE NOAUTO
+  INCLUDE XEXIT (NOLIBE NOAUTO
+  INCLUDE CONCAT (NOLIBE NOAUTO
+  INCLUDE HEX (NOLIBE NOAUTO
+  INCLUDE ALLOCA (NOLIBE NOAUTO
+  INCLUDE LBASENAM (NOLIBE NOAUTO
+  INCLUDE OBSTACK (NOLIBE NOAUTO
+  INCLUDE STRSIGNA (NOLIBE NOAUTO
+  INCLUDE SAFE-CTY (NOLIBE NOAUTO
+  INCLUDE SPLAY-TR (NOLIBE NOAUTO
+  INCLUDE FIBHEAP (NOLIBE NOAUTO
+  INCLUDE HASHTAB (NOLIBE NOAUTO
+  INCLUDE ASPRINTF (NOLIBE NOAUTO
+  INCLUDE VASPRINT (NOLIBE NOAUTO
+  INCLUDE GETPAGES (NOLIBE NOAUTO
+  INCLUDE PARTITIO (NOLIBE NOAUTO
+  INCLUDE RTL (NOLIBE NOAUTO
+  INCLUDE READ-RTL (NOLIBE NOAUTO
+  INCLUDE BITMAP (NOLIBE NOAUTO
+  INCLUDE GGC-NONE (NOLIBE NOAUTO
+  INCLUDE GENSUPPO (NOLIBE NOAUTO
+  INCLUDE PRINT-RT (NOLIBE NOAUTO
+ &STACK RT
+ INCLUDE ERRORS (NOAUTO
+ 
+ GENMOD GENCONFI
+ 
+ FILEDEF SYSPRINT DISK INSN-CON H &SRC (LRECL 2000 RECFM V
+ GENCONFI "I370 MD"
+ FILEDEF SYSPRINT CLEAR
+ 
+ 
+ EXEC GCCE GENCODES C &SRC (PARM GENCOMP
+ 
+ &STACK HT
+ LOAD GENCODES (NOAUTO NOLIBE NOMAP
+  INCLUDE XMALLOC (NOLIBE NOAUTO
+  INCLUDE XSTRERRO (NOLIBE NOAUTO
+  INCLUDE XSTRDUP (NOLIBE NOAUTO
+  INCLUDE XEXIT (NOLIBE NOAUTO
+  INCLUDE CONCAT (NOLIBE NOAUTO
+  INCLUDE HEX (NOLIBE NOAUTO
+  INCLUDE ALLOCA (NOLIBE NOAUTO
+  INCLUDE LBASENAM (NOLIBE NOAUTO
+  INCLUDE OBSTACK (NOLIBE NOAUTO
+  INCLUDE STRSIGNA (NOLIBE NOAUTO
+  INCLUDE SAFE-CTY (NOLIBE NOAUTO
+  INCLUDE SPLAY-TR (NOLIBE NOAUTO
+  INCLUDE FIBHEAP (NOLIBE NOAUTO
+  INCLUDE HASHTAB (NOLIBE NOAUTO
+  INCLUDE ASPRINTF (NOLIBE NOAUTO
+  INCLUDE VASPRINT (NOLIBE NOAUTO
+  INCLUDE GETPAGES (NOLIBE NOAUTO
+  INCLUDE PARTITIO (NOLIBE NOAUTO
+  INCLUDE RTL (NOLIBE NOAUTO
+  INCLUDE READ-RTL (NOLIBE NOAUTO
+  INCLUDE BITMAP (NOLIBE NOAUTO
+  INCLUDE GGC-NONE (NOLIBE NOAUTO
+  INCLUDE GENSUPPO (NOLIBE NOAUTO
+  INCLUDE PRINT-RT (NOLIBE NOAUTO
+ &STACK RT
+ INCLUDE ERRORS (NOAUTO
+ 
+ GENMOD GENCODES
+ 
+ FILEDEF SYSPRINT DISK INSN-COD H &SRC (LRECL 2000 RECFM V
+ GENCODES "I370 MD"
+ FILEDEF SYSPRINT CLEAR
+ 
+ 
+ EXEC GCCE GENATTR C &SRC (PARM GENCOMP
+ 
+ &STACK HT
+ LOAD GENATTR (NOAUTO NOLIBE NOMAP
+  INCLUDE XMALLOC (NOLIBE NOAUTO
+  INCLUDE XSTRERRO (NOLIBE NOAUTO
+  INCLUDE XSTRDUP (NOLIBE NOAUTO
+  INCLUDE XEXIT (NOLIBE NOAUTO
+  INCLUDE CONCAT (NOLIBE NOAUTO
+  INCLUDE HEX (NOLIBE NOAUTO
+  INCLUDE ALLOCA (NOLIBE NOAUTO
+  INCLUDE LBASENAM (NOLIBE NOAUTO
+  INCLUDE OBSTACK (NOLIBE NOAUTO
+  INCLUDE STRSIGNA (NOLIBE NOAUTO
+  INCLUDE SAFE-CTY (NOLIBE NOAUTO
+  INCLUDE SPLAY-TR (NOLIBE NOAUTO
+  INCLUDE FIBHEAP (NOLIBE NOAUTO
+  INCLUDE HASHTAB (NOLIBE NOAUTO
+  INCLUDE ASPRINTF (NOLIBE NOAUTO
+  INCLUDE VASPRINT (NOLIBE NOAUTO
+  INCLUDE GETPAGES (NOLIBE NOAUTO
+  INCLUDE PARTITIO (NOLIBE NOAUTO
+  INCLUDE RTL (NOLIBE NOAUTO
+  INCLUDE READ-RTL (NOLIBE NOAUTO
+  INCLUDE BITMAP (NOLIBE NOAUTO
+  INCLUDE GGC-NONE (NOLIBE NOAUTO
+  INCLUDE GENSUPPO (NOLIBE NOAUTO
+  INCLUDE PRINT-RT (NOLIBE NOAUTO
+ &STACK RT
+ INCLUDE ERRORS (NOAUTO
+ 
+ GENMOD GENATTR
+ 
+ FILEDEF SYSPRINT DISK INSN-ATT H &SRC (LRECL 2000 RECFM V
+ GENATTR "I370 MD"
+ FILEDEF SYSPRINT CLEAR
+ 
+ 
+ EXEC GCCE GENATTRT C &SRC (PARM GENCOMP
+ 
+ &STACK HT
+ LOAD GENATTRT (NOAUTO NOLIBE NOMAP
+  INCLUDE XMALLOC (NOLIBE NOAUTO
+  INCLUDE XSTRERRO (NOLIBE NOAUTO
+  INCLUDE XSTRDUP (NOLIBE NOAUTO
+  INCLUDE XEXIT (NOLIBE NOAUTO
+  INCLUDE CONCAT (NOLIBE NOAUTO
+  INCLUDE HEX (NOLIBE NOAUTO
+  INCLUDE ALLOCA (NOLIBE NOAUTO
+  INCLUDE LBASENAM (NOLIBE NOAUTO
+  INCLUDE OBSTACK (NOLIBE NOAUTO
+  INCLUDE STRSIGNA (NOLIBE NOAUTO
+  INCLUDE SAFE-CTY (NOLIBE NOAUTO
+  INCLUDE SPLAY-TR (NOLIBE NOAUTO
+  INCLUDE FIBHEAP (NOLIBE NOAUTO
+  INCLUDE HASHTAB (NOLIBE NOAUTO
+  INCLUDE ASPRINTF (NOLIBE NOAUTO
+  INCLUDE VASPRINT (NOLIBE NOAUTO
+  INCLUDE GETPAGES (NOLIBE NOAUTO
+  INCLUDE PARTITIO (NOLIBE NOAUTO
+  INCLUDE RTL (NOLIBE NOAUTO
+  INCLUDE READ-RTL (NOLIBE NOAUTO
+  INCLUDE BITMAP (NOLIBE NOAUTO
+  INCLUDE GGC-NONE (NOLIBE NOAUTO
+  INCLUDE GENSUPPO (NOLIBE NOAUTO
+  INCLUDE PRINT-RT (NOLIBE NOAUTO
+ &STACK RT
+ INCLUDE ERRORS (NOAUTO
+ 
+ GENMOD GENATTRT
+ 
+ FILEDEF SYSPRINT DISK INSN-ATT C &SRC (LRECL 2000 RECFM V
+ GENATTRT "I370 MD"
+ FILEDEF SYSPRINT CLEAR
+ 
+ 
+ EXEC GCCE GENEMIT C &SRC (PARM GENCOMP
+ 
+ &STACK HT
+ LOAD GENEMIT (NOAUTO NOLIBE NOMAP
+  INCLUDE XMALLOC (NOLIBE NOAUTO
+  INCLUDE XSTRERRO (NOLIBE NOAUTO
+  INCLUDE XSTRDUP (NOLIBE NOAUTO
+  INCLUDE XEXIT (NOLIBE NOAUTO
+  INCLUDE CONCAT (NOLIBE NOAUTO
+  INCLUDE HEX (NOLIBE NOAUTO
+  INCLUDE ALLOCA (NOLIBE NOAUTO
+  INCLUDE LBASENAM (NOLIBE NOAUTO
+  INCLUDE OBSTACK (NOLIBE NOAUTO
+  INCLUDE STRSIGNA (NOLIBE NOAUTO
+  INCLUDE SAFE-CTY (NOLIBE NOAUTO
+  INCLUDE SPLAY-TR (NOLIBE NOAUTO
+  INCLUDE FIBHEAP (NOLIBE NOAUTO
+  INCLUDE HASHTAB (NOLIBE NOAUTO
+  INCLUDE ASPRINTF (NOLIBE NOAUTO
+  INCLUDE VASPRINT (NOLIBE NOAUTO
+  INCLUDE GETPAGES (NOLIBE NOAUTO
+  INCLUDE PARTITIO (NOLIBE NOAUTO
+  INCLUDE RTL (NOLIBE NOAUTO
+  INCLUDE READ-RTL (NOLIBE NOAUTO
+  INCLUDE BITMAP (NOLIBE NOAUTO
+  INCLUDE GGC-NONE (NOLIBE NOAUTO
+  INCLUDE GENSUPPO (NOLIBE NOAUTO
+  INCLUDE PRINT-RT (NOLIBE NOAUTO
+ &STACK RT
+ INCLUDE ERRORS (NOAUTO
+ 
+ GENMOD GENEMIT
+ 
+ FILEDEF SYSPRINT DISK INSN-EMI C &SRC (LRECL 2000 RECFM V
+ GENEMIT "I370 MD"
+ FILEDEF SYSPRINT CLEAR
+ 
+ 
+ EXEC GCCE GENEXTRA C &SRC (PARM GENCOMP
+ 
+ &STACK HT
+ LOAD GENEXTRA (NOAUTO NOLIBE NOMAP
+  INCLUDE XMALLOC (NOLIBE NOAUTO
+  INCLUDE XSTRERRO (NOLIBE NOAUTO
+  INCLUDE XSTRDUP (NOLIBE NOAUTO
+  INCLUDE XEXIT (NOLIBE NOAUTO
+  INCLUDE CONCAT (NOLIBE NOAUTO
+  INCLUDE HEX (NOLIBE NOAUTO
+  INCLUDE ALLOCA (NOLIBE NOAUTO
+  INCLUDE LBASENAM (NOLIBE NOAUTO
+  INCLUDE OBSTACK (NOLIBE NOAUTO
+  INCLUDE STRSIGNA (NOLIBE NOAUTO
+  INCLUDE SAFE-CTY (NOLIBE NOAUTO
+  INCLUDE SPLAY-TR (NOLIBE NOAUTO
+  INCLUDE FIBHEAP (NOLIBE NOAUTO
+  INCLUDE HASHTAB (NOLIBE NOAUTO
+  INCLUDE ASPRINTF (NOLIBE NOAUTO
+  INCLUDE VASPRINT (NOLIBE NOAUTO
+  INCLUDE GETPAGES (NOLIBE NOAUTO
+  INCLUDE PARTITIO (NOLIBE NOAUTO
+  INCLUDE RTL (NOLIBE NOAUTO
+  INCLUDE READ-RTL (NOLIBE NOAUTO
+  INCLUDE BITMAP (NOLIBE NOAUTO
+  INCLUDE GGC-NONE (NOLIBE NOAUTO
+  INCLUDE GENSUPPO (NOLIBE NOAUTO
+  INCLUDE PRINT-RT (NOLIBE NOAUTO
+ &STACK RT
+ INCLUDE ERRORS (NOAUTO
+ 
+ GENMOD GENEXTRA
+ 
+ FILEDEF SYSPRINT DISK INSN-EXT C &SRC (LRECL 2000 RECFM V
+ GENEXTRA "I370 MD"
+ FILEDEF SYSPRINT CLEAR
+ 
+ 
+ EXEC GCCE GENOPINI C &SRC (PARM GENCOMP
+ 
+ &STACK HT
+ LOAD GENOPINI (NOAUTO NOLIBE NOMAP
+  INCLUDE XMALLOC (NOLIBE NOAUTO
+  INCLUDE XSTRERRO (NOLIBE NOAUTO
+  INCLUDE XSTRDUP (NOLIBE NOAUTO
+  INCLUDE XEXIT (NOLIBE NOAUTO
+  INCLUDE CONCAT (NOLIBE NOAUTO
+  INCLUDE HEX (NOLIBE NOAUTO
+  INCLUDE ALLOCA (NOLIBE NOAUTO
+  INCLUDE LBASENAM (NOLIBE NOAUTO
+  INCLUDE OBSTACK (NOLIBE NOAUTO
+  INCLUDE STRSIGNA (NOLIBE NOAUTO
+  INCLUDE SAFE-CTY (NOLIBE NOAUTO
+  INCLUDE SPLAY-TR (NOLIBE NOAUTO
+  INCLUDE FIBHEAP (NOLIBE NOAUTO
+  INCLUDE HASHTAB (NOLIBE NOAUTO
+  INCLUDE ASPRINTF (NOLIBE NOAUTO
+  INCLUDE VASPRINT (NOLIBE NOAUTO
+  INCLUDE GETPAGES (NOLIBE NOAUTO
+  INCLUDE PARTITIO (NOLIBE NOAUTO
+  INCLUDE RTL (NOLIBE NOAUTO
+  INCLUDE READ-RTL (NOLIBE NOAUTO
+  INCLUDE BITMAP (NOLIBE NOAUTO
+  INCLUDE GGC-NONE (NOLIBE NOAUTO
+  INCLUDE GENSUPPO (NOLIBE NOAUTO
+  INCLUDE PRINT-RT (NOLIBE NOAUTO
+ &STACK RT
+ INCLUDE ERRORS (NOAUTO
+ 
+ GENMOD GENOPINI
+ 
+ FILEDEF SYSPRINT DISK INSN-OPI C &SRC (LRECL 2000 RECFM V
+ GENOPINI "I370 MD"
+ FILEDEF SYSPRINT CLEAR
+ 
+ 
+ EXEC GCCE GENOUTPU C &SRC (PARM GENCOMP
+ 
+ &STACK HT
+ LOAD GENOUTPU (NOAUTO NOLIBE NOMAP
+  INCLUDE XMALLOC (NOLIBE NOAUTO
+  INCLUDE XSTRERRO (NOLIBE NOAUTO
+  INCLUDE XSTRDUP (NOLIBE NOAUTO
+  INCLUDE XEXIT (NOLIBE NOAUTO
+  INCLUDE CONCAT (NOLIBE NOAUTO
+  INCLUDE HEX (NOLIBE NOAUTO
+  INCLUDE ALLOCA (NOLIBE NOAUTO
+  INCLUDE LBASENAM (NOLIBE NOAUTO
+  INCLUDE OBSTACK (NOLIBE NOAUTO
+  INCLUDE STRSIGNA (NOLIBE NOAUTO
+  INCLUDE SAFE-CTY (NOLIBE NOAUTO
+  INCLUDE SPLAY-TR (NOLIBE NOAUTO
+  INCLUDE FIBHEAP (NOLIBE NOAUTO
+  INCLUDE HASHTAB (NOLIBE NOAUTO
+  INCLUDE ASPRINTF (NOLIBE NOAUTO
+  INCLUDE VASPRINT (NOLIBE NOAUTO
+  INCLUDE GETPAGES (NOLIBE NOAUTO
+  INCLUDE PARTITIO (NOLIBE NOAUTO
+  INCLUDE RTL (NOLIBE NOAUTO
+  INCLUDE READ-RTL (NOLIBE NOAUTO
+  INCLUDE BITMAP (NOLIBE NOAUTO
+  INCLUDE GGC-NONE (NOLIBE NOAUTO
+  INCLUDE GENSUPPO (NOLIBE NOAUTO
+  INCLUDE PRINT-RT (NOLIBE NOAUTO
+ &STACK RT
+ INCLUDE ERRORS (NOAUTO
+ 
+ GENMOD GENOUTPU
+ 
+ FILEDEF SYSPRINT DISK INSN-OUT C &SRC (LRECL 2000 RECFM V
+ GENOUTPU "I370 MD"
+ FILEDEF SYSPRINT CLEAR
+ 
+ 
+ EXEC GCCE GENPEEP C &SRC (PARM GENCOMP
+ 
+ &STACK HT
+ LOAD GENPEEP (NOAUTO NOLIBE NOMAP
+  INCLUDE XMALLOC (NOLIBE NOAUTO
+  INCLUDE XSTRERRO (NOLIBE NOAUTO
+  INCLUDE XSTRDUP (NOLIBE NOAUTO
+  INCLUDE XEXIT (NOLIBE NOAUTO
+  INCLUDE CONCAT (NOLIBE NOAUTO
+  INCLUDE HEX (NOLIBE NOAUTO
+  INCLUDE ALLOCA (NOLIBE NOAUTO
+  INCLUDE LBASENAM (NOLIBE NOAUTO
+  INCLUDE OBSTACK (NOLIBE NOAUTO
+  INCLUDE STRSIGNA (NOLIBE NOAUTO
+  INCLUDE SAFE-CTY (NOLIBE NOAUTO
+  INCLUDE SPLAY-TR (NOLIBE NOAUTO
+  INCLUDE FIBHEAP (NOLIBE NOAUTO
+  INCLUDE HASHTAB (NOLIBE NOAUTO
+  INCLUDE ASPRINTF (NOLIBE NOAUTO
+  INCLUDE VASPRINT (NOLIBE NOAUTO
+  INCLUDE GETPAGES (NOLIBE NOAUTO
+  INCLUDE PARTITIO (NOLIBE NOAUTO
+  INCLUDE RTL (NOLIBE NOAUTO
+  INCLUDE READ-RTL (NOLIBE NOAUTO
+  INCLUDE BITMAP (NOLIBE NOAUTO
+  INCLUDE GGC-NONE (NOLIBE NOAUTO
+  INCLUDE GENSUPPO (NOLIBE NOAUTO
+  INCLUDE PRINT-RT (NOLIBE NOAUTO
+ &STACK RT
+ INCLUDE ERRORS (NOAUTO
+ 
+ GENMOD GENPEEP
+ 
+ FILEDEF SYSPRINT DISK INSN-PEE C &SRC (LRECL 2000 RECFM V
+ GENPEEP "I370 MD"
+ FILEDEF SYSPRINT CLEAR
+ 
+ 
+ EXEC GCCE GENRECOG C &SRC (PARM GENCOMP
+ 
+ &STACK HT
+ LOAD GENRECOG (NOAUTO NOLIBE NOMAP
+  INCLUDE XMALLOC (NOLIBE NOAUTO
+  INCLUDE XSTRERRO (NOLIBE NOAUTO
+  INCLUDE XSTRDUP (NOLIBE NOAUTO
+  INCLUDE XEXIT (NOLIBE NOAUTO
+  INCLUDE CONCAT (NOLIBE NOAUTO
+  INCLUDE HEX (NOLIBE NOAUTO
+  INCLUDE ALLOCA (NOLIBE NOAUTO
+  INCLUDE LBASENAM (NOLIBE NOAUTO
+  INCLUDE OBSTACK (NOLIBE NOAUTO
+  INCLUDE STRSIGNA (NOLIBE NOAUTO
+  INCLUDE SAFE-CTY (NOLIBE NOAUTO
+  INCLUDE SPLAY-TR (NOLIBE NOAUTO
+  INCLUDE FIBHEAP (NOLIBE NOAUTO
+  INCLUDE HASHTAB (NOLIBE NOAUTO
+  INCLUDE ASPRINTF (NOLIBE NOAUTO
+  INCLUDE VASPRINT (NOLIBE NOAUTO
+  INCLUDE GETPAGES (NOLIBE NOAUTO
+  INCLUDE PARTITIO (NOLIBE NOAUTO
+  INCLUDE RTL (NOLIBE NOAUTO
+  INCLUDE READ-RTL (NOLIBE NOAUTO
+  INCLUDE BITMAP (NOLIBE NOAUTO
+  INCLUDE GGC-NONE (NOLIBE NOAUTO
+  INCLUDE GENSUPPO (NOLIBE NOAUTO
+  INCLUDE PRINT-RT (NOLIBE NOAUTO
+ &STACK RT
+ INCLUDE ERRORS (NOAUTO
+ 
+ GENMOD GENRECOG
+ 
+ FILEDEF SYSPRINT DISK INSN-REC C &SRC (LRECL 2000 RECFM V
+ GENRECOG "I370 MD"
+ FILEDEF SYSPRINT CLEAR
+ 
+ 
+ FILEDEF SYSIN DISK C-PARSE IN &SRC
+ FILEDEF SYSPRINT DISK C-PARSE Y &SRC (LRECL 2000 RECFM V
+ FILEDEF SYSPARM DISK GENSED PARM &SRC
+ SED
+ FILEDEF SYSIN CLEAR
+ FILEDEF SYSPRINT CLEAR
+ FILEDEF SYSPARM CLEAR
+ 
+ 
+ EXEC BISON C-PARSE Y &SRC C-PARSE C &SRC TMPDEF TXT &SRC
+ 
+ ERASE C-PARSE Y &SRC
+ ERASE TMPDEF TXT &SRC
+ 
+ 
+ ERASE * TEXT &SRC
+ ERASE * MODULE &SRC
Index: gcc/gcc/gencomp.jcl
diff -c nul gcc/gcc/gencomp.jcl:1.48
*** nul	Tue Oct 01 16:28:45 2019
--- gcc/gcc/gencomp.jcl	Sun Jun 14 12:54:59 2015
***************
*** 0 ****
--- 1,911 ----
+ //GCCGEN   JOB CLASS=C,REGION=0K
+ //*
+ //CREATE   PROC
+ //S1       EXEC PGM=IEFBR14
+ //DD10     DD DSN=&&TMPLOAD,DISP=(,PASS),
+ // DCB=(RECFM=U,LRECL=0,BLKSIZE=6144),
+ // SPACE=(6144,(1000,1000,44)),UNIT=SYSALLDA
+ //DD11     DD DSN=&&TMPNCAL,DISP=(,PASS),
+ // DCB=(RECFM=U,LRECL=0,BLKSIZE=6144),
+ // SPACE=(6144,(1000,1000,44)),UNIT=SYSALLDA
+ //         PEND
+ //*
+ //GENCMP   PROC GCCPREF='GCC',PDPPREF='PDPCLIB',MEMBER='',
+ //* Note - due to the 100-character limit, we use 'GENFILES'
+ //* rather than the normal defines you would expect.
+ // COS1='-Os -S -ansi -pedantic-errors -remap -DHAVE_CONFIG_H',
+ // COS2='-DGENFILES -o dd:out -'
+ //*
+ //COMP     EXEC PGM=GCC,
+ // PARM='&COS1 &COS2'
+ //STEPLIB  DD DSN=&GCCPREF..LINKLIB,DISP=(SHR,PASS)
+ //SYSIN    DD DSN=&GCCPREF..SOURCE(&MEMBER),DISP=SHR
+ //INCLUDE  DD DSN=&GCCPREF..INCLUDE,DISP=SHR
+ //         DD DSN=&PDPPREF..INCLUDE,DISP=SHR
+ //SYSINCL  DD DSN=&GCCPREF..INCLUDE,DISP=SHR
+ //         DD DSN=&PDPPREF..INCLUDE,DISP=SHR
+ //OUT      DD DSN=&&TEMP,DISP=(,PASS),UNIT=SYSALLDA,
+ //            DCB=(LRECL=80,BLKSIZE=6160,RECFM=FB),
+ //            SPACE=(6160,(500,500))
+ //SYSPRINT DD SYSOUT=*
+ //SYSTERM  DD SYSOUT=*
+ //*
+ //ASM      EXEC PGM=ASMA90,
+ //            PARM='DECK,NOLIST',
+ //            COND=(4,LT,COMP)
+ //SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR
+ //         DD DSN=&PDPPREF..MACLIB,DISP=SHR
+ //SYSUT1   DD UNIT=SYSALLDA,SPACE=(CYL,(20,10))
+ //SYSUT2   DD UNIT=SYSALLDA,SPACE=(CYL,(10,10))
+ //SYSUT3   DD UNIT=SYSALLDA,SPACE=(CYL,(10,10))
+ //SYSPRINT DD SYSOUT=*
+ //SYSLIN   DD DUMMY
+ //SYSGO    DD DUMMY
+ //SYSPUNCH DD DSN=&&OBJSET,UNIT=SYSALLDA,SPACE=(80,(4000,4000)),
+ //            DISP=(,PASS)
+ //SYSIN    DD DSN=&&TEMP,DISP=(OLD,DELETE)
+ //*
+ //LKED     EXEC PGM=IEWL,PARM='NCAL',
+ //            COND=(4,LT,ASM)
+ //SYSLIN   DD DSN=&&OBJSET,DISP=(OLD,DELETE)
+ //SYSLMOD  DD DSN=&&TMPNCAL(&MEMBER),DISP=(SHR,PASS)
+ //SYSUT1   DD UNIT=SYSALLDA,SPACE=(CYL,(2,1))
+ //SYSPRINT DD SYSOUT=*
+ //         PEND
+ //*
+ //LINK     PROC PDPPREF='PDPCLIB',EXE=''
+ //LKED     EXEC PGM=IEWL,
+ //  PARM='MAP,LIST,SIZE=(999424,65536),AMODE=31,RMODE=ANY'
+ //SYSUT1   DD UNIT=SYSALLDA,SPACE=(CYL,(30,10))
+ //SYSPRINT DD SYSOUT=*
+ //SYSLIB   DD DSN=&&TMPNCAL,DISP=(SHR,PASS)
+ //         DD DSN=&PDPPREF..NCALIB,DISP=SHR
+ //SYSLMOD  DD DSN=&&TMPLOAD(&EXE),DISP=(SHR,PASS)
+ //         PEND
+ //*
+ //MAKECP   PROC GCCPREF='GCC',BISPREF='BISON',SEDPREF='SED',
+ // SO1='-e "/^ifobjc$/,/^end ifobjc$/d"',
+ // SO2='-e "/^ifc$/d" -e "/^end ifc$/d"'
+ //SED      EXEC PGM=SED,PARM='&SO1 &SO2'
+ //STEPLIB  DD DSN=&SEDPREF..LINKLIB,DISP=SHR
+ //SYSIN    DD DSN=&GCCPREF..DOC(C@PARSE),DISP=SHR
+ //SYSPRINT DD DSN=&&TEMP2,DISP=(NEW,PASS),UNIT=SYSALLDA,
+ //            DCB=(RECFM=VB,LRECL=255,BLKSIZE=6233),
+ //            SPACE=(6233,(1000,1000))
+ //SYSTERM  DD SYSOUT=*
+ //*
+ //BISON    EXEC PGM=BISON,PARM='--output=dd:out dd:in'
+ //STEPLIB  DD DSN=&BISPREF..LINKLIB,DISP=SHR
+ //SYSIN    DD DUMMY
+ //SYSPRINT DD SYSOUT=*
+ //SYSTERM  DD SYSOUT=*
+ //IN       DD DSN=&&TEMP2,DISP=(OLD,DELETE)
+ //OUT      DD DSN=&GCCPREF..SOURCE(C@PARSE),DISP=SHR
+ //BISONH   DD DSN=&BISPREF..SOURCE(HAIRY),DISP=SHR
+ //BISONS   DD DSN=&BISPREF..SOURCE(SIMPLE),DISP=SHR
+ //         PEND
+ //*
+ //CREATTMP EXEC CREATE
+ //*
+ //XMALLOC  EXEC GENCMP,MEMBER=XMALLOC
+ //XSTRERRO EXEC GENCMP,MEMBER=XSTRERRO
+ //XSTRDUP  EXEC GENCMP,MEMBER=XSTRDUP
+ //XEXIT    EXEC GENCMP,MEMBER=XEXIT  
+ //CONCAT   EXEC GENCMP,MEMBER=CONCAT 
+ //HEX      EXEC GENCMP,MEMBER=HEX    
+ //ALLOCA   EXEC GENCMP,MEMBER=ALLOCA 
+ //LBASENAM EXEC GENCMP,MEMBER=LBASENAM
+ //OBSTACK  EXEC GENCMP,MEMBER=OBSTACK
+ //STRSIGNA EXEC GENCMP,MEMBER=STRSIGNA
+ //SAFE@CTY EXEC GENCMP,MEMBER=SAFE@CTY
+ //SPLAY@TR EXEC GENCMP,MEMBER=SPLAY@TR
+ //FIBHEAP  EXEC GENCMP,MEMBER=FIBHEAP
+ //HASHTAB  EXEC GENCMP,MEMBER=HASHTAB
+ //ASPRINTF EXEC GENCMP,MEMBER=ASPRINTF
+ //VASPRINT EXEC GENCMP,MEMBER=VASPRINT
+ //GETPAGES EXEC GENCMP,MEMBER=GETPAGES
+ //PARTITIO EXEC GENCMP,MEMBER=PARTITIO
+ //*
+ //GENGENRT EXEC GENCMP,MEMBER=GENGENRT
+ //*
+ //DOLINK   EXEC LINK,EXE='GENGENRT'
+ //LKED.SYSLIN   DD *
+  INCLUDE SYSLIB(MVSSTART)
+  INCLUDE SYSLIB(START)
+  INCLUDE SYSLIB(MVSSUPA)
+  INCLUDE SYSLIB(STDIO)
+  INCLUDE SYSLIB(STDLIB)
+  INCLUDE SYSLIB(CTYPE)
+  INCLUDE SYSLIB(STRING)
+  INCLUDE SYSLIB(TIME)
+  INCLUDE SYSLIB(ERRNO)
+  INCLUDE SYSLIB(ASSERT)
+  INCLUDE SYSLIB(LOCALE)
+  INCLUDE SYSLIB(MATH)
+  INCLUDE SYSLIB(SETJMP)
+  INCLUDE SYSLIB(SIGNAL) 
+  INCLUDE SYSLIB(XMALLOC)
+  INCLUDE SYSLIB(XSTRERRO)
+  INCLUDE SYSLIB(XSTRDUP)
+  INCLUDE SYSLIB(XEXIT)
+  INCLUDE SYSLIB(CONCAT)
+  INCLUDE SYSLIB(HEX)
+  INCLUDE SYSLIB(ALLOCA)
+  INCLUDE SYSLIB(LBASENAM)
+  INCLUDE SYSLIB(OBSTACK)
+  INCLUDE SYSLIB(STRSIGNA)
+  INCLUDE SYSLIB(SAFE@CTY)
+  INCLUDE SYSLIB(SPLAY@TR)
+  INCLUDE SYSLIB(FIBHEAP)
+  INCLUDE SYSLIB(HASHTAB)
+  INCLUDE SYSLIB(ASPRINTF)
+  INCLUDE SYSLIB(VASPRINT)
+  INCLUDE SYSLIB(GETPAGES)
+  INCLUDE SYSLIB(PARTITIO)
+  INCLUDE SYSLIB(GENGENRT)
+  ENTRY @@MAIN
+ /*
+ //*
+ //GENGENRT EXEC PGM=GENGENRT,PARM='-h'
+ //STEPLIB  DD DSN=&&TMPLOAD,DISP=(SHR,PASS)
+ //SYSIN    DD DUMMY
+ //SYSPRINT DD DSN=GCC.INCLUDE(GENRTL),DISP=SHR
+ //SYSTERM  DD SYSOUT=*
+ //*
+ //GENGENRT EXEC PGM=GENGENRT
+ //STEPLIB  DD DSN=&&TMPLOAD,DISP=(SHR,PASS)
+ //SYSIN    DD DUMMY
+ //SYSPRINT DD DSN=GCC.SOURCE(GENRTL),DISP=SHR
+ //SYSTERM  DD SYSOUT=*
+ //*
+ //GENCHECK EXEC GENCMP,MEMBER=GENCHECK
+ //*
+ //DOLINK   EXEC LINK,EXE='GENCHECK'
+ //LKED.SYSLIN   DD *
+  INCLUDE SYSLIB(MVSSTART)
+  INCLUDE SYSLIB(START)
+  INCLUDE SYSLIB(MVSSUPA)
+  INCLUDE SYSLIB(STDIO)
+  INCLUDE SYSLIB(STDLIB)
+  INCLUDE SYSLIB(CTYPE)
+  INCLUDE SYSLIB(STRING)
+  INCLUDE SYSLIB(TIME)
+  INCLUDE SYSLIB(ERRNO)
+  INCLUDE SYSLIB(ASSERT)
+  INCLUDE SYSLIB(LOCALE)
+  INCLUDE SYSLIB(MATH)
+  INCLUDE SYSLIB(SETJMP)
+  INCLUDE SYSLIB(SIGNAL) 
+  INCLUDE SYSLIB(XMALLOC)
+  INCLUDE SYSLIB(XSTRERRO)
+  INCLUDE SYSLIB(XSTRDUP)
+  INCLUDE SYSLIB(XEXIT)
+  INCLUDE SYSLIB(CONCAT)
+  INCLUDE SYSLIB(HEX)
+  INCLUDE SYSLIB(ALLOCA)
+  INCLUDE SYSLIB(LBASENAM)
+  INCLUDE SYSLIB(OBSTACK)
+  INCLUDE SYSLIB(STRSIGNA)
+  INCLUDE SYSLIB(SAFE@CTY)
+  INCLUDE SYSLIB(SPLAY@TR)
+  INCLUDE SYSLIB(FIBHEAP)
+  INCLUDE SYSLIB(HASHTAB)
+  INCLUDE SYSLIB(ASPRINTF)
+  INCLUDE SYSLIB(VASPRINT)
+  INCLUDE SYSLIB(GETPAGES)
+  INCLUDE SYSLIB(PARTITIO)
+  INCLUDE SYSLIB(GENCHECK)
+  ENTRY @@MAIN
+ /*
+ //*
+ //GENCHECK EXEC PGM=GENCHECK
+ //STEPLIB  DD DSN=&&TMPLOAD,DISP=(SHR,PASS)
+ //SYSIN    DD DUMMY
+ //SYSPRINT DD DSN=GCC.INCLUDE(TREE@CHE),DISP=SHR
+ //SYSTERM  DD SYSOUT=*
+ //*
+ //BITMAP   EXEC GENCMP,MEMBER=BITMAP  
+ //PRINT@RT EXEC GENCMP,MEMBER=PRINT@RT
+ //RTL      EXEC GENCMP,MEMBER=RTL
+ //*
+ //ERRORS   EXEC GENCMP,MEMBER=ERRORS
+ //READ@RTL EXEC GENCMP,MEMBER=READ@RTL
+ //GGC@NONE EXEC GENCMP,MEMBER=GGC@NONE
+ //GENSUPPO EXEC GENCMP,MEMBER=GENSUPPO
+ //*
+ //GENFLAGS EXEC GENCMP,MEMBER=GENFLAGS
+ //*
+ //DOLINK   EXEC LINK,EXE='GENFLAGS'
+ //LKED.SYSLIN   DD *
+  INCLUDE SYSLIB(MVSSTART)
+  INCLUDE SYSLIB(START)
+  INCLUDE SYSLIB(MVSSUPA)
+  INCLUDE SYSLIB(STDIO)
+  INCLUDE SYSLIB(STDLIB)
+  INCLUDE SYSLIB(CTYPE)
+  INCLUDE SYSLIB(STRING)
+  INCLUDE SYSLIB(TIME)
+  INCLUDE SYSLIB(ERRNO)
+  INCLUDE SYSLIB(ASSERT)
+  INCLUDE SYSLIB(LOCALE)
+  INCLUDE SYSLIB(MATH)
+  INCLUDE SYSLIB(SETJMP)
+  INCLUDE SYSLIB(SIGNAL) 
+  INCLUDE SYSLIB(XMALLOC)
+  INCLUDE SYSLIB(XSTRERRO)
+  INCLUDE SYSLIB(XSTRDUP)
+  INCLUDE SYSLIB(XEXIT)
+  INCLUDE SYSLIB(CONCAT)
+  INCLUDE SYSLIB(HEX)
+  INCLUDE SYSLIB(ALLOCA)
+  INCLUDE SYSLIB(LBASENAM)
+  INCLUDE SYSLIB(OBSTACK)
+  INCLUDE SYSLIB(STRSIGNA)
+  INCLUDE SYSLIB(SAFE@CTY)
+  INCLUDE SYSLIB(SPLAY@TR)
+  INCLUDE SYSLIB(FIBHEAP)
+  INCLUDE SYSLIB(HASHTAB)
+  INCLUDE SYSLIB(ASPRINTF)
+  INCLUDE SYSLIB(VASPRINT)
+  INCLUDE SYSLIB(GETPAGES)
+  INCLUDE SYSLIB(PARTITIO)
+  INCLUDE SYSLIB(RTL)
+  INCLUDE SYSLIB(READ@RTL)
+  INCLUDE SYSLIB(BITMAP)  
+  INCLUDE SYSLIB(GGC@NONE)
+  INCLUDE SYSLIB(GENSUPPO)
+  INCLUDE SYSLIB(PRINT@RT)
+  INCLUDE SYSLIB(ERRORS)
+  INCLUDE SYSLIB(GENFLAGS)
+  ENTRY @@MAIN
+ /*
+ //*
+ //GENFLAGS EXEC PGM=GENFLAGS,PARM='dd:i370md'
+ //STEPLIB  DD DSN=&&TMPLOAD,DISP=(SHR,PASS)
+ //SYSIN    DD DUMMY
+ //I370MD   DD DSN=GCC.DOC(I370),DISP=SHR
+ //SYSPRINT DD DSN=GCC.INCLUDE(INSN@FLA),DISP=SHR
+ //SYSTERM  DD SYSOUT=*
+ //*
+ //GENCONST EXEC GENCMP,MEMBER=GENCONST
+ //*
+ //DOLINK   EXEC LINK,EXE='GENCONST'
+ //LKED.SYSLIN   DD *
+  INCLUDE SYSLIB(MVSSTART)
+  INCLUDE SYSLIB(START)
+  INCLUDE SYSLIB(MVSSUPA)
+  INCLUDE SYSLIB(STDIO)
+  INCLUDE SYSLIB(STDLIB)
+  INCLUDE SYSLIB(CTYPE)
+  INCLUDE SYSLIB(STRING)
+  INCLUDE SYSLIB(TIME)
+  INCLUDE SYSLIB(ERRNO)
+  INCLUDE SYSLIB(ASSERT)
+  INCLUDE SYSLIB(LOCALE)
+  INCLUDE SYSLIB(MATH)
+  INCLUDE SYSLIB(SETJMP)
+  INCLUDE SYSLIB(SIGNAL) 
+  INCLUDE SYSLIB(XMALLOC)
+  INCLUDE SYSLIB(XSTRERRO)
+  INCLUDE SYSLIB(XSTRDUP)
+  INCLUDE SYSLIB(XEXIT)
+  INCLUDE SYSLIB(CONCAT)
+  INCLUDE SYSLIB(HEX)
+  INCLUDE SYSLIB(ALLOCA)
+  INCLUDE SYSLIB(LBASENAM)
+  INCLUDE SYSLIB(OBSTACK)
+  INCLUDE SYSLIB(STRSIGNA)
+  INCLUDE SYSLIB(SAFE@CTY)
+  INCLUDE SYSLIB(SPLAY@TR)
+  INCLUDE SYSLIB(FIBHEAP)
+  INCLUDE SYSLIB(HASHTAB)
+  INCLUDE SYSLIB(ASPRINTF)
+  INCLUDE SYSLIB(VASPRINT)
+  INCLUDE SYSLIB(GETPAGES)
+  INCLUDE SYSLIB(PARTITIO)
+  INCLUDE SYSLIB(RTL)
+  INCLUDE SYSLIB(READ@RTL)
+  INCLUDE SYSLIB(BITMAP)  
+  INCLUDE SYSLIB(GGC@NONE)
+  INCLUDE SYSLIB(GENSUPPO)
+  INCLUDE SYSLIB(ERRORS)
+  INCLUDE SYSLIB(GENCONST)
+  ENTRY @@MAIN
+ /*
+ //*
+ //GENCONST EXEC PGM=GENCONST,PARM='dd:i370md'
+ //STEPLIB  DD DSN=&&TMPLOAD,DISP=(SHR,PASS)
+ //SYSIN    DD DUMMY
+ //I370MD   DD DSN=GCC.DOC(I370),DISP=SHR
+ //SYSPRINT DD DSN=GCC.INCLUDE(I@CONSTA),DISP=SHR
+ //SYSTERM  DD SYSOUT=*
+ //*
+ //GENPREDS EXEC GENCMP,MEMBER=GENPREDS
+ //*
+ //DOLINK   EXEC LINK,EXE='GENPREDS'
+ //LKED.SYSLIN   DD *
+  INCLUDE SYSLIB(MVSSTART)
+  INCLUDE SYSLIB(START)
+  INCLUDE SYSLIB(MVSSUPA)
+  INCLUDE SYSLIB(STDIO)
+  INCLUDE SYSLIB(STDLIB)
+  INCLUDE SYSLIB(CTYPE)
+  INCLUDE SYSLIB(STRING)
+  INCLUDE SYSLIB(TIME)
+  INCLUDE SYSLIB(ERRNO)
+  INCLUDE SYSLIB(ASSERT)
+  INCLUDE SYSLIB(LOCALE)
+  INCLUDE SYSLIB(MATH)
+  INCLUDE SYSLIB(SETJMP)
+  INCLUDE SYSLIB(SIGNAL) 
+  INCLUDE SYSLIB(XMALLOC)
+  INCLUDE SYSLIB(XSTRERRO)
+  INCLUDE SYSLIB(XSTRDUP)
+  INCLUDE SYSLIB(XEXIT)
+  INCLUDE SYSLIB(CONCAT)
+  INCLUDE SYSLIB(HEX)
+  INCLUDE SYSLIB(ALLOCA)
+  INCLUDE SYSLIB(LBASENAM)
+  INCLUDE SYSLIB(OBSTACK)
+  INCLUDE SYSLIB(STRSIGNA)
+  INCLUDE SYSLIB(SAFE@CTY)
+  INCLUDE SYSLIB(SPLAY@TR)
+  INCLUDE SYSLIB(FIBHEAP)
+  INCLUDE SYSLIB(HASHTAB)
+  INCLUDE SYSLIB(ASPRINTF)
+  INCLUDE SYSLIB(VASPRINT)
+  INCLUDE SYSLIB(GETPAGES)
+  INCLUDE SYSLIB(PARTITIO)
+  INCLUDE SYSLIB(GENPREDS)
+  ENTRY @@MAIN
+ /*
+ //*
+ //GENPREDS EXEC PGM=GENPREDS
+ //STEPLIB  DD DSN=&&TMPLOAD,DISP=(SHR,PASS)
+ //SYSIN    DD DUMMY
+ //SYSPRINT DD DSN=GCC.INCLUDE(TM@PREDS),DISP=SHR
+ //SYSTERM  DD SYSOUT=*
+ //*
+ //GENCONFI EXEC GENCMP,MEMBER=GENCONFI
+ //*
+ //DOLINK   EXEC LINK,EXE='GENCONFI'
+ //LKED.SYSLIN   DD *
+  INCLUDE SYSLIB(MVSSTART)
+  INCLUDE SYSLIB(START)
+  INCLUDE SYSLIB(MVSSUPA)
+  INCLUDE SYSLIB(STDIO)
+  INCLUDE SYSLIB(STDLIB)
+  INCLUDE SYSLIB(CTYPE)
+  INCLUDE SYSLIB(STRING)
+  INCLUDE SYSLIB(TIME)
+  INCLUDE SYSLIB(ERRNO)
+  INCLUDE SYSLIB(ASSERT)
+  INCLUDE SYSLIB(LOCALE)
+  INCLUDE SYSLIB(MATH)
+  INCLUDE SYSLIB(SETJMP)
+  INCLUDE SYSLIB(SIGNAL) 
+  INCLUDE SYSLIB(XMALLOC)
+  INCLUDE SYSLIB(XSTRERRO)
+  INCLUDE SYSLIB(XSTRDUP)
+  INCLUDE SYSLIB(XEXIT)
+  INCLUDE SYSLIB(CONCAT)
+  INCLUDE SYSLIB(HEX)
+  INCLUDE SYSLIB(ALLOCA)
+  INCLUDE SYSLIB(LBASENAM)
+  INCLUDE SYSLIB(OBSTACK)
+  INCLUDE SYSLIB(STRSIGNA)
+  INCLUDE SYSLIB(SAFE@CTY)
+  INCLUDE SYSLIB(SPLAY@TR)
+  INCLUDE SYSLIB(FIBHEAP)
+  INCLUDE SYSLIB(HASHTAB)
+  INCLUDE SYSLIB(ASPRINTF)
+  INCLUDE SYSLIB(VASPRINT)
+  INCLUDE SYSLIB(GETPAGES)
+  INCLUDE SYSLIB(PARTITIO)
+  INCLUDE SYSLIB(RTL)
+  INCLUDE SYSLIB(READ@RTL)
+  INCLUDE SYSLIB(BITMAP)  
+  INCLUDE SYSLIB(GGC@NONE)
+  INCLUDE SYSLIB(GENSUPPO)
+  INCLUDE SYSLIB(PRINT@RT)
+  INCLUDE SYSLIB(ERRORS)
+  INCLUDE SYSLIB(GENCONFI)
+  ENTRY @@MAIN
+ /*
+ //*
+ //GENCONFI EXEC PGM=GENCONFI,PARM='dd:i370md'
+ //STEPLIB  DD DSN=&&TMPLOAD,DISP=(SHR,PASS)
+ //SYSIN    DD DUMMY
+ //I370MD   DD DSN=GCC.DOC(I370),DISP=SHR
+ //SYSPRINT DD DSN=GCC.INCLUDE(INSN@CON),DISP=SHR
+ //SYSTERM  DD SYSOUT=*
+ //*
+ //GENCODES EXEC GENCMP,MEMBER=GENCODES
+ //*
+ //DOLINK   EXEC LINK,EXE='GENCODES'
+ //LKED.SYSLIN   DD *
+  INCLUDE SYSLIB(MVSSTART)
+  INCLUDE SYSLIB(START)
+  INCLUDE SYSLIB(MVSSUPA)
+  INCLUDE SYSLIB(STDIO)
+  INCLUDE SYSLIB(STDLIB)
+  INCLUDE SYSLIB(CTYPE)
+  INCLUDE SYSLIB(STRING)
+  INCLUDE SYSLIB(TIME)
+  INCLUDE SYSLIB(ERRNO)
+  INCLUDE SYSLIB(ASSERT)
+  INCLUDE SYSLIB(LOCALE)
+  INCLUDE SYSLIB(MATH)
+  INCLUDE SYSLIB(SETJMP)
+  INCLUDE SYSLIB(SIGNAL) 
+  INCLUDE SYSLIB(XMALLOC)
+  INCLUDE SYSLIB(XSTRERRO)
+  INCLUDE SYSLIB(XSTRDUP)
+  INCLUDE SYSLIB(XEXIT)
+  INCLUDE SYSLIB(CONCAT)
+  INCLUDE SYSLIB(HEX)
+  INCLUDE SYSLIB(ALLOCA)
+  INCLUDE SYSLIB(LBASENAM)
+  INCLUDE SYSLIB(OBSTACK)
+  INCLUDE SYSLIB(STRSIGNA)
+  INCLUDE SYSLIB(SAFE@CTY)
+  INCLUDE SYSLIB(SPLAY@TR)
+  INCLUDE SYSLIB(FIBHEAP)
+  INCLUDE SYSLIB(HASHTAB)
+  INCLUDE SYSLIB(ASPRINTF)
+  INCLUDE SYSLIB(VASPRINT)
+  INCLUDE SYSLIB(GETPAGES)
+  INCLUDE SYSLIB(PARTITIO)
+  INCLUDE SYSLIB(RTL)
+  INCLUDE SYSLIB(READ@RTL)
+  INCLUDE SYSLIB(BITMAP)  
+  INCLUDE SYSLIB(GGC@NONE)
+  INCLUDE SYSLIB(GENSUPPO)
+  INCLUDE SYSLIB(PRINT@RT)
+  INCLUDE SYSLIB(ERRORS)
+  INCLUDE SYSLIB(GENCODES)
+  ENTRY @@MAIN
+ /*
+ //*
+ //GENCODES EXEC PGM=GENCODES,PARM='dd:i370md'
+ //STEPLIB  DD DSN=&&TMPLOAD,DISP=(SHR,PASS)
+ //SYSIN    DD DUMMY
+ //I370MD   DD DSN=GCC.DOC(I370),DISP=SHR
+ //SYSPRINT DD DSN=GCC.INCLUDE(INSN@COD),DISP=SHR
+ //SYSTERM  DD SYSOUT=*
+ //*
+ //GENATTR  EXEC GENCMP,MEMBER=GENATTR
+ //*
+ //DOLINK   EXEC LINK,EXE='GENATTR'
+ //LKED.SYSLIN   DD *
+  INCLUDE SYSLIB(MVSSTART)
+  INCLUDE SYSLIB(START)
+  INCLUDE SYSLIB(MVSSUPA)
+  INCLUDE SYSLIB(STDIO)
+  INCLUDE SYSLIB(STDLIB)
+  INCLUDE SYSLIB(CTYPE)
+  INCLUDE SYSLIB(STRING)
+  INCLUDE SYSLIB(TIME)
+  INCLUDE SYSLIB(ERRNO)
+  INCLUDE SYSLIB(ASSERT)
+  INCLUDE SYSLIB(LOCALE)
+  INCLUDE SYSLIB(MATH)
+  INCLUDE SYSLIB(SETJMP)
+  INCLUDE SYSLIB(SIGNAL) 
+  INCLUDE SYSLIB(XMALLOC)
+  INCLUDE SYSLIB(XSTRERRO)
+  INCLUDE SYSLIB(XSTRDUP)
+  INCLUDE SYSLIB(XEXIT)
+  INCLUDE SYSLIB(CONCAT)
+  INCLUDE SYSLIB(HEX)
+  INCLUDE SYSLIB(ALLOCA)
+  INCLUDE SYSLIB(LBASENAM)
+  INCLUDE SYSLIB(OBSTACK)
+  INCLUDE SYSLIB(STRSIGNA)
+  INCLUDE SYSLIB(SAFE@CTY)
+  INCLUDE SYSLIB(SPLAY@TR)
+  INCLUDE SYSLIB(FIBHEAP)
+  INCLUDE SYSLIB(HASHTAB)
+  INCLUDE SYSLIB(ASPRINTF)
+  INCLUDE SYSLIB(VASPRINT)
+  INCLUDE SYSLIB(GETPAGES)
+  INCLUDE SYSLIB(PARTITIO)
+  INCLUDE SYSLIB(RTL)
+  INCLUDE SYSLIB(READ@RTL)
+  INCLUDE SYSLIB(BITMAP)  
+  INCLUDE SYSLIB(GGC@NONE)
+  INCLUDE SYSLIB(GENSUPPO)
+  INCLUDE SYSLIB(PRINT@RT)
+  INCLUDE SYSLIB(ERRORS)
+  INCLUDE SYSLIB(GENATTR)
+  ENTRY @@MAIN
+ /*
+ //*
+ //GENATTR  EXEC PGM=GENATTR,PARM='dd:i370md'
+ //STEPLIB  DD DSN=&&TMPLOAD,DISP=(SHR,PASS)
+ //SYSIN    DD DUMMY
+ //I370MD   DD DSN=GCC.DOC(I370),DISP=SHR
+ //SYSPRINT DD DSN=GCC.INCLUDE(INSN@ATT),DISP=SHR
+ //SYSTERM  DD SYSOUT=*
+ //*
+ //GENATTRT EXEC GENCMP,MEMBER=GENATTRT
+ //*
+ //DOLINK   EXEC LINK,EXE='GENATTRT'
+ //LKED.SYSLIN   DD *
+  INCLUDE SYSLIB(MVSSTART)
+  INCLUDE SYSLIB(START)
+  INCLUDE SYSLIB(MVSSUPA)
+  INCLUDE SYSLIB(STDIO)
+  INCLUDE SYSLIB(STDLIB)
+  INCLUDE SYSLIB(CTYPE)
+  INCLUDE SYSLIB(STRING)
+  INCLUDE SYSLIB(TIME)
+  INCLUDE SYSLIB(ERRNO)
+  INCLUDE SYSLIB(ASSERT)
+  INCLUDE SYSLIB(LOCALE)
+  INCLUDE SYSLIB(MATH)
+  INCLUDE SYSLIB(SETJMP)
+  INCLUDE SYSLIB(SIGNAL) 
+  INCLUDE SYSLIB(XMALLOC)
+  INCLUDE SYSLIB(XSTRERRO)
+  INCLUDE SYSLIB(XSTRDUP)
+  INCLUDE SYSLIB(XEXIT)
+  INCLUDE SYSLIB(CONCAT)
+  INCLUDE SYSLIB(HEX)
+  INCLUDE SYSLIB(ALLOCA)
+  INCLUDE SYSLIB(LBASENAM)
+  INCLUDE SYSLIB(OBSTACK)
+  INCLUDE SYSLIB(STRSIGNA)
+  INCLUDE SYSLIB(SAFE@CTY)
+  INCLUDE SYSLIB(SPLAY@TR)
+  INCLUDE SYSLIB(FIBHEAP)
+  INCLUDE SYSLIB(HASHTAB)
+  INCLUDE SYSLIB(ASPRINTF)
+  INCLUDE SYSLIB(VASPRINT)
+  INCLUDE SYSLIB(GETPAGES)
+  INCLUDE SYSLIB(PARTITIO)
+  INCLUDE SYSLIB(RTL)
+  INCLUDE SYSLIB(READ@RTL)
+  INCLUDE SYSLIB(BITMAP)  
+  INCLUDE SYSLIB(GGC@NONE)
+  INCLUDE SYSLIB(GENSUPPO)
+  INCLUDE SYSLIB(PRINT@RT)
+  INCLUDE SYSLIB(ERRORS)
+  INCLUDE SYSLIB(GENATTRT)
+  ENTRY @@MAIN
+ /*
+ //*
+ //GENATTRT EXEC PGM=GENATTRT,PARM='dd:i370md'
+ //STEPLIB  DD DSN=&&TMPLOAD,DISP=(SHR,PASS)
+ //SYSIN    DD DUMMY
+ //I370MD   DD DSN=GCC.DOC(I370),DISP=SHR
+ //SYSPRINT DD DSN=GCC.SOURCE(INSN@ATT),DISP=SHR
+ //SYSTERM  DD SYSOUT=*
+ //*
+ //GENEMIT  EXEC GENCMP,MEMBER=GENEMIT 
+ //*
+ //DOLINK   EXEC LINK,EXE='GENEMIT'
+ //LKED.SYSLIN   DD *
+  INCLUDE SYSLIB(MVSSTART)
+  INCLUDE SYSLIB(START)
+  INCLUDE SYSLIB(MVSSUPA)
+  INCLUDE SYSLIB(STDIO)
+  INCLUDE SYSLIB(STDLIB)
+  INCLUDE SYSLIB(CTYPE)
+  INCLUDE SYSLIB(STRING)
+  INCLUDE SYSLIB(TIME)
+  INCLUDE SYSLIB(ERRNO)
+  INCLUDE SYSLIB(ASSERT)
+  INCLUDE SYSLIB(LOCALE)
+  INCLUDE SYSLIB(MATH)
+  INCLUDE SYSLIB(SETJMP)
+  INCLUDE SYSLIB(SIGNAL) 
+  INCLUDE SYSLIB(XMALLOC)
+  INCLUDE SYSLIB(XSTRERRO)
+  INCLUDE SYSLIB(XSTRDUP)
+  INCLUDE SYSLIB(XEXIT)
+  INCLUDE SYSLIB(CONCAT)
+  INCLUDE SYSLIB(HEX)
+  INCLUDE SYSLIB(ALLOCA)
+  INCLUDE SYSLIB(LBASENAM)
+  INCLUDE SYSLIB(OBSTACK)
+  INCLUDE SYSLIB(STRSIGNA)
+  INCLUDE SYSLIB(SAFE@CTY)
+  INCLUDE SYSLIB(SPLAY@TR)
+  INCLUDE SYSLIB(FIBHEAP)
+  INCLUDE SYSLIB(HASHTAB)
+  INCLUDE SYSLIB(ASPRINTF)
+  INCLUDE SYSLIB(VASPRINT)
+  INCLUDE SYSLIB(GETPAGES)
+  INCLUDE SYSLIB(PARTITIO)
+  INCLUDE SYSLIB(RTL)
+  INCLUDE SYSLIB(READ@RTL)
+  INCLUDE SYSLIB(BITMAP)  
+  INCLUDE SYSLIB(GGC@NONE)
+  INCLUDE SYSLIB(GENSUPPO)
+  INCLUDE SYSLIB(PRINT@RT)
+  INCLUDE SYSLIB(ERRORS)
+  INCLUDE SYSLIB(GENEMIT)
+  ENTRY @@MAIN
+ /*
+ //*
+ //GENEMIT  EXEC PGM=GENEMIT,PARM='dd:i370md'
+ //STEPLIB  DD DSN=&&TMPLOAD,DISP=(SHR,PASS)
+ //SYSIN    DD DUMMY
+ //I370MD   DD DSN=GCC.DOC(I370),DISP=SHR
+ //SYSPRINT DD DSN=GCC.SOURCE(INSN@EMI),DISP=SHR
+ //SYSTERM  DD SYSOUT=*
+ //*
+ //GENEXTRA EXEC GENCMP,MEMBER=GENEXTRA
+ //*
+ //DOLINK   EXEC LINK,EXE='GENEXTRA'
+ //LKED.SYSLIN   DD *
+  INCLUDE SYSLIB(MVSSTART)
+  INCLUDE SYSLIB(START)
+  INCLUDE SYSLIB(MVSSUPA)
+  INCLUDE SYSLIB(STDIO)
+  INCLUDE SYSLIB(STDLIB)
+  INCLUDE SYSLIB(CTYPE)
+  INCLUDE SYSLIB(STRING)
+  INCLUDE SYSLIB(TIME)
+  INCLUDE SYSLIB(ERRNO)
+  INCLUDE SYSLIB(ASSERT)
+  INCLUDE SYSLIB(LOCALE)
+  INCLUDE SYSLIB(MATH)
+  INCLUDE SYSLIB(SETJMP)
+  INCLUDE SYSLIB(SIGNAL) 
+  INCLUDE SYSLIB(XMALLOC)
+  INCLUDE SYSLIB(XSTRERRO)
+  INCLUDE SYSLIB(XSTRDUP)
+  INCLUDE SYSLIB(XEXIT)
+  INCLUDE SYSLIB(CONCAT)
+  INCLUDE SYSLIB(HEX)
+  INCLUDE SYSLIB(ALLOCA)
+  INCLUDE SYSLIB(LBASENAM)
+  INCLUDE SYSLIB(OBSTACK)
+  INCLUDE SYSLIB(STRSIGNA)
+  INCLUDE SYSLIB(SAFE@CTY)
+  INCLUDE SYSLIB(SPLAY@TR)
+  INCLUDE SYSLIB(FIBHEAP)
+  INCLUDE SYSLIB(HASHTAB)
+  INCLUDE SYSLIB(ASPRINTF)
+  INCLUDE SYSLIB(VASPRINT)
+  INCLUDE SYSLIB(GETPAGES)
+  INCLUDE SYSLIB(PARTITIO)
+  INCLUDE SYSLIB(RTL)
+  INCLUDE SYSLIB(READ@RTL)
+  INCLUDE SYSLIB(BITMAP)  
+  INCLUDE SYSLIB(GGC@NONE)
+  INCLUDE SYSLIB(GENSUPPO)
+  INCLUDE SYSLIB(PRINT@RT)
+  INCLUDE SYSLIB(ERRORS)
+  INCLUDE SYSLIB(GENEXTRA)
+  ENTRY @@MAIN
+ /*
+ //*
+ //GENEXTRA EXEC PGM=GENEXTRA,PARM='dd:i370md'
+ //STEPLIB  DD DSN=&&TMPLOAD,DISP=(SHR,PASS)
+ //SYSIN    DD DUMMY
+ //I370MD   DD DSN=GCC.DOC(I370),DISP=SHR
+ //SYSPRINT DD DSN=GCC.SOURCE(INSN@EXT),DISP=SHR
+ //SYSTERM  DD SYSOUT=*
+ //*
+ //GENOPINI EXEC GENCMP,MEMBER=GENOPINI
+ //*
+ //DOLINK   EXEC LINK,EXE='GENOPINI'
+ //LKED.SYSLIN   DD *
+  INCLUDE SYSLIB(MVSSTART)
+  INCLUDE SYSLIB(START)
+  INCLUDE SYSLIB(MVSSUPA)
+  INCLUDE SYSLIB(STDIO)
+  INCLUDE SYSLIB(STDLIB)
+  INCLUDE SYSLIB(CTYPE)
+  INCLUDE SYSLIB(STRING)
+  INCLUDE SYSLIB(TIME)
+  INCLUDE SYSLIB(ERRNO)
+  INCLUDE SYSLIB(ASSERT)
+  INCLUDE SYSLIB(LOCALE)
+  INCLUDE SYSLIB(MATH)
+  INCLUDE SYSLIB(SETJMP)
+  INCLUDE SYSLIB(SIGNAL) 
+  INCLUDE SYSLIB(XMALLOC)
+  INCLUDE SYSLIB(XSTRERRO)
+  INCLUDE SYSLIB(XSTRDUP)
+  INCLUDE SYSLIB(XEXIT)
+  INCLUDE SYSLIB(CONCAT)
+  INCLUDE SYSLIB(HEX)
+  INCLUDE SYSLIB(ALLOCA)
+  INCLUDE SYSLIB(LBASENAM)
+  INCLUDE SYSLIB(OBSTACK)
+  INCLUDE SYSLIB(STRSIGNA)
+  INCLUDE SYSLIB(SAFE@CTY)
+  INCLUDE SYSLIB(SPLAY@TR)
+  INCLUDE SYSLIB(FIBHEAP)
+  INCLUDE SYSLIB(HASHTAB)
+  INCLUDE SYSLIB(ASPRINTF)
+  INCLUDE SYSLIB(VASPRINT)
+  INCLUDE SYSLIB(GETPAGES)
+  INCLUDE SYSLIB(PARTITIO)
+  INCLUDE SYSLIB(RTL)
+  INCLUDE SYSLIB(READ@RTL)
+  INCLUDE SYSLIB(BITMAP)  
+  INCLUDE SYSLIB(GGC@NONE)
+  INCLUDE SYSLIB(GENSUPPO)
+  INCLUDE SYSLIB(PRINT@RT)
+  INCLUDE SYSLIB(ERRORS)
+  INCLUDE SYSLIB(GENOPINI)
+  ENTRY @@MAIN
+ /*
+ //*
+ //GENOPINI EXEC PGM=GENOPINI,PARM='dd:i370md'
+ //STEPLIB  DD DSN=&&TMPLOAD,DISP=(SHR,PASS)
+ //SYSIN    DD DUMMY
+ //I370MD   DD DSN=GCC.DOC(I370),DISP=SHR
+ //SYSPRINT DD DSN=GCC.SOURCE(INSN@OPI),DISP=SHR
+ //SYSTERM  DD SYSOUT=*
+ //*
+ //GENOUTPU EXEC GENCMP,MEMBER=GENOUTPU
+ //*
+ //DOLINK   EXEC LINK,EXE='GENOUTPU'
+ //LKED.SYSLIN   DD *
+  INCLUDE SYSLIB(MVSSTART)
+  INCLUDE SYSLIB(START)
+  INCLUDE SYSLIB(MVSSUPA)
+  INCLUDE SYSLIB(STDIO)
+  INCLUDE SYSLIB(STDLIB)
+  INCLUDE SYSLIB(CTYPE)
+  INCLUDE SYSLIB(STRING)
+  INCLUDE SYSLIB(TIME)
+  INCLUDE SYSLIB(ERRNO)
+  INCLUDE SYSLIB(ASSERT)
+  INCLUDE SYSLIB(LOCALE)
+  INCLUDE SYSLIB(MATH)
+  INCLUDE SYSLIB(SETJMP)
+  INCLUDE SYSLIB(SIGNAL) 
+  INCLUDE SYSLIB(XMALLOC)
+  INCLUDE SYSLIB(XSTRERRO)
+  INCLUDE SYSLIB(XSTRDUP)
+  INCLUDE SYSLIB(XEXIT)
+  INCLUDE SYSLIB(CONCAT)
+  INCLUDE SYSLIB(HEX)
+  INCLUDE SYSLIB(ALLOCA)
+  INCLUDE SYSLIB(LBASENAM)
+  INCLUDE SYSLIB(OBSTACK)
+  INCLUDE SYSLIB(STRSIGNA)
+  INCLUDE SYSLIB(SAFE@CTY)
+  INCLUDE SYSLIB(SPLAY@TR)
+  INCLUDE SYSLIB(FIBHEAP)
+  INCLUDE SYSLIB(HASHTAB)
+  INCLUDE SYSLIB(ASPRINTF)
+  INCLUDE SYSLIB(VASPRINT)
+  INCLUDE SYSLIB(GETPAGES)
+  INCLUDE SYSLIB(PARTITIO)
+  INCLUDE SYSLIB(RTL)
+  INCLUDE SYSLIB(READ@RTL)
+  INCLUDE SYSLIB(BITMAP)  
+  INCLUDE SYSLIB(GGC@NONE)
+  INCLUDE SYSLIB(GENSUPPO)
+  INCLUDE SYSLIB(PRINT@RT)
+  INCLUDE SYSLIB(ERRORS)
+  INCLUDE SYSLIB(GENOUTPU)
+  ENTRY @@MAIN
+ /*
+ //*
+ //GENOUTPU EXEC PGM=GENOUTPU,PARM='dd:i370md'
+ //STEPLIB  DD DSN=&&TMPLOAD,DISP=(SHR,PASS)
+ //SYSIN    DD DUMMY
+ //I370MD   DD DSN=GCC.DOC(I370),DISP=SHR
+ //SYSPRINT DD DSN=GCC.SOURCE(INSN@OUT),DISP=SHR
+ //SYSTERM  DD SYSOUT=*
+ //*
+ //GENPEEP  EXEC GENCMP,MEMBER=GENPEEP
+ //*
+ //DOLINK   EXEC LINK,EXE='GENPEEP'
+ //LKED.SYSLIN   DD *
+  INCLUDE SYSLIB(MVSSTART)
+  INCLUDE SYSLIB(START)
+  INCLUDE SYSLIB(MVSSUPA)
+  INCLUDE SYSLIB(STDIO)
+  INCLUDE SYSLIB(STDLIB)
+  INCLUDE SYSLIB(CTYPE)
+  INCLUDE SYSLIB(STRING)
+  INCLUDE SYSLIB(TIME)
+  INCLUDE SYSLIB(ERRNO)
+  INCLUDE SYSLIB(ASSERT)
+  INCLUDE SYSLIB(LOCALE)
+  INCLUDE SYSLIB(MATH)
+  INCLUDE SYSLIB(SETJMP)
+  INCLUDE SYSLIB(SIGNAL) 
+  INCLUDE SYSLIB(XMALLOC)
+  INCLUDE SYSLIB(XSTRERRO)
+  INCLUDE SYSLIB(XSTRDUP)
+  INCLUDE SYSLIB(XEXIT)
+  INCLUDE SYSLIB(CONCAT)
+  INCLUDE SYSLIB(HEX)
+  INCLUDE SYSLIB(ALLOCA)
+  INCLUDE SYSLIB(LBASENAM)
+  INCLUDE SYSLIB(OBSTACK)
+  INCLUDE SYSLIB(STRSIGNA)
+  INCLUDE SYSLIB(SAFE@CTY)
+  INCLUDE SYSLIB(SPLAY@TR)
+  INCLUDE SYSLIB(FIBHEAP)
+  INCLUDE SYSLIB(HASHTAB)
+  INCLUDE SYSLIB(ASPRINTF)
+  INCLUDE SYSLIB(VASPRINT)
+  INCLUDE SYSLIB(GETPAGES)
+  INCLUDE SYSLIB(PARTITIO)
+  INCLUDE SYSLIB(RTL)
+  INCLUDE SYSLIB(READ@RTL)
+  INCLUDE SYSLIB(BITMAP)  
+  INCLUDE SYSLIB(GGC@NONE)
+  INCLUDE SYSLIB(GENSUPPO)
+  INCLUDE SYSLIB(PRINT@RT)
+  INCLUDE SYSLIB(ERRORS)
+  INCLUDE SYSLIB(GENPEEP)
+  ENTRY @@MAIN
+ /*
+ //*
+ //GENPEEP  EXEC PGM=GENPEEP,PARM='dd:i370md'
+ //STEPLIB  DD DSN=&&TMPLOAD,DISP=(SHR,PASS)
+ //SYSIN    DD DUMMY
+ //I370MD   DD DSN=GCC.DOC(I370),DISP=SHR
+ //SYSPRINT DD DSN=GCC.SOURCE(INSN@PEE),DISP=SHR
+ //SYSTERM  DD SYSOUT=*
+ //*
+ //GENRECOG EXEC GENCMP,MEMBER=GENRECOG
+ //*
+ //DOLINK   EXEC LINK,EXE='GENRECOG'
+ //LKED.SYSLIN   DD *
+  INCLUDE SYSLIB(MVSSTART)
+  INCLUDE SYSLIB(START)
+  INCLUDE SYSLIB(MVSSUPA)
+  INCLUDE SYSLIB(STDIO)
+  INCLUDE SYSLIB(STDLIB)
+  INCLUDE SYSLIB(CTYPE)
+  INCLUDE SYSLIB(STRING)
+  INCLUDE SYSLIB(TIME)
+  INCLUDE SYSLIB(ERRNO)
+  INCLUDE SYSLIB(ASSERT)
+  INCLUDE SYSLIB(LOCALE)
+  INCLUDE SYSLIB(MATH)
+  INCLUDE SYSLIB(SETJMP)
+  INCLUDE SYSLIB(SIGNAL) 
+  INCLUDE SYSLIB(XMALLOC)
+  INCLUDE SYSLIB(XSTRERRO)
+  INCLUDE SYSLIB(XSTRDUP)
+  INCLUDE SYSLIB(XEXIT)
+  INCLUDE SYSLIB(CONCAT)
+  INCLUDE SYSLIB(HEX)
+  INCLUDE SYSLIB(ALLOCA)
+  INCLUDE SYSLIB(LBASENAM)
+  INCLUDE SYSLIB(OBSTACK)
+  INCLUDE SYSLIB(STRSIGNA)
+  INCLUDE SYSLIB(SAFE@CTY)
+  INCLUDE SYSLIB(SPLAY@TR)
+  INCLUDE SYSLIB(FIBHEAP)
+  INCLUDE SYSLIB(HASHTAB)
+  INCLUDE SYSLIB(ASPRINTF)
+  INCLUDE SYSLIB(VASPRINT)
+  INCLUDE SYSLIB(GETPAGES)
+  INCLUDE SYSLIB(PARTITIO)
+  INCLUDE SYSLIB(RTL)
+  INCLUDE SYSLIB(READ@RTL)
+  INCLUDE SYSLIB(BITMAP)  
+  INCLUDE SYSLIB(GGC@NONE)
+  INCLUDE SYSLIB(GENSUPPO)
+  INCLUDE SYSLIB(PRINT@RT)
+  INCLUDE SYSLIB(ERRORS)
+  INCLUDE SYSLIB(GENRECOG)
+  ENTRY @@MAIN
+ /*
+ //*
+ //GENRECOG EXEC PGM=GENRECOG,PARM='dd:i370md'
+ //STEPLIB  DD DSN=&&TMPLOAD,DISP=(SHR,PASS)
+ //SYSIN    DD DUMMY
+ //I370MD   DD DSN=GCC.DOC(I370),DISP=SHR
+ //SYSPRINT DD DSN=GCC.SOURCE(INSN@REC),DISP=SHR
+ //SYSTERM  DD SYSOUT=*
+ //*
+ //MAKECP   EXEC MAKECP
+ //*
+ //
Index: gcc/gcc/gencomp.parm
diff -c nul gcc/gcc/gencomp.parm:1.1
*** nul	Tue Oct 01 16:28:45 2019
--- gcc/gcc/gencomp.parm	Sun Oct 26 16:01:28 2008
***************
*** 0 ****
--- 1 ----
+ -Os -S -ansi -pedantic-errors -remap -DHAVE_CONFIG_H -DGENFILES -o dd:out -
Index: gcc/gcc/genfiles.txt
diff -c nul gcc/gcc/genfiles.txt:1.4
*** nul	Tue Oct 01 16:28:45 2019
--- gcc/gcc/genfiles.txt	Tue Nov 07 21:46:41 2006
***************
*** 0 ****
--- 1,25 ----
+ auto-host.h
+ config.h
+ configargs.h
+ gencheck.h
+ genrtl.c
+ genrtl.h
+ hconfig.h
+ insn-attr.h
+ insn-attrtab.c
+ insn-codes.h
+ insn-config.h
+ insn-constants.h
+ insn-emit.c
+ insn-extract.c
+ insn-flags.h
+ insn-opinit.c
+ insn-output.c
+ insn-peep.c
+ insn-recog.c
+ multilib.h
+ options.h
+ specs.h
+ tm-preds.h
+ tm_p.h
+ tree-check.h
Index: gcc/gcc/genoutput.c
diff -c gcc/gcc/genoutput.c:1.1.1.1 gcc/gcc/genoutput.c:1.2
*** gcc/gcc/genoutput.c:1.1.1.1	Wed Feb 15 21:22:25 2006
--- gcc/gcc/genoutput.c	Sun Nov 11 15:32:10 2007
***************
*** 383,389 ****
  	  break;
  	case INSN_OUTPUT_FORMAT_MULTI:
  	case INSN_OUTPUT_FORMAT_FUNCTION:
! 	  printf ("    (const PTR) output_%d,\n", d->code_number);
  	  break;
  	default:
  	  abort ();
--- 383,389 ----
  	  break;
  	case INSN_OUTPUT_FORMAT_MULTI:
  	case INSN_OUTPUT_FORMAT_FUNCTION:
! 	  printf ("    __extension__ (const PTR) output_%d,\n", d->code_number);
  	  break;
  	default:
  	  abort ();
Index: gcc/gcc/genrtl.c
diff -c nul gcc/gcc/genrtl.c:1.1
*** nul	Tue Oct 01 16:28:45 2019
--- gcc/gcc/genrtl.c	Wed Feb 15 21:25:41 2006
***************
*** 0 ****
--- 1,902 ----
+ /* Generated automatically by gengenrtl from rtl.def.  */
+ 
+ #include "config.h"
+ #include "system.h"
+ #include "obstack.h"
+ #include "rtl.h"
+ #include "ggc.h"
+ 
+ extern struct obstack *rtl_obstack;
+ 
+ #define obstack_alloc_rtx(n)					\
+     ((rtx) obstack_alloc (rtl_obstack,				\
+ 			  sizeof (struct rtx_def)		\
+ 			  + ((n) - 1) * sizeof (rtunion)))
+ 
+ rtx
+ gen_rtx_fmt_s (code, mode, arg0)
+      RTX_CODE code;
+      enum machine_mode mode;
+      const char *arg0;
+ {
+   rtx rt;
+   rt = ggc_alloc_rtx (1);
+   memset (rt, 0, sizeof (struct rtx_def) - sizeof (rtunion));
+ 
+   PUT_CODE (rt, code);
+   PUT_MODE (rt, mode);
+   XSTR (rt, 0) = arg0;
+ 
+   return rt;
+ }
+ 
+ rtx
+ gen_rtx_fmt_ee (code, mode, arg0, arg1)
+      RTX_CODE code;
+      enum machine_mode mode;
+      rtx arg0;
+      rtx arg1;
+ {
+   rtx rt;
+   rt = ggc_alloc_rtx (2);
+   memset (rt, 0, sizeof (struct rtx_def) - sizeof (rtunion));
+ 
+   PUT_CODE (rt, code);
+   PUT_MODE (rt, mode);
+   XEXP (rt, 0) = arg0;
+   XEXP (rt, 1) = arg1;
+ 
+   return rt;
+ }
+ 
+ rtx
+ gen_rtx_fmt_ue (code, mode, arg0, arg1)
+      RTX_CODE code;
+      enum machine_mode mode;
+      rtx arg0;
+      rtx arg1;
+ {
+   rtx rt;
+   rt = ggc_alloc_rtx (2);
+   memset (rt, 0, sizeof (struct rtx_def) - sizeof (rtunion));
+ 
+   PUT_CODE (rt, code);
+   PUT_MODE (rt, mode);
+   XEXP (rt, 0) = arg0;
+   XEXP (rt, 1) = arg1;
+ 
+   return rt;
+ }
+ 
+ rtx
+ gen_rtx_fmt_iss (code, mode, arg0, arg1, arg2)
+      RTX_CODE code;
+      enum machine_mode mode;
+      int arg0;
+      const char *arg1;
+      const char *arg2;
+ {
+   rtx rt;
+   rt = ggc_alloc_rtx (3);
+   memset (rt, 0, sizeof (struct rtx_def) - sizeof (rtunion));
+ 
+   PUT_CODE (rt, code);
+   PUT_MODE (rt, mode);
+   XINT (rt, 0) = arg0;
+   XSTR (rt, 1) = arg1;
+   XSTR (rt, 2) = arg2;
+ 
+   return rt;
+ }
+ 
+ rtx
+ gen_rtx_fmt_is (code, mode, arg0, arg1)
+      RTX_CODE code;
+      enum machine_mode mode;
+      int arg0;
+      const char *arg1;
+ {
+   rtx rt;
+   rt = ggc_alloc_rtx (2);
+   memset (rt, 0, sizeof (struct rtx_def) - sizeof (rtunion));
+ 
+   PUT_CODE (rt, code);
+   PUT_MODE (rt, mode);
+   XINT (rt, 0) = arg0;
+   XSTR (rt, 1) = arg1;
+ 
+   return rt;
+ }
+ 
+ rtx
+ gen_rtx_fmt_i (code, mode, arg0)
+      RTX_CODE code;
+      enum machine_mode mode;
+      int arg0;
+ {
+   rtx rt;
+   rt = ggc_alloc_rtx (1);
+   memset (rt, 0, sizeof (struct rtx_def) - sizeof (rtunion));
+ 
+   PUT_CODE (rt, code);
+   PUT_MODE (rt, mode);
+   XINT (rt, 0) = arg0;
+ 
+   return rt;
+ }
+ 
+ rtx
+ gen_rtx_fmt_isE (code, mode, arg0, arg1, arg2)
+      RTX_CODE code;
+      enum machine_mode mode;
+      int arg0;
+      const char *arg1;
+      rtvec arg2;
+ {
+   rtx rt;
+   rt = ggc_alloc_rtx (3);
+   memset (rt, 0, sizeof (struct rtx_def) - sizeof (rtunion));
+ 
+   PUT_CODE (rt, code);
+   PUT_MODE (rt, mode);
+   XINT (rt, 0) = arg0;
+   XSTR (rt, 1) = arg1;
+   XVEC (rt, 2) = arg2;
+ 
+   return rt;
+ }
+ 
+ rtx
+ gen_rtx_fmt_iE (code, mode, arg0, arg1)
+      RTX_CODE code;
+      enum machine_mode mode;
+      int arg0;
+      rtvec arg1;
+ {
+   rtx rt;
+   rt = ggc_alloc_rtx (2);
+   memset (rt, 0, sizeof (struct rtx_def) - sizeof (rtunion));
+ 
+   PUT_CODE (rt, code);
+   PUT_MODE (rt, mode);
+   XINT (rt, 0) = arg0;
+   XVEC (rt, 1) = arg1;
+ 
+   return rt;
+ }
+ 
+ rtx
+ gen_rtx_fmt_Ess (code, mode, arg0, arg1, arg2)
+      RTX_CODE code;
+      enum machine_mode mode;
+      rtvec arg0;
+      const char *arg1;
+      const char *arg2;
+ {
+   rtx rt;
+   rt = ggc_alloc_rtx (3);
+   memset (rt, 0, sizeof (struct rtx_def) - sizeof (rtunion));
+ 
+   PUT_CODE (rt, code);
+   PUT_MODE (rt, mode);
+   XVEC (rt, 0) = arg0;
+   XSTR (rt, 1) = arg1;
+   XSTR (rt, 2) = arg2;
+ 
+   return rt;
+ }
+ 
+ rtx
+ gen_rtx_fmt_sEss (code, mode, arg0, arg1, arg2, arg3)
+      RTX_CODE code;
+      enum machine_mode mode;
+      const char *arg0;
+      rtvec arg1;
+      const char *arg2;
+      const char *arg3;
+ {
+   rtx rt;
+   rt = ggc_alloc_rtx (4);
+   memset (rt, 0, sizeof (struct rtx_def) - sizeof (rtunion));
+ 
+   PUT_CODE (rt, code);
+   PUT_MODE (rt, mode);
+   XSTR (rt, 0) = arg0;
+   XVEC (rt, 1) = arg1;
+   XSTR (rt, 2) = arg2;
+   XSTR (rt, 3) = arg3;
+ 
+   return rt;
+ }
+ 
+ rtx
+ gen_rtx_fmt_eE (code, mode, arg0, arg1)
+      RTX_CODE code;
+      enum machine_mode mode;
+      rtx arg0;
+      rtvec arg1;
+ {
+   rtx rt;
+   rt = ggc_alloc_rtx (2);
+   memset (rt, 0, sizeof (struct rtx_def) - sizeof (rtunion));
+ 
+   PUT_CODE (rt, code);
+   PUT_MODE (rt, mode);
+   XEXP (rt, 0) = arg0;
+   XVEC (rt, 1) = arg1;
+ 
+   return rt;
+ }
+ 
+ rtx
+ gen_rtx_fmt_E (code, mode, arg0)
+      RTX_CODE code;
+      enum machine_mode mode;
+      rtvec arg0;
+ {
+   rtx rt;
+   rt = ggc_alloc_rtx (1);
+   memset (rt, 0, sizeof (struct rtx_def) - sizeof (rtunion));
+ 
+   PUT_CODE (rt, code);
+   PUT_MODE (rt, mode);
+   XVEC (rt, 0) = arg0;
+ 
+   return rt;
+ }
+ 
+ rtx
+ gen_rtx_fmt_e (code, mode, arg0)
+      RTX_CODE code;
+      enum machine_mode mode;
+      rtx arg0;
+ {
+   rtx rt;
+   rt = ggc_alloc_rtx (1);
+   memset (rt, 0, sizeof (struct rtx_def) - sizeof (rtunion));
+ 
+   PUT_CODE (rt, code);
+   PUT_MODE (rt, mode);
+   XEXP (rt, 0) = arg0;
+ 
+   return rt;
+ }
+ 
+ rtx
+ gen_rtx_fmt_sse (code, mode, arg0, arg1, arg2)
+      RTX_CODE code;
+      enum machine_mode mode;
+      const char *arg0;
+      const char *arg1;
+      rtx arg2;
+ {
+   rtx rt;
+   rt = ggc_alloc_rtx (3);
+   memset (rt, 0, sizeof (struct rtx_def) - sizeof (rtunion));
+ 
+   PUT_CODE (rt, code);
+   PUT_MODE (rt, mode);
+   XSTR (rt, 0) = arg0;
+   XSTR (rt, 1) = arg1;
+   XEXP (rt, 2) = arg2;
+ 
+   return rt;
+ }
+ 
+ rtx
+ gen_rtx_fmt_ss (code, mode, arg0, arg1)
+      RTX_CODE code;
+      enum machine_mode mode;
+      const char *arg0;
+      const char *arg1;
+ {
+   rtx rt;
+   rt = ggc_alloc_rtx (2);
+   memset (rt, 0, sizeof (struct rtx_def) - sizeof (rtunion));
+ 
+   PUT_CODE (rt, code);
+   PUT_MODE (rt, mode);
+   XSTR (rt, 0) = arg0;
+   XSTR (rt, 1) = arg1;
+ 
+   return rt;
+ }
+ 
+ rtx
+ gen_rtx_fmt_sE (code, mode, arg0, arg1)
+      RTX_CODE code;
+      enum machine_mode mode;
+      const char *arg0;
+      rtvec arg1;
+ {
+   rtx rt;
+   rt = ggc_alloc_rtx (2);
+   memset (rt, 0, sizeof (struct rtx_def) - sizeof (rtunion));
+ 
+   PUT_CODE (rt, code);
+   PUT_MODE (rt, mode);
+   XSTR (rt, 0) = arg0;
+   XVEC (rt, 1) = arg1;
+ 
+   return rt;
+ }
+ 
+ rtx
+ gen_rtx_fmt_iuueiee (code, mode, arg0, arg1, arg2, arg3, arg4, arg5, arg6)
+      RTX_CODE code;
+      enum machine_mode mode;
+      int arg0;
+      rtx arg1;
+      rtx arg2;
+      rtx arg3;
+      int arg4;
+      rtx arg5;
+      rtx arg6;
+ {
+   rtx rt;
+   rt = ggc_alloc_rtx (7);
+   memset (rt, 0, sizeof (struct rtx_def) - sizeof (rtunion));
+ 
+   PUT_CODE (rt, code);
+   PUT_MODE (rt, mode);
+   XINT (rt, 0) = arg0;
+   XEXP (rt, 1) = arg1;
+   XEXP (rt, 2) = arg2;
+   XEXP (rt, 3) = arg3;
+   XINT (rt, 4) = arg4;
+   XEXP (rt, 5) = arg5;
+   XEXP (rt, 6) = arg6;
+ 
+   return rt;
+ }
+ 
+ rtx
+ gen_rtx_fmt_iuueiee0 (code, mode, arg0, arg1, arg2, arg3, arg4, arg5, arg6)
+      RTX_CODE code;
+      enum machine_mode mode;
+      int arg0;
+      rtx arg1;
+      rtx arg2;
+      rtx arg3;
+      int arg4;
+      rtx arg5;
+      rtx arg6;
+ {
+   rtx rt;
+   rt = ggc_alloc_rtx (8);
+   memset (rt, 0, sizeof (struct rtx_def) - sizeof (rtunion));
+ 
+   PUT_CODE (rt, code);
+   PUT_MODE (rt, mode);
+   XINT (rt, 0) = arg0;
+   XEXP (rt, 1) = arg1;
+   XEXP (rt, 2) = arg2;
+   XEXP (rt, 3) = arg3;
+   XINT (rt, 4) = arg4;
+   XEXP (rt, 5) = arg5;
+   XEXP (rt, 6) = arg6;
+   X0EXP (rt, 7) = NULL_RTX;
+ 
+   return rt;
+ }
+ 
+ rtx
+ gen_rtx_fmt_iuueieee (code, mode, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7)
+      RTX_CODE code;
+      enum machine_mode mode;
+      int arg0;
+      rtx arg1;
+      rtx arg2;
+      rtx arg3;
+      int arg4;
+      rtx arg5;
+      rtx arg6;
+      rtx arg7;
+ {
+   rtx rt;
+   rt = ggc_alloc_rtx (8);
+   memset (rt, 0, sizeof (struct rtx_def) - sizeof (rtunion));
+ 
+   PUT_CODE (rt, code);
+   PUT_MODE (rt, mode);
+   XINT (rt, 0) = arg0;
+   XEXP (rt, 1) = arg1;
+   XEXP (rt, 2) = arg2;
+   XEXP (rt, 3) = arg3;
+   XINT (rt, 4) = arg4;
+   XEXP (rt, 5) = arg5;
+   XEXP (rt, 6) = arg6;
+   XEXP (rt, 7) = arg7;
+ 
+   return rt;
+ }
+ 
+ rtx
+ gen_rtx_fmt_iuu (code, mode, arg0, arg1, arg2)
+      RTX_CODE code;
+      enum machine_mode mode;
+      int arg0;
+      rtx arg1;
+      rtx arg2;
+ {
+   rtx rt;
+   rt = ggc_alloc_rtx (3);
+   memset (rt, 0, sizeof (struct rtx_def) - sizeof (rtunion));
+ 
+   PUT_CODE (rt, code);
+   PUT_MODE (rt, mode);
+   XINT (rt, 0) = arg0;
+   XEXP (rt, 1) = arg1;
+   XEXP (rt, 2) = arg2;
+ 
+   return rt;
+ }
+ 
+ rtx
+ gen_rtx_fmt_iuu00iss (code, mode, arg0, arg1, arg2, arg3, arg4, arg5)
+      RTX_CODE code;
+      enum machine_mode mode;
+      int arg0;
+      rtx arg1;
+      rtx arg2;
+      int arg3;
+      const char *arg4;
+      const char *arg5;
+ {
+   rtx rt;
+   rt = ggc_alloc_rtx (8);
+   memset (rt, 0, sizeof (struct rtx_def) - sizeof (rtunion));
+ 
+   PUT_CODE (rt, code);
+   PUT_MODE (rt, mode);
+   XINT (rt, 0) = arg0;
+   XEXP (rt, 1) = arg1;
+   XEXP (rt, 2) = arg2;
+   X0EXP (rt, 3) = NULL_RTX;
+   X0EXP (rt, 4) = NULL_RTX;
+   XINT (rt, 5) = arg3;
+   XSTR (rt, 6) = arg4;
+   XSTR (rt, 7) = arg5;
+ 
+   return rt;
+ }
+ 
+ rtx
+ gen_rtx_fmt_ssiEEsi (code, mode, arg0, arg1, arg2, arg3, arg4, arg5, arg6)
+      RTX_CODE code;
+      enum machine_mode mode;
+      const char *arg0;
+      const char *arg1;
+      int arg2;
+      rtvec arg3;
+      rtvec arg4;
+      const char *arg5;
+      int arg6;
+ {
+   rtx rt;
+   rt = ggc_alloc_rtx (7);
+   memset (rt, 0, sizeof (struct rtx_def) - sizeof (rtunion));
+ 
+   PUT_CODE (rt, code);
+   PUT_MODE (rt, mode);
+   XSTR (rt, 0) = arg0;
+   XSTR (rt, 1) = arg1;
+   XINT (rt, 2) = arg2;
+   XVEC (rt, 3) = arg3;
+   XVEC (rt, 4) = arg4;
+   XSTR (rt, 5) = arg5;
+   XINT (rt, 6) = arg6;
+ 
+   return rt;
+ }
+ 
+ rtx
+ gen_rtx_fmt_Ei (code, mode, arg0, arg1)
+      RTX_CODE code;
+      enum machine_mode mode;
+      rtvec arg0;
+      int arg1;
+ {
+   rtx rt;
+   rt = ggc_alloc_rtx (2);
+   memset (rt, 0, sizeof (struct rtx_def) - sizeof (rtunion));
+ 
+   PUT_CODE (rt, code);
+   PUT_MODE (rt, mode);
+   XVEC (rt, 0) = arg0;
+   XINT (rt, 1) = arg1;
+ 
+   return rt;
+ }
+ 
+ rtx
+ gen_rtx_fmt_eEee0 (code, mode, arg0, arg1, arg2, arg3)
+      RTX_CODE code;
+      enum machine_mode mode;
+      rtx arg0;
+      rtvec arg1;
+      rtx arg2;
+      rtx arg3;
+ {
+   rtx rt;
+   rt = ggc_alloc_rtx (5);
+   memset (rt, 0, sizeof (struct rtx_def) - sizeof (rtunion));
+ 
+   PUT_CODE (rt, code);
+   PUT_MODE (rt, mode);
+   XEXP (rt, 0) = arg0;
+   XVEC (rt, 1) = arg1;
+   XEXP (rt, 2) = arg2;
+   XEXP (rt, 3) = arg3;
+   X0EXP (rt, 4) = NULL_RTX;
+ 
+   return rt;
+ }
+ 
+ rtx
+ gen_rtx_fmt_eee (code, mode, arg0, arg1, arg2)
+      RTX_CODE code;
+      enum machine_mode mode;
+      rtx arg0;
+      rtx arg1;
+      rtx arg2;
+ {
+   rtx rt;
+   rt = ggc_alloc_rtx (3);
+   memset (rt, 0, sizeof (struct rtx_def) - sizeof (rtunion));
+ 
+   PUT_CODE (rt, code);
+   PUT_MODE (rt, mode);
+   XEXP (rt, 0) = arg0;
+   XEXP (rt, 1) = arg1;
+   XEXP (rt, 2) = arg2;
+ 
+   return rt;
+ }
+ 
+ rtx
+ gen_rtx_fmt_ (code, mode)
+      RTX_CODE code;
+      enum machine_mode mode;
+ {
+   rtx rt;
+   rt = ggc_alloc_rtx (0);
+   memset (rt, 0, sizeof (struct rtx_def) - sizeof (rtunion));
+ 
+   PUT_CODE (rt, code);
+   PUT_MODE (rt, mode);
+ 
+   return rt;
+ }
+ 
+ rtx
+ gen_rtx_fmt_w (code, mode, arg0)
+      RTX_CODE code;
+      enum machine_mode mode;
+      HOST_WIDE_INT arg0;
+ {
+   rtx rt;
+   rt = ggc_alloc_rtx (1);
+   memset (rt, 0, sizeof (struct rtx_def) - sizeof (rtunion));
+ 
+   PUT_CODE (rt, code);
+   PUT_MODE (rt, mode);
+   XWINT (rt, 0) = arg0;
+ 
+   return rt;
+ }
+ 
+ rtx
+ gen_rtx_fmt_0ww (code, mode, arg0, arg1)
+      RTX_CODE code;
+      enum machine_mode mode;
+      HOST_WIDE_INT arg0;
+      HOST_WIDE_INT arg1;
+ {
+   rtx rt;
+   rt = ggc_alloc_rtx (3);
+   memset (rt, 0, sizeof (struct rtx_def) - sizeof (rtunion));
+ 
+   PUT_CODE (rt, code);
+   PUT_MODE (rt, mode);
+   X0EXP (rt, 0) = NULL_RTX;
+   XWINT (rt, 1) = arg0;
+   XWINT (rt, 2) = arg1;
+ 
+   return rt;
+ }
+ 
+ rtx
+ gen_rtx_fmt_0 (code, mode)
+      RTX_CODE code;
+      enum machine_mode mode;
+ {
+   rtx rt;
+   rt = ggc_alloc_rtx (1);
+   memset (rt, 0, sizeof (struct rtx_def) - sizeof (rtunion));
+ 
+   PUT_CODE (rt, code);
+   PUT_MODE (rt, mode);
+   X0EXP (rt, 0) = NULL_RTX;
+ 
+   return rt;
+ }
+ 
+ rtx
+ gen_rtx_fmt_i0 (code, mode, arg0)
+      RTX_CODE code;
+      enum machine_mode mode;
+      int arg0;
+ {
+   rtx rt;
+   rt = ggc_alloc_rtx (2);
+   memset (rt, 0, sizeof (struct rtx_def) - sizeof (rtunion));
+ 
+   PUT_CODE (rt, code);
+   PUT_MODE (rt, mode);
+   XINT (rt, 0) = arg0;
+   X0EXP (rt, 1) = NULL_RTX;
+ 
+   return rt;
+ }
+ 
+ rtx
+ gen_rtx_fmt_ei (code, mode, arg0, arg1)
+      RTX_CODE code;
+      enum machine_mode mode;
+      rtx arg0;
+      int arg1;
+ {
+   rtx rt;
+   rt = ggc_alloc_rtx (2);
+   memset (rt, 0, sizeof (struct rtx_def) - sizeof (rtunion));
+ 
+   PUT_CODE (rt, code);
+   PUT_MODE (rt, mode);
+   XEXP (rt, 0) = arg0;
+   XINT (rt, 1) = arg1;
+ 
+   return rt;
+ }
+ 
+ rtx
+ gen_rtx_fmt_e0 (code, mode, arg0)
+      RTX_CODE code;
+      enum machine_mode mode;
+      rtx arg0;
+ {
+   rtx rt;
+   rt = ggc_alloc_rtx (2);
+   memset (rt, 0, sizeof (struct rtx_def) - sizeof (rtunion));
+ 
+   PUT_CODE (rt, code);
+   PUT_MODE (rt, mode);
+   XEXP (rt, 0) = arg0;
+   X0EXP (rt, 1) = NULL_RTX;
+ 
+   return rt;
+ }
+ 
+ rtx
+ gen_rtx_fmt_u00 (code, mode, arg0)
+      RTX_CODE code;
+      enum machine_mode mode;
+      rtx arg0;
+ {
+   rtx rt;
+   rt = ggc_alloc_rtx (3);
+   memset (rt, 0, sizeof (struct rtx_def) - sizeof (rtunion));
+ 
+   PUT_CODE (rt, code);
+   PUT_MODE (rt, mode);
+   XEXP (rt, 0) = arg0;
+   X0EXP (rt, 1) = NULL_RTX;
+   X0EXP (rt, 2) = NULL_RTX;
+ 
+   return rt;
+ }
+ 
+ rtx
+ gen_rtx_fmt_eit (code, mode, arg0, arg1, arg2)
+      RTX_CODE code;
+      enum machine_mode mode;
+      rtx arg0;
+      int arg1;
+      union tree_node *arg2;
+ {
+   rtx rt;
+   rt = ggc_alloc_rtx (3);
+   memset (rt, 0, sizeof (struct rtx_def) - sizeof (rtunion));
+ 
+   PUT_CODE (rt, code);
+   PUT_MODE (rt, mode);
+   XEXP (rt, 0) = arg0;
+   XINT (rt, 1) = arg1;
+   XTREE (rt, 2) = arg2;
+ 
+   return rt;
+ }
+ 
+ rtx
+ gen_rtx_fmt_eeeee (code, mode, arg0, arg1, arg2, arg3, arg4)
+      RTX_CODE code;
+      enum machine_mode mode;
+      rtx arg0;
+      rtx arg1;
+      rtx arg2;
+      rtx arg3;
+      rtx arg4;
+ {
+   rtx rt;
+   rt = ggc_alloc_rtx (5);
+   memset (rt, 0, sizeof (struct rtx_def) - sizeof (rtunion));
+ 
+   PUT_CODE (rt, code);
+   PUT_MODE (rt, mode);
+   XEXP (rt, 0) = arg0;
+   XEXP (rt, 1) = arg1;
+   XEXP (rt, 2) = arg2;
+   XEXP (rt, 3) = arg3;
+   XEXP (rt, 4) = arg4;
+ 
+   return rt;
+ }
+ 
+ rtx
+ gen_rtx_fmt_Ee (code, mode, arg0, arg1)
+      RTX_CODE code;
+      enum machine_mode mode;
+      rtvec arg0;
+      rtx arg1;
+ {
+   rtx rt;
+   rt = ggc_alloc_rtx (2);
+   memset (rt, 0, sizeof (struct rtx_def) - sizeof (rtunion));
+ 
+   PUT_CODE (rt, code);
+   PUT_MODE (rt, mode);
+   XVEC (rt, 0) = arg0;
+   XEXP (rt, 1) = arg1;
+ 
+   return rt;
+ }
+ 
+ rtx
+ gen_rtx_fmt_uuEiiiiiibbii (code, mode, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12)
+      RTX_CODE code;
+      enum machine_mode mode;
+      rtx arg0;
+      rtx arg1;
+      rtvec arg2;
+      int arg3;
+      int arg4;
+      int arg5;
+      int arg6;
+      int arg7;
+      int arg8;
+      struct bitmap_head_def *arg9;
+      struct bitmap_head_def *arg10;
+      int arg11;
+      int arg12;
+ {
+   rtx rt;
+   rt = ggc_alloc_rtx (13);
+   memset (rt, 0, sizeof (struct rtx_def) - sizeof (rtunion));
+ 
+   PUT_CODE (rt, code);
+   PUT_MODE (rt, mode);
+   XEXP (rt, 0) = arg0;
+   XEXP (rt, 1) = arg1;
+   XVEC (rt, 2) = arg2;
+   XINT (rt, 3) = arg3;
+   XINT (rt, 4) = arg4;
+   XINT (rt, 5) = arg5;
+   XINT (rt, 6) = arg6;
+   XINT (rt, 7) = arg7;
+   XINT (rt, 8) = arg8;
+   XBITMAP (rt, 9) = arg9;
+   XBITMAP (rt, 10) = arg10;
+   XINT (rt, 11) = arg11;
+   XINT (rt, 12) = arg12;
+ 
+   return rt;
+ }
+ 
+ rtx
+ gen_rtx_fmt_iiiiiiiitt (code, mode, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9)
+      RTX_CODE code;
+      enum machine_mode mode;
+      int arg0;
+      int arg1;
+      int arg2;
+      int arg3;
+      int arg4;
+      int arg5;
+      int arg6;
+      int arg7;
+      union tree_node *arg8;
+      union tree_node *arg9;
+ {
+   rtx rt;
+   rt = ggc_alloc_rtx (10);
+   memset (rt, 0, sizeof (struct rtx_def) - sizeof (rtunion));
+ 
+   PUT_CODE (rt, code);
+   PUT_MODE (rt, mode);
+   XINT (rt, 0) = arg0;
+   XINT (rt, 1) = arg1;
+   XINT (rt, 2) = arg2;
+   XINT (rt, 3) = arg3;
+   XINT (rt, 4) = arg4;
+   XINT (rt, 5) = arg5;
+   XINT (rt, 6) = arg6;
+   XINT (rt, 7) = arg7;
+   XTREE (rt, 8) = arg8;
+   XTREE (rt, 9) = arg9;
+ 
+   return rt;
+ }
+ 
+ rtx
+ gen_rtx_fmt_eti (code, mode, arg0, arg1, arg2)
+      RTX_CODE code;
+      enum machine_mode mode;
+      rtx arg0;
+      union tree_node *arg1;
+      int arg2;
+ {
+   rtx rt;
+   rt = ggc_alloc_rtx (3);
+   memset (rt, 0, sizeof (struct rtx_def) - sizeof (rtunion));
+ 
+   PUT_CODE (rt, code);
+   PUT_MODE (rt, mode);
+   XEXP (rt, 0) = arg0;
+   XTREE (rt, 1) = arg1;
+   XINT (rt, 2) = arg2;
+ 
+   return rt;
+ }
+ 
+ rtx
+ gen_rtx_fmt_bi (code, mode, arg0, arg1)
+      RTX_CODE code;
+      enum machine_mode mode;
+      struct bitmap_head_def *arg0;
+      int arg1;
+ {
+   rtx rt;
+   rt = ggc_alloc_rtx (2);
+   memset (rt, 0, sizeof (struct rtx_def) - sizeof (rtunion));
+ 
+   PUT_CODE (rt, code);
+   PUT_MODE (rt, mode);
+   XBITMAP (rt, 0) = arg0;
+   XINT (rt, 1) = arg1;
+ 
+   return rt;
+ }
+ 
+ rtx
+ gen_rtx_fmt_uuuu (code, mode, arg0, arg1, arg2, arg3)
+      RTX_CODE code;
+      enum machine_mode mode;
+      rtx arg0;
+      rtx arg1;
+      rtx arg2;
+      rtx arg3;
+ {
+   rtx rt;
+   rt = ggc_alloc_rtx (4);
+   memset (rt, 0, sizeof (struct rtx_def) - sizeof (rtunion));
+ 
+   PUT_CODE (rt, code);
+   PUT_MODE (rt, mode);
+   XEXP (rt, 0) = arg0;
+   XEXP (rt, 1) = arg1;
+   XEXP (rt, 2) = arg2;
+   XEXP (rt, 3) = arg3;
+ 
+   return rt;
+ }
+ 
Index: gcc/gcc/genrtl.h
diff -c nul gcc/gcc/genrtl.h:1.1
*** nul	Tue Oct 01 16:28:45 2019
--- gcc/gcc/genrtl.h	Wed Feb 15 21:25:41 2006
***************
*** 0 ****
--- 1,405 ----
+ /* Generated automatically by gengenrtl from rtl.def.  */
+ 
+ #ifndef GCC_GENRTL_H
+ #define GCC_GENRTL_H
+ 
+ extern rtx gen_rtx_fmt_s	PARAMS ((RTX_CODE, enum machine_mode mode,
+ 				       const char *arg0));
+ extern rtx gen_rtx_fmt_ee	PARAMS ((RTX_CODE, enum machine_mode mode,
+ 				       rtx arg0, rtx arg1));
+ extern rtx gen_rtx_fmt_ue	PARAMS ((RTX_CODE, enum machine_mode mode,
+ 				       rtx arg0, rtx arg1));
+ extern rtx gen_rtx_fmt_iss	PARAMS ((RTX_CODE, enum machine_mode mode,
+ 				       int arg0, const char *arg1,
+ 				       const char *arg2));
+ extern rtx gen_rtx_fmt_is	PARAMS ((RTX_CODE, enum machine_mode mode,
+ 				       int arg0, const char *arg1));
+ extern rtx gen_rtx_fmt_i	PARAMS ((RTX_CODE, enum machine_mode mode,
+ 				       int arg0));
+ extern rtx gen_rtx_fmt_isE	PARAMS ((RTX_CODE, enum machine_mode mode,
+ 				       int arg0, const char *arg1,
+ 				       rtvec arg2));
+ extern rtx gen_rtx_fmt_iE	PARAMS ((RTX_CODE, enum machine_mode mode,
+ 				       int arg0, rtvec arg1));
+ extern rtx gen_rtx_fmt_Ess	PARAMS ((RTX_CODE, enum machine_mode mode,
+ 				       rtvec arg0, const char *arg1,
+ 				       const char *arg2));
+ extern rtx gen_rtx_fmt_sEss	PARAMS ((RTX_CODE, enum machine_mode mode,
+ 				       const char *arg0, rtvec arg1,
+ 				       const char *arg2, const char *arg3));
+ extern rtx gen_rtx_fmt_eE	PARAMS ((RTX_CODE, enum machine_mode mode,
+ 				       rtx arg0, rtvec arg1));
+ extern rtx gen_rtx_fmt_E	PARAMS ((RTX_CODE, enum machine_mode mode,
+ 				       rtvec arg0));
+ extern rtx gen_rtx_fmt_e	PARAMS ((RTX_CODE, enum machine_mode mode,
+ 				       rtx arg0));
+ extern rtx gen_rtx_fmt_sse	PARAMS ((RTX_CODE, enum machine_mode mode,
+ 				       const char *arg0, const char *arg1,
+ 				       rtx arg2));
+ extern rtx gen_rtx_fmt_ss	PARAMS ((RTX_CODE, enum machine_mode mode,
+ 				       const char *arg0, const char *arg1));
+ extern rtx gen_rtx_fmt_sE	PARAMS ((RTX_CODE, enum machine_mode mode,
+ 				       const char *arg0, rtvec arg1));
+ extern rtx gen_rtx_fmt_iuueiee	PARAMS ((RTX_CODE, enum machine_mode mode,
+ 				       int arg0, rtx arg1, rtx arg2,
+ 				       rtx arg3, int arg4, rtx arg5,
+ 				       rtx arg6));
+ extern rtx gen_rtx_fmt_iuueiee0	PARAMS ((RTX_CODE, enum machine_mode mode,
+ 				       int arg0, rtx arg1, rtx arg2,
+ 				       rtx arg3, int arg4, rtx arg5,
+ 				       rtx arg6));
+ extern rtx gen_rtx_fmt_iuueieee	PARAMS ((RTX_CODE, enum machine_mode mode,
+ 				       int arg0, rtx arg1, rtx arg2,
+ 				       rtx arg3, int arg4, rtx arg5,
+ 				       rtx arg6, rtx arg7));
+ extern rtx gen_rtx_fmt_iuu	PARAMS ((RTX_CODE, enum machine_mode mode,
+ 				       int arg0, rtx arg1, rtx arg2));
+ extern rtx gen_rtx_fmt_iuu00iss	PARAMS ((RTX_CODE, enum machine_mode mode,
+ 				       int arg0, rtx arg1, rtx arg2,
+ 				       int arg3, const char *arg4,
+ 				       const char *arg5));
+ extern rtx gen_rtx_fmt_ssiEEsi	PARAMS ((RTX_CODE, enum machine_mode mode,
+ 				       const char *arg0, const char *arg1,
+ 				       int arg2, rtvec arg3, rtvec arg4,
+ 				       const char *arg5, int arg6));
+ extern rtx gen_rtx_fmt_Ei	PARAMS ((RTX_CODE, enum machine_mode mode,
+ 				       rtvec arg0, int arg1));
+ extern rtx gen_rtx_fmt_eEee0	PARAMS ((RTX_CODE, enum machine_mode mode,
+ 				       rtx arg0, rtvec arg1, rtx arg2,
+ 				       rtx arg3));
+ extern rtx gen_rtx_fmt_eee	PARAMS ((RTX_CODE, enum machine_mode mode,
+ 				       rtx arg0, rtx arg1, rtx arg2));
+ extern rtx gen_rtx_fmt_	PARAMS ((RTX_CODE, enum machine_mode mode));
+ extern rtx gen_rtx_fmt_w	PARAMS ((RTX_CODE, enum machine_mode mode,
+ 				       HOST_WIDE_INT arg0));
+ extern rtx gen_rtx_fmt_0ww	PARAMS ((RTX_CODE, enum machine_mode mode,
+ 				       HOST_WIDE_INT arg0,
+ 				       HOST_WIDE_INT arg1));
+ extern rtx gen_rtx_fmt_0	PARAMS ((RTX_CODE, enum machine_mode mode));
+ extern rtx gen_rtx_fmt_i0	PARAMS ((RTX_CODE, enum machine_mode mode,
+ 				       int arg0));
+ extern rtx gen_rtx_fmt_ei	PARAMS ((RTX_CODE, enum machine_mode mode,
+ 				       rtx arg0, int arg1));
+ extern rtx gen_rtx_fmt_e0	PARAMS ((RTX_CODE, enum machine_mode mode,
+ 				       rtx arg0));
+ extern rtx gen_rtx_fmt_u00	PARAMS ((RTX_CODE, enum machine_mode mode,
+ 				       rtx arg0));
+ extern rtx gen_rtx_fmt_eit	PARAMS ((RTX_CODE, enum machine_mode mode,
+ 				       rtx arg0, int arg1,
+ 				       union tree_node *arg2));
+ extern rtx gen_rtx_fmt_eeeee	PARAMS ((RTX_CODE, enum machine_mode mode,
+ 				       rtx arg0, rtx arg1, rtx arg2,
+ 				       rtx arg3, rtx arg4));
+ extern rtx gen_rtx_fmt_Ee	PARAMS ((RTX_CODE, enum machine_mode mode,
+ 				       rtvec arg0, rtx arg1));
+ extern rtx gen_rtx_fmt_uuEiiiiiibbii	PARAMS ((RTX_CODE, enum machine_mode mode,
+ 				       rtx arg0, rtx arg1, rtvec arg2,
+ 				       int arg3, int arg4, int arg5,
+ 				       int arg6, int arg7, int arg8,
+ 				       struct bitmap_head_def *arg9,
+ 				       struct bitmap_head_def *arg10,
+ 				       int arg11, int arg12));
+ extern rtx gen_rtx_fmt_iiiiiiiitt	PARAMS ((RTX_CODE, enum machine_mode mode,
+ 				       int arg0, int arg1, int arg2,
+ 				       int arg3, int arg4, int arg5,
+ 				       int arg6, int arg7,
+ 				       union tree_node *arg8,
+ 				       union tree_node *arg9));
+ extern rtx gen_rtx_fmt_eti	PARAMS ((RTX_CODE, enum machine_mode mode,
+ 				       rtx arg0, union tree_node *arg1,
+ 				       int arg2));
+ extern rtx gen_rtx_fmt_bi	PARAMS ((RTX_CODE, enum machine_mode mode,
+ 				       struct bitmap_head_def *arg0,
+ 				       int arg1));
+ extern rtx gen_rtx_fmt_uuuu	PARAMS ((RTX_CODE, enum machine_mode mode,
+ 				       rtx arg0, rtx arg1, rtx arg2,
+ 				       rtx arg3));
+ 
+ #define gen_rtx_INCLUDE(MODE, ARG0) \
+   gen_rtx_fmt_s (INCLUDE, (MODE), (ARG0))
+ #define gen_rtx_EXPR_LIST(MODE, ARG0, ARG1) \
+   gen_rtx_fmt_ee (EXPR_LIST, (MODE), (ARG0), (ARG1))
+ #define gen_rtx_INSN_LIST(MODE, ARG0, ARG1) \
+   gen_rtx_fmt_ue (INSN_LIST, (MODE), (ARG0), (ARG1))
+ #define gen_rtx_MATCH_OPERAND(MODE, ARG0, ARG1, ARG2) \
+   gen_rtx_fmt_iss (MATCH_OPERAND, (MODE), (ARG0), (ARG1), (ARG2))
+ #define gen_rtx_MATCH_SCRATCH(MODE, ARG0, ARG1) \
+   gen_rtx_fmt_is (MATCH_SCRATCH, (MODE), (ARG0), (ARG1))
+ #define gen_rtx_MATCH_DUP(MODE, ARG0) \
+   gen_rtx_fmt_i (MATCH_DUP, (MODE), (ARG0))
+ #define gen_rtx_MATCH_OPERATOR(MODE, ARG0, ARG1, ARG2) \
+   gen_rtx_fmt_isE (MATCH_OPERATOR, (MODE), (ARG0), (ARG1), (ARG2))
+ #define gen_rtx_MATCH_PARALLEL(MODE, ARG0, ARG1, ARG2) \
+   gen_rtx_fmt_isE (MATCH_PARALLEL, (MODE), (ARG0), (ARG1), (ARG2))
+ #define gen_rtx_MATCH_OP_DUP(MODE, ARG0, ARG1) \
+   gen_rtx_fmt_iE (MATCH_OP_DUP, (MODE), (ARG0), (ARG1))
+ #define gen_rtx_MATCH_PAR_DUP(MODE, ARG0, ARG1) \
+   gen_rtx_fmt_iE (MATCH_PAR_DUP, (MODE), (ARG0), (ARG1))
+ #define gen_rtx_MATCH_INSN(MODE, ARG0, ARG1) \
+   gen_rtx_fmt_is (MATCH_INSN, (MODE), (ARG0), (ARG1))
+ #define gen_rtx_DEFINE_COMBINE(MODE, ARG0, ARG1, ARG2) \
+   gen_rtx_fmt_Ess (DEFINE_COMBINE, (MODE), (ARG0), (ARG1), (ARG2))
+ #define gen_rtx_DEFINE_EXPAND(MODE, ARG0, ARG1, ARG2, ARG3) \
+   gen_rtx_fmt_sEss (DEFINE_EXPAND, (MODE), (ARG0), (ARG1), (ARG2), (ARG3))
+ #define gen_rtx_DEFINE_DELAY(MODE, ARG0, ARG1) \
+   gen_rtx_fmt_eE (DEFINE_DELAY, (MODE), (ARG0), (ARG1))
+ #define gen_rtx_DEFINE_COND_EXEC(MODE, ARG0, ARG1, ARG2) \
+   gen_rtx_fmt_Ess (DEFINE_COND_EXEC, (MODE), (ARG0), (ARG1), (ARG2))
+ #define gen_rtx_SEQUENCE(MODE, ARG0) \
+   gen_rtx_fmt_E (SEQUENCE, (MODE), (ARG0))
+ #define gen_rtx_ADDRESS(MODE, ARG0) \
+   gen_rtx_fmt_e (ADDRESS, (MODE), (ARG0))
+ #define gen_rtx_DEFINE_ATTR(MODE, ARG0, ARG1, ARG2) \
+   gen_rtx_fmt_sse (DEFINE_ATTR, (MODE), (ARG0), (ARG1), (ARG2))
+ #define gen_rtx_ATTR(MODE, ARG0) \
+   gen_rtx_fmt_s (ATTR, (MODE), (ARG0))
+ #define gen_rtx_SET_ATTR(MODE, ARG0, ARG1) \
+   gen_rtx_fmt_ss (SET_ATTR, (MODE), (ARG0), (ARG1))
+ #define gen_rtx_SET_ATTR_ALTERNATIVE(MODE, ARG0, ARG1) \
+   gen_rtx_fmt_sE (SET_ATTR_ALTERNATIVE, (MODE), (ARG0), (ARG1))
+ #define gen_rtx_EQ_ATTR(MODE, ARG0, ARG1) \
+   gen_rtx_fmt_ss (EQ_ATTR, (MODE), (ARG0), (ARG1))
+ #define gen_rtx_ATTR_FLAG(MODE, ARG0) \
+   gen_rtx_fmt_s (ATTR_FLAG, (MODE), (ARG0))
+ #define gen_rtx_INSN(MODE, ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6) \
+   gen_rtx_fmt_iuueiee (INSN, (MODE), (ARG0), (ARG1), (ARG2), (ARG3), (ARG4), (ARG5), (ARG6))
+ #define gen_rtx_JUMP_INSN(MODE, ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6) \
+   gen_rtx_fmt_iuueiee0 (JUMP_INSN, (MODE), (ARG0), (ARG1), (ARG2), (ARG3), (ARG4), (ARG5), (ARG6))
+ #define gen_rtx_CALL_INSN(MODE, ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7) \
+   gen_rtx_fmt_iuueieee (CALL_INSN, (MODE), (ARG0), (ARG1), (ARG2), (ARG3), (ARG4), (ARG5), (ARG6), (ARG7))
+ #define gen_rtx_BARRIER(MODE, ARG0, ARG1, ARG2) \
+   gen_rtx_fmt_iuu (BARRIER, (MODE), (ARG0), (ARG1), (ARG2))
+ #define gen_rtx_CODE_LABEL(MODE, ARG0, ARG1, ARG2, ARG3, ARG4, ARG5) \
+   gen_rtx_fmt_iuu00iss (CODE_LABEL, (MODE), (ARG0), (ARG1), (ARG2), (ARG3), (ARG4), (ARG5))
+ #define gen_rtx_COND_EXEC(MODE, ARG0, ARG1) \
+   gen_rtx_fmt_ee (COND_EXEC, (MODE), (ARG0), (ARG1))
+ #define gen_rtx_PARALLEL(MODE, ARG0) \
+   gen_rtx_fmt_E (PARALLEL, (MODE), (ARG0))
+ #define gen_rtx_ASM_INPUT(MODE, ARG0) \
+   gen_rtx_fmt_s (ASM_INPUT, (MODE), (ARG0))
+ #define gen_rtx_ASM_OPERANDS(MODE, ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6) \
+   gen_rtx_fmt_ssiEEsi (ASM_OPERANDS, (MODE), (ARG0), (ARG1), (ARG2), (ARG3), (ARG4), (ARG5), (ARG6))
+ #define gen_rtx_UNSPEC(MODE, ARG0, ARG1) \
+   gen_rtx_fmt_Ei (UNSPEC, (MODE), (ARG0), (ARG1))
+ #define gen_rtx_UNSPEC_VOLATILE(MODE, ARG0, ARG1) \
+   gen_rtx_fmt_Ei (UNSPEC_VOLATILE, (MODE), (ARG0), (ARG1))
+ #define gen_rtx_ADDR_VEC(MODE, ARG0) \
+   gen_rtx_fmt_E (ADDR_VEC, (MODE), (ARG0))
+ #define gen_rtx_ADDR_DIFF_VEC(MODE, ARG0, ARG1, ARG2, ARG3) \
+   gen_rtx_fmt_eEee0 (ADDR_DIFF_VEC, (MODE), (ARG0), (ARG1), (ARG2), (ARG3))
+ #define gen_rtx_PREFETCH(MODE, ARG0, ARG1, ARG2) \
+   gen_rtx_fmt_eee (PREFETCH, (MODE), (ARG0), (ARG1), (ARG2))
+ #define gen_rtx_SET(MODE, ARG0, ARG1) \
+   gen_rtx_fmt_ee (SET, (MODE), (ARG0), (ARG1))
+ #define gen_rtx_USE(MODE, ARG0) \
+   gen_rtx_fmt_e (USE, (MODE), (ARG0))
+ #define gen_rtx_CLOBBER(MODE, ARG0) \
+   gen_rtx_fmt_e (CLOBBER, (MODE), (ARG0))
+ #define gen_rtx_CALL(MODE, ARG0, ARG1) \
+   gen_rtx_fmt_ee (CALL, (MODE), (ARG0), (ARG1))
+ #define gen_rtx_RETURN(MODE) \
+   gen_rtx_fmt_ (RETURN, (MODE))
+ #define gen_rtx_TRAP_IF(MODE, ARG0, ARG1) \
+   gen_rtx_fmt_ee (TRAP_IF, (MODE), (ARG0), (ARG1))
+ #define gen_rtx_RESX(MODE, ARG0) \
+   gen_rtx_fmt_i (RESX, (MODE), (ARG0))
+ #define gen_rtx_raw_CONST_INT(MODE, ARG0) \
+   gen_rtx_fmt_w (CONST_INT, (MODE), (ARG0))
+ #define gen_rtx_raw_CONST_DOUBLE(MODE, ARG0, ARG1) \
+   gen_rtx_fmt_0ww (CONST_DOUBLE, (MODE), (ARG0), (ARG1))
+ #define gen_rtx_CONST_VECTOR(MODE, ARG0) \
+   gen_rtx_fmt_E (CONST_VECTOR, (MODE), (ARG0))
+ #define gen_rtx_CONST_STRING(MODE, ARG0) \
+   gen_rtx_fmt_s (CONST_STRING, (MODE), (ARG0))
+ #define gen_rtx_CONST(MODE, ARG0) \
+   gen_rtx_fmt_e (CONST, (MODE), (ARG0))
+ #define gen_rtx_PC(MODE) \
+   gen_rtx_fmt_ (PC, (MODE))
+ #define gen_rtx_VALUE(MODE) \
+   gen_rtx_fmt_0 (VALUE, (MODE))
+ #define gen_rtx_raw_REG(MODE, ARG0) \
+   gen_rtx_fmt_i0 (REG, (MODE), (ARG0))
+ #define gen_rtx_SCRATCH(MODE) \
+   gen_rtx_fmt_0 (SCRATCH, (MODE))
+ #define gen_rtx_raw_SUBREG(MODE, ARG0, ARG1) \
+   gen_rtx_fmt_ei (SUBREG, (MODE), (ARG0), (ARG1))
+ #define gen_rtx_STRICT_LOW_PART(MODE, ARG0) \
+   gen_rtx_fmt_e (STRICT_LOW_PART, (MODE), (ARG0))
+ #define gen_rtx_CONCAT(MODE, ARG0, ARG1) \
+   gen_rtx_fmt_ee (CONCAT, (MODE), (ARG0), (ARG1))
+ #define gen_rtx_raw_MEM(MODE, ARG0) \
+   gen_rtx_fmt_e0 (MEM, (MODE), (ARG0))
+ #define gen_rtx_LABEL_REF(MODE, ARG0) \
+   gen_rtx_fmt_u00 (LABEL_REF, (MODE), (ARG0))
+ #define gen_rtx_SYMBOL_REF(MODE, ARG0) \
+   gen_rtx_fmt_s (SYMBOL_REF, (MODE), (ARG0))
+ #define gen_rtx_CC0(MODE) \
+   gen_rtx_fmt_ (CC0, (MODE))
+ #define gen_rtx_ADDRESSOF(MODE, ARG0, ARG1, ARG2) \
+   gen_rtx_fmt_eit (ADDRESSOF, (MODE), (ARG0), (ARG1), (ARG2))
+ #define gen_rtx_QUEUED(MODE, ARG0, ARG1, ARG2, ARG3, ARG4) \
+   gen_rtx_fmt_eeeee (QUEUED, (MODE), (ARG0), (ARG1), (ARG2), (ARG3), (ARG4))
+ #define gen_rtx_IF_THEN_ELSE(MODE, ARG0, ARG1, ARG2) \
+   gen_rtx_fmt_eee (IF_THEN_ELSE, (MODE), (ARG0), (ARG1), (ARG2))
+ #define gen_rtx_COND(MODE, ARG0, ARG1) \
+   gen_rtx_fmt_Ee (COND, (MODE), (ARG0), (ARG1))
+ #define gen_rtx_COMPARE(MODE, ARG0, ARG1) \
+   gen_rtx_fmt_ee (COMPARE, (MODE), (ARG0), (ARG1))
+ #define gen_rtx_PLUS(MODE, ARG0, ARG1) \
+   gen_rtx_fmt_ee (PLUS, (MODE), (ARG0), (ARG1))
+ #define gen_rtx_MINUS(MODE, ARG0, ARG1) \
+   gen_rtx_fmt_ee (MINUS, (MODE), (ARG0), (ARG1))
+ #define gen_rtx_NEG(MODE, ARG0) \
+   gen_rtx_fmt_e (NEG, (MODE), (ARG0))
+ #define gen_rtx_MULT(MODE, ARG0, ARG1) \
+   gen_rtx_fmt_ee (MULT, (MODE), (ARG0), (ARG1))
+ #define gen_rtx_DIV(MODE, ARG0, ARG1) \
+   gen_rtx_fmt_ee (DIV, (MODE), (ARG0), (ARG1))
+ #define gen_rtx_MOD(MODE, ARG0, ARG1) \
+   gen_rtx_fmt_ee (MOD, (MODE), (ARG0), (ARG1))
+ #define gen_rtx_UDIV(MODE, ARG0, ARG1) \
+   gen_rtx_fmt_ee (UDIV, (MODE), (ARG0), (ARG1))
+ #define gen_rtx_UMOD(MODE, ARG0, ARG1) \
+   gen_rtx_fmt_ee (UMOD, (MODE), (ARG0), (ARG1))
+ #define gen_rtx_AND(MODE, ARG0, ARG1) \
+   gen_rtx_fmt_ee (AND, (MODE), (ARG0), (ARG1))
+ #define gen_rtx_IOR(MODE, ARG0, ARG1) \
+   gen_rtx_fmt_ee (IOR, (MODE), (ARG0), (ARG1))
+ #define gen_rtx_XOR(MODE, ARG0, ARG1) \
+   gen_rtx_fmt_ee (XOR, (MODE), (ARG0), (ARG1))
+ #define gen_rtx_NOT(MODE, ARG0) \
+   gen_rtx_fmt_e (NOT, (MODE), (ARG0))
+ #define gen_rtx_ASHIFT(MODE, ARG0, ARG1) \
+   gen_rtx_fmt_ee (ASHIFT, (MODE), (ARG0), (ARG1))
+ #define gen_rtx_ROTATE(MODE, ARG0, ARG1) \
+   gen_rtx_fmt_ee (ROTATE, (MODE), (ARG0), (ARG1))
+ #define gen_rtx_ASHIFTRT(MODE, ARG0, ARG1) \
+   gen_rtx_fmt_ee (ASHIFTRT, (MODE), (ARG0), (ARG1))
+ #define gen_rtx_LSHIFTRT(MODE, ARG0, ARG1) \
+   gen_rtx_fmt_ee (LSHIFTRT, (MODE), (ARG0), (ARG1))
+ #define gen_rtx_ROTATERT(MODE, ARG0, ARG1) \
+   gen_rtx_fmt_ee (ROTATERT, (MODE), (ARG0), (ARG1))
+ #define gen_rtx_SMIN(MODE, ARG0, ARG1) \
+   gen_rtx_fmt_ee (SMIN, (MODE), (ARG0), (ARG1))
+ #define gen_rtx_SMAX(MODE, ARG0, ARG1) \
+   gen_rtx_fmt_ee (SMAX, (MODE), (ARG0), (ARG1))
+ #define gen_rtx_UMIN(MODE, ARG0, ARG1) \
+   gen_rtx_fmt_ee (UMIN, (MODE), (ARG0), (ARG1))
+ #define gen_rtx_UMAX(MODE, ARG0, ARG1) \
+   gen_rtx_fmt_ee (UMAX, (MODE), (ARG0), (ARG1))
+ #define gen_rtx_PRE_DEC(MODE, ARG0) \
+   gen_rtx_fmt_e (PRE_DEC, (MODE), (ARG0))
+ #define gen_rtx_PRE_INC(MODE, ARG0) \
+   gen_rtx_fmt_e (PRE_INC, (MODE), (ARG0))
+ #define gen_rtx_POST_DEC(MODE, ARG0) \
+   gen_rtx_fmt_e (POST_DEC, (MODE), (ARG0))
+ #define gen_rtx_POST_INC(MODE, ARG0) \
+   gen_rtx_fmt_e (POST_INC, (MODE), (ARG0))
+ #define gen_rtx_PRE_MODIFY(MODE, ARG0, ARG1) \
+   gen_rtx_fmt_ee (PRE_MODIFY, (MODE), (ARG0), (ARG1))
+ #define gen_rtx_POST_MODIFY(MODE, ARG0, ARG1) \
+   gen_rtx_fmt_ee (POST_MODIFY, (MODE), (ARG0), (ARG1))
+ #define gen_rtx_NE(MODE, ARG0, ARG1) \
+   gen_rtx_fmt_ee (NE, (MODE), (ARG0), (ARG1))
+ #define gen_rtx_EQ(MODE, ARG0, ARG1) \
+   gen_rtx_fmt_ee (EQ, (MODE), (ARG0), (ARG1))
+ #define gen_rtx_GE(MODE, ARG0, ARG1) \
+   gen_rtx_fmt_ee (GE, (MODE), (ARG0), (ARG1))
+ #define gen_rtx_GT(MODE, ARG0, ARG1) \
+   gen_rtx_fmt_ee (GT, (MODE), (ARG0), (ARG1))
+ #define gen_rtx_LE(MODE, ARG0, ARG1) \
+   gen_rtx_fmt_ee (LE, (MODE), (ARG0), (ARG1))
+ #define gen_rtx_LT(MODE, ARG0, ARG1) \
+   gen_rtx_fmt_ee (LT, (MODE), (ARG0), (ARG1))
+ #define gen_rtx_GEU(MODE, ARG0, ARG1) \
+   gen_rtx_fmt_ee (GEU, (MODE), (ARG0), (ARG1))
+ #define gen_rtx_GTU(MODE, ARG0, ARG1) \
+   gen_rtx_fmt_ee (GTU, (MODE), (ARG0), (ARG1))
+ #define gen_rtx_LEU(MODE, ARG0, ARG1) \
+   gen_rtx_fmt_ee (LEU, (MODE), (ARG0), (ARG1))
+ #define gen_rtx_LTU(MODE, ARG0, ARG1) \
+   gen_rtx_fmt_ee (LTU, (MODE), (ARG0), (ARG1))
+ #define gen_rtx_UNORDERED(MODE, ARG0, ARG1) \
+   gen_rtx_fmt_ee (UNORDERED, (MODE), (ARG0), (ARG1))
+ #define gen_rtx_ORDERED(MODE, ARG0, ARG1) \
+   gen_rtx_fmt_ee (ORDERED, (MODE), (ARG0), (ARG1))
+ #define gen_rtx_UNEQ(MODE, ARG0, ARG1) \
+   gen_rtx_fmt_ee (UNEQ, (MODE), (ARG0), (ARG1))
+ #define gen_rtx_UNGE(MODE, ARG0, ARG1) \
+   gen_rtx_fmt_ee (UNGE, (MODE), (ARG0), (ARG1))
+ #define gen_rtx_UNGT(MODE, ARG0, ARG1) \
+   gen_rtx_fmt_ee (UNGT, (MODE), (ARG0), (ARG1))
+ #define gen_rtx_UNLE(MODE, ARG0, ARG1) \
+   gen_rtx_fmt_ee (UNLE, (MODE), (ARG0), (ARG1))
+ #define gen_rtx_UNLT(MODE, ARG0, ARG1) \
+   gen_rtx_fmt_ee (UNLT, (MODE), (ARG0), (ARG1))
+ #define gen_rtx_LTGT(MODE, ARG0, ARG1) \
+   gen_rtx_fmt_ee (LTGT, (MODE), (ARG0), (ARG1))
+ #define gen_rtx_SIGN_EXTEND(MODE, ARG0) \
+   gen_rtx_fmt_e (SIGN_EXTEND, (MODE), (ARG0))
+ #define gen_rtx_ZERO_EXTEND(MODE, ARG0) \
+   gen_rtx_fmt_e (ZERO_EXTEND, (MODE), (ARG0))
+ #define gen_rtx_TRUNCATE(MODE, ARG0) \
+   gen_rtx_fmt_e (TRUNCATE, (MODE), (ARG0))
+ #define gen_rtx_FLOAT_EXTEND(MODE, ARG0) \
+   gen_rtx_fmt_e (FLOAT_EXTEND, (MODE), (ARG0))
+ #define gen_rtx_FLOAT_TRUNCATE(MODE, ARG0) \
+   gen_rtx_fmt_e (FLOAT_TRUNCATE, (MODE), (ARG0))
+ #define gen_rtx_FLOAT(MODE, ARG0) \
+   gen_rtx_fmt_e (FLOAT, (MODE), (ARG0))
+ #define gen_rtx_FIX(MODE, ARG0) \
+   gen_rtx_fmt_e (FIX, (MODE), (ARG0))
+ #define gen_rtx_UNSIGNED_FLOAT(MODE, ARG0) \
+   gen_rtx_fmt_e (UNSIGNED_FLOAT, (MODE), (ARG0))
+ #define gen_rtx_UNSIGNED_FIX(MODE, ARG0) \
+   gen_rtx_fmt_e (UNSIGNED_FIX, (MODE), (ARG0))
+ #define gen_rtx_ABS(MODE, ARG0) \
+   gen_rtx_fmt_e (ABS, (MODE), (ARG0))
+ #define gen_rtx_SQRT(MODE, ARG0) \
+   gen_rtx_fmt_e (SQRT, (MODE), (ARG0))
+ #define gen_rtx_FFS(MODE, ARG0) \
+   gen_rtx_fmt_e (FFS, (MODE), (ARG0))
+ #define gen_rtx_SIGN_EXTRACT(MODE, ARG0, ARG1, ARG2) \
+   gen_rtx_fmt_eee (SIGN_EXTRACT, (MODE), (ARG0), (ARG1), (ARG2))
+ #define gen_rtx_ZERO_EXTRACT(MODE, ARG0, ARG1, ARG2) \
+   gen_rtx_fmt_eee (ZERO_EXTRACT, (MODE), (ARG0), (ARG1), (ARG2))
+ #define gen_rtx_HIGH(MODE, ARG0) \
+   gen_rtx_fmt_e (HIGH, (MODE), (ARG0))
+ #define gen_rtx_LO_SUM(MODE, ARG0, ARG1) \
+   gen_rtx_fmt_ee (LO_SUM, (MODE), (ARG0), (ARG1))
+ #define gen_rtx_RANGE_INFO(MODE, ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12) \
+   gen_rtx_fmt_uuEiiiiiibbii (RANGE_INFO, (MODE), (ARG0), (ARG1), (ARG2), (ARG3), (ARG4), (ARG5), (ARG6), (ARG7), (ARG8), (ARG9), (ARG10), (ARG11), (ARG12))
+ #define gen_rtx_RANGE_REG(MODE, ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9) \
+   gen_rtx_fmt_iiiiiiiitt (RANGE_REG, (MODE), (ARG0), (ARG1), (ARG2), (ARG3), (ARG4), (ARG5), (ARG6), (ARG7), (ARG8), (ARG9))
+ #define gen_rtx_RANGE_VAR(MODE, ARG0, ARG1, ARG2) \
+   gen_rtx_fmt_eti (RANGE_VAR, (MODE), (ARG0), (ARG1), (ARG2))
+ #define gen_rtx_RANGE_LIVE(MODE, ARG0, ARG1) \
+   gen_rtx_fmt_bi (RANGE_LIVE, (MODE), (ARG0), (ARG1))
+ #define gen_rtx_CONSTANT_P_RTX(MODE, ARG0) \
+   gen_rtx_fmt_e (CONSTANT_P_RTX, (MODE), (ARG0))
+ #define gen_rtx_CALL_PLACEHOLDER(MODE, ARG0, ARG1, ARG2, ARG3) \
+   gen_rtx_fmt_uuuu (CALL_PLACEHOLDER, (MODE), (ARG0), (ARG1), (ARG2), (ARG3))
+ #define gen_rtx_VEC_MERGE(MODE, ARG0, ARG1, ARG2) \
+   gen_rtx_fmt_eee (VEC_MERGE, (MODE), (ARG0), (ARG1), (ARG2))
+ #define gen_rtx_VEC_SELECT(MODE, ARG0, ARG1) \
+   gen_rtx_fmt_ee (VEC_SELECT, (MODE), (ARG0), (ARG1))
+ #define gen_rtx_VEC_CONCAT(MODE, ARG0, ARG1) \
+   gen_rtx_fmt_ee (VEC_CONCAT, (MODE), (ARG0), (ARG1))
+ #define gen_rtx_VEC_DUPLICATE(MODE, ARG0) \
+   gen_rtx_fmt_e (VEC_DUPLICATE, (MODE), (ARG0))
+ #define gen_rtx_SS_PLUS(MODE, ARG0, ARG1) \
+   gen_rtx_fmt_ee (SS_PLUS, (MODE), (ARG0), (ARG1))
+ #define gen_rtx_US_PLUS(MODE, ARG0, ARG1) \
+   gen_rtx_fmt_ee (US_PLUS, (MODE), (ARG0), (ARG1))
+ #define gen_rtx_SS_MINUS(MODE, ARG0, ARG1) \
+   gen_rtx_fmt_ee (SS_MINUS, (MODE), (ARG0), (ARG1))
+ #define gen_rtx_US_MINUS(MODE, ARG0, ARG1) \
+   gen_rtx_fmt_ee (US_MINUS, (MODE), (ARG0), (ARG1))
+ #define gen_rtx_SS_TRUNCATE(MODE, ARG0) \
+   gen_rtx_fmt_e (SS_TRUNCATE, (MODE), (ARG0))
+ #define gen_rtx_US_TRUNCATE(MODE, ARG0) \
+   gen_rtx_fmt_e (US_TRUNCATE, (MODE), (ARG0))
+ #define gen_rtx_PHI(MODE, ARG0) \
+   gen_rtx_fmt_E (PHI, (MODE), (ARG0))
+ 
+ #endif /* GCC_GENRTL_H */
Index: gcc/gcc/gensed.parm
diff -c nul gcc/gcc/gensed.parm:1.1
*** nul	Tue Oct 01 16:28:45 2019
--- gcc/gcc/gensed.parm	Mon Oct 27 02:17:58 2008
***************
*** 0 ****
--- 1 ----
+ -e "/^ifobjc$/,/^end ifobjc$/d" -e "/^ifc$/d" -e "/^end ifc$/d"
Index: gcc/gcc/hconfig.h
diff -c nul gcc/gcc/hconfig.h:1.6
*** nul	Tue Oct 01 16:28:45 2019
--- gcc/gcc/hconfig.h	Mon Jun 18 04:16:33 2018
***************
*** 0 ****
--- 1,39 ----
+ #include "config.h"
+ #ifdef S390
+ /* need this otherwise rtunion is 8 bytes
+    in some places, 4 in others */
+ #include "system.h"
+ #endif
+ #include "auto-host.h"
+ #ifdef IN_GCC
+ /* Provide three core typedefs used by everything, if we are compiling
+    GCC.  These used to be found in rtl.h and tree.h, but this is no
+    longer practical.  Providing these here rather that system.h allows
+    the typedefs to be used everywhere within GCC. */
+ #ifndef RTX_FORWARD
+ #define RTX_FORWARD 1
+ struct rtx_def;
+ typedef struct rtx_def *rtx;
+ struct rtvec_def;
+ typedef struct rtvec_def *rtvec;
+ union tree_node;
+ typedef union tree_node *tree;
+ #endif
+ #endif
+ #ifdef IN_GCC
+ # include "ansidecl.h"
+ /*# include "i386/xm-cygwin.h"*/
+ /*#include "xm-mvs.h"*/
+ #if defined(I386)
+ #include "i386.h"
+ #elif defined(S390)
+ #include "s390.h"
+ #else
+ # include "mvspdp.h"
+ # include "i370.h"
+ #endif
+ # include "defaults.h"
+ #endif
+ #ifndef POSIX
+ # define POSIX
+ #endif
Index: gcc/gcc/insn-attr.h
diff -c nul gcc/gcc/insn-attr.h:1.1
*** nul	Tue Oct 01 16:28:45 2019
--- gcc/gcc/insn-attr.h	Wed Feb 15 21:25:41 2006
***************
*** 0 ****
--- 1,26 ----
+ /* Generated automatically by the program `genattr'
+    from the machine description file `md'.  */
+ 
+ #ifndef GCC_INSN_ATTR_H
+ #define GCC_INSN_ATTR_H
+ 
+ #define HAVE_ATTR_alternative
+ #define get_attr_alternative(insn) which_alternative
+ #define HAVE_ATTR_length
+ extern int get_attr_length PARAMS ((rtx));
+ extern void shorten_branches PARAMS ((rtx));
+ extern int insn_default_length PARAMS ((rtx));
+ extern int insn_variable_length_p PARAMS ((rtx));
+ extern int insn_current_length PARAMS ((rtx));
+ 
+ #include "insn-addr.h"
+ 
+ 
+ #define ATTR_FLAG_forward	0x1
+ #define ATTR_FLAG_backward	0x2
+ #define ATTR_FLAG_likely	0x4
+ #define ATTR_FLAG_very_likely	0x8
+ #define ATTR_FLAG_unlikely	0x10
+ #define ATTR_FLAG_very_unlikely	0x20
+ 
+ #endif /* GCC_INSN_ATTR_H */
Index: gcc/gcc/insn-attrtab.c
diff -c nul gcc/gcc/insn-attrtab.c:1.6
*** nul	Tue Oct 01 16:28:45 2019
--- gcc/gcc/insn-attrtab.c	Sat Sep 26 12:58:26 2009
***************
*** 0 ****
--- 1,177 ----
+ /* Generated automatically by the program `genattrtab'
+ from the machine description file `md'.  */
+ 
+ #include "config.h"
+ #include "system.h"
+ #include "rtl.h"
+ #include "tm_p.h"
+ #include "insn-config.h"
+ #include "recog.h"
+ #include "regs.h"
+ #include "real.h"
+ #include "output.h"
+ #include "insn-attr.h"
+ #include "toplev.h"
+ #include "flags.h"
+ 
+ #define operands recog_data.operand
+ 
+ extern int insn_current_length PARAMS ((rtx));
+ int
+ insn_current_length (insn)
+      rtx insn;
+ {
+   switch (recog_memoized (insn))
+     {
+     case -1:
+       if (GET_CODE (PATTERN (insn)) != ASM_INPUT
+           && asm_noperands (PATTERN (insn)) < 0)
+         fatal_insn_not_found (insn);
+     default:
+       return 0;
+ 
+     }
+ }
+ 
+ extern int insn_variable_length_p PARAMS ((rtx));
+ int
+ insn_variable_length_p (insn)
+      rtx insn;
+ {
+   switch (recog_memoized (insn))
+     {
+     case -1:
+       if (GET_CODE (PATTERN (insn)) != ASM_INPUT
+           && asm_noperands (PATTERN (insn)) < 0)
+         fatal_insn_not_found (insn);
+     default:
+       return 0;
+ 
+     }
+ }
+ 
+ extern int insn_default_length PARAMS ((rtx));
+ int
+ insn_default_length (insn)
+      rtx insn;
+ {
+   switch (recog_memoized (insn))
+     {
+     case 133:
+     case 85:
+     case 84:
+     case 82:
+     case 81:
+     case 80:
+     case 78:
+     case 49:
+     case 36:
+     case 26:
+     case 4:
+     case 3:
+     case 1:
+       return 2;
+ 
+     case 132:
+     case 131:
+     case 130:
+     case 129:
+     case 35:
+     case 11:
+       return 22 /* 0x16 */;
+ 
+     case 128:
+     case 83:
+     case 79:
+     case 46:
+     case 38:
+     case 37:
+       return 10 /* 0xa */;
+ 
+     case 126:
+     case 125:
+     case 124:
+     case 123:
+     case 122:
+     case 121:
+     case 120:
+     case 119:
+     case 118:
+     case 117:
+     case 116:
+     case 115:
+     case 114:
+     case 113:
+     case 112:
+     case 111:
+     case 110:
+     case 109:
+     case 108:
+     case 107:
+     case 106:
+     case 105:
+     case 104:
+     case 88:
+     case 86:
+     case 76:
+     case 74:
+     case 72:
+     case 70:
+     case 68:
+     case 66:
+     case 64:
+     case 62:
+     case 60:
+     case 40:
+     case 25:
+     case 18:
+     case 16:
+       return 6;
+ 
+     case 103:
+     case 102:
+     case 99:
+     case 97:
+     case 96:
+     case 48:
+     case 42:
+     case 33:
+     case 32:
+     case 31:
+     case 24:
+     case 23:
+     case 20:
+     case 15:
+     case 14:
+     case 13:
+     case 7:
+     case 6:
+       return 8;
+ 
+     case 34:
+       return 14 /* 0xe */;
+ 
+     case 29:
+     case 28:
+     case 27:
+     case 22:
+     case 21:
+       return 12 /* 0xc */;
+ 
+     case 12:
+     case 8:
+       return 18 /* 0x12 */;
+ 
+     case -1:
+       if (GET_CODE (PATTERN (insn)) != ASM_INPUT
+           && asm_noperands (PATTERN (insn)) < 0)
+         fatal_insn_not_found (insn);
+       return 0;
+ 
+     default:
+       return 4;
+ 
+     }
+ }
+ 
+ int length_unit_log = 1;
Index: gcc/gcc/insn-codes.h
diff -c nul gcc/gcc/insn-codes.h:1.10
*** nul	Tue Oct 01 16:28:45 2019
--- gcc/gcc/insn-codes.h	Sat Sep 26 12:58:27 2009
***************
*** 0 ****
--- 1,115 ----
+ /* Generated automatically by the program `gencodes'
+    from the machine description file `md'.  */
+ 
+ #ifndef GCC_INSN_CODES_H
+ #define GCC_INSN_CODES_H
+ 
+ enum insn_code {
+   CODE_FOR_tstdi = 0,
+   CODE_FOR_tstsi = 1,
+   CODE_FOR_tsthi = 2,
+   CODE_FOR_tstdf = 3,
+   CODE_FOR_tstsf = 4,
+   CODE_FOR_cmpsi = 5,
+   CODE_FOR_cmphi = 6,
+   CODE_FOR_cmpqi = 8,
+   CODE_FOR_cmpdf = 9,
+   CODE_FOR_cmpsf = 10,
+   CODE_FOR_cmpstrsi_1 = 12,
+   CODE_FOR_movdi = 14,
+   CODE_FOR_movsi = 15,
+   CODE_FOR_movhi = 17,
+   CODE_FOR_movqi = 19,
+   CODE_FOR_movstricthi = 20,
+   CODE_FOR_movdf = 22,
+   CODE_FOR_movsf = 24,
+   CODE_FOR_movstrsi_1 = 26,
+   CODE_FOR_extendhisi2 = 27,
+   CODE_FOR_extendqisi2 = 28,
+   CODE_FOR_extendqihi2 = 29,
+   CODE_FOR_zero_extendhisi2 = 30,
+   CODE_FOR_zero_extendqisi2 = 31,
+   CODE_FOR_zero_extendqihi2 = 32,
+   CODE_FOR_truncsihi2 = 33,
+   CODE_FOR_fix_truncdfsi2 = 34,
+   CODE_FOR_floatsidf2 = 35,
+   CODE_FOR_truncdfsf2 = 36,
+   CODE_FOR_extendsfdf2 = 37,
+   CODE_FOR_addsi3 = 41,
+   CODE_FOR_addhi3 = 42,
+   CODE_FOR_addqi3 = 43,
+   CODE_FOR_adddf3 = 44,
+   CODE_FOR_addsf3 = 45,
+   CODE_FOR_subsi3 = 47,
+   CODE_FOR_subhi3 = 48,
+   CODE_FOR_subqi3 = 49,
+   CODE_FOR_subdf3 = 50,
+   CODE_FOR_subsf3 = 51,
+   CODE_FOR_muldf3 = 54,
+   CODE_FOR_mulsf3 = 55,
+   CODE_FOR_divdf3 = 57,
+   CODE_FOR_divsf3 = 58,
+   CODE_FOR_andsi3 = 61,
+   CODE_FOR_andhi3 = 63,
+   CODE_FOR_andqi3 = 65,
+   CODE_FOR_iorsi3 = 67,
+   CODE_FOR_iorhi3 = 69,
+   CODE_FOR_iorqi3 = 71,
+   CODE_FOR_xorsi3 = 73,
+   CODE_FOR_xorhi3 = 75,
+   CODE_FOR_xorqi3 = 77,
+   CODE_FOR_negsi2 = 78,
+   CODE_FOR_neghi2 = 79,
+   CODE_FOR_negdf2 = 80,
+   CODE_FOR_negsf2 = 81,
+   CODE_FOR_abssi2 = 82,
+   CODE_FOR_abshi2 = 83,
+   CODE_FOR_absdf2 = 84,
+   CODE_FOR_abssf2 = 85,
+   CODE_FOR_one_cmplsi2 = 87,
+   CODE_FOR_one_cmplhi2 = 89,
+   CODE_FOR_one_cmplqi2 = 91,
+   CODE_FOR_ashldi3 = 92,
+   CODE_FOR_ashrdi3 = 93,
+   CODE_FOR_ashlsi3 = 94,
+   CODE_FOR_ashrsi3 = 95,
+   CODE_FOR_ashlhi3 = 96,
+   CODE_FOR_ashrhi3 = 97,
+   CODE_FOR_ashlqi3 = 98,
+   CODE_FOR_ashrqi3 = 99,
+   CODE_FOR_lshrdi3 = 100,
+   CODE_FOR_lshrsi3 = 101,
+   CODE_FOR_lshrhi3 = 102,
+   CODE_FOR_lshrqi3 = 103,
+   CODE_FOR_beq = 104,
+   CODE_FOR_bne = 105,
+   CODE_FOR_bgt = 106,
+   CODE_FOR_bgtu = 107,
+   CODE_FOR_blt = 108,
+   CODE_FOR_bltu = 109,
+   CODE_FOR_bge = 110,
+   CODE_FOR_bgeu = 111,
+   CODE_FOR_ble = 112,
+   CODE_FOR_bleu = 113,
+   CODE_FOR_jump = 126,
+   CODE_FOR_indirect_jump = 127,
+   CODE_FOR_tablejump = 128,
+   CODE_FOR_call = 129,
+   CODE_FOR_call_value = 130,
+   CODE_FOR_nop = 133,
+   CODE_FOR_cmpstrsi = 134,
+   CODE_FOR_clrstrsi = 135,
+   CODE_FOR_movstrsi = 136,
+   CODE_FOR_extendsidi2 = 137,
+   CODE_FOR_zero_extendsidi2 = 138,
+   CODE_FOR_adddi3 = 139,
+   CODE_FOR_mulsi3 = 140,
+   CODE_FOR_divsi3 = 141,
+   CODE_FOR_udivsi3 = 142,
+   CODE_FOR_modsi3 = 143,
+   CODE_FOR_umodsi3 = 144,
+   CODE_FOR_untyped_call = 145,
+ CODE_FOR_nothing
+ };
+ 
+ #endif /* GCC_INSN_CODES_H */
Index: gcc/gcc/insn-config.h
diff -c nul gcc/gcc/insn-config.h:1.1
*** nul	Tue Oct 01 16:28:45 2019
--- gcc/gcc/insn-config.h	Wed Feb 15 21:25:41 2006
***************
*** 0 ****
--- 1,14 ----
+ /* Generated automatically by the program `genconfig'
+    from the machine description file `md'.  */
+ 
+ #ifndef GCC_INSN_CONFIG_H
+ #define GCC_INSN_CONFIG_H
+ 
+ #define MAX_RECOG_OPERANDS 30
+ #define MAX_DUP_OPERANDS 4
+ #ifndef MAX_INSNS_PER_SPLIT
+ #define MAX_INSNS_PER_SPLIT 1
+ #endif
+ #define HAVE_cc0 1
+ 
+ #endif /* GCC_INSN_CONFIG_H */
Index: gcc/gcc/insn-constants.h
diff -c nul gcc/gcc/insn-constants.h:1.1
*** nul	Tue Oct 01 16:28:45 2019
--- gcc/gcc/insn-constants.h	Wed Feb 15 21:25:41 2006
***************
*** 0 ****
--- 1,8 ----
+ /* Generated automatically by the program `genconstants'
+    from the machine description file `md'.  */
+ 
+ #ifndef GCC_INSN_CONSTANTS_H
+ #define GCC_INSN_CONSTANTS_H
+ 
+ 
+ #endif /* GCC_INSN_CONSTANTS_H */
Index: gcc/gcc/insn-emit.c
diff -c nul gcc/gcc/insn-emit.c:1.19
*** nul	Tue Oct 01 16:28:45 2019
--- gcc/gcc/insn-emit.c	Thu Jan 14 15:53:03 2016
***************
*** 0 ****
--- 1,1955 ----
+ /* Generated automatically by the program `genemit'
+ from the machine description file `md'.  */
+ 
+ #include "config.h"
+ #include "system.h"
+ #include "rtl.h"
+ #include "tm_p.h"
+ #include "function.h"
+ #include "expr.h"
+ #include "optabs.h"
+ #include "real.h"
+ #include "flags.h"
+ #include "output.h"
+ #include "insn-config.h"
+ #include "hard-reg-set.h"
+ #include "recog.h"
+ #include "resource.h"
+ #include "reload.h"
+ #include "toplev.h"
+ #include "ggc.h"
+ 
+ #define FAIL return (end_sequence (), _val)
+ #define DONE return (_val = gen_sequence (), end_sequence (), _val)
+ rtx
+ gen_tstdi (operand0)
+      rtx operand0;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	cc0_rtx,
+ 	operand0);
+ }
+ 
+ rtx
+ gen_tstsi (operand0)
+      rtx operand0;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	cc0_rtx,
+ 	operand0);
+ }
+ 
+ rtx
+ gen_tsthi (operand0)
+      rtx operand0;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	cc0_rtx,
+ 	operand0);
+ }
+ 
+ rtx
+ gen_tstdf (operand0)
+      rtx operand0;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	cc0_rtx,
+ 	operand0);
+ }
+ 
+ rtx
+ gen_tstsf (operand0)
+      rtx operand0;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	cc0_rtx,
+ 	operand0);
+ }
+ 
+ rtx
+ gen_cmpsi (operand0, operand1)
+      rtx operand0;
+      rtx operand1;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	cc0_rtx,
+ 	gen_rtx_COMPARE (VOIDmode,
+ 	operand0,
+ 	operand1));
+ }
+ 
+ rtx
+ gen_cmphi (operand0, operand1)
+      rtx operand0;
+      rtx operand1;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	cc0_rtx,
+ 	gen_rtx_COMPARE (VOIDmode,
+ 	operand0,
+ 	operand1));
+ }
+ 
+ rtx
+ gen_cmpqi (operand0, operand1)
+      rtx operand0;
+      rtx operand1;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	cc0_rtx,
+ 	gen_rtx_COMPARE (VOIDmode,
+ 	operand0,
+ 	operand1));
+ }
+ 
+ rtx
+ gen_cmpdf (operand0, operand1)
+      rtx operand0;
+      rtx operand1;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	cc0_rtx,
+ 	gen_rtx_COMPARE (VOIDmode,
+ 	operand0,
+ 	operand1));
+ }
+ 
+ rtx
+ gen_cmpsf (operand0, operand1)
+      rtx operand0;
+      rtx operand1;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	cc0_rtx,
+ 	gen_rtx_COMPARE (VOIDmode,
+ 	operand0,
+ 	operand1));
+ }
+ 
+ rtx
+ gen_cmpstrsi_1 (operand0, operand1, operand2)
+      rtx operand0;
+      rtx operand1;
+      rtx operand2;
+ {
+   return gen_rtx_PARALLEL (VOIDmode, gen_rtvec (5,
+ 		gen_rtx_SET (VOIDmode,
+ 	operand0,
+ 	gen_rtx_COMPARE (SImode,
+ 	gen_rtx_MEM (BLKmode,
+ 	operand1),
+ 	gen_rtx_MEM (BLKmode,
+ 	operand2))),
+ 		gen_rtx_USE (VOIDmode,
+ 	operand1),
+ 		gen_rtx_USE (VOIDmode,
+ 	operand2),
+ 		gen_rtx_CLOBBER (VOIDmode,
+ 	operand1),
+ 		gen_rtx_CLOBBER (VOIDmode,
+ 	operand2)));
+ }
+ 
+ rtx
+ gen_movdi (operand0, operand1)
+      rtx operand0;
+      rtx operand1;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	operand0,
+ 	operand1);
+ }
+ 
+ rtx
+ gen_movsi (operand0, operand1)
+      rtx operand0;
+      rtx operand1;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	operand0,
+ 	operand1);
+ }
+ 
+ rtx
+ gen_movhi (operand0, operand1)
+      rtx operand0;
+      rtx operand1;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	operand0,
+ 	operand1);
+ }
+ 
+ rtx
+ gen_movqi (operand0, operand1)
+      rtx operand0;
+      rtx operand1;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	operand0,
+ 	operand1);
+ }
+ 
+ rtx
+ gen_movstricthi (operand0, operand1)
+      rtx operand0;
+      rtx operand1;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	gen_rtx_STRICT_LOW_PART (VOIDmode,
+ 	operand0),
+ 	operand1);
+ }
+ 
+ rtx
+ gen_movdf (operand0, operand1)
+      rtx operand0;
+      rtx operand1;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	operand0,
+ 	operand1);
+ }
+ 
+ rtx
+ gen_movsf (operand0, operand1)
+      rtx operand0;
+      rtx operand1;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	operand0,
+ 	operand1);
+ }
+ 
+ rtx
+ gen_movstrsi_1 (operand0, operand1)
+      rtx operand0;
+      rtx operand1;
+ {
+   return gen_rtx_PARALLEL (VOIDmode, gen_rtvec (5,
+ 		gen_rtx_SET (VOIDmode,
+ 	gen_rtx_MEM (BLKmode,
+ 	operand0),
+ 	gen_rtx_MEM (BLKmode,
+ 	operand1)),
+ 		gen_rtx_USE (VOIDmode,
+ 	operand0),
+ 		gen_rtx_USE (VOIDmode,
+ 	operand1),
+ 		gen_rtx_CLOBBER (VOIDmode,
+ 	operand0),
+ 		gen_rtx_CLOBBER (VOIDmode,
+ 	operand1)));
+ }
+ 
+ rtx
+ gen_extendhisi2 (operand0, operand1)
+      rtx operand0;
+      rtx operand1;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	operand0,
+ 	gen_rtx_SIGN_EXTEND (SImode,
+ 	operand1));
+ }
+ 
+ rtx
+ gen_extendqisi2 (operand0, operand1)
+      rtx operand0;
+      rtx operand1;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	operand0,
+ 	gen_rtx_SIGN_EXTEND (SImode,
+ 	operand1));
+ }
+ 
+ rtx
+ gen_extendqihi2 (operand0, operand1)
+      rtx operand0;
+      rtx operand1;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	operand0,
+ 	gen_rtx_SIGN_EXTEND (HImode,
+ 	operand1));
+ }
+ 
+ rtx
+ gen_zero_extendhisi2 (operand0, operand1)
+      rtx operand0;
+      rtx operand1;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	operand0,
+ 	gen_rtx_ZERO_EXTEND (SImode,
+ 	operand1));
+ }
+ 
+ rtx
+ gen_zero_extendqisi2 (operand0, operand1)
+      rtx operand0;
+      rtx operand1;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	operand0,
+ 	gen_rtx_ZERO_EXTEND (SImode,
+ 	operand1));
+ }
+ 
+ rtx
+ gen_zero_extendqihi2 (operand0, operand1)
+      rtx operand0;
+      rtx operand1;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	operand0,
+ 	gen_rtx_ZERO_EXTEND (HImode,
+ 	operand1));
+ }
+ 
+ rtx
+ gen_truncsihi2 (operand0, operand1)
+      rtx operand0;
+      rtx operand1;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	operand0,
+ 	gen_rtx_TRUNCATE (HImode,
+ 	operand1));
+ }
+ 
+ rtx
+ gen_fix_truncdfsi2 (operand0, operand1)
+      rtx operand0;
+      rtx operand1;
+ {
+   return gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2,
+ 		gen_rtx_SET (VOIDmode,
+ 	operand0,
+ 	gen_rtx_FIX (SImode,
+ 	gen_rtx_TRUNCATE (DFmode,
+ 	operand1))),
+ 		gen_rtx_CLOBBER (VOIDmode,
+ 	gen_rtx_REG (DFmode,
+ 	16))));
+ }
+ 
+ rtx
+ gen_floatsidf2 (operand0, operand1)
+      rtx operand0;
+      rtx operand1;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	operand0,
+ 	gen_rtx_FLOAT (DFmode,
+ 	operand1));
+ }
+ 
+ rtx
+ gen_truncdfsf2 (operand0, operand1)
+      rtx operand0;
+      rtx operand1;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	operand0,
+ 	gen_rtx_FLOAT_TRUNCATE (SFmode,
+ 	operand1));
+ }
+ 
+ rtx
+ gen_extendsfdf2 (operand0, operand1)
+      rtx operand0;
+      rtx operand1;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	operand0,
+ 	gen_rtx_FLOAT_EXTEND (DFmode,
+ 	operand1));
+ }
+ 
+ rtx
+ gen_addsi3 (operand0, operand1, operand2)
+      rtx operand0;
+      rtx operand1;
+      rtx operand2;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	operand0,
+ 	gen_rtx_PLUS (SImode,
+ 	operand1,
+ 	operand2));
+ }
+ 
+ rtx
+ gen_addhi3 (operand0, operand1, operand2)
+      rtx operand0;
+      rtx operand1;
+      rtx operand2;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	operand0,
+ 	gen_rtx_PLUS (HImode,
+ 	operand1,
+ 	operand2));
+ }
+ 
+ rtx
+ gen_addqi3 (operand0, operand1, operand2)
+      rtx operand0;
+      rtx operand1;
+      rtx operand2;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	operand0,
+ 	gen_rtx_PLUS (QImode,
+ 	operand1,
+ 	operand2));
+ }
+ 
+ rtx
+ gen_adddf3 (operand0, operand1, operand2)
+      rtx operand0;
+      rtx operand1;
+      rtx operand2;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	operand0,
+ 	gen_rtx_PLUS (DFmode,
+ 	operand1,
+ 	operand2));
+ }
+ 
+ rtx
+ gen_addsf3 (operand0, operand1, operand2)
+      rtx operand0;
+      rtx operand1;
+      rtx operand2;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	operand0,
+ 	gen_rtx_PLUS (SFmode,
+ 	operand1,
+ 	operand2));
+ }
+ 
+ rtx
+ gen_subsi3 (operand0, operand1, operand2)
+      rtx operand0;
+      rtx operand1;
+      rtx operand2;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	operand0,
+ 	gen_rtx_MINUS (SImode,
+ 	operand1,
+ 	operand2));
+ }
+ 
+ rtx
+ gen_subhi3 (operand0, operand1, operand2)
+      rtx operand0;
+      rtx operand1;
+      rtx operand2;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	operand0,
+ 	gen_rtx_MINUS (HImode,
+ 	operand1,
+ 	operand2));
+ }
+ 
+ rtx
+ gen_subqi3 (operand0, operand1, operand2)
+      rtx operand0;
+      rtx operand1;
+      rtx operand2;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	operand0,
+ 	gen_rtx_MINUS (QImode,
+ 	operand1,
+ 	operand2));
+ }
+ 
+ rtx
+ gen_subdf3 (operand0, operand1, operand2)
+      rtx operand0;
+      rtx operand1;
+      rtx operand2;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	operand0,
+ 	gen_rtx_MINUS (DFmode,
+ 	operand1,
+ 	operand2));
+ }
+ 
+ rtx
+ gen_subsf3 (operand0, operand1, operand2)
+      rtx operand0;
+      rtx operand1;
+      rtx operand2;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	operand0,
+ 	gen_rtx_MINUS (SFmode,
+ 	operand1,
+ 	operand2));
+ }
+ 
+ rtx
+ gen_muldf3 (operand0, operand1, operand2)
+      rtx operand0;
+      rtx operand1;
+      rtx operand2;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	operand0,
+ 	gen_rtx_MULT (DFmode,
+ 	operand1,
+ 	operand2));
+ }
+ 
+ rtx
+ gen_mulsf3 (operand0, operand1, operand2)
+      rtx operand0;
+      rtx operand1;
+      rtx operand2;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	operand0,
+ 	gen_rtx_MULT (SFmode,
+ 	operand1,
+ 	operand2));
+ }
+ 
+ rtx
+ gen_divdf3 (operand0, operand1, operand2)
+      rtx operand0;
+      rtx operand1;
+      rtx operand2;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	operand0,
+ 	gen_rtx_DIV (DFmode,
+ 	operand1,
+ 	operand2));
+ }
+ 
+ rtx
+ gen_divsf3 (operand0, operand1, operand2)
+      rtx operand0;
+      rtx operand1;
+      rtx operand2;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	operand0,
+ 	gen_rtx_DIV (SFmode,
+ 	operand1,
+ 	operand2));
+ }
+ 
+ rtx
+ gen_andsi3 (operand0, operand1, operand2)
+      rtx operand0;
+      rtx operand1;
+      rtx operand2;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	operand0,
+ 	gen_rtx_AND (SImode,
+ 	operand1,
+ 	operand2));
+ }
+ 
+ rtx
+ gen_andhi3 (operand0, operand1, operand2)
+      rtx operand0;
+      rtx operand1;
+      rtx operand2;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	operand0,
+ 	gen_rtx_AND (HImode,
+ 	operand1,
+ 	operand2));
+ }
+ 
+ rtx
+ gen_andqi3 (operand0, operand1, operand2)
+      rtx operand0;
+      rtx operand1;
+      rtx operand2;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	operand0,
+ 	gen_rtx_AND (QImode,
+ 	operand1,
+ 	operand2));
+ }
+ 
+ rtx
+ gen_iorsi3 (operand0, operand1, operand2)
+      rtx operand0;
+      rtx operand1;
+      rtx operand2;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	operand0,
+ 	gen_rtx_IOR (SImode,
+ 	operand1,
+ 	operand2));
+ }
+ 
+ rtx
+ gen_iorhi3 (operand0, operand1, operand2)
+      rtx operand0;
+      rtx operand1;
+      rtx operand2;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	operand0,
+ 	gen_rtx_IOR (HImode,
+ 	operand1,
+ 	operand2));
+ }
+ 
+ rtx
+ gen_iorqi3 (operand0, operand1, operand2)
+      rtx operand0;
+      rtx operand1;
+      rtx operand2;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	operand0,
+ 	gen_rtx_IOR (QImode,
+ 	operand1,
+ 	operand2));
+ }
+ 
+ rtx
+ gen_xorsi3 (operand0, operand1, operand2)
+      rtx operand0;
+      rtx operand1;
+      rtx operand2;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	operand0,
+ 	gen_rtx_XOR (SImode,
+ 	operand1,
+ 	operand2));
+ }
+ 
+ rtx
+ gen_xorhi3 (operand0, operand1, operand2)
+      rtx operand0;
+      rtx operand1;
+      rtx operand2;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	operand0,
+ 	gen_rtx_XOR (HImode,
+ 	operand1,
+ 	operand2));
+ }
+ 
+ rtx
+ gen_xorqi3 (operand0, operand1, operand2)
+      rtx operand0;
+      rtx operand1;
+      rtx operand2;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	operand0,
+ 	gen_rtx_XOR (QImode,
+ 	operand1,
+ 	operand2));
+ }
+ 
+ rtx
+ gen_negsi2 (operand0, operand1)
+      rtx operand0;
+      rtx operand1;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	operand0,
+ 	gen_rtx_NEG (SImode,
+ 	operand1));
+ }
+ 
+ rtx
+ gen_neghi2 (operand0, operand1)
+      rtx operand0;
+      rtx operand1;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	operand0,
+ 	gen_rtx_NEG (HImode,
+ 	operand1));
+ }
+ 
+ rtx
+ gen_negdf2 (operand0, operand1)
+      rtx operand0;
+      rtx operand1;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	operand0,
+ 	gen_rtx_NEG (DFmode,
+ 	operand1));
+ }
+ 
+ rtx
+ gen_negsf2 (operand0, operand1)
+      rtx operand0;
+      rtx operand1;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	operand0,
+ 	gen_rtx_NEG (SFmode,
+ 	operand1));
+ }
+ 
+ rtx
+ gen_abssi2 (operand0, operand1)
+      rtx operand0;
+      rtx operand1;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	operand0,
+ 	gen_rtx_ABS (SImode,
+ 	operand1));
+ }
+ 
+ rtx
+ gen_abshi2 (operand0, operand1)
+      rtx operand0;
+      rtx operand1;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	operand0,
+ 	gen_rtx_ABS (HImode,
+ 	operand1));
+ }
+ 
+ rtx
+ gen_absdf2 (operand0, operand1)
+      rtx operand0;
+      rtx operand1;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	operand0,
+ 	gen_rtx_ABS (DFmode,
+ 	operand1));
+ }
+ 
+ rtx
+ gen_abssf2 (operand0, operand1)
+      rtx operand0;
+      rtx operand1;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	operand0,
+ 	gen_rtx_ABS (SFmode,
+ 	operand1));
+ }
+ 
+ rtx
+ gen_one_cmplsi2 (operand0, operand1)
+      rtx operand0;
+      rtx operand1;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	operand0,
+ 	gen_rtx_NOT (SImode,
+ 	operand1));
+ }
+ 
+ rtx
+ gen_one_cmplhi2 (operand0, operand1)
+      rtx operand0;
+      rtx operand1;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	operand0,
+ 	gen_rtx_NOT (HImode,
+ 	operand1));
+ }
+ 
+ rtx
+ gen_one_cmplqi2 (operand0, operand1)
+      rtx operand0;
+      rtx operand1;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	operand0,
+ 	gen_rtx_NOT (QImode,
+ 	operand1));
+ }
+ 
+ rtx
+ gen_ashldi3 (operand0, operand1, operand2)
+      rtx operand0;
+      rtx operand1;
+      rtx operand2;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	operand0,
+ 	gen_rtx_ASHIFT (DImode,
+ 	operand1,
+ 	operand2));
+ }
+ 
+ rtx
+ gen_ashrdi3 (operand0, operand1, operand2)
+      rtx operand0;
+      rtx operand1;
+      rtx operand2;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	operand0,
+ 	gen_rtx_ASHIFTRT (DImode,
+ 	operand1,
+ 	operand2));
+ }
+ 
+ rtx
+ gen_ashlsi3 (operand0, operand1, operand2)
+      rtx operand0;
+      rtx operand1;
+      rtx operand2;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	operand0,
+ 	gen_rtx_ASHIFT (SImode,
+ 	operand1,
+ 	operand2));
+ }
+ 
+ rtx
+ gen_ashrsi3 (operand0, operand1, operand2)
+      rtx operand0;
+      rtx operand1;
+      rtx operand2;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	operand0,
+ 	gen_rtx_ASHIFTRT (SImode,
+ 	operand1,
+ 	operand2));
+ }
+ 
+ rtx
+ gen_ashlhi3 (operand0, operand1, operand2)
+      rtx operand0;
+      rtx operand1;
+      rtx operand2;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	operand0,
+ 	gen_rtx_ASHIFT (HImode,
+ 	operand1,
+ 	operand2));
+ }
+ 
+ rtx
+ gen_ashrhi3 (operand0, operand1, operand2)
+      rtx operand0;
+      rtx operand1;
+      rtx operand2;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	operand0,
+ 	gen_rtx_ASHIFTRT (HImode,
+ 	operand1,
+ 	operand2));
+ }
+ 
+ rtx
+ gen_ashlqi3 (operand0, operand1, operand2)
+      rtx operand0;
+      rtx operand1;
+      rtx operand2;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	operand0,
+ 	gen_rtx_ASHIFT (QImode,
+ 	operand1,
+ 	operand2));
+ }
+ 
+ rtx
+ gen_ashrqi3 (operand0, operand1, operand2)
+      rtx operand0;
+      rtx operand1;
+      rtx operand2;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	operand0,
+ 	gen_rtx_ASHIFTRT (QImode,
+ 	operand1,
+ 	operand2));
+ }
+ 
+ rtx
+ gen_lshrdi3 (operand0, operand1, operand2)
+      rtx operand0;
+      rtx operand1;
+      rtx operand2;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	operand0,
+ 	gen_rtx_LSHIFTRT (DImode,
+ 	operand1,
+ 	operand2));
+ }
+ 
+ rtx
+ gen_lshrsi3 (operand0, operand1, operand2)
+      rtx operand0;
+      rtx operand1;
+      rtx operand2;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	operand0,
+ 	gen_rtx_LSHIFTRT (SImode,
+ 	operand1,
+ 	operand2));
+ }
+ 
+ rtx
+ gen_lshrhi3 (operand0, operand1, operand2)
+      rtx operand0;
+      rtx operand1;
+      rtx operand2;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	operand0,
+ 	gen_rtx_LSHIFTRT (HImode,
+ 	operand1,
+ 	operand2));
+ }
+ 
+ rtx
+ gen_lshrqi3 (operand0, operand1, operand2)
+      rtx operand0;
+      rtx operand1;
+      rtx operand2;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	operand0,
+ 	gen_rtx_LSHIFTRT (QImode,
+ 	operand1,
+ 	operand2));
+ }
+ 
+ rtx
+ gen_beq (operand0)
+      rtx operand0;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	pc_rtx,
+ 	gen_rtx_IF_THEN_ELSE (VOIDmode,
+ 	gen_rtx_EQ (VOIDmode,
+ 	cc0_rtx,
+ 	const0_rtx),
+ 	gen_rtx_LABEL_REF (VOIDmode,
+ 	operand0),
+ 	pc_rtx));
+ }
+ 
+ rtx
+ gen_bne (operand0)
+      rtx operand0;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	pc_rtx,
+ 	gen_rtx_IF_THEN_ELSE (VOIDmode,
+ 	gen_rtx_NE (VOIDmode,
+ 	cc0_rtx,
+ 	const0_rtx),
+ 	gen_rtx_LABEL_REF (VOIDmode,
+ 	operand0),
+ 	pc_rtx));
+ }
+ 
+ rtx
+ gen_bgt (operand0)
+      rtx operand0;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	pc_rtx,
+ 	gen_rtx_IF_THEN_ELSE (VOIDmode,
+ 	gen_rtx_GT (VOIDmode,
+ 	cc0_rtx,
+ 	const0_rtx),
+ 	gen_rtx_LABEL_REF (VOIDmode,
+ 	operand0),
+ 	pc_rtx));
+ }
+ 
+ rtx
+ gen_bgtu (operand0)
+      rtx operand0;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	pc_rtx,
+ 	gen_rtx_IF_THEN_ELSE (VOIDmode,
+ 	gen_rtx_GTU (VOIDmode,
+ 	cc0_rtx,
+ 	const0_rtx),
+ 	gen_rtx_LABEL_REF (VOIDmode,
+ 	operand0),
+ 	pc_rtx));
+ }
+ 
+ rtx
+ gen_blt (operand0)
+      rtx operand0;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	pc_rtx,
+ 	gen_rtx_IF_THEN_ELSE (VOIDmode,
+ 	gen_rtx_LT (VOIDmode,
+ 	cc0_rtx,
+ 	const0_rtx),
+ 	gen_rtx_LABEL_REF (VOIDmode,
+ 	operand0),
+ 	pc_rtx));
+ }
+ 
+ rtx
+ gen_bltu (operand0)
+      rtx operand0;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	pc_rtx,
+ 	gen_rtx_IF_THEN_ELSE (VOIDmode,
+ 	gen_rtx_LTU (VOIDmode,
+ 	cc0_rtx,
+ 	const0_rtx),
+ 	gen_rtx_LABEL_REF (VOIDmode,
+ 	operand0),
+ 	pc_rtx));
+ }
+ 
+ rtx
+ gen_bge (operand0)
+      rtx operand0;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	pc_rtx,
+ 	gen_rtx_IF_THEN_ELSE (VOIDmode,
+ 	gen_rtx_GE (VOIDmode,
+ 	cc0_rtx,
+ 	const0_rtx),
+ 	gen_rtx_LABEL_REF (VOIDmode,
+ 	operand0),
+ 	pc_rtx));
+ }
+ 
+ rtx
+ gen_bgeu (operand0)
+      rtx operand0;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	pc_rtx,
+ 	gen_rtx_IF_THEN_ELSE (VOIDmode,
+ 	gen_rtx_GEU (VOIDmode,
+ 	cc0_rtx,
+ 	const0_rtx),
+ 	gen_rtx_LABEL_REF (VOIDmode,
+ 	operand0),
+ 	pc_rtx));
+ }
+ 
+ rtx
+ gen_ble (operand0)
+      rtx operand0;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	pc_rtx,
+ 	gen_rtx_IF_THEN_ELSE (VOIDmode,
+ 	gen_rtx_LE (VOIDmode,
+ 	cc0_rtx,
+ 	const0_rtx),
+ 	gen_rtx_LABEL_REF (VOIDmode,
+ 	operand0),
+ 	pc_rtx));
+ }
+ 
+ rtx
+ gen_bleu (operand0)
+      rtx operand0;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	pc_rtx,
+ 	gen_rtx_IF_THEN_ELSE (VOIDmode,
+ 	gen_rtx_LEU (VOIDmode,
+ 	cc0_rtx,
+ 	const0_rtx),
+ 	gen_rtx_LABEL_REF (VOIDmode,
+ 	operand0),
+ 	pc_rtx));
+ }
+ 
+ rtx
+ gen_jump (operand0)
+      rtx operand0;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	pc_rtx,
+ 	gen_rtx_LABEL_REF (VOIDmode,
+ 	operand0));
+ }
+ 
+ rtx
+ gen_indirect_jump (operand0)
+      rtx operand0;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	pc_rtx,
+ 	operand0);
+ }
+ 
+ rtx
+ gen_tablejump (operand0, operand1)
+      rtx operand0;
+      rtx operand1;
+ {
+   return gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2,
+ 		gen_rtx_SET (VOIDmode,
+ 	pc_rtx,
+ 	operand0),
+ 		gen_rtx_USE (VOIDmode,
+ 	gen_rtx_LABEL_REF (VOIDmode,
+ 	operand1))));
+ }
+ 
+ rtx
+ gen_call (operand0, operand1)
+      rtx operand0;
+      rtx operand1;
+ {
+   return gen_rtx_CALL (VOIDmode,
+ 	operand0,
+ 	operand1);
+ }
+ 
+ rtx
+ gen_call_value (operand0, operand1, operand2)
+      rtx operand0;
+      rtx operand1;
+      rtx operand2;
+ {
+   return gen_rtx_SET (VOIDmode,
+ 	operand0,
+ 	gen_rtx_CALL (VOIDmode,
+ 	operand1,
+ 	operand2));
+ }
+ 
+ rtx
+ gen_nop ()
+ {
+   return const0_rtx;
+ }
+ 
+ rtx
+ gen_cmpstrsi (operand0, operand1, operand2, operand3, operand4)
+      rtx operand0;
+      rtx operand1;
+      rtx operand2;
+      rtx operand3;
+      rtx operand4;
+ {
+   rtx _val = 0;
+   start_sequence ();
+   {
+     rtx operands[5];
+     operands[0] = operand0;
+     operands[1] = operand1;
+     operands[2] = operand2;
+     operands[3] = operand3;
+     operands[4] = operand4;
+ 
+ {
+   rtx op1, op2;
+ 
+   op1 = XEXP (operands[1], 0);
+   if (GET_CODE (op1) == REG
+       || (GET_CODE (op1) == PLUS && GET_CODE (XEXP (op1, 0)) == REG
+ 	  && GET_CODE (XEXP (op1, 1)) == CONST_INT
+ 	  && (unsigned) INTVAL (XEXP (op1, 1)) < 4096))
+     {
+       op1 = operands[1];
+     }
+   else
+     {
+       op1 = gen_rtx_MEM (BLKmode, copy_to_mode_reg (SImode, op1));
+     }
+ 
+   op2 = XEXP (operands[2], 0);
+   if (GET_CODE (op2) == REG
+       || (GET_CODE (op2) == PLUS && GET_CODE (XEXP (op2, 0)) == REG
+ 	  && GET_CODE (XEXP (op2, 1)) == CONST_INT
+ 	  && (unsigned) INTVAL (XEXP (op2, 1)) < 4096))
+     {
+       op2 = operands[2];
+     }
+   else
+     {
+       op2 = gen_rtx_MEM (BLKmode, copy_to_mode_reg (SImode, op2));
+     }
+       
+   if (GET_CODE (operands[3]) == CONST_INT 
+       && (unsigned)INTVAL (operands[3]) <= 256)
+     {
+       emit_insn (gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2,
+ 		gen_rtx_SET (VOIDmode, operands[0], 
+ 			gen_rtx_COMPARE (SImode, op1, op2)), /* was VOIDmode */
+ 		gen_rtx_USE (VOIDmode, operands[3]))));
+     }
+   else
+     {
+         /* implementation suggested by  Richard Henderson <rth@cygnus.com> */
+         rtx reg1 = gen_reg_rtx (DImode);
+         rtx reg2 = gen_reg_rtx (DImode);
+         rtx result = operands[0];
+         rtx mem1 = operands[1];
+         rtx mem2 = operands[2];
+         rtx len = operands[3];
+         if (!CONSTANT_P (len))
+           len = force_reg (SImode, len);
+ 
+         /* Load up the address+length pairs.  */
+         emit_insn (gen_rtx_CLOBBER (VOIDmode, reg1));
+         emit_move_insn (gen_rtx_SUBREG (SImode, reg1, 0),
+                         force_operand (XEXP (mem1, 0), NULL_RTX));
+         emit_move_insn (gen_rtx_SUBREG (SImode, reg1, GET_MODE_SIZE (SImode)), len);
+ 
+         emit_insn (gen_rtx_CLOBBER (VOIDmode, reg2));
+         emit_move_insn (gen_rtx_SUBREG (SImode, reg2, 0),
+                         force_operand (XEXP (mem2, 0), NULL_RTX));
+         emit_move_insn (gen_rtx_SUBREG (SImode, reg2, GET_MODE_SIZE (SImode)), len);
+ 
+         /* Compare! */
+         emit_insn (gen_cmpstrsi_1 (result, reg1, reg2));
+     }
+   DONE;
+ }
+     operand0 = operands[0];
+     operand1 = operands[1];
+     operand2 = operands[2];
+     operand3 = operands[3];
+     operand4 = operands[4];
+   }
+   emit_insn (gen_rtx_SET (VOIDmode,
+ 	operand0,
+ 	gen_rtx_COMPARE (VOIDmode,
+ 	operand1,
+ 	operand2)));
+   emit_insn (gen_rtx_USE (VOIDmode,
+ 	operand3));
+   emit_insn (gen_rtx_USE (VOIDmode,
+ 	operand4));
+   _val = gen_sequence ();
+   end_sequence ();
+   return _val;
+ }
+ 
+ rtx
+ gen_clrstrsi (operand0, operand1, operand2)
+      rtx operand0;
+      rtx operand1;
+      rtx operand2;
+ {
+   rtx _val = 0;
+   start_sequence ();
+   {
+     rtx operands[3];
+     operands[0] = operand0;
+     operands[1] = operand1;
+     operands[2] = operand2;
+ 
+ {
+   {
+         /* implementation suggested by  Richard Henderson <rth@cygnus.com> */
+         rtx reg1 = gen_reg_rtx (DImode);
+         rtx reg2 = gen_reg_rtx (DImode);
+         rtx mem1 = operands[0];
+         rtx zippo = gen_rtx_CONST_INT (SImode, 0);
+         rtx len = operands[1];
+         if (!CONSTANT_P (len))
+           len = force_reg (SImode, len);
+ 
+         /* Load up the address+length pairs.  */
+         emit_insn (gen_rtx_CLOBBER (VOIDmode, reg1));
+         emit_move_insn (gen_rtx_SUBREG (SImode, reg1, 0),
+                         force_operand (XEXP (mem1, 0), NULL_RTX));
+         emit_move_insn (gen_rtx_SUBREG (SImode, reg1, GET_MODE_SIZE (SImode)), len);
+ 
+         emit_insn (gen_rtx_CLOBBER (VOIDmode, reg2));
+         emit_move_insn (gen_rtx_SUBREG (SImode, reg2, 0), zippo);
+         emit_move_insn (gen_rtx_SUBREG (SImode, reg2, GET_MODE_SIZE (SImode)), zippo);
+ 
+         /* Copy! */
+         emit_insn (gen_movstrsi_1 (reg1, reg2));
+   }
+   DONE;
+ }
+     operand0 = operands[0];
+     operand1 = operands[1];
+     operand2 = operands[2];
+   }
+   emit_insn (gen_rtx_SET (VOIDmode,
+ 	operand0,
+ 	const0_rtx));
+   emit_insn (gen_rtx_USE (VOIDmode,
+ 	operand1));
+   emit (operand2);
+   _val = gen_sequence ();
+   end_sequence ();
+   return _val;
+ }
+ 
+ rtx
+ gen_movstrsi (operand0, operand1, operand2, operand3)
+      rtx operand0;
+      rtx operand1;
+      rtx operand2;
+      rtx operand3;
+ {
+   rtx _val = 0;
+   start_sequence ();
+   {
+     rtx operands[4];
+     operands[0] = operand0;
+     operands[1] = operand1;
+     operands[2] = operand2;
+     operands[3] = operand3;
+ 
+ {
+   rtx op0, op1;
+ 
+   op0 = XEXP (operands[0], 0);
+   if (GET_CODE (op0) == REG
+       || (GET_CODE (op0) == PLUS && GET_CODE (XEXP (op0, 0)) == REG
+ 	  && GET_CODE (XEXP (op0, 1)) == CONST_INT
+ 	  && (unsigned) INTVAL (XEXP (op0, 1)) < 4096))
+     op0 = operands[0];
+   else
+     op0 = replace_equiv_address (operands[0], copy_to_mode_reg (SImode, op0));
+ 
+   op1 = XEXP (operands[1], 0);
+   if (GET_CODE (op1) == REG
+       || (GET_CODE (op1) == PLUS && GET_CODE (XEXP (op1, 0)) == REG
+ 	  && GET_CODE (XEXP (op1, 1)) == CONST_INT
+ 	  && (unsigned) INTVAL (XEXP (op1, 1)) < 4096))
+     op1 = operands[1];
+   else
+     op1 = replace_equiv_address (operands[1], copy_to_mode_reg (SImode, op1));
+ 
+   if (GET_CODE (operands[2]) == CONST_INT
+       && (unsigned) INTVAL (operands[2]) <= 256)
+     emit_insn (gen_rtx_PARALLEL (VOIDmode,
+ 			gen_rtvec (2,
+ 				   gen_rtx_SET (VOIDmode, op0, op1),
+ 				   gen_rtx_USE (VOIDmode, operands[2]))));
+ 
+   else
+     {
+         /* implementation provided by  Richard Henderson <rth@cygnus.com> */
+         rtx reg1 = gen_reg_rtx (DImode);
+         rtx reg2 = gen_reg_rtx (DImode);
+         rtx mem1 = operands[0];
+         rtx mem2 = operands[1];
+         rtx len = operands[2];
+         if (!CONSTANT_P (len))
+           len = force_reg (SImode, len);
+ 
+         /* Load up the address+length pairs.  */
+         emit_insn (gen_rtx_CLOBBER (VOIDmode, reg1));
+         emit_move_insn (gen_rtx_SUBREG (SImode, reg1, 0),
+                         force_operand (XEXP (mem1, 0), NULL_RTX));
+         emit_move_insn (gen_rtx_SUBREG (SImode, reg1, GET_MODE_SIZE (SImode)), len);
+ 
+         emit_insn (gen_rtx_CLOBBER (VOIDmode, reg2));
+         emit_move_insn (gen_rtx_SUBREG (SImode, reg2, 0),
+                         force_operand (XEXP (mem2, 0), NULL_RTX));
+         emit_move_insn (gen_rtx_SUBREG (SImode, reg2, GET_MODE_SIZE (SImode)), len);
+ 
+         /* Copy! */
+         emit_insn (gen_movstrsi_1 (reg1, reg2));
+     }
+   DONE;
+ }
+     operand0 = operands[0];
+     operand1 = operands[1];
+     operand2 = operands[2];
+     operand3 = operands[3];
+   }
+   emit_insn (gen_rtx_SET (VOIDmode,
+ 	operand0,
+ 	operand1));
+   emit_insn (gen_rtx_USE (VOIDmode,
+ 	operand2));
+   emit (operand3);
+   _val = gen_sequence ();
+   end_sequence ();
+   return _val;
+ }
+ 
+ rtx
+ gen_extendsidi2 (operand0, operand1)
+      rtx operand0;
+      rtx operand1;
+ {
+   rtx _val = 0;
+   start_sequence ();
+   {
+     rtx operands[2];
+     operands[0] = operand0;
+     operands[1] = operand1;
+ 
+ {
+   if (GET_CODE (operands[1]) != CONST_INT)
+     {
+       emit_insn (gen_rtx_SET (VOIDmode,
+ 		  operand_subword (operands[0], 0, 1, DImode), operands[1]));
+       emit_insn (gen_rtx_SET (VOIDmode, operands[0],
+ 			gen_rtx_ASHIFTRT (DImode, operands[0],
+ 				gen_rtx_CONST_INT (SImode, 32))));
+     }
+   else
+     {
+       if (INTVAL (operands[1]) < 0)
+ 	{
+ 	  emit_insn (gen_rtx_SET (VOIDmode,
+ 				  operand_subword (operands[0], 0, 1, DImode),
+ 			       gen_rtx_CONST_INT (SImode, -1)));
+         }
+       else
+ 	{
+ 	  emit_insn (gen_rtx_SET (VOIDmode,
+ 				operand_subword (operands[0], 0, 1, DImode),
+ 			       gen_rtx_CONST_INT (SImode, 0)));
+         }
+       emit_insn (gen_rtx_SET (VOIDmode, gen_lowpart (SImode, operands[0]),
+ 			   operands[1]));
+     }
+   DONE;
+ }
+     operand0 = operands[0];
+     operand1 = operands[1];
+   }
+   emit_insn (gen_rtx_SET (VOIDmode,
+ 	operand0,
+ 	gen_rtx_SIGN_EXTEND (DImode,
+ 	operand1)));
+   _val = gen_sequence ();
+   end_sequence ();
+   return _val;
+ }
+ 
+ rtx
+ gen_zero_extendsidi2 (operand0, operand1)
+      rtx operand0;
+      rtx operand1;
+ {
+   rtx _val = 0;
+   start_sequence ();
+   {
+     rtx operands[2];
+     operands[0] = operand0;
+     operands[1] = operand1;
+ 
+ {
+       emit_insn (gen_rtx_SET (VOIDmode,
+ 		  operand_subword (operands[0], 0, 1, DImode), operands[1]));
+       emit_insn (gen_rtx_SET (VOIDmode, operands[0],
+ 			gen_rtx_LSHIFTRT (DImode, operands[0],
+ 				gen_rtx_CONST_INT (SImode, 32))));
+   DONE;
+ }
+     operand0 = operands[0];
+     operand1 = operands[1];
+   }
+   emit_insn (gen_rtx_SET (VOIDmode,
+ 	operand0,
+ 	gen_rtx_ZERO_EXTEND (DImode,
+ 	operand1)));
+   _val = gen_sequence ();
+   end_sequence ();
+   return _val;
+ }
+ 
+ rtx
+ gen_adddi3 (operand0, operand1, operand2)
+      rtx operand0;
+      rtx operand1;
+      rtx operand2;
+ {
+   rtx _val = 0;
+   start_sequence ();
+   {
+     rtx operands[3];
+     operands[0] = operand0;
+     operands[1] = operand1;
+     operands[2] = operand2;
+ 
+ {
+   rtx label = gen_label_rtx ();
+   rtx op0_high = operand_subword (operands[0], 0, 1, DImode);
+   rtx op0_low = gen_lowpart (SImode, operands[0]);
+ 	
+   emit_insn (gen_rtx_SET (VOIDmode, op0_high,
+ 		    gen_rtx_PLUS (SImode,
+ 			    operand_subword (operands[1], 0, 1, DImode),
+ 			    operand_subword (operands[2], 0, 1, DImode))));
+   emit_jump_insn (gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2,
+ 	      gen_rtx_SET (VOIDmode, op0_low,
+ 		      gen_rtx_PLUS (SImode, gen_lowpart (SImode, operands[1]),
+ 			      gen_lowpart (SImode, operands[2]))),
+ 	      gen_rtx_USE (VOIDmode, gen_rtx_LABEL_REF (VOIDmode, label)))));
+   emit_insn (gen_rtx_SET (VOIDmode, op0_high,
+ 		    gen_rtx_PLUS (SImode, op0_high,
+ 			    gen_rtx_CONST_INT (SImode, 1))));
+   emit_label (label);
+   DONE;
+ }
+     operand0 = operands[0];
+     operand1 = operands[1];
+     operand2 = operands[2];
+   }
+   emit_insn (gen_rtx_SET (VOIDmode,
+ 	operand0,
+ 	gen_rtx_PLUS (DImode,
+ 	operand1,
+ 	operand2)));
+   _val = gen_sequence ();
+   end_sequence ();
+   return _val;
+ }
+ 
+ rtx
+ gen_mulsi3 (operand0, operand1, operand2)
+      rtx operand0;
+      rtx operand1;
+      rtx operand2;
+ {
+   rtx _val = 0;
+   start_sequence ();
+   {
+     rtx operands[3];
+     operands[0] = operand0;
+     operands[1] = operand1;
+     operands[2] = operand2;
+ 
+ {
+   if (GET_CODE (operands[1]) == CONST_INT
+       && REG_P (operands[0])
+       && CONST_OK_FOR_LETTER_P (INTVAL (operands[1]), 'K'))
+     {
+       emit_insn (gen_rtx_SET (VOIDmode, operands[0],
+ 			  gen_rtx_MULT (SImode, operands[2], operands[1])));
+     }
+   else if (GET_CODE (operands[2]) == CONST_INT
+            && REG_P (operands[0])
+ 	   && CONST_OK_FOR_LETTER_P (INTVAL (operands[2]), 'K'))
+     {
+       emit_insn (gen_rtx_SET (VOIDmode, operands[0],
+ 			  gen_rtx_MULT (SImode, operands[1], operands[2])));
+     }
+   else
+     {
+       rtx r = gen_reg_rtx (DImode);
+ 
+       /* XXX trouble.  Below we generate some rtx's that model what
+        * is really supposed to happen with multiply on the 370/390
+        * hardware, and that is all well & good.  However, during optimization
+        * it can happen that the two operands are exchanged (after all,
+        * multiplication is commutitive), in which case the doubleword
+        * ends up in memory and everything is hosed.  The gen_reg_rtx
+        * should have kept it in a reg ...  We hack around this
+        * below, in the M/MR isntruction pattern, and constrain it to
+        * "di" instead of "g".  But this still ends up with lots & lots of
+        * movement between registers & memory and is an awful waste.
+        * Dunno how to untwist it elegantly; but it seems to work for now.
+        
+        * Note, this comment doesn't seem to be relevant for 3.4.6
+        * at least, so it is being opened up.
+        */
+       if (GET_CODE (operands[1]) == CONST_INT)
+       {
+       emit_insn (gen_rtx_SET (VOIDmode,
+ 			  gen_rtx_SUBREG (SImode, r, GET_MODE_SIZE (SImode)),
+ 					  operands[1]));
+       emit_insn (gen_rtx_SET (VOIDmode, r,
+ 			  gen_rtx_MULT (DImode, r, operands[2])));
+       }
+       else
+       {
+       emit_insn (gen_rtx_SET (VOIDmode,
+ 			  gen_rtx_SUBREG (SImode, r, GET_MODE_SIZE (SImode)),
+ 					  operands[2]));
+       emit_insn (gen_rtx_SET (VOIDmode, r,
+ 			  gen_rtx_MULT (DImode, r, operands[1])));
+       }
+       emit_insn (gen_rtx_SET (VOIDmode, operands[0],
+ 			  gen_rtx_SUBREG (SImode, r, GET_MODE_SIZE (SImode))));
+     }
+   DONE;
+ }
+     operand0 = operands[0];
+     operand1 = operands[1];
+     operand2 = operands[2];
+   }
+   emit_insn (gen_rtx_SET (VOIDmode,
+ 	operand0,
+ 	gen_rtx_MULT (SImode,
+ 	operand1,
+ 	operand2)));
+   _val = gen_sequence ();
+   end_sequence ();
+   return _val;
+ }
+ 
+ rtx
+ gen_divsi3 (operand0, operand1, operand2)
+      rtx operand0;
+      rtx operand1;
+      rtx operand2;
+ {
+   rtx _val = 0;
+   start_sequence ();
+   {
+     rtx operands[3];
+     operands[0] = operand0;
+     operands[1] = operand1;
+     operands[2] = operand2;
+ 
+ {
+   rtx r = gen_reg_rtx (DImode);
+ 
+   emit_insn (gen_extendsidi2 (r, operands[1]));
+   emit_insn (gen_rtx_SET (VOIDmode, r,
+ 			gen_rtx_DIV (DImode, r, operands[2])));
+   emit_insn (gen_rtx_SET (VOIDmode, operands[0],
+ 			gen_rtx_SUBREG (SImode, r, GET_MODE_SIZE (SImode))));
+   DONE;
+ }
+     operand0 = operands[0];
+     operand1 = operands[1];
+     operand2 = operands[2];
+   }
+   emit_insn (gen_rtx_SET (VOIDmode,
+ 	operand0,
+ 	gen_rtx_DIV (SImode,
+ 	operand1,
+ 	operand2)));
+   _val = gen_sequence ();
+   end_sequence ();
+   return _val;
+ }
+ 
+ rtx
+ gen_udivsi3 (operand0, operand1, operand2)
+      rtx operand0;
+      rtx operand1;
+      rtx operand2;
+ {
+   rtx _val = 0;
+   start_sequence ();
+   {
+     rtx operands[3];
+     operands[0] = operand0;
+     operands[1] = operand1;
+     operands[2] = operand2;
+ 
+ {
+   rtx dr = gen_reg_rtx (DImode);
+   rtx dr_0 = gen_rtx_SUBREG (SImode, dr, 0);
+   rtx dr_1 = gen_rtx_SUBREG (SImode, dr, GET_MODE_SIZE (SImode));
+ 
+ 
+   if (GET_CODE (operands[2]) == CONST_INT)
+     {
+       if (INTVAL (operands[2]) > 0)
+ 	{
+ 	  emit_insn (gen_zero_extendsidi2 (dr, operands[1]));
+ 	  emit_insn (gen_rtx_SET (VOIDmode, dr,
+ 			gen_rtx_DIV (DImode, dr, operands[2])));
+ 	}
+       else
+ 	{
+ 	  rtx label1 = gen_label_rtx ();
+ 
+ 	  emit_insn (gen_rtx_SET (VOIDmode, dr_0, operands[1]));
+ 	  emit_insn (gen_rtx_SET (VOIDmode, dr_1, const0_rtx));
+ 	  emit_insn (gen_cmpsi (dr_0, operands[2]));
+ 	  emit_jump_insn (gen_bltu (label1));
+ 	  emit_insn (gen_rtx_SET (VOIDmode, dr_1, const1_rtx));
+ 	  emit_label (label1);
+ 	}
+     }
+   else
+     {
+       rtx label1 = gen_label_rtx ();
+       rtx label2 = gen_label_rtx ();
+       rtx label3 = gen_label_rtx ();
+       rtx sr = gen_reg_rtx (SImode);
+ 
+       emit_insn (gen_rtx_SET (VOIDmode, dr_0, operands[1]));
+       emit_insn (gen_rtx_SET (VOIDmode, sr, operands[2]));
+       emit_insn (gen_rtx_SET (VOIDmode, dr_1, const0_rtx));
+       emit_insn (gen_cmpsi (sr, dr_0));
+       emit_jump_insn (gen_bgtu (label3));
+       emit_insn (gen_cmpsi (sr, const0_rtx));
+       emit_jump_insn (gen_blt (label2));
+       emit_insn (gen_cmpsi (sr, const1_rtx));
+       emit_jump_insn (gen_beq (label1));
+       emit_insn (gen_rtx_SET (VOIDmode, dr,
+ 			  gen_rtx_LSHIFTRT (DImode, dr,
+ 				    gen_rtx_CONST_INT (SImode, 32))));
+       emit_insn (gen_rtx_SET (VOIDmode, dr,
+ 		    gen_rtx_DIV (DImode, dr, sr)));
+       emit_jump_insn (gen_jump (label3));
+       emit_label (label1);
+       emit_insn (gen_rtx_SET (VOIDmode, dr_1, dr_0));
+       emit_jump_insn (gen_jump (label3));
+       emit_label (label2);
+       emit_insn (gen_rtx_SET (VOIDmode, dr_1, const1_rtx));
+       emit_label (label3);
+     }
+   emit_insn (gen_rtx_SET (VOIDmode, operands[0], dr_1));
+ 
+   DONE;
+ }
+     operand0 = operands[0];
+     operand1 = operands[1];
+     operand2 = operands[2];
+   }
+   emit_insn (gen_rtx_SET (VOIDmode,
+ 	operand0,
+ 	gen_rtx_UDIV (SImode,
+ 	operand1,
+ 	operand2)));
+   _val = gen_sequence ();
+   end_sequence ();
+   return _val;
+ }
+ 
+ rtx
+ gen_modsi3 (operand0, operand1, operand2)
+      rtx operand0;
+      rtx operand1;
+      rtx operand2;
+ {
+   rtx _val = 0;
+   start_sequence ();
+   {
+     rtx operands[3];
+     operands[0] = operand0;
+     operands[1] = operand1;
+     operands[2] = operand2;
+ 
+ {
+   rtx r = gen_reg_rtx (DImode);
+ 
+   emit_insn (gen_extendsidi2 (r, operands[1]));
+   emit_insn (gen_rtx_SET (VOIDmode, r,
+ 			gen_rtx_MOD (DImode, r, operands[2])));
+   emit_insn (gen_rtx_SET (VOIDmode, operands[0],
+ 			gen_rtx_SUBREG (SImode, r, 0)));
+   DONE;
+ }
+     operand0 = operands[0];
+     operand1 = operands[1];
+     operand2 = operands[2];
+   }
+   emit_insn (gen_rtx_SET (VOIDmode,
+ 	operand0,
+ 	gen_rtx_MOD (SImode,
+ 	operand1,
+ 	operand2)));
+   _val = gen_sequence ();
+   end_sequence ();
+   return _val;
+ }
+ 
+ rtx
+ gen_umodsi3 (operand0, operand1, operand2)
+      rtx operand0;
+      rtx operand1;
+      rtx operand2;
+ {
+   rtx _val = 0;
+   start_sequence ();
+   {
+     rtx operands[3];
+     operands[0] = operand0;
+     operands[1] = operand1;
+     operands[2] = operand2;
+ 
+ {
+   rtx dr = gen_reg_rtx (DImode);
+   rtx dr_0 = gen_rtx_SUBREG (SImode, dr, 0);
+ 
+   emit_insn (gen_rtx_SET (VOIDmode, dr_0, operands[1]));
+ 
+   if (GET_CODE (operands[2]) == CONST_INT)
+     {
+       if (INTVAL (operands[2]) > 0)
+ 	{
+ 	  emit_insn (gen_rtx_SET (VOIDmode, dr,
+ 			      gen_rtx_LSHIFTRT (DImode, dr,
+ 					gen_rtx_CONST_INT (SImode, 32))));
+ 	  emit_insn (gen_rtx_SET (VOIDmode, dr,
+ 			gen_rtx_MOD (DImode, dr, operands[2])));
+ 	}
+       else
+ 	{
+ 	  rtx label1 = gen_label_rtx ();
+ 	  rtx sr = gen_reg_rtx (SImode);
+ 
+ 	  emit_insn (gen_rtx_SET (VOIDmode, sr, operands[2]));
+ 	  emit_insn (gen_cmpsi (dr_0, sr));
+ 	  emit_jump_insn (gen_bltu (label1));
+ 	  emit_insn (gen_rtx_SET (VOIDmode, sr, gen_rtx_ABS (SImode, sr)));
+ 	  emit_insn (gen_rtx_SET (VOIDmode, dr_0,
+ 			      gen_rtx_PLUS (SImode, dr_0, sr)));
+ 	  emit_label (label1);
+ 	}
+     }
+   else
+     {
+       rtx label1 = gen_label_rtx ();
+       rtx label2 = gen_label_rtx ();
+       rtx label3 = gen_label_rtx ();
+       rtx sr = gen_reg_rtx (SImode);
+ 
+       emit_insn (gen_rtx_SET (VOIDmode, dr_0, operands[1]));
+       emit_insn (gen_rtx_SET (VOIDmode, sr, operands[2]));
+       emit_insn (gen_cmpsi (sr, dr_0));
+       emit_jump_insn (gen_bgtu (label3));
+       emit_insn (gen_cmpsi (sr, const0_rtx));
+       emit_jump_insn (gen_blt (label2));
+       emit_insn (gen_cmpsi (sr, const1_rtx));
+       emit_jump_insn (gen_beq (label1));
+       emit_insn (gen_rtx_SET (VOIDmode, dr,
+ 			  gen_rtx_LSHIFTRT (DImode, dr,
+ 				    gen_rtx_CONST_INT (SImode, 32))));
+       emit_insn (gen_rtx_SET (VOIDmode, dr, gen_rtx_MOD (DImode, dr, sr)));
+       emit_jump_insn (gen_jump (label3));
+       emit_label (label1);
+       emit_insn (gen_rtx_SET (VOIDmode, dr_0, const0_rtx));
+       emit_jump_insn (gen_jump (label3));
+       emit_label (label2);
+       emit_insn (gen_rtx_SET (VOIDmode, dr_0,
+ 			  gen_rtx_MINUS (SImode, dr_0, sr)));
+       emit_label (label3);
+ 
+     }
+   emit_insn (gen_rtx_SET (VOIDmode, operands[0], dr_0));
+ 
+   DONE;
+ }
+     operand0 = operands[0];
+     operand1 = operands[1];
+     operand2 = operands[2];
+   }
+   emit_insn (gen_rtx_SET (VOIDmode,
+ 	operand0,
+ 	gen_rtx_UMOD (SImode,
+ 	operand1,
+ 	operand2)));
+   _val = gen_sequence ();
+   end_sequence ();
+   return _val;
+ }
+ 
+ rtx
+ gen_untyped_call (operand0, operand1, operand2)
+      rtx operand0;
+      rtx operand1;
+      rtx operand2;
+ {
+   rtx _val = 0;
+   start_sequence ();
+   {
+     rtx operands[3];
+     operands[0] = operand0;
+     operands[1] = operand1;
+     operands[2] = operand2;
+ 
+ {
+   int i;
+ 
+   emit_call_insn (GEN_CALL (operands[0], const0_rtx, const0_rtx, const0_rtx));
+ 
+   for (i = 0; i < XVECLEN (operands[2], 0); i++)
+     {
+       rtx set = XVECEXP (operands[2], 0, i);
+       emit_move_insn (SET_DEST (set), SET_SRC (set));
+     }
+ 
+   /* The optimizer does not know that the call sets the function value
+      registers we stored in the result block.  We avoid problems by
+      claiming that all hard registers are used and clobbered at this
+      point.  */
+   /* emit_insn (gen_blockage ()); */
+ 
+   DONE;
+ }
+     operand0 = operands[0];
+     operand1 = operands[1];
+     operand2 = operands[2];
+   }
+   emit_call_insn (gen_rtx_PARALLEL (VOIDmode,
+ 	gen_rtvec (3,
+ 		gen_rtx_CALL (VOIDmode,
+ 	operand0,
+ 	const0_rtx),
+ 		operand1,
+ 		operand2)));
+   _val = gen_sequence ();
+   end_sequence ();
+   return _val;
+ }
+ 
+ 
+ 
+ void
+ add_clobbers (pattern, insn_code_number)
+      rtx pattern ATTRIBUTE_UNUSED;
+      int insn_code_number;
+ {
+   switch (insn_code_number)
+     {
+     case 34:
+       XVECEXP (pattern, 0, 1) = gen_rtx_CLOBBER (VOIDmode,
+ 	gen_rtx_REG (DFmode,
+ 	16));
+       break;
+ 
+     default:
+       abort ();
+     }
+ }
+ 
+ 
+ int
+ added_clobbers_hard_reg_p (insn_code_number)
+      int insn_code_number;
+ {
+   switch (insn_code_number)
+     {
+     case 34:
+       return 1;
+ 
+     default:
+       abort ();
+     }
+ }
Index: gcc/gcc/insn-extract.c
diff -c nul gcc/gcc/insn-extract.c:1.31
*** nul	Tue Oct 01 16:28:46 2019
--- gcc/gcc/insn-extract.c	Mon Nov 06 20:44:09 2017
***************
*** 0 ****
--- 1,271 ----
+ /* Generated automatically by the program `genextract'
+ from the machine description file `md'.  */
+ 
+ #include "config.h"
+ #include "system.h"
+ #include "rtl.h"
+ #include "insn-config.h"
+ #include "recog.h"
+ #include "toplev.h"
+ 
+ static rtx junk ATTRIBUTE_UNUSED;
+ void
+ insn_extract (insn)
+      rtx insn;
+ {
+   rtx *ro = recog_data.operand;
+   rtx **ro_loc = recog_data.operand_loc;
+   rtx pat = PATTERN (insn);
+   int i ATTRIBUTE_UNUSED;
+ 
+   memset (ro, 0, sizeof (*ro) * MAX_RECOG_OPERANDS);
+   memset (ro_loc, 0, sizeof (*ro_loc) * MAX_RECOG_OPERANDS);
+   switch (INSN_CODE (insn))
+     {
+     case -1:
+       fatal_insn_not_found (insn);
+ 
+     case 133:  /* nop */
+       break;
+ 
+     case 132:  /* *i370.md:4884 */
+       ro[0] = *(ro_loc[0] = &XEXP (pat, 0));
+       ro[1] = *(ro_loc[1] = &XEXP (XEXP (XEXP (pat, 1), 0), 0));
+       ro[2] = *(ro_loc[2] = &XEXP (XEXP (pat, 1), 1));
+       break;
+ 
+     case 128:  /* tablejump */
+       ro[0] = *(ro_loc[0] = &XEXP (XVECEXP (pat, 0, 0), 1));
+       ro[1] = *(ro_loc[1] = &XEXP (XEXP (XVECEXP (pat, 0, 1), 0), 0));
+       break;
+ 
+     case 126:  /* jump */
+       ro[0] = *(ro_loc[0] = &XEXP (XEXP (pat, 1), 0));
+       break;
+ 
+     case 125:  /* *i370.md:4610 */
+       ro[0] = *(ro_loc[0] = &XEXP (XEXP (XEXP (XEXP (XVECEXP (pat, 0, 0), 1), 0), 0), 0));
+       ro[1] = *(ro_loc[1] = &XEXP (XEXP (XEXP (XVECEXP (pat, 0, 0), 1), 2), 0));
+       recog_data.dup_loc[0] = &XEXP (XVECEXP (pat, 0, 1), 0);
+       recog_data.dup_num[0] = 0;
+       recog_data.dup_loc[1] = &XEXP (XEXP (XVECEXP (pat, 0, 1), 1), 0);
+       recog_data.dup_num[1] = 0;
+       break;
+ 
+     case 124:  /* *i370.md:4582 */
+       ro[0] = *(ro_loc[0] = &XEXP (XEXP (XEXP (XEXP (XVECEXP (pat, 0, 0), 1), 0), 0), 0));
+       ro[1] = *(ro_loc[1] = &XEXP (XEXP (XEXP (XVECEXP (pat, 0, 0), 1), 1), 0));
+       recog_data.dup_loc[0] = &XEXP (XVECEXP (pat, 0, 1), 0);
+       recog_data.dup_num[0] = 0;
+       recog_data.dup_loc[1] = &XEXP (XEXP (XVECEXP (pat, 0, 1), 1), 0);
+       recog_data.dup_num[1] = 0;
+       break;
+ 
+     case 123:  /* *i370.md:4554 */
+     case 122:  /* *i370.md:4531 */
+     case 121:  /* *i370.md:4508 */
+     case 120:  /* *i370.md:4485 */
+     case 119:  /* *i370.md:4462 */
+     case 118:  /* *i370.md:4439 */
+     case 117:  /* *i370.md:4416 */
+     case 116:  /* *i370.md:4393 */
+     case 115:  /* *i370.md:4370 */
+     case 114:  /* *i370.md:4347 */
+       ro[0] = *(ro_loc[0] = &XEXP (XEXP (XEXP (pat, 1), 2), 0));
+       break;
+ 
+     case 113:  /* bleu */
+     case 112:  /* ble */
+     case 111:  /* bgeu */
+     case 110:  /* bge */
+     case 109:  /* bltu */
+     case 108:  /* blt */
+     case 107:  /* bgtu */
+     case 106:  /* bgt */
+     case 105:  /* bne */
+     case 104:  /* beq */
+       ro[0] = *(ro_loc[0] = &XEXP (XEXP (XEXP (pat, 1), 1), 0));
+       break;
+ 
+     case 130:  /* call_value */
+     case 103:  /* lshrqi3 */
+     case 102:  /* lshrhi3 */
+     case 101:  /* lshrsi3 */
+     case 100:  /* lshrdi3 */
+     case 99:  /* ashrqi3 */
+     case 98:  /* ashlqi3 */
+     case 97:  /* ashrhi3 */
+     case 96:  /* ashlhi3 */
+     case 95:  /* ashrsi3 */
+     case 94:  /* ashlsi3 */
+     case 93:  /* ashrdi3 */
+     case 92:  /* ashldi3 */
+     case 77:  /* xorqi3 */
+     case 76:  /* *i370.md:3479 */
+     case 75:  /* xorhi3 */
+     case 74:  /* *i370.md:3418 */
+     case 73:  /* xorsi3 */
+     case 72:  /* *i370.md:3369 */
+     case 71:  /* iorqi3 */
+     case 70:  /* *i370.md:3289 */
+     case 69:  /* iorhi3 */
+     case 68:  /* *i370.md:3228 */
+     case 67:  /* iorsi3 */
+     case 66:  /* *i370.md:3179 */
+     case 65:  /* andqi3 */
+     case 64:  /* *i370.md:3099 */
+     case 63:  /* andhi3 */
+     case 62:  /* *i370.md:3038 */
+     case 61:  /* andsi3 */
+     case 60:  /* *i370.md:2989 */
+     case 59:  /* *i370.md:2940 */
+     case 58:  /* divsf3 */
+     case 57:  /* divdf3 */
+     case 56:  /* *i370.md:2774 */
+     case 55:  /* mulsf3 */
+     case 54:  /* muldf3 */
+     case 53:  /* *i370.md:2611 */
+     case 52:  /* *i370.md:2595 */
+     case 51:  /* subsf3 */
+     case 50:  /* subdf3 */
+     case 49:  /* subqi3 */
+     case 48:  /* subhi3 */
+     case 47:  /* subsi3 */
+     case 45:  /* addsf3 */
+     case 44:  /* adddf3 */
+     case 43:  /* addqi3 */
+     case 42:  /* addhi3 */
+     case 41:  /* addsi3 */
+     case 40:  /* *i370.md:2134 */
+     case 39:  /* *i370.md:2117 */
+       ro[0] = *(ro_loc[0] = &XEXP (pat, 0));
+       ro[1] = *(ro_loc[1] = &XEXP (XEXP (pat, 1), 0));
+       ro[2] = *(ro_loc[2] = &XEXP (XEXP (pat, 1), 1));
+       break;
+ 
+     case 46:  /* *i370.md:2333 */
+     case 38:  /* *i370.md:2064 */
+       ro[0] = *(ro_loc[0] = &XEXP (XVECEXP (pat, 0, 0), 0));
+       ro[1] = *(ro_loc[1] = &XEXP (XEXP (XVECEXP (pat, 0, 0), 1), 0));
+       ro[2] = *(ro_loc[2] = &XEXP (XEXP (XVECEXP (pat, 0, 0), 1), 1));
+       ro[3] = *(ro_loc[3] = &XEXP (XEXP (XVECEXP (pat, 0, 1), 0), 0));
+       break;
+ 
+     case 34:  /* fix_truncdfsi2 */
+       ro[0] = *(ro_loc[0] = &XEXP (XVECEXP (pat, 0, 0), 0));
+       ro[1] = *(ro_loc[1] = &XEXP (XEXP (XEXP (XVECEXP (pat, 0, 0), 1), 0), 0));
+       break;
+ 
+     case 91:  /* one_cmplqi2 */
+     case 90:  /* *i370.md:3775 */
+     case 89:  /* one_cmplhi2 */
+     case 88:  /* *i370.md:3738 */
+     case 87:  /* one_cmplsi2 */
+     case 86:  /* *i370.md:3700 */
+     case 85:  /* abssf2 */
+     case 84:  /* absdf2 */
+     case 83:  /* abshi2 */
+     case 82:  /* abssi2 */
+     case 81:  /* negsf2 */
+     case 80:  /* negdf2 */
+     case 79:  /* neghi2 */
+     case 78:  /* negsi2 */
+     case 37:  /* extendsfdf2 */
+     case 36:  /* truncdfsf2 */
+     case 35:  /* floatsidf2 */
+     case 33:  /* truncsihi2 */
+     case 32:  /* zero_extendqihi2 */
+     case 31:  /* zero_extendqisi2 */
+     case 30:  /* zero_extendhisi2 */
+     case 29:  /* extendqihi2 */
+     case 28:  /* extendqisi2 */
+     case 27:  /* extendhisi2 */
+       ro[0] = *(ro_loc[0] = &XEXP (pat, 0));
+       ro[1] = *(ro_loc[1] = &XEXP (XEXP (pat, 1), 0));
+       break;
+ 
+     case 26:  /* movstrsi_1 */
+       ro[0] = *(ro_loc[0] = &XEXP (XEXP (XVECEXP (pat, 0, 0), 0), 0));
+       ro[1] = *(ro_loc[1] = &XEXP (XEXP (XVECEXP (pat, 0, 0), 1), 0));
+       recog_data.dup_loc[0] = &XEXP (XVECEXP (pat, 0, 4), 0);
+       recog_data.dup_num[0] = 1;
+       recog_data.dup_loc[1] = &XEXP (XVECEXP (pat, 0, 3), 0);
+       recog_data.dup_num[1] = 0;
+       recog_data.dup_loc[2] = &XEXP (XVECEXP (pat, 0, 2), 0);
+       recog_data.dup_num[2] = 1;
+       recog_data.dup_loc[3] = &XEXP (XVECEXP (pat, 0, 1), 0);
+       recog_data.dup_num[3] = 0;
+       break;
+ 
+     case 25:  /* *i370.md:1630 */
+       ro[0] = *(ro_loc[0] = &XEXP (XVECEXP (pat, 0, 0), 0));
+       ro[1] = *(ro_loc[1] = &XEXP (XVECEXP (pat, 0, 0), 1));
+       ro[2] = *(ro_loc[2] = &XEXP (XVECEXP (pat, 0, 1), 0));
+       break;
+ 
+     case 131:  /* *i370.md:4836 */
+     case 20:  /* movstricthi */
+       ro[0] = *(ro_loc[0] = &XEXP (XEXP (pat, 0), 0));
+       ro[1] = *(ro_loc[1] = &XEXP (pat, 1));
+       break;
+ 
+     case 129:  /* call */
+     case 24:  /* movsf */
+     case 23:  /* *i370.md:1410 */
+     case 22:  /* movdf */
+     case 21:  /* *i370.md:1285 */
+     case 19:  /* movqi */
+     case 18:  /* *i370.md:1104 */
+     case 17:  /* movhi */
+     case 16:  /* *i370.md:1010 */
+     case 15:  /* movsi */
+     case 14:  /* movdi */
+     case 13:  /* *i370.md:792 */
+       ro[0] = *(ro_loc[0] = &XEXP (pat, 0));
+       ro[1] = *(ro_loc[1] = &XEXP (pat, 1));
+       break;
+ 
+     case 12:  /* cmpstrsi_1 */
+       ro[0] = *(ro_loc[0] = &XEXP (XVECEXP (pat, 0, 0), 0));
+       ro[1] = *(ro_loc[1] = &XEXP (XEXP (XEXP (XVECEXP (pat, 0, 0), 1), 0), 0));
+       ro[2] = *(ro_loc[2] = &XEXP (XEXP (XEXP (XVECEXP (pat, 0, 0), 1), 1), 0));
+       recog_data.dup_loc[0] = &XEXP (XVECEXP (pat, 0, 4), 0);
+       recog_data.dup_num[0] = 2;
+       recog_data.dup_loc[1] = &XEXP (XVECEXP (pat, 0, 3), 0);
+       recog_data.dup_num[1] = 1;
+       recog_data.dup_loc[2] = &XEXP (XVECEXP (pat, 0, 2), 0);
+       recog_data.dup_num[2] = 2;
+       recog_data.dup_loc[3] = &XEXP (XVECEXP (pat, 0, 1), 0);
+       recog_data.dup_num[3] = 1;
+       break;
+ 
+     case 11:  /* *i370.md:746 */
+       ro[0] = *(ro_loc[0] = &XEXP (XVECEXP (pat, 0, 0), 0));
+       ro[1] = *(ro_loc[1] = &XEXP (XEXP (XVECEXP (pat, 0, 0), 1), 0));
+       ro[2] = *(ro_loc[2] = &XEXP (XEXP (XVECEXP (pat, 0, 0), 1), 1));
+       ro[3] = *(ro_loc[3] = &XEXP (XVECEXP (pat, 0, 1), 0));
+       break;
+ 
+     case 10:  /* cmpsf */
+     case 9:  /* cmpdf */
+     case 8:  /* cmpqi */
+     case 7:  /* *i370.md:522 */
+     case 6:  /* cmphi */
+     case 5:  /* cmpsi */
+       ro[0] = *(ro_loc[0] = &XEXP (XEXP (pat, 1), 0));
+       ro[1] = *(ro_loc[1] = &XEXP (XEXP (pat, 1), 1));
+       break;
+ 
+     case 127:  /* indirect_jump */
+     case 4:  /* tstsf */
+     case 3:  /* tstdf */
+     case 2:  /* tsthi */
+     case 1:  /* tstsi */
+     case 0:  /* tstdi */
+       ro[0] = *(ro_loc[0] = &XEXP (pat, 1));
+       break;
+ 
+     default:
+       abort ();
+     }
+ }
Index: gcc/gcc/insn-flags.h
diff -c nul gcc/gcc/insn-flags.h:1.8
*** nul	Tue Oct 01 16:28:46 2019
--- gcc/gcc/insn-flags.h	Sat Sep 26 12:58:27 2009
***************
*** 0 ****
--- 1,219 ----
+ /* Generated automatically by the program `genflags'
+    from the machine description file `md'.  */
+ 
+ #ifndef GCC_INSN_FLAGS_H
+ #define GCC_INSN_FLAGS_H
+ 
+ #define HAVE_tstdi 1
+ #define HAVE_tstsi 1
+ #define HAVE_tsthi 1
+ #define HAVE_tstdf 1
+ #define HAVE_tstsf 1
+ #define HAVE_cmpsi 1
+ #define HAVE_cmphi 1
+ #define HAVE_cmpqi 1
+ #define HAVE_cmpdf 1
+ #define HAVE_cmpsf 1
+ #define HAVE_cmpstrsi_1 1
+ #define HAVE_movdi 1
+ #define HAVE_movsi 1
+ #define HAVE_movhi 1
+ #define HAVE_movqi 1
+ #define HAVE_movstricthi 1
+ #define HAVE_movdf 1
+ #define HAVE_movsf 1
+ #define HAVE_movstrsi_1 1
+ #define HAVE_extendhisi2 1
+ #define HAVE_extendqisi2 1
+ #define HAVE_extendqihi2 1
+ #define HAVE_zero_extendhisi2 1
+ #define HAVE_zero_extendqisi2 1
+ #define HAVE_zero_extendqihi2 1
+ #define HAVE_truncsihi2 1
+ #define HAVE_fix_truncdfsi2 1
+ #define HAVE_floatsidf2 1
+ #define HAVE_truncdfsf2 1
+ #define HAVE_extendsfdf2 1
+ #define HAVE_addsi3 1
+ #define HAVE_addhi3 1
+ #define HAVE_addqi3 1
+ #define HAVE_adddf3 1
+ #define HAVE_addsf3 1
+ #define HAVE_subsi3 1
+ #define HAVE_subhi3 1
+ #define HAVE_subqi3 1
+ #define HAVE_subdf3 1
+ #define HAVE_subsf3 1
+ #define HAVE_muldf3 1
+ #define HAVE_mulsf3 1
+ #define HAVE_divdf3 1
+ #define HAVE_divsf3 1
+ #define HAVE_andsi3 1
+ #define HAVE_andhi3 1
+ #define HAVE_andqi3 1
+ #define HAVE_iorsi3 1
+ #define HAVE_iorhi3 1
+ #define HAVE_iorqi3 1
+ #define HAVE_xorsi3 1
+ #define HAVE_xorhi3 1
+ #define HAVE_xorqi3 1
+ #define HAVE_negsi2 1
+ #define HAVE_neghi2 1
+ #define HAVE_negdf2 1
+ #define HAVE_negsf2 1
+ #define HAVE_abssi2 1
+ #define HAVE_abshi2 1
+ #define HAVE_absdf2 1
+ #define HAVE_abssf2 1
+ #define HAVE_one_cmplsi2 1
+ #define HAVE_one_cmplhi2 1
+ #define HAVE_one_cmplqi2 1
+ #define HAVE_ashldi3 1
+ #define HAVE_ashrdi3 1
+ #define HAVE_ashlsi3 1
+ #define HAVE_ashrsi3 1
+ #define HAVE_ashlhi3 1
+ #define HAVE_ashrhi3 1
+ #define HAVE_ashlqi3 1
+ #define HAVE_ashrqi3 1
+ #define HAVE_lshrdi3 1
+ #define HAVE_lshrsi3 1
+ #define HAVE_lshrhi3 1
+ #define HAVE_lshrqi3 1
+ #define HAVE_beq 1
+ #define HAVE_bne 1
+ #define HAVE_bgt 1
+ #define HAVE_bgtu 1
+ #define HAVE_blt 1
+ #define HAVE_bltu 1
+ #define HAVE_bge 1
+ #define HAVE_bgeu 1
+ #define HAVE_ble 1
+ #define HAVE_bleu 1
+ #define HAVE_jump 1
+ #define HAVE_indirect_jump 1
+ #define HAVE_tablejump 1
+ #define HAVE_call 1
+ #define HAVE_call_value 1
+ #define HAVE_nop 1
+ #define HAVE_cmpstrsi 1
+ #define HAVE_clrstrsi 1
+ #define HAVE_movstrsi 1
+ #define HAVE_extendsidi2 1
+ #define HAVE_zero_extendsidi2 1
+ #define HAVE_adddi3 1
+ #define HAVE_mulsi3 1
+ #define HAVE_divsi3 1
+ #define HAVE_udivsi3 1
+ #define HAVE_modsi3 1
+ #define HAVE_umodsi3 1
+ #define HAVE_untyped_call 1
+ struct rtx_def;
+ extern struct rtx_def *gen_tstdi            PARAMS ((struct rtx_def *));
+ extern struct rtx_def *gen_tstsi            PARAMS ((struct rtx_def *));
+ extern struct rtx_def *gen_tsthi            PARAMS ((struct rtx_def *));
+ extern struct rtx_def *gen_tstdf            PARAMS ((struct rtx_def *));
+ extern struct rtx_def *gen_tstsf            PARAMS ((struct rtx_def *));
+ extern struct rtx_def *gen_cmpsi            PARAMS ((struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_cmphi            PARAMS ((struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_cmpqi            PARAMS ((struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_cmpdf            PARAMS ((struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_cmpsf            PARAMS ((struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_cmpstrsi_1       PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_movdi            PARAMS ((struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_movsi            PARAMS ((struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_movhi            PARAMS ((struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_movqi            PARAMS ((struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_movstricthi      PARAMS ((struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_movdf            PARAMS ((struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_movsf            PARAMS ((struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_movstrsi_1       PARAMS ((struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_extendhisi2      PARAMS ((struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_extendqisi2      PARAMS ((struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_extendqihi2      PARAMS ((struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_zero_extendhisi2 PARAMS ((struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_zero_extendqisi2 PARAMS ((struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_zero_extendqihi2 PARAMS ((struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_truncsihi2       PARAMS ((struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_fix_truncdfsi2   PARAMS ((struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_floatsidf2       PARAMS ((struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_truncdfsf2       PARAMS ((struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_extendsfdf2      PARAMS ((struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_addsi3           PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_addhi3           PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_addqi3           PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_adddf3           PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_addsf3           PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_subsi3           PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_subhi3           PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_subqi3           PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_subdf3           PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_subsf3           PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_muldf3           PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_mulsf3           PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_divdf3           PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_divsf3           PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_andsi3           PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_andhi3           PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_andqi3           PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_iorsi3           PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_iorhi3           PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_iorqi3           PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_xorsi3           PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_xorhi3           PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_xorqi3           PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_negsi2           PARAMS ((struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_neghi2           PARAMS ((struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_negdf2           PARAMS ((struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_negsf2           PARAMS ((struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_abssi2           PARAMS ((struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_abshi2           PARAMS ((struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_absdf2           PARAMS ((struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_abssf2           PARAMS ((struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_one_cmplsi2      PARAMS ((struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_one_cmplhi2      PARAMS ((struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_one_cmplqi2      PARAMS ((struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_ashldi3          PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_ashrdi3          PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_ashlsi3          PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_ashrsi3          PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_ashlhi3          PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_ashrhi3          PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_ashlqi3          PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_ashrqi3          PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_lshrdi3          PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_lshrsi3          PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_lshrhi3          PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_lshrqi3          PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_beq              PARAMS ((struct rtx_def *));
+ extern struct rtx_def *gen_bne              PARAMS ((struct rtx_def *));
+ extern struct rtx_def *gen_bgt              PARAMS ((struct rtx_def *));
+ extern struct rtx_def *gen_bgtu             PARAMS ((struct rtx_def *));
+ extern struct rtx_def *gen_blt              PARAMS ((struct rtx_def *));
+ extern struct rtx_def *gen_bltu             PARAMS ((struct rtx_def *));
+ extern struct rtx_def *gen_bge              PARAMS ((struct rtx_def *));
+ extern struct rtx_def *gen_bgeu             PARAMS ((struct rtx_def *));
+ extern struct rtx_def *gen_ble              PARAMS ((struct rtx_def *));
+ extern struct rtx_def *gen_bleu             PARAMS ((struct rtx_def *));
+ extern struct rtx_def *gen_jump             PARAMS ((struct rtx_def *));
+ extern struct rtx_def *gen_indirect_jump    PARAMS ((struct rtx_def *));
+ extern struct rtx_def *gen_tablejump        PARAMS ((struct rtx_def *, struct rtx_def *));
+ #define GEN_CALL(A, B, C, D) gen_call ((A), (B))
+ extern struct rtx_def *gen_call             PARAMS ((struct rtx_def *, struct rtx_def *));
+ #define GEN_CALL_VALUE(A, B, C, D, E) gen_call_value ((A), (B), (C))
+ extern struct rtx_def *gen_call_value       PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_nop              PARAMS ((void));
+ extern struct rtx_def *gen_cmpstrsi         PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *, struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_clrstrsi         PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_movstrsi         PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_extendsidi2      PARAMS ((struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_zero_extendsidi2 PARAMS ((struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_adddi3           PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_mulsi3           PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_divsi3           PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_udivsi3          PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_modsi3           PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_umodsi3          PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));
+ extern struct rtx_def *gen_untyped_call     PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));
+ 
+ #endif /* GCC_INSN_FLAGS_H */
Index: gcc/gcc/insn-opinit.c
diff -c nul gcc/gcc/insn-opinit.c:1.4
*** nul	Tue Oct 01 16:28:46 2019
--- gcc/gcc/insn-opinit.c	Sat Sep 26 12:58:26 2009
***************
*** 0 ****
--- 1,119 ----
+ /* Generated automatically by the program `genopinit'
+ from the machine description file `md'.  */
+ 
+ #include "config.h"
+ #include "system.h"
+ #include "rtl.h"
+ #include "flags.h"
+ #include "insn-config.h"
+ #include "recog.h"
+ #include "expr.h"
+ #include "optabs.h"
+ #include "reload.h"
+ 
+ void
+ init_all_optabs ()
+ {
+   tst_optab->handlers[(int) DImode].insn_code = CODE_FOR_tstdi;
+   tst_optab->handlers[(int) SImode].insn_code = CODE_FOR_tstsi;
+   tst_optab->handlers[(int) HImode].insn_code = CODE_FOR_tsthi;
+   tst_optab->handlers[(int) DFmode].insn_code = CODE_FOR_tstdf;
+   tst_optab->handlers[(int) SFmode].insn_code = CODE_FOR_tstsf;
+   cmp_optab->handlers[(int) SImode].insn_code = CODE_FOR_cmpsi;
+   cmp_optab->handlers[(int) HImode].insn_code = CODE_FOR_cmphi;
+   cmp_optab->handlers[(int) QImode].insn_code = CODE_FOR_cmpqi;
+   cmp_optab->handlers[(int) DFmode].insn_code = CODE_FOR_cmpdf;
+   cmp_optab->handlers[(int) SFmode].insn_code = CODE_FOR_cmpsf;
+   mov_optab->handlers[(int) DImode].insn_code = CODE_FOR_movdi;
+   mov_optab->handlers[(int) SImode].insn_code = CODE_FOR_movsi;
+   mov_optab->handlers[(int) HImode].insn_code = CODE_FOR_movhi;
+   mov_optab->handlers[(int) QImode].insn_code = CODE_FOR_movqi;
+   movstrict_optab->handlers[(int) HImode].insn_code = CODE_FOR_movstricthi;
+   mov_optab->handlers[(int) DFmode].insn_code = CODE_FOR_movdf;
+   mov_optab->handlers[(int) SFmode].insn_code = CODE_FOR_movsf;
+   extendtab[(int) SImode][(int) HImode][0] = CODE_FOR_extendhisi2;
+   extendtab[(int) SImode][(int) QImode][0] = CODE_FOR_extendqisi2;
+   extendtab[(int) HImode][(int) QImode][0] = CODE_FOR_extendqihi2;
+   extendtab[(int) SImode][(int) HImode][1] = CODE_FOR_zero_extendhisi2;
+   extendtab[(int) SImode][(int) QImode][1] = CODE_FOR_zero_extendqisi2;
+   extendtab[(int) HImode][(int) QImode][1] = CODE_FOR_zero_extendqihi2;
+   fixtrunctab[(int) DFmode][(int) SImode][0] = CODE_FOR_fix_truncdfsi2;
+   floattab[(int) DFmode][(int) SImode][0] = CODE_FOR_floatsidf2;
+   extendtab[(int) DFmode][(int) SFmode][0] = CODE_FOR_extendsfdf2;
+   add_optab->handlers[(int) SImode].insn_code = CODE_FOR_addsi3;
+   add_optab->handlers[(int) HImode].insn_code = CODE_FOR_addhi3;
+   add_optab->handlers[(int) QImode].insn_code = CODE_FOR_addqi3;
+   addv_optab->handlers[(int) (int) DFmode].insn_code =
+     add_optab->handlers[(int) (int) DFmode].insn_code = CODE_FOR_adddf3;
+   addv_optab->handlers[(int) (int) SFmode].insn_code =
+     add_optab->handlers[(int) (int) SFmode].insn_code = CODE_FOR_addsf3;
+   sub_optab->handlers[(int) SImode].insn_code = CODE_FOR_subsi3;
+   sub_optab->handlers[(int) HImode].insn_code = CODE_FOR_subhi3;
+   sub_optab->handlers[(int) QImode].insn_code = CODE_FOR_subqi3;
+   subv_optab->handlers[(int) (int) DFmode].insn_code =
+     sub_optab->handlers[(int) (int) DFmode].insn_code = CODE_FOR_subdf3;
+   subv_optab->handlers[(int) (int) SFmode].insn_code =
+     sub_optab->handlers[(int) (int) SFmode].insn_code = CODE_FOR_subsf3;
+   smulv_optab->handlers[(int) (int) DFmode].insn_code =
+     smul_optab->handlers[(int) (int) DFmode].insn_code = CODE_FOR_muldf3;
+   smulv_optab->handlers[(int) (int) SFmode].insn_code =
+     smul_optab->handlers[(int) (int) SFmode].insn_code = CODE_FOR_mulsf3;
+   sdiv_optab->handlers[(int) DFmode].insn_code = CODE_FOR_divdf3;
+   sdiv_optab->handlers[(int) SFmode].insn_code = CODE_FOR_divsf3;
+   and_optab->handlers[(int) SImode].insn_code = CODE_FOR_andsi3;
+   and_optab->handlers[(int) HImode].insn_code = CODE_FOR_andhi3;
+   and_optab->handlers[(int) QImode].insn_code = CODE_FOR_andqi3;
+   ior_optab->handlers[(int) SImode].insn_code = CODE_FOR_iorsi3;
+   ior_optab->handlers[(int) HImode].insn_code = CODE_FOR_iorhi3;
+   ior_optab->handlers[(int) QImode].insn_code = CODE_FOR_iorqi3;
+   xor_optab->handlers[(int) SImode].insn_code = CODE_FOR_xorsi3;
+   xor_optab->handlers[(int) HImode].insn_code = CODE_FOR_xorhi3;
+   xor_optab->handlers[(int) QImode].insn_code = CODE_FOR_xorqi3;
+   neg_optab->handlers[(int) SImode].insn_code = CODE_FOR_negsi2;
+   neg_optab->handlers[(int) HImode].insn_code = CODE_FOR_neghi2;
+   negv_optab->handlers[(int) (int) DFmode].insn_code =
+     neg_optab->handlers[(int) (int) DFmode].insn_code = CODE_FOR_negdf2;
+   negv_optab->handlers[(int) (int) SFmode].insn_code =
+     neg_optab->handlers[(int) (int) SFmode].insn_code = CODE_FOR_negsf2;
+   abs_optab->handlers[(int) SImode].insn_code = CODE_FOR_abssi2;
+   abs_optab->handlers[(int) HImode].insn_code = CODE_FOR_abshi2;
+   absv_optab->handlers[(int) (int) DFmode].insn_code =
+     abs_optab->handlers[(int) (int) DFmode].insn_code = CODE_FOR_absdf2;
+   absv_optab->handlers[(int) (int) SFmode].insn_code =
+     abs_optab->handlers[(int) (int) SFmode].insn_code = CODE_FOR_abssf2;
+   one_cmpl_optab->handlers[(int) SImode].insn_code = CODE_FOR_one_cmplsi2;
+   one_cmpl_optab->handlers[(int) HImode].insn_code = CODE_FOR_one_cmplhi2;
+   one_cmpl_optab->handlers[(int) QImode].insn_code = CODE_FOR_one_cmplqi2;
+   ashl_optab->handlers[(int) DImode].insn_code = CODE_FOR_ashldi3;
+   ashr_optab->handlers[(int) DImode].insn_code = CODE_FOR_ashrdi3;
+   ashl_optab->handlers[(int) SImode].insn_code = CODE_FOR_ashlsi3;
+   ashr_optab->handlers[(int) SImode].insn_code = CODE_FOR_ashrsi3;
+   ashl_optab->handlers[(int) HImode].insn_code = CODE_FOR_ashlhi3;
+   ashr_optab->handlers[(int) HImode].insn_code = CODE_FOR_ashrhi3;
+   ashl_optab->handlers[(int) QImode].insn_code = CODE_FOR_ashlqi3;
+   ashr_optab->handlers[(int) QImode].insn_code = CODE_FOR_ashrqi3;
+   lshr_optab->handlers[(int) DImode].insn_code = CODE_FOR_lshrdi3;
+   lshr_optab->handlers[(int) SImode].insn_code = CODE_FOR_lshrsi3;
+   lshr_optab->handlers[(int) HImode].insn_code = CODE_FOR_lshrhi3;
+   lshr_optab->handlers[(int) QImode].insn_code = CODE_FOR_lshrqi3;
+   bcc_gen_fctn[(int) EQ] = gen_beq;
+   bcc_gen_fctn[(int) NE] = gen_bne;
+   bcc_gen_fctn[(int) GT] = gen_bgt;
+   bcc_gen_fctn[(int) GTU] = gen_bgtu;
+   bcc_gen_fctn[(int) LT] = gen_blt;
+   bcc_gen_fctn[(int) LTU] = gen_bltu;
+   bcc_gen_fctn[(int) GE] = gen_bge;
+   bcc_gen_fctn[(int) GEU] = gen_bgeu;
+   bcc_gen_fctn[(int) LE] = gen_ble;
+   bcc_gen_fctn[(int) LEU] = gen_bleu;
+   clrstr_optab[(int) SImode] = CODE_FOR_clrstrsi;
+   movstr_optab[(int) SImode] = CODE_FOR_movstrsi;
+   extendtab[(int) DImode][(int) SImode][0] = CODE_FOR_extendsidi2;
+   extendtab[(int) DImode][(int) SImode][1] = CODE_FOR_zero_extendsidi2;
+   add_optab->handlers[(int) DImode].insn_code = CODE_FOR_adddi3;
+   smul_optab->handlers[(int) SImode].insn_code = CODE_FOR_mulsi3;
+   sdiv_optab->handlers[(int) SImode].insn_code = CODE_FOR_divsi3;
+   udiv_optab->handlers[(int) SImode].insn_code = CODE_FOR_udivsi3;
+   smod_optab->handlers[(int) SImode].insn_code = CODE_FOR_modsi3;
+   umod_optab->handlers[(int) SImode].insn_code = CODE_FOR_umodsi3;
+ }
Index: gcc/gcc/insn-output.c
diff -c nul gcc/gcc/insn-output.c:1.71
*** nul	Tue Oct 01 16:28:46 2019
--- gcc/gcc/insn-output.c	Mon Nov 06 20:44:09 2017
***************
*** 0 ****
--- 1,6310 ----
+ /* Generated automatically by the program `genoutput'
+    from the machine description file `md'.  */
+ 
+ #include "config.h"
+ #include "system.h"
+ #include "flags.h"
+ #include "ggc.h"
+ #include "rtl.h"
+ #include "expr.h"
+ #include "insn-codes.h"
+ #include "tm_p.h"
+ #include "function.h"
+ #include "regs.h"
+ #include "hard-reg-set.h"
+ #include "real.h"
+ #include "insn-config.h"
+ 
+ #include "conditions.h"
+ #include "insn-attr.h"
+ 
+ #include "recog.h"
+ 
+ #include "toplev.h"
+ #include "output.h"
+ 
+ static const char *output_0 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_0 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   mvs_check_page (0, 4, 0);
+   return "SRDA	%0,0";
+ }
+ }
+ 
+ static const char *output_1 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_1 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   mvs_check_page (0, 2, 0);
+   return "LTR	%0,%0";
+ }
+ }
+ 
+ static const char *output_2 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_2 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   mvs_check_page (0, 4, 2);
+   return "CH	%0,=H'0'";
+ }
+ }
+ 
+ static const char *output_3 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_3 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   mvs_check_page (0, 2, 0);
+   return "LTDR	%0,%0";
+ }
+ }
+ 
+ static const char *output_4 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_4 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   mvs_check_page (0, 2, 0);
+   return "LTER	%0,%0";
+ }
+ }
+ 
+ static const char *output_5 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_5 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   if (REG_P (operands[1]))
+     {
+       mvs_check_page (0, 2, 0);
+       if (unsigned_jump_follows_p (insn))
+ 	return "CLR	%0,%1";
+       return "CR	%0,%1";
+     }
+   if (GET_CODE (operands[1]) == CONST_INT)
+     {
+       mvs_check_page (0, 4, 4);
+       if (unsigned_jump_follows_p (insn))
+ 	 return "CL	%0,=F'%c1'";
+       return "C	%0,=F'%c1'";
+     }
+   mvs_check_page (0, 4, 0);
+   if (unsigned_jump_follows_p (insn))
+     return "CL	%0,%1";
+   return "C	%0,%1";
+ }
+ }
+ 
+ static const char *output_6 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_6 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   if (REG_P (operands[1]))
+     {
+       mvs_check_page (0, 8, 0);
+       if (unsigned_jump_follows_p (insn))
+ 	return "STH	%1," CONVLO "(,13)\n\tCLM	%0,3," CONVLO "(13)";
+       return "STH	%1," CONVLO "(,13)\n\tCH	%0," CONVLO "(,13)";
+     }
+   if (GET_CODE (operands[1]) == CONST_INT)
+     {
+       if (unsigned_jump_follows_p (insn))
+         {
+       mvs_check_page (0, 4, 2);
+       return "CLM	%0,3,%H1";
+         }
+       mvs_check_page (0, 4, 2);
+       return "CH	%0,%H1";
+     }
+   if (unsigned_jump_follows_p (insn))
+     {
+       mvs_check_page (0, 10, 0);
+       if (REG_P (operands[1]))
+ 	return "STH	%1," CONVLO "(,13)\n\tCLM	%0,3," CONVLO "(13)";
+       return "MVC	" CONVLO "(2,13),%1\n\tCLM	%0,3," CONVLO "(13)";
+     }
+   mvs_check_page (0, 4, 0);
+   return "CH	%0,%1";
+ }
+ }
+ 
+ static const char *output_7 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_7 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   if (REG_P (operands[0]))
+     {
+       if (REG_P (operands[1]))
+ 	{
+ 	  mvs_check_page (0, 8, 0);
+           return "STC	%1," CONVLO "(,13)\n\tCLM	%0,1," CONVLO "(13)";
+         }
+       if (GET_CODE (operands[1]) == CONST_INT)
+ 	{
+ 	  mvs_check_page (0, 4, 1);
+           return "CLM	%0,1,=XL1'%X1'";
+         }
+       mvs_check_page (0, 4, 0);
+       return "CLM	%0,1,%1";
+     }
+   else if (GET_CODE (operands[0]) == CONST_INT)
+     {
+       cc_status.flags |= CC_REVERSED;
+       if (REG_P (operands[1]))
+ 	{
+ 	  mvs_check_page (0, 4, 1);
+           return "CLM	%1,1,=XL1'%X0'";
+         }
+       mvs_check_page (0, 4, 0);
+       return "CLI	%1,%B0";
+     }
+   if (GET_CODE (operands[1]) == CONST_INT)
+     {
+       mvs_check_page (0, 4, 0);
+       return "CLI	%0,%B1";
+     }
+   if (GET_CODE (operands[1]) == MEM)
+     {
+       mvs_check_page (0, 6, 0);
+       return "CLC	%O0(1,%R0),%1";
+     }
+   cc_status.flags |= CC_REVERSED;
+   mvs_check_page (0, 4, 0);
+   return "CLM	%1,1,%0";
+ }
+ }
+ 
+ static const char *output_8 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_8 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   if (unsigned_jump_follows_p (insn))
+     {
+       if (GET_CODE (operands[1]) == CONST_INT)
+ 	{
+ 	  mvs_check_page (0, 4, 1);
+           return "CLM	%0,1,=XL1'%X1'";
+         }
+       if (!(REG_P (operands[1])))
+ 	{
+ 	  mvs_check_page (0, 4, 0);
+           return "CLM	%0,1,%1";
+         }
+       mvs_check_page (0, 8, 0);
+       return "STC	%1," CONVLO "(,13)\n\tCLM	%0,1," CONVLO "(13)";
+     }
+   if (REG_P (operands[1]))
+     {
+       mvs_check_page (0, 18, 0);
+       return "SLL	%0,24\n\tSRA	%0,24\n\tSLL	%1,24\n\tSRA	%1,24\n\tCR	%0,%1";
+     }
+   mvs_check_page (0, 12, 0);
+   return "SLL	%0,24\n\tSRA	%0,24\n\tC	%0,%1";
+ }
+ }
+ 
+ static const char *output_9 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_9 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   if (FP_REG_P (operands[0]))
+     {
+       if (FP_REG_P (operands[1]))
+ 	{
+ 	  mvs_check_page (0, 2, 0);
+ 	  return "CDR	%0,%1";
+ 	}
+       mvs_check_page (0, 4, 0);
+       return "CD	%0,%1";
+     }
+   cc_status.flags |= CC_REVERSED;
+   mvs_check_page (0, 4, 0);
+   return "CD	%1,%0";
+ }
+ }
+ 
+ static const char *output_10 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_10 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+ check_label_emit ();
+   if (FP_REG_P (operands[0]))
+     {
+       if (FP_REG_P (operands[1]))
+ 	{
+ 	  mvs_check_page (0, 2, 0);
+ 	  return "CER	%0,%1";
+ 	}
+       mvs_check_page (0, 4, 0);
+       return "CE	%0,%1";
+     }
+   cc_status.flags |= CC_REVERSED;
+   mvs_check_page (0, 4, 0);
+   return "CE	%1,%0";
+ }
+ }
+ 
+ static const char *output_11 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_11 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   mvs_check_page (0, 22, 0);
+   return "CLC	%O1(%c3,%R1),%2\n\tLA	%0,1(0,0)\n\tBH	*+12\n\tBL	*+6\n\tSLR	%0,%0\n\tLNR	%0,%0";
+ }
+ }
+ 
+ static const char *output_12 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_12 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   mvs_check_page (0, 18, 0);
+   return "LA	%0,1(0,0)\n\tCLCL	%1,%2\n\tBH	*+12\n\tBL	*+6\n\tSLR	%0,%0\n\tLNR	%0,%0";
+ }
+ }
+ 
+ static const char *output_13 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_13 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   if (REG_P (operands[0]))
+     {
+       if (FP_REG_P (operands[1]))
+ 	{
+ 	  mvs_check_page (0, 8, 0);
+ 	  return "STD	%1," CONVLO "(,13)\n\tLM	%0,%N0," CONVLO "(13)";
+ 	}
+       if (REG_P (operands[1]))
+ 	{
+ 	  mvs_check_page (0, 4, 0);
+ 	  return "LR	%0,%1\n\tLR	%N0,%N1";
+ 	}
+       if (operands[1] == const0_rtx)
+ 	{
+ 	  CC_STATUS_INIT;
+ 	  mvs_check_page (0, 4, 0);
+ 	  return "SLR	%0,%0\n\tSLR	%N0,%N0";
+ 	}
+       if (GET_CODE (operands[1]) == CONST_INT
+   	  && (unsigned) INTVAL (operands[1]) < 4096)
+ 	{
+ 	  CC_STATUS_INIT;
+ 	  mvs_check_page (0, 6, 0);
+ 	  return "SLR	%0,%0\n\tLA	%N0,%c1(0,0)";
+ 	}
+       if (GET_CODE (operands[1]) == CONST_INT)
+ 	{
+ 	  CC_STATUS_SET (operands[0], operands[1]);
+ 	  mvs_check_page (0, 8, 0);
+ 	  return "L	%0,%1\n\tSRDA	%0,32";
+ 	}
+       if (GET_CODE (operands[1]) == CONST_DOUBLE)
+ 	{
+ 	  mvs_check_page (0, 6, 8);
+ 	  return "LM	%0,%N0,%1";
+ 	}
+       mvs_check_page (0, 4, 0);
+       /*return "LM	%0,%N0,%1";*/
+       return "L	%0,%1\n\tL	%N0,4+%1";
+     }
+   else if (FP_REG_P (operands[1]))
+     {
+       mvs_check_page (0, 4, 0);
+       return "STD	%1,%0";
+     }
+   else if (REG_P (operands[1]))
+     {
+       mvs_check_page (0, 4, 0);
+       /*return "STM	%1,%N1,%0"; */
+       return "ST	%1,%0\n\tST	%N1,4+%0"; 
+     }
+   mvs_check_page (0, 6, 8);
+   return "MVC	%O0(8,%R0),%1";
+ }
+ }
+ 
+ static const char *output_14 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_14 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   if (REG_P (operands[0]))
+     {
+       if (FP_REG_P (operands[1]))
+ 	{
+ 	  mvs_check_page (0, 8, 0);
+ 	  return "STD	%1," CONVLO "(,13)\n\tLM	%0,%N0," CONVLO "(13)";
+ 	}
+       if (REG_P (operands[1]))
+ 	{
+ 	  mvs_check_page (0, 4, 0);
+ 	  return "LR	%0,%1\n\tLR	%N0,%N1";
+ 	}
+       if (operands[1] == const0_rtx)
+ 	{
+ 	  CC_STATUS_INIT;
+ 	  mvs_check_page (0, 4, 0);
+ 	  return "SLR	%0,%0\n\tSLR	%N0,%N0";
+ 	}
+       if (GET_CODE (operands[1]) == CONST_INT
+   	  && (unsigned) INTVAL (operands[1]) < 4096)
+ 	{
+ 	  CC_STATUS_INIT;
+ 	  mvs_check_page (0, 6, 0);
+ 	  return "SLR	%0,%0\n\tLA	%N0,%c1(0,0)";
+ 	}
+       if (GET_CODE (operands[1]) == CONST_INT)
+ 	{
+ 	  CC_STATUS_SET (operands[0], operands[1]);
+ 	  mvs_check_page (0, 8, 0);
+ 	  return "L	%0,%1\n\tSRDA	%0,32";
+ 	}
+       mvs_check_page (0, 4, 0);
+       /*return "LM	%0,%N0,%1";*/
+       return "L	%0,%1\n\tL	%N0,4+%1";
+     }
+   else if (FP_REG_P (operands[1]))
+     {
+       mvs_check_page (0, 4, 0);
+       return "STD	%1,%0";
+     }
+   mvs_check_page (0, 4, 0);
+   /*return "STM	%1,%N1,%0"; */
+   return "ST	%1,%0\n\tST	%N1,4+%0"; 
+ }
+ }
+ 
+ static const char *output_15 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_15 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   if (REG_P (operands[0]))
+     {
+       if (FP_REG_P (operands[1]))
+ 	{
+ 	  mvs_check_page (0, 8, 0);
+ 	  return "STE	%1," CONVLO "(,13)\n\tL	%0," CONVLO "(,13)";
+ 	}
+       if (REG_P (operands[1]))
+ 	{
+ 	  mvs_check_page (0, 2, 0);
+ 	  return "LR	%0,%1";
+ 	}
+       if (operands[1] == const0_rtx)
+ 	{
+ 	  CC_STATUS_INIT;
+ 	  mvs_check_page (0, 2, 0);
+ 	  return "SLR	%0,%0";
+ 	}
+       if (GET_CODE (operands[1]) == CONST_INT
+ 	  && (unsigned) INTVAL (operands[1]) < 4096)
+ 	{
+ 	  mvs_check_page (0, 4, 0);
+ 	  return "LA	%0,%c1(0,0)";
+ 	}
+       mvs_check_page (0, 4, 0);
+       return "L	%0,%1";
+     }
+   else if (FP_REG_P (operands[1]))
+     {
+       mvs_check_page (0, 4, 0);
+       return "STE	%1,%0";
+     }
+   else if (!REG_P (operands[1]))
+     {
+       mvs_check_page (0, 6, 0);
+       return "MVC	%O0(4,%R0),%1";
+     }
+   mvs_check_page (0, 4, 0);
+   return "ST	%1,%0";
+ }
+ }
+ 
+ static const char *output_16 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_16 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   if (REG_P (operands[0]))
+     {
+       if (REG_P (operands[1]))
+ 	{
+ 	  mvs_check_page (0, 2, 0);
+ 	  return "LR	%0,%1";
+ 	}
+       if (operands[1] == const0_rtx)
+ 	{
+ 	  CC_STATUS_INIT;
+ 	  mvs_check_page (0, 2, 0);
+ 	  return "SLR	%0,%0";
+ 	}
+       if (GET_CODE (operands[1]) == CONST_INT
+ 	  && (unsigned) INTVAL (operands[1]) < 4096)
+ 	{
+ 	  mvs_check_page (0, 4, 0);
+ 	  return "LA	%0,%c1(0,0)";
+ 	}
+       if (GET_CODE (operands[1]) == CONST_INT)
+ 	{
+ 	  mvs_check_page (0, 4, 2);
+ 	  return "LH	%0,%H1";
+ 	}
+       mvs_check_page (0, 4, 0);
+       return "LH	%0,%1";
+     }
+   else if (REG_P (operands[1]))
+     {
+       mvs_check_page (0, 4, 0);
+       return "STH	%1,%0";
+     }
+   if (GET_CODE (operands[1]) == CONST_INT)
+     {
+       mvs_check_page (0, 6, 2);
+       return "MVC	%O0(2,%R0),%H1";
+     }
+   mvs_check_page (0, 6, 0);
+   return "MVC	%O0(2,%R0),%1";
+ }
+ }
+ 
+ static const char *output_17 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_17 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   if (REG_P (operands[0]))
+     {
+       if (REG_P (operands[1]))
+ 	{
+ 	  mvs_check_page (0, 2, 0);
+ 	  return "LR	%0,%1";
+ 	}
+       if (operands[1] == const0_rtx)
+ 	{
+ 	  CC_STATUS_INIT;
+ 	  mvs_check_page (0, 2, 0);
+ 	  return "SLR	%0,%0";
+ 	}
+       if (GET_CODE (operands[1]) == CONST_INT
+ 	  && (unsigned) INTVAL (operands[1]) < 4096)
+ 	{
+ 	  mvs_check_page (0, 4, 0);
+ 	  return "LA	%0,%c1(0,0)";
+ 	}
+       if (GET_CODE (operands[1]) == CONST_INT)
+ 	{
+ 	  mvs_check_page (0, 4, 2);
+ 	  return "LH	%0,%H1";
+ 	}
+       mvs_check_page (0, 4, 0);
+       return "LH	%0,%1";
+     }
+   mvs_check_page (0, 4, 0);
+   return "STH	%1,%0";
+ }
+ }
+ 
+ static const char *output_18 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_18 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   if (REG_P (operands[0]))
+     {
+       if (REG_P (operands[1]))
+ 	{
+ 	  mvs_check_page (0, 2, 0);
+ 	  return "LR	%0,%1";
+ 	}
+       if (operands[1] == const0_rtx)
+ 	{
+ 	  CC_STATUS_INIT;
+ 	  mvs_check_page (0, 2, 0);
+ 	  return "SLR	%0,%0";
+ 	}
+       if (GET_CODE (operands[1]) == CONST_INT)
+ 	{
+ 	  if ((INTVAL (operands[1]) >= 0)
+   	      && (unsigned) INTVAL (operands[1]) < 4096)
+ 	    {
+ 	      mvs_check_page (0, 4, 0);
+ 	      return "LA	%0,%c1(0,0)";
+ 	    }
+ 	  mvs_check_page (0, 4, 4);
+ 	  return "L	%0,=F'%c1'";
+ 	}
+       mvs_check_page (0, 4, 0);
+       return "IC	%0,%1";
+     }
+   else if (REG_P (operands[1]))
+     {
+       mvs_check_page (0, 4, 0);
+       return "STC	%1,%0";
+     }
+   else if (GET_CODE (operands[1]) == CONST_INT)
+     {
+       mvs_check_page (0, 4, 0);
+       return "MVI	%0,%B1";
+     }
+   mvs_check_page (0, 6, 0);
+   return "MVC	%O0(1,%R0),%1";
+ }
+ }
+ 
+ static const char *output_19 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_19 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   if (REG_P (operands[0]))
+     {
+       if (REG_P (operands[1]))
+ 	{
+ 	  mvs_check_page (0, 2, 0);
+ 	  return "LR	%0,%1";
+ 	}
+       if (operands[1] == const0_rtx)
+ 	{
+ 	  CC_STATUS_INIT;
+ 	  mvs_check_page (0, 2, 0);
+ 	  return "SLR	%0,%0";
+ 	}
+       if (GET_CODE (operands[1]) == CONST_INT)
+ 	{
+ 	  if ((INTVAL (operands[1]) >= 0)
+   	      && (unsigned) INTVAL (operands[1]) < 4096)
+ 	    {
+ 	      mvs_check_page (0, 4, 0);
+ 	      return "LA	%0,%c1(0,0)";
+ 	    }
+ 	  mvs_check_page (0, 4, 4);
+ 	  return "L	%0,=F'%c1'";
+ 	}
+       mvs_check_page (0, 4, 0);
+       return "IC	%0,%1";
+     }
+   mvs_check_page (0, 4, 0);
+   return "STC	%1,%0";
+ }
+ }
+ 
+ static const char *output_20 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_20 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   if (REG_P (operands[0]))
+     {
+       mvs_check_page (0, 8, 0);
+       return "STH	%1," CONVLO "(,13)\n\tICM	%0,3," CONVLO "(13)";
+     }
+   mvs_check_page (0, 4, 0);
+   return "STH	%1,%0";
+ }
+ }
+ 
+ static const char *output_21 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_21 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   if (FP_REG_P (operands[0]))
+     {
+       if (FP_REG_P (operands[1]))
+ 	{
+ 	  mvs_check_page (0, 2, 0);
+ 	  return "LDR	%0,%1";
+ 	}
+       if (REG_P (operands[1]))
+ 	{
+ 	  mvs_check_page (0, 8, 0);
+ 	  return "STM	%1,%N1," CONVLO "(13)\n\tLD	%0," CONVLO "(,13)";
+ 	}
+       if (operands[1] == const0_rtx)
+ 	{
+ 	  CC_STATUS_SET (operands[0], operands[1]);
+ 	  mvs_check_page (0, 2, 0);
+ 	  return "SDR	%0,%0";
+ 	}
+       mvs_check_page (0, 4, 0);
+       return "LD	%0,%1";
+     }
+   if (REG_P (operands[0]))
+     {
+       if (FP_REG_P (operands[1]))
+ 	{
+ 	  mvs_check_page (0, 12, 0);
+ 	  return "STD	%1," CONVLO "(,13)\n\tLM	%0,%N0," CONVLO "(13)";
+ 	}
+       if (REG_P (operands[1]))
+ 	{
+ 	  mvs_check_page (0, 4, 0);
+ 	  return "LR	%0,%1\n\tLR	%N0,%N1";
+ 	}
+       mvs_check_page (0, 4, 0);
+       return "LM	%0,%N0,%1";
+       /*return "L	%0,%1\n\tL	%N0,4+%1";*/
+     }
+   else if (FP_REG_P (operands[1]))
+     {
+       mvs_check_page (0, 4, 0);
+       return "STD	%1,%0";
+     }
+   else if (REG_P (operands[1]))
+     {
+       mvs_check_page (0, 4, 0);
+       /*return "STM	%1,%N1,%0"; */
+       return "ST	%1,%0\n\tST	%N1,4+%0"; 
+     }
+   mvs_check_page (0, 6, 8);
+   return "MVC	%O0(8,%R0),%1";
+ }
+ }
+ 
+ static const char *output_22 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_22 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   if (FP_REG_P (operands[0]))
+     {
+       if (FP_REG_P (operands[1]))
+ 	{
+ 	  mvs_check_page (0, 2, 0);
+ 	  return "LDR	%0,%1";
+ 	}
+       if (REG_P (operands[1]))
+ 	{
+ 	  mvs_check_page (0, 8, 0);
+ 	  return "STM	%1,%N1," CONVLO "(13)\n\tLD	%0," CONVLO "(,13)";
+ 	}
+       if (operands[1] == const0_rtx)
+ 	{
+ 	  CC_STATUS_SET (operands[0], operands[1]);
+ 	  mvs_check_page (0, 2, 0);
+ 	  return "SDR	%0,%0";
+ 	}
+       mvs_check_page (0, 4, 0);
+       return "LD	%0,%1";
+     }
+   else if (REG_P (operands[0]))
+     {
+       if (FP_REG_P (operands[1]))
+ 	{
+ 	  mvs_check_page (0, 12, 0);
+ 	  return "STD	%1," CONVLO "(,13)\n\tLM	%0,%N0," CONVLO "(13)";
+ 	}
+       if (REG_P (operands[1]))
+ 	{
+ 	  mvs_check_page (0, 4, 0);
+ 	  return "LR	%0,%1\n\tLR	%N0,%N1";
+ 	}
+       mvs_check_page (0, 4, 0);
+       /*return "LM	%0,%N0,%1";*/
+       return "L	%0,%1\n\tL	%N0,4+%1";
+     }
+   else if (FP_REG_P (operands[1]))
+     {
+       mvs_check_page (0, 4, 0);
+       return "STD	%1,%0";
+     }
+   mvs_check_page (0, 4, 0);
+   /*return "STM	%1,%N1,%0"; */
+   return "ST	%1,%0\n\tST	%N1,4+%0"; 
+ }
+ }
+ 
+ static const char *output_23 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_23 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   if (FP_REG_P (operands[0]))
+     {
+       if (FP_REG_P (operands[1]))
+ 	{
+ 	  mvs_check_page (0, 2, 0);
+ 	  return "LER	%0,%1";
+ 	}
+       if (REG_P (operands[1]))
+ 	{
+ 	  mvs_check_page (0, 8, 0);
+ 	  return "ST	%1," CONVLO "(,13)\n\tLE	%0," CONVLO "(,13)";
+ 	}
+       if (operands[1] == const0_rtx)
+ 	{
+ 	  CC_STATUS_SET (operands[0], operands[1]);
+ 	  mvs_check_page (0, 2, 0);
+ 	  return "SER	%0,%0";
+ 	}
+       mvs_check_page (0, 4, 0);
+       return "LE	%0,%1";
+     }
+   else if (REG_P (operands[0]))
+     {
+       if (FP_REG_P (operands[1]))
+ 	{
+ 	  mvs_check_page (0, 8, 0);
+ 	  return "STE	%1," CONVLO "(,13)\n\tL	%0," CONVLO "(,13)";
+ 	}
+       if (REG_P (operands[1]))
+ 	{
+ 	  mvs_check_page (0, 2, 0);
+ 	  return "LR	%0,%1";
+ 	}
+       mvs_check_page (0, 4, 0);
+       return "L	%0,%1";
+     }
+   else if (FP_REG_P (operands[1]))
+     {
+       mvs_check_page (0, 4, 0);
+       return "STE	%1,%0";
+     }
+   else if (REG_P (operands[1]))
+     {
+       mvs_check_page (0, 4, 0);
+       return "ST	%1,%0";
+     }
+   mvs_check_page (0, 6, 0);
+   return "MVC	%O0(4,%R0),%1";
+ }
+ }
+ 
+ static const char *output_24 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_24 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   if (FP_REG_P (operands[0]))
+     {
+       if (FP_REG_P (operands[1]))
+ 	{
+ 	  mvs_check_page (0, 2, 0);
+ 	  return "LER	%0,%1";
+ 	}
+       if (REG_P (operands[1]))
+ 	{
+ 	  mvs_check_page (0, 8, 0);
+ 	  return "ST	%1," CONVLO "(,13)\n\tLE	%0," CONVLO "(,13)";
+ 	}
+       if (operands[1] == const0_rtx)
+ 	{
+ 	  CC_STATUS_SET (operands[0], operands[1]);
+ 	  mvs_check_page (0, 2, 0);
+ 	  return "SER	%0,%0";
+ 	}
+       mvs_check_page (0, 4, 0);
+       return "LE	%0,%1";
+     }
+   else if (REG_P (operands[0]))
+     {
+       if (FP_REG_P (operands[1]))
+ 	{
+ 	  mvs_check_page (0, 8, 0);
+ 	  return "STE	%1," CONVLO "(,13)\n\tL	%0," CONVLO "(,13)";
+ 	}
+       mvs_check_page (0, 4, 0);
+       return "L	%0,%1";
+     }
+   else if (FP_REG_P (operands[1]))
+     {
+       mvs_check_page (0, 4, 0);
+       return "STE	%1,%0";
+     }
+   mvs_check_page (0, 4, 0);
+   return "ST	%1,%0";
+ }
+ }
+ 
+ static const char *output_25 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_25 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   mvs_check_page (0, 6, 0);
+   return "MVC	%O0(%c2,%R0),%1";
+ }
+ }
+ 
+ static const char *output_26 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_26 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   mvs_check_page (0, 2, 0);
+   return "MVCL	%0,%1";
+ }
+ }
+ 
+ static const char *output_27 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_27 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   if (REG_P (operands[0]))
+     {
+       if (REG_P (operands[1]))
+       {
+         if (REGNO (operands[0]) != REGNO (operands[1]))
+ 	  {
+ 	    mvs_check_page (0, 10, 0);
+             return "LR	%0,%1\n\tSLL	%0,16\n\tSRA	%0,16";
+ 	  }
+         else
+           return ""; /* Should be empty.  16-bits regs are always 32-bits.  */
+       }
+       if (operands[1] == const0_rtx)
+ 	{
+ 	  CC_STATUS_INIT;
+ 	  mvs_check_page (0, 2, 0);
+ 	  return "SLR	%0,%0";
+ 	}
+       if (GET_CODE (operands[1]) == CONST_INT
+  	  && (unsigned) INTVAL (operands[1]) < 4096)
+ 	{
+ 	  mvs_check_page (0, 4, 0);
+ 	  return "LA	%0,%c1(0,0)";
+ 	}
+       if (GET_CODE (operands[1]) == CONST_INT)
+ 	{
+ 	  mvs_check_page (0, 4, 2);
+ 	  return "LH	%0,%H1";
+ 	}
+       mvs_check_page (0, 4, 0);
+       return "LH	%0,%1";
+     }
+   mvs_check_page (0, 12, 0);
+   return "SLL	%1,16\n\tSRA	%1,16\n\tST	%1,%0";
+ }
+ }
+ 
+ static const char *output_28 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_28 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   CC_STATUS_SET (operands[0], operands[1]);
+   if (REG_P (operands[1]))
+     {
+       mvs_check_page (0, 8, 0);
+       return "SLL	%0,24\n\tSRA	%0,24";
+     }
+   if (s_operand (operands[1], GET_MODE (operands[1])))
+     {
+       mvs_check_page (0, 8, 0);
+       return "ICM	%0,8,%1\n\tSRA	%0,24";
+     }
+   mvs_check_page (0, 12, 0);
+   return "IC	%0,%1\n\tSLL	%0,24\n\tSRA	%0,24";
+ }
+ }
+ 
+ static const char *output_29 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_29 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   CC_STATUS_SET (operands[0], operands[1]);
+   if (REG_P (operands[1]))
+     {
+       mvs_check_page (0, 8, 0);
+       return "SLL	%0,24\n\tSRA	%0,24";
+     }
+   if (s_operand (operands[1], GET_MODE (operands[1])))
+     {
+       mvs_check_page (0, 8, 0);
+       return "ICM	%0,8,%1\n\tSRA	%0,24";
+     }
+   mvs_check_page (0, 12, 0);
+   return "IC	%0,%1\n\tSLL	%0,24\n\tSRA	%0,24";
+ }
+ }
+ 
+ static const char *output_30 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_30 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   /* AND only sets zero/not-zero bits not the arithmetic bits ...  */
+   CC_STATUS_INIT;
+   mvs_check_page (0, 4, 4);
+   return "N	%1,=XL4'0000FFFF'";
+ }
+ }
+ 
+ static const char *output_31 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_31 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   if (REG_P (operands[1]))
+     {
+       /* AND only sets zero/not-zero bits not the arithmetic bits ...  */
+       CC_STATUS_INIT;
+       mvs_check_page (0, 4, 4);
+       return "N	%0,=XL4'000000FF'";
+     }
+   if (GET_CODE (operands[1]) == CONST_INT)
+     {
+       mvs_check_page (0, 4, 0);
+       return "LA	%0,%c1(0,0)";
+     }
+   CC_STATUS_INIT;
+   mvs_check_page (0, 8, 0);
+   return "SLR	%0,%0\n\tIC	%0,%1";
+ }
+ }
+ 
+ static const char *output_32 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_32 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   if (REG_P (operands[1]))
+     {
+       /* AND only sets zero/not-zero bits not the arithmetic bits ...  */
+       CC_STATUS_INIT;
+       mvs_check_page (0, 4, 4);
+       return "N	%0,=XL4'000000FF'";
+     }
+   if (GET_CODE (operands[1]) == CONST_INT)
+     {
+       mvs_check_page (0, 4, 0);
+       return "LA	%0,%c1(0,0)";
+     }
+   CC_STATUS_INIT;
+   mvs_check_page (0, 8, 0);
+   return "SLR	%0,%0\n\tIC	%0,%1";
+ }
+ }
+ 
+ static const char *output_33 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_33 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   if (REG_P (operands[0]))
+     {
+       CC_STATUS_SET (operands[0], operands[1]);
+       mvs_check_page (0, 8, 0);
+       return "SLL	%0,16\n\tSRA	%0,16";
+     }
+   mvs_check_page (0, 4, 0);
+   return "STH	%1,%0";
+ }
+ }
+ 
+ static const char *output_34 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_34 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   CC_STATUS_INIT;
+   if (REGNO (operands[1]) == 16)
+     {
+       mvs_check_page (0, 12, 8);
+       return "AD	0,=XL8'4F08000000000000'\n\tSTD	0," CONVLO "(,13)\n\tL	%0," CONVHI "(,13)";
+     }
+   mvs_check_page (0, 14, 8);
+   return "LDR	0,%1\n\tAD	0,=XL8'4F08000000000000'\n\tSTD	0," CONVLO "(,13)\n\tL	%0," CONVHI "(,13)";
+ }
+ }
+ 
+ static const char *output_35 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_35 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   CC_STATUS_INIT;
+ #if defined(TARGET_LINUX)
+   mvs_check_page (0, 22, 12);
+   return "MVC	" CONVLO "(4,13),=XL4'4E000000'\n\tST	%1," CONVLO "+4(,13)\n\tXI	" CONVLO "+4(13),128\n\tLD	%0," CONVLO "(,13)\n\tSD	%0,=XL8'4E00000080000000'";
+ #elif defined(TARGET_DIGNUS) || defined(TARGET_PDPMAC)
+   mvs_check_page (0, 22, 12);
+   return "MVC	" CONVLO "(4,13),=XL8'4E00000080000000'\n\tST	%1," CONVHI "(,13)\n\tXI	" CONVHI "(13),128\n\tLD	%0," CONVLO "(,13)\n\tSD	%0,=XL8'4E00000080000000'";
+ #else
+   mvs_check_page (0, 16, 8);
+   return "ST	%1,508(,12)\n\tXI	508(12),128\n\tLD	%0,504(,12)\n\tSD	%0,=XL8'4E00000080000000'";
+ #endif
+ }
+ }
+ 
+ static const char *output_36 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_36 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   mvs_check_page (0, 2, 0);
+   return "LRER	%0,%1";
+ }
+ }
+ 
+ static const char *output_37 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_37 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   CC_STATUS_SET (0, const0_rtx);
+   if (FP_REG_P (operands[1]))
+     {
+       if (REGNO (operands[0]) == REGNO (operands[1]))
+ 	{
+ 	  mvs_check_page (0, 10, 0);
+ 	  return "STE	%1," CONVLO "(,13)\n\tSDR	%0,%0\n\tLE	%0," CONVLO "(,13)";
+ 	}
+       mvs_check_page (0, 4, 0);
+       return "SDR	%0,%0\n\tLER	%0,%1";
+     }
+   mvs_check_page (0, 6, 0);
+   return "SDR	%0,%0\n\tLE	%0,%1";
+ }
+ }
+ 
+ static const char *output_38 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_38 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   int onpage;
+ 
+   check_label_emit ();
+   onpage = mvs_check_label (CODE_LABEL_NUMBER (operands[3]));
+   if (REG_P (operands[2]))
+     {
+       if (!onpage)
+ 	{
+ 	  mvs_check_page (0, 8, 4);
+ 	  return "ALR	%0,%2\n\tL	14,=A(%l3)\n\tBCR	12,14";
+ 	}
+       if (mvs_check_page (0, 6, 0))
+ 	{
+ 	  mvs_check_page (0, 2, 4);
+ 	  return "ALR	%0,%2\n\tL	14,=A(%l3)\n\tBCR	12,14";
+ 	}
+       return "ALR	%0,%2\n\tBC	12,%l3";
+     }
+   if (!onpage)
+     {
+       mvs_check_page (0, 10, 4);
+       return "AL	%0,%2\n\tL	14,=A(%l3)\n\tBCR	12,14";
+     }
+   if (mvs_check_page (0, 8 ,0))
+     {
+       mvs_check_page (0, 2, 4);
+       return "AL	%0,%2\n\tL	14,=A(%l3)\n\tBCR	12,14";
+     }
+   return "AL	%0,%2\n\tBC	12,%l3";
+ }
+ }
+ 
+ static const char *output_39 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_39 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   CC_STATUS_INIT;  /* add assumes CC but LA doesn't set CC */
+   mvs_check_page (0, 4, 0);
+   return "LA	%0,%c2(,%1)";
+ }
+ }
+ 
+ static const char *output_40 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_40 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   if ((unsigned) INTVAL (operands[2]) < 4096)
+     {
+       CC_STATUS_INIT;  /* add assumes CC but LA doesn't set CC */
+       mvs_check_page (0, 4, 0);
+       return "LA	%0,%c2(,%1)";
+     }
+   if (REGNO (operands[1]) == REGNO (operands[0]))
+     {
+       CC_STATUS_INIT;
+       mvs_check_page (0, 4, 0);
+       return "A	%0,%2";
+     }
+   mvs_check_page (0, 6, 0);
+   return "L	%0,%2\n\tAR	%0,%1";
+ }
+ }
+ 
+ static const char *output_41 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_41 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   if (REG_P (operands[2]))
+     {
+       mvs_check_page (0, 2, 0);
+       return "AR	%0,%2";
+     }
+   if (GET_CODE (operands[2]) == CONST_INT)
+     {
+       if (INTVAL (operands[2]) == -1)
+ 	{
+           CC_STATUS_INIT;  /* add assumes CC but BCTR doesn't set CC */
+ 	  mvs_check_page (0, 2, 0);
+ 	  return "BCTR	%0,0";
+ 	}
+     }
+   mvs_check_page (0, 4, 0);
+   return "A	%0,%2";
+ }
+ }
+ 
+ static const char *output_42 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_42 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   if (REG_P (operands[2]))
+     {
+       mvs_check_page (0, 8, 0);
+       return "STH	%2," CONVLO "(,13)\n\tAH	%0," CONVLO "(,13)";
+     }
+   if (GET_CODE (operands[2]) == CONST_INT)
+     {
+       if (INTVAL (operands[2]) == -1)
+ 	{
+           CC_STATUS_INIT;  /* add assumes CC but BCTR doesn't set CC */
+ 	  mvs_check_page (0, 2, 0);
+ 	  return "BCTR	%0,0";
+ 	}
+       mvs_check_page (0, 4, 2);
+       return "AH	%0,%H2";
+     }
+   mvs_check_page (0, 4, 0);
+   return "AH	%0,%2";
+ }
+ }
+ 
+ static const char *output_43 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_43 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   CC_STATUS_INIT;  /* add assumes CC but LA doesn't set CC */
+   mvs_check_page (0, 4, 0);
+   if (REG_P (operands[2]))
+     return "LA	%0,0(%1,%2)";
+   return "LA	%0,%B2(,%1)";
+ }
+ }
+ 
+ static const char *output_44 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_44 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   if (FP_REG_P (operands[2]))
+     {
+       mvs_check_page (0, 2, 0);
+       return "ADR	%0,%2";
+     }
+   mvs_check_page (0, 4, 0);
+   return "AD	%0,%2";
+ }
+ }
+ 
+ static const char *output_45 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_45 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   if (FP_REG_P (operands[2]))
+     {
+       mvs_check_page (0, 2, 0);
+       return "AER	%0,%2";
+     }
+   mvs_check_page (0, 4, 0);
+   return "AE	%0,%2";
+ }
+ }
+ 
+ static const char *output_46 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_46 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   int onpage;
+ 
+   check_label_emit ();
+   CC_STATUS_INIT;
+   onpage = mvs_check_label (CODE_LABEL_NUMBER (operands[3]));
+   if (REG_P (operands[2]))
+     {
+       if (!onpage)
+ 	{
+ 	  mvs_check_page (0, 8, 4);
+ 	  return "SLR	%0,%2\n\tL	14,=A(%l3)\n\tBCR	12,14";
+ 	}
+       if (mvs_check_page (0, 6, 0))
+ 	{
+ 	  mvs_check_page (0, 2, 4);
+ 	  return "SLR	%0,%2\n\tL	14,=A(%l3)\n\tBCR	12,14";
+ 	}
+       return "SLR	%0,%2\n\tBC	12,%l3";
+     }
+   if (!onpage)
+     {
+       mvs_check_page (0, 10, 4);
+       return "SL	%0,%2\n\tL	14,=A(%l3)\n\tBCR	12,14";
+     }
+   if (mvs_check_page (0, 8, 0))
+     {
+       mvs_check_page (0, 2, 4);
+       return "SL	%0,%2\n\tL	14,=A(%l3)\n\tBCR	12,14";
+     }
+   return "SL	%0,%2\n\tBC	12,%l3";
+ }
+ }
+ 
+ static const char *output_47 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_47 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   if (REG_P (operands[2]))
+     {
+       mvs_check_page (0, 2, 0);
+       return "SR	%0,%2";
+     }
+   if (operands[2] == const1_rtx)
+     {
+       CC_STATUS_INIT;  /* subtract assumes CC but BCTR doesn't set CC */
+       mvs_check_page (0, 2, 0);
+       return "BCTR	%0,0";
+     }
+   mvs_check_page (0, 4, 0);
+   return "S	%0,%2";
+ }
+ }
+ 
+ static const char *output_48 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_48 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   if (REG_P (operands[2]))
+     {
+       mvs_check_page (0, 8, 0);
+       return "STH	%2," CONVLO "(,13)\n\tSH	%0," CONVLO "(,13)";
+     }
+   if (operands[2] == const1_rtx)
+     {
+       CC_STATUS_INIT;  /* subtract assumes CC but BCTR doesn't set CC */
+       mvs_check_page (0, 2, 0);
+       return "BCTR	%0,0";
+     }
+   if (GET_CODE (operands[2]) == CONST_INT)
+     {
+       mvs_check_page (0, 4, 2);
+       return "SH	%0,%H2";
+     }
+   mvs_check_page (0, 4, 0);
+   return "SH	%0,%2";
+ }
+ }
+ 
+ static const char *output_49 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_49 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   mvs_check_page (0, 2, 0);
+   return "SR	%0,%2";
+ }
+ }
+ 
+ static const char *output_50 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_50 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   if (FP_REG_P (operands[2]))
+     {
+       mvs_check_page (0, 2, 0);
+       return "SDR	%0,%2";
+     }
+   mvs_check_page (0, 4, 0);
+   return "SD	%0,%2";
+ }
+ }
+ 
+ static const char *output_51 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_51 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   if (FP_REG_P (operands[2]))
+     {
+       mvs_check_page (0, 2, 0);
+       return "SER	%0,%2";
+     }
+   mvs_check_page (0, 4, 0);
+   return "SE	%0,%2";
+ }
+ }
+ 
+ static const char *output_52 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_52 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   mvs_check_page (0, 4, 0);
+   return "MH	%0,%H2";
+ }
+ }
+ 
+ static const char *output_53 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_53 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   if (REG_P (operands[2]))
+     {
+       mvs_check_page (0, 2, 0);
+       return "MR	%0,%2";
+     }
+   mvs_check_page (0, 4, 0);
+   return "M	%0,%2";
+ }
+ }
+ 
+ static const char *output_54 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_54 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   if (FP_REG_P (operands[2]))
+     {
+       mvs_check_page (0, 2, 0);
+       return "MDR	%0,%2";
+     }
+   mvs_check_page (0, 4, 0);
+   return "MD	%0,%2";
+ }
+ }
+ 
+ static const char *output_55 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_55 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   if (FP_REG_P (operands[2]))
+     {
+       mvs_check_page (0, 2, 0);
+       return "MER	%0,%2";
+     }
+   mvs_check_page (0, 4, 0);
+   return "ME	%0,%2";
+ }
+ }
+ 
+ static const char *output_56 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_56 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   if (REG_P (operands[2]))
+     {
+       mvs_check_page (0, 2, 0);
+       return "DR	%0,%2";
+     }
+   mvs_check_page (0, 4, 0);
+   return "D	%0,%2";
+ }
+ }
+ 
+ static const char *output_57 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_57 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   if (FP_REG_P (operands[2]))
+     {
+       mvs_check_page (0, 2, 0);
+       return "DDR	%0,%2";
+     }
+   mvs_check_page (0, 4, 0);
+   return "DD	%0,%2";
+ }
+ }
+ 
+ static const char *output_58 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_58 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   if (FP_REG_P (operands[2]))
+     {
+       mvs_check_page (0, 2, 0);
+       return "DER	%0,%2";
+     }
+   mvs_check_page (0, 4, 0);
+   return "DE	%0,%2";
+ }
+ }
+ 
+ static const char *output_59 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_59 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   if (REG_P (operands[2]))
+     {
+       mvs_check_page (0, 2, 0);
+       return "DR	%0,%2";
+     }
+   mvs_check_page (0, 4, 0);
+   return "D	%0,%2";
+ }
+ }
+ 
+ static const char *output_60 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_60 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   CC_STATUS_INIT;  /* AND sets CC but not how we want it */
+   if (REG_P (operands[2]))
+     {
+       mvs_check_page (0, 2, 0);
+       return "NR	%0,%2";
+     }
+   if (REG_P (operands[0]))
+     {
+       mvs_check_page (0, 4, 0);
+       return "N	%0,%2";
+     }
+   mvs_check_page (0, 6, 0);
+   return "NC	%O0(4,%R0),%2";
+ }
+ }
+ 
+ static const char *output_61 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_61 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   CC_STATUS_INIT;  /* AND sets CC but not how we want it */
+   if (REG_P (operands[2]))
+     {
+       mvs_check_page (0, 2, 0);
+       return "NR	%0,%2";
+     }
+   mvs_check_page (0, 4, 0);
+   return "N	%0,%2";
+ }
+ }
+ 
+ static const char *output_62 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_62 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   CC_STATUS_INIT;  /* AND sets CC but not how we want it */
+   if (REG_P (operands[2]))
+     {
+       mvs_check_page (0, 2, 0);
+       return "NR	%0,%2";
+     }
+   if (REG_P (operands[0]))
+     {
+       /* %K2 == sign extend operand to 32 bits so that CH works - huh??? */
+       if (GET_CODE (operands[2]) == CONST_INT)
+         {
+           mvs_check_page (0, 4, 4);
+           return "N	%0,%K2";
+         }
+       mvs_check_page (0, 4, 0);
+       return "N	%0,%2";
+     }
+   if (GET_CODE (operands[2]) == CONST_INT)
+     {
+       mvs_check_page (0, 6, 2);
+       return "NC	%O0(2,%R0),%H2";
+     }
+   mvs_check_page (0, 6, 0);
+   return "NC	%O0(2,%R0),%2";
+ }
+ }
+ 
+ static const char *output_63 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_63 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   CC_STATUS_INIT;  /* AND sets CC but not how we want it */
+   if (GET_CODE (operands[2]) == CONST_INT)
+     {
+       /* %K2 == sign extend operand to 32 bits so that CH works - huh??? */
+       mvs_check_page (0, 4, 4);
+       return "N	%0,%K2";
+     }
+   mvs_check_page (0, 2, 0);
+   return "NR	%0,%2";
+ }
+ }
+ 
+ static const char *output_64 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_64 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   CC_STATUS_INIT;  /* AND sets CC but not how we want it */
+   if (REG_P (operands[2]))
+     {
+       mvs_check_page (0, 2, 0);
+       return "NR	%0,%2";
+     }
+   if (REG_P (operands[0]))
+     {
+       mvs_check_page (0, 4, 0);
+       return "N	%0,%2";
+     }
+   if (GET_CODE (operands[2]) == CONST_INT)
+     {
+       mvs_check_page (0, 4, 0);
+       return "NI	%0,%B2";
+     }
+   mvs_check_page (0, 6, 0);
+   return "NC	%O0(1,%R0),%2";
+ }
+ }
+ 
+ static const char *output_65 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_65 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   CC_STATUS_INIT;  /* AND sets CC but not how we want it */
+   if (GET_CODE (operands[2]) == CONST_INT)
+     {
+       mvs_check_page (0, 4, 4);
+       return "N	%0,=XL4'%X2'";
+     }
+   mvs_check_page (0, 2, 0);
+   return "NR	%0,%2";
+ }
+ }
+ 
+ static const char *output_66 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_66 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   CC_STATUS_INIT;  /* OR sets CC but not how we want it */
+   if (REG_P (operands[2]))
+     {
+       mvs_check_page (0, 2, 0);
+       return "OR	%0,%2";
+     }
+   if (REG_P (operands[0]))
+     {
+       mvs_check_page (0, 4, 0);
+       return "O	%0,%2";
+     }
+   mvs_check_page (0, 6, 0);
+   return "OC	%O0(4,%R0),%2";
+ }
+ }
+ 
+ static const char *output_67 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_67 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   CC_STATUS_INIT;  /* OR sets CC but not how we want it */
+   if (REG_P (operands[2]))
+     {
+       mvs_check_page (0, 2, 0);
+       return "OR	%0,%2";
+     }
+   mvs_check_page (0, 4, 0);
+   return "O	%0,%2";
+ }
+ }
+ 
+ static const char *output_68 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_68 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   CC_STATUS_INIT;  /* OR sets CC but not how we want it */
+   if (REG_P (operands[2]))
+     {
+       mvs_check_page (0, 2, 0);
+       return "OR	%0,%2";
+     }
+   if (REG_P (operands[0]))
+     {
+       /* %K2 == sign extend operand to 32 bits so that CH works - huh??? */
+       if (GET_CODE (operands[2]) == CONST_INT)
+         {
+           mvs_check_page (0, 4, 4);
+           return "O	%0,%K2";
+         }
+       mvs_check_page (0, 4, 0);
+       return "O	%0,%2";
+     }
+   if (GET_CODE (operands[2]) == CONST_INT)
+     {
+       mvs_check_page (0, 6, 2);
+       return "OC	%O0(2,%R0),%H2";
+     }
+   mvs_check_page (0, 6, 0);
+   return "OC	%O0(2,%R0),%2";
+ }
+ }
+ 
+ static const char *output_69 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_69 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   CC_STATUS_INIT;  /* OR sets CC but not how we want it */
+   if (GET_CODE (operands[2]) == CONST_INT)
+     {
+       /* %K2 == sign extend operand to 32 bits so that CH works - huh??? */
+       mvs_check_page (0, 4, 4);
+       return "O	%0,%K2";
+     }
+   mvs_check_page (0, 2, 0);
+   return "OR	%0,%2";
+ }
+ }
+ 
+ static const char *output_70 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_70 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   CC_STATUS_INIT;  /* OR sets CC but not how we want it */
+   if (REG_P (operands[2]))
+     {
+       mvs_check_page (0, 2, 0);
+       return "OR	%0,%2";
+     }
+   if (REG_P (operands[0]))
+     {
+       mvs_check_page (0, 4, 0);
+       return "O	%0,%2";
+     }
+   if (GET_CODE (operands[2]) == CONST_INT)
+     {
+       mvs_check_page (0, 4, 0);
+       return "OI	%0,%B2";
+     }
+   mvs_check_page (0, 6, 0);
+   return "OC	%O0(1,%R0),%2";
+ }
+ }
+ 
+ static const char *output_71 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_71 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   CC_STATUS_INIT;  /* OR sets CC but not how we want it */
+   if (GET_CODE (operands[2]) == CONST_INT)
+     {
+       mvs_check_page (0, 4, 4);
+       return "O	%0,=XL4'%X2'";
+     }
+   mvs_check_page (0, 2, 0);
+   return "OR	%0,%2";
+ }
+ }
+ 
+ static const char *output_72 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_72 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   CC_STATUS_INIT;  /* XOR sets CC but not how we want it */
+   if (REG_P (operands[2]))
+     {
+       mvs_check_page (0, 2, 0);
+       return "XR	%0,%2";
+     }
+   if (REG_P (operands[0]))
+     {
+       mvs_check_page (0, 4, 0);
+       return "X	%0,%2";
+     }
+   mvs_check_page (0, 6, 0);
+   return "XC	%O0(4,%R0),%2";
+ }
+ }
+ 
+ static const char *output_73 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_73 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   CC_STATUS_INIT;  /* XOR sets CC but not how we want it */
+   if (REG_P (operands[2]))
+     {
+       mvs_check_page (0, 2, 0);
+       return "XR	%0,%2";
+     }
+   mvs_check_page (0, 4, 0);
+   return "X	%0,%2";
+ }
+ }
+ 
+ static const char *output_74 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_74 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   CC_STATUS_INIT;  /* XOR sets CC but not how we want it */
+   if (REG_P (operands[2]))
+     {
+       mvs_check_page (0, 2, 0);
+       return "XR	%0,%2";
+     }
+   if (REG_P (operands[0]))
+     {
+       /* %K2 == sign extend operand to 32 bits so that CH works - huh??? */
+       if (GET_CODE (operands[2]) == CONST_INT)
+         {
+           mvs_check_page (0, 4, 4);
+           return "X	%0,%K2";
+         }
+       mvs_check_page (0, 4, 0);
+       return "X	%0,%2";
+     }
+   if (GET_CODE (operands[2]) == CONST_INT)
+     {
+       mvs_check_page (0, 6, 2);
+       return "XC	%O0(2,%R0),%H2";
+     }
+   mvs_check_page (0, 6, 0);
+   return "XC	%O0(2,%R0),%2";
+ }
+ }
+ 
+ static const char *output_75 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_75 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   CC_STATUS_INIT;  /* XOR sets CC but not how we want it */
+   if (GET_CODE (operands[2]) == CONST_INT)
+     {
+       /* %K2 == sign extend operand to 32 bits so that CH works - huh??? */
+       mvs_check_page (0, 4, 4);
+       return "X	%0,%K2";
+     }
+   mvs_check_page (0, 2, 0);
+   return "XR	%0,%2";
+ }
+ }
+ 
+ static const char *output_76 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_76 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   CC_STATUS_INIT;  /* XOR sets CC but not how we want it */
+   if (REG_P (operands[2]))
+     {
+       mvs_check_page (0, 2, 0);
+       return "XR	%0,%2";
+     }
+   if (REG_P (operands[0]))
+     {
+       mvs_check_page (0, 4, 0);
+       return "X	%0,%2";
+     }
+   if (GET_CODE (operands[2]) == CONST_INT)
+     {
+       mvs_check_page (0, 4, 0);
+       return "XI	%0,%B2";
+     }
+   mvs_check_page (0, 6, 0);
+   return "XC	%O0(1,%R0),%2";
+ }
+ }
+ 
+ static const char *output_77 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_77 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   CC_STATUS_INIT;  /* XOR sets CC but not how we want it */
+   if (GET_CODE (operands[2]) == CONST_INT)
+     {
+       mvs_check_page (0, 4, 0);
+       return "X	%0,=XL4'%X2'";
+     }
+   mvs_check_page (0, 2, 0);
+   return "XR	%0,%2";
+ }
+ }
+ 
+ static const char *output_78 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_78 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   mvs_check_page (0, 2, 0);
+   return "LCR	%0,%1";
+ }
+ }
+ 
+ static const char *output_79 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_79 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   mvs_check_page (0, 10, 0);
+   return "SLL	%1,16\n\tSRA	%1,16\n\tLCR	%0,%1";
+ }
+ }
+ 
+ static const char *output_80 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_80 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   mvs_check_page (0, 2, 0);
+   return "LCDR	%0,%1";
+ }
+ }
+ 
+ static const char *output_81 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_81 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   mvs_check_page (0, 2, 0);
+   return "LCER	%0,%1";
+ }
+ }
+ 
+ static const char *output_82 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_82 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   mvs_check_page (0, 2, 0);
+   return "LPR	%0,%1";
+ }
+ }
+ 
+ static const char *output_83 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_83 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   mvs_check_page (0, 10, 0);
+   return "SLL	%1,16\n\tSRA	%1,16\n\tLPR	%0,%1";
+ }
+ }
+ 
+ static const char *output_84 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_84 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   mvs_check_page (0, 2, 0);
+   return "LPDR	%0,%1";
+ }
+ }
+ 
+ static const char *output_85 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_85 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   mvs_check_page (0, 2, 0);
+   return "LPER	%0,%1";
+ }
+ }
+ 
+ static const char *output_86 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_86 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   CC_STATUS_INIT;  /* XOR sets CC but not how we want it */
+   if (REG_P (operands[0]))
+     {
+       mvs_check_page (0, 4, 4);
+       return "X	%0,=F'-1'";
+     }
+   CC_STATUS_INIT;
+   mvs_check_page (0, 6, 4);
+   return "XC	%O0(4,%R0),=F'-1'";
+ }
+ }
+ 
+ static const char *output_87 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_87 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   CC_STATUS_INIT;  /* XOR sets CC but not how we want it */
+   mvs_check_page (0, 4, 4);
+   return "X	%0,=F'-1'";
+ }
+ }
+ 
+ static const char *output_88 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_88 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   CC_STATUS_INIT;  /* XOR sets CC but not how we want it */
+   if (REG_P (operands[0]))
+     {
+       mvs_check_page (0, 4, 4);
+       return "X	%0,=F'-1'";
+     }
+   mvs_check_page (0, 6, 2);
+   return "XC	%O0(2,%R0),=XL2'FFFF'";
+ }
+ }
+ 
+ static const char *output_89 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_89 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   CC_STATUS_INIT;  /* XOR sets CC but not how we want it */
+   mvs_check_page (0, 4, 4);
+   return "X	%0,=F'-1'";
+ }
+ }
+ 
+ static const char *output_90 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_90 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   CC_STATUS_INIT;  /* XOR sets CC but not how we want it */
+   if (REG_P (operands[0]))
+     {
+       mvs_check_page (0, 4, 4);
+       return "X	%0,=F'-1'";
+     }
+   mvs_check_page (0, 4, 0);
+   return "XI	%0,255";
+ }
+ }
+ 
+ static const char *output_91 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_91 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   CC_STATUS_INIT;  /* XOR sets CC but not how we want it */
+   mvs_check_page (0, 4, 4);
+   return "X	%0,=F'-1'";
+ }
+ }
+ 
+ static const char *output_92 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_92 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   /* this status set seems not have the desired effect,
+    * proably because the 64-bit long-long test is emulated ?! */
+   CC_STATUS_SET (operands[0], operands[1]);
+   mvs_check_page (0, 4, 0);
+   if (REG_P (operands[2]))
+     return "SLDA	%0,0(%2)";
+   return "SLDA	%0,%c2";
+ }
+ }
+ 
+ static const char *output_93 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_93 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   /* this status set seems not have the desired effect,
+    * proably because the 64-bit long-long test is emulated ?! */
+   CC_STATUS_SET (operands[0], operands[1]);
+   mvs_check_page (0, 4, 0);
+   if (REG_P (operands[2])) 
+     return "SRDA	%0,0(%2)";
+   return "SRDA	%0,%c2";
+ }
+ }
+ 
+ static const char *output_94 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_94 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   mvs_check_page (0, 4, 0);
+   if (REG_P (operands[2])) 
+     return "SLL	%0,0(%2)";
+   return "SLL	%0,%c2";
+ }
+ }
+ 
+ static const char *output_95 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_95 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   CC_STATUS_SET (operands[0], operands[1]);
+   mvs_check_page (0, 4, 0);
+   if (REG_P (operands[2])) 
+     return "SRA	%0,0(%2)";
+   return "SRA	%0,%c2";
+ }
+ }
+ 
+ static const char *output_96 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_96 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   mvs_check_page (0, 8, 0);
+   if (REG_P (operands[2])) 
+     return "SLL	%0,16(%2)\n\tSRA	%0,16";
+   return "SLL	%0,16+%c2\n\tSRA	%0,16";
+ }
+ }
+ 
+ static const char *output_97 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_97 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   mvs_check_page (0, 8, 0);
+   if (REG_P (operands[2])) 
+     return "SLL	%0,16\n\tSRA	%0,16(%2)";
+   return "SLL	%0,16\n\tSRA	%0,16+%c2";
+ }
+ }
+ 
+ static const char *output_98 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_98 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   mvs_check_page (0, 4, 0);
+   if (REG_P (operands[2])) 
+     return "SLL	%0,0(%2)";
+   return "SLL	%0,%c2";
+ }
+ }
+ 
+ static const char *output_99 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_99 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   mvs_check_page (0, 8, 0);
+   if (REG_P (operands[2])) 
+     return "SLL	%0,24\n\tSRA	%0,24(%2)";
+   return "SLL	%0,24\n\tSRA	%0,24+%c2";
+ }
+ }
+ 
+ static const char *output_100 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_100 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   mvs_check_page (0, 4, 0);
+   if (REG_P (operands[2])) 
+     return "SRDL	%0,0(%2)";
+   return "SRDL	%0,%c2";
+ }
+ }
+ 
+ static const char *output_101 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_101 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   mvs_check_page (0, 4, 0);
+   if (REG_P (operands[2])) 
+     return "SRL	%0,0(%2)";
+   return "SRL	%0,%c2";
+ }
+ }
+ 
+ static const char *output_102 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_102 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   CC_STATUS_INIT; /* AND sets the CC but not how we want it */
+   if (REG_P (operands[2]))
+     {
+       mvs_check_page (0, 8, 4);
+       return "N	%0,=XL4'0000FFFF'\n\tSRL	%0,0(%2)";
+     }
+   mvs_check_page (0, 8, 4);
+   return "N	%0,=XL4'0000FFFF'\n\tSRL	%0,%c2";
+ }
+ }
+ 
+ static const char *output_103 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_103 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   CC_STATUS_INIT; /* AND sets the CC but not how we want it */
+   mvs_check_page (0, 8, 4);
+   if (REG_P (operands[2])) 
+     return "N	%0,=XL4'000000FF'\n\tSRL	%0,0(%2)";
+   return "N	%0,=XL4'000000FF'\n\tSRL	%0,%c2";
+ }
+ }
+ 
+ static const char *output_104 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_104 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   mvs_check_page (0, 4, 0);
+   if (i370_short_branch(insn) || mvs_check_label (CODE_LABEL_NUMBER (operands[0])))
+     { 
+       return "BE	%l0";
+     }
+   mvs_check_page (0, 2, 4);
+   return "L	14,=A(%l0)\n\tBER	14";
+ }
+ }
+ 
+ static const char *output_105 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_105 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   mvs_check_page (0, 4, 0);
+   if (i370_short_branch(insn) || mvs_check_label (CODE_LABEL_NUMBER (operands[0])))
+     { 
+       return "BNE	%l0";
+     }
+   mvs_check_page (0, 2, 4);
+   return "L	14,=A(%l0)\n\tBNER	14";
+ }
+ }
+ 
+ static const char *output_106 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_106 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   mvs_check_page (0, 4, 0);
+   if (i370_short_branch(insn) || mvs_check_label (CODE_LABEL_NUMBER (operands[0])))
+     { 
+       return "BH	%l0";
+     }
+   mvs_check_page (0, 2, 4);
+   return "L	14,=A(%l0)\n\tBHR	14";
+ }
+ }
+ 
+ static const char *output_107 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_107 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   mvs_check_page (0, 4, 0);
+   if (i370_short_branch(insn) || mvs_check_label (CODE_LABEL_NUMBER (operands[0])))
+     { 
+       return "BH	%l0";
+     }
+   mvs_check_page (0, 2, 4);
+   return "L	14,=A(%l0)\n\tBHR	14";
+ }
+ }
+ 
+ static const char *output_108 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_108 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   mvs_check_page (0, 4, 0);
+   if (i370_short_branch(insn) || mvs_check_label (CODE_LABEL_NUMBER (operands[0])))
+     { 
+       return "BL	%l0";
+     }
+   mvs_check_page (0, 2, 4);
+   return "L	14,=A(%l0)\n\tBLR	14";
+ }
+ }
+ 
+ static const char *output_109 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_109 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   mvs_check_page (0, 4, 0);
+   if (i370_short_branch(insn) || mvs_check_label (CODE_LABEL_NUMBER (operands[0])))
+     { 
+       return "BL	%l0";
+     }
+   mvs_check_page (0, 2, 4);
+   return "L	14,=A(%l0)\n\tBLR	14";
+ }
+ }
+ 
+ static const char *output_110 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_110 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   mvs_check_page (0, 4, 0);
+   if (i370_short_branch(insn) || mvs_check_label (CODE_LABEL_NUMBER (operands[0])))
+     { 
+       return "BNL	%l0";
+     }
+   mvs_check_page (0, 2, 4);
+   return "L	14,=A(%l0)\n\tBNLR	14";
+ }
+ }
+ 
+ static const char *output_111 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_111 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   mvs_check_page (0, 4, 0);
+   if (i370_short_branch(insn) || mvs_check_label (CODE_LABEL_NUMBER (operands[0])))
+     { 
+       return "BNL	%l0";
+     }
+   mvs_check_page (0, 2, 4);
+   return "L	14,=A(%l0)\n\tBNLR	14";
+ }
+ }
+ 
+ static const char *output_112 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_112 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   mvs_check_page (0, 4, 0);
+   if (i370_short_branch(insn) || mvs_check_label (CODE_LABEL_NUMBER (operands[0])))
+     { 
+       return "BNH	%l0";
+     }
+   mvs_check_page (0, 2, 4);
+   return "L	14,=A(%l0)\n\tBNHR	14";
+ }
+ }
+ 
+ static const char *output_113 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_113 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   mvs_check_page (0, 4, 0);
+   if (i370_short_branch(insn) || mvs_check_label (CODE_LABEL_NUMBER (operands[0])))
+     { 
+       return "BNH	%l0";
+     }
+   mvs_check_page (0, 2, 4);
+   return "L	14,=A(%l0)\n\tBNHR	14";
+ }
+ }
+ 
+ static const char *output_114 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_114 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   mvs_check_page (0, 4, 0);
+   if (i370_short_branch(insn) || mvs_check_label (CODE_LABEL_NUMBER (operands[0])))
+     { 
+       return "BNE	%l0";
+     }
+   mvs_check_page (0, 2, 4);
+   return "L	14,=A(%l0)\n\tBNER	14";
+ }
+ }
+ 
+ static const char *output_115 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_115 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   mvs_check_page (0, 4, 0);
+   if (i370_short_branch(insn) || mvs_check_label (CODE_LABEL_NUMBER (operands[0])))
+     { 
+       return "BE	%l0";
+     }
+   mvs_check_page (0, 2, 4);
+   return "L	14,=A(%l0)\n\tBER	14";
+ }
+ }
+ 
+ static const char *output_116 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_116 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   mvs_check_page (0, 4, 0);
+   if (i370_short_branch(insn) || mvs_check_label (CODE_LABEL_NUMBER (operands[0])))
+     { 
+       return "BNH	%l0";
+     }
+   mvs_check_page (0, 2, 4);
+   return "L	14,=A(%l0)\n\tBNHR	14";
+ }
+ }
+ 
+ static const char *output_117 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_117 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   mvs_check_page (0, 4, 0);
+   if (i370_short_branch(insn) || mvs_check_label (CODE_LABEL_NUMBER (operands[0])))
+     { 
+       return "BNH	%l0";
+     }
+   mvs_check_page (0, 2, 4);
+   return "L	14,=A(%l0)\n\tBNHR	14";
+ }
+ }
+ 
+ static const char *output_118 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_118 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   mvs_check_page (0, 4, 0);
+   if (i370_short_branch(insn) || mvs_check_label (CODE_LABEL_NUMBER (operands[0])))
+     { 
+       return "BNL	%l0";
+     }
+   mvs_check_page (0, 2, 4);
+   return "L	14,=A(%l0)\n\tBNLR	14";
+ }
+ }
+ 
+ static const char *output_119 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_119 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   mvs_check_page (0, 4, 0);
+   if (i370_short_branch(insn) || mvs_check_label (CODE_LABEL_NUMBER (operands[0])))
+     { 
+       return "BNL	%l0";
+     }
+   mvs_check_page (0, 2, 4);
+   return "L	14,=A(%l0)\n\tBNLR	14";
+ }
+ }
+ 
+ static const char *output_120 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_120 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   mvs_check_page (0, 4, 0);
+   if (i370_short_branch(insn) || mvs_check_label (CODE_LABEL_NUMBER (operands[0])))
+     { 
+       return "BL	%l0";
+     }
+   mvs_check_page (0, 2, 4);
+   return "L	14,=A(%l0)\n\tBLR	14";
+ }
+ }
+ 
+ static const char *output_121 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_121 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   mvs_check_page (0, 4, 0);
+   if (i370_short_branch(insn) || mvs_check_label (CODE_LABEL_NUMBER (operands[0])))
+     { 
+       return "BL	%l0";
+     }
+   mvs_check_page (0, 2, 4);
+   return "L	14,=A(%l0)\n\tBLR	14";
+ }
+ }
+ 
+ static const char *output_122 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_122 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   mvs_check_page (0, 4, 0);
+   if (i370_short_branch(insn) || mvs_check_label (CODE_LABEL_NUMBER (operands[0])))
+     { 
+       return "BH	%l0";
+     }
+   mvs_check_page (0, 2, 4);
+   return "L	14,=A(%l0)\n\tBHR	14";
+ }
+ }
+ 
+ static const char *output_123 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_123 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   mvs_check_page (0, 4, 0);
+   if (i370_short_branch(insn) || mvs_check_label (CODE_LABEL_NUMBER (operands[0])))
+     { 
+       return "BH	%l0";
+     }
+   mvs_check_page (0, 2, 4);
+   return "L	14,=A(%l0)\n\tBHR	14";
+ }
+ }
+ 
+ static const char *output_124 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_124 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   mvs_check_page (0, 4, 0);
+   if (mvs_check_label (CODE_LABEL_NUMBER (operands[1])))
+     {
+       return "BCT	%0,%l1";
+     }
+   mvs_check_page (0, 2, 4);
+   return "L	14,=A(%l1)\n\tBCTR	%0,14";
+ }
+ }
+ 
+ static const char *output_125 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_125 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   mvs_check_page (0, 4, 0);
+   if (mvs_check_label (CODE_LABEL_NUMBER (operands[1])))
+     {
+       return "BCT	%0,%l1";
+     }
+   mvs_check_page (0, 2, 4);
+   return "L	14,=A(%l1)\n\tBCTR	%0,14";
+ }
+ }
+ 
+ static const char *output_126 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_126 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   mvs_check_page (0, 4, 0);
+   if (i370_short_branch(insn) || mvs_check_label (CODE_LABEL_NUMBER (operands[0])))
+     {
+       return "B	%l0";
+     }
+   mvs_check_page (0, 2, 4);
+   return "L	14,=A(%l0)\n\tBR	14";
+ }
+ }
+ 
+ static const char *output_127 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_127 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   if (REG_P (operands[0]))
+     {
+       mvs_check_page (0, 2, 0);
+       return "BR	%0";
+     }
+   mvs_check_page (0, 4, 0);
+   return "B	%0";
+ }
+ }
+ 
+ static const char *output_128 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_128 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   if (REG_P (operands[0]))
+     {
+       mvs_check_page (0, 6, 0);
+       return "BR	%0\n\tDS	0F";
+     }
+   mvs_check_page (0, 10, 0);
+   return "L	14,%0\n\tBR	14\n\tDS	0F";
+ }
+ }
+ 
+ static const char *output_129 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_129 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+ #ifdef TARGET_LINUX
+ #ifdef STACK_GROWS_DOWNWARD
+   static char temp[128];
+   int i = STACK_POINTER_OFFSET;
+ 
+   CC_STATUS_INIT;
+   check_label_emit ();
+   mvs_check_page (0, 10, 4);
+   sprintf ( temp, "LA	r2,%d(,sp)\n\tLA	15,%%0\n\tBASR	14,15", i );
+   return temp;
+ #else /* STACK_GROWS_DOWNWARD */
+   CC_STATUS_INIT;
+   check_label_emit ();
+   mvs_check_page (0, 6, 4);
+   return "LA	15,%0\n\tBASR	14,15";
+ #endif /* STACK_GROWS_DOWNWARD */
+ 
+ #else
+ 
+   static char temp[128];
+   int i = STACK_POINTER_OFFSET;
+ 
+   CC_STATUS_INIT;
+   check_label_emit ();
+   if (mvs_function_check (XSTR (operands[0], 0)))
+     {
+       mvs_check_page (0, 22, 4);
+       sprintf ( temp, "LA	1,136(,13)\n\tST	1,%d(,13)\n\tLA 1,%d(,13)\n\tLA	15,%%0\n\tBALR	14,15\n\tLD	0,136(,13)",
+ 	     i - 4, i - 4 );
+     }
+   else
+     {
+       mvs_check_page (0, 10, 4);
+       sprintf ( temp, "LA	1,%d(,13)\n\tLA	15,%%0\n\tBALR	14,15", i );
+     }
+   return temp;
+ #endif
+ }
+ }
+ 
+ static const char *output_130 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_130 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+ #ifdef TARGET_LINUX
+ #ifdef STACK_GROWS_DOWNWARD
+   static char temp[128];
+   int i = STACK_POINTER_OFFSET;
+   CC_STATUS_INIT;
+   mvs_check_page (0, 10, 4);
+   sprintf ( temp, "LA	r2,%d(,sp)\n\tLA	15,%%1\n\tBASR	14,15", i );
+   return temp;     
+ 
+ #else /* STACK_GROWS_DOWNWARD */
+   CC_STATUS_INIT;
+   check_label_emit ();
+   mvs_check_page (0, 6, 4);
+   return "LA	15,%1\n\tBASR	14,15";
+ #endif /* STACK_GROWS_DOWNWARD */
+ 
+ #else
+ 
+   static char temp[128];
+   int i = STACK_POINTER_OFFSET;
+   CC_STATUS_INIT;
+ 
+   check_label_emit ();
+   if (mvs_function_check (XSTR (operands[1], 0)))
+     {
+       mvs_check_page (0, 22, 4);
+       sprintf ( temp, "LA	1,136(,13)\n\tST	1,%d(,13)\n\tLA 1,%d(,13)\n\tLA	15,%%1\n\tBALR	14,15\n\tLD	0,136(,13)",
+ 	   i - 4, i - 4 );
+     }
+   else
+     {
+       mvs_check_page (0, 10, 4);
+       sprintf ( temp, "LA	1,%d(,13)\n\tLA	15,%%1\n\tBALR	14,15", i );
+     }
+   return temp;
+ 
+ #endif
+ }
+ }
+ 
+ static const char *output_131 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_131 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+ #ifdef TARGET_LINUX
+ #ifdef STACK_GROWS_DOWNWARD
+   static char temp[128];
+   int i = STACK_POINTER_OFFSET;
+   CC_STATUS_INIT;
+   mvs_check_page (0, 10, 4);
+   sprintf ( temp, "LA	r2,%d(,sp)\n\tL	15,%%0\n\tBASR	14,15", i );
+   return temp;
+ 
+ #else /* STACK_GROWS_DOWNWARD */
+   CC_STATUS_INIT;
+   check_label_emit ();
+   mvs_check_page (0, 6, 4);
+   return "L	15,%0\n\tBASR	14,15";
+ #endif /* STACK_GROWS_DOWNWARD */
+ 
+ #else
+ 
+   static char temp[128];
+   int i = STACK_POINTER_OFFSET;
+   CC_STATUS_INIT;
+ 
+   check_label_emit ();
+   if (mvs_function_check (XSTR (operands[0], 0)))
+     {
+       mvs_check_page (0, 22, 4);
+       sprintf ( temp, "LA	1,136(,13)\n\tST	1,%d(,13)\n\tLA	1,%d(,13)\n\tL	15,%%0\n\tBALR	14,15\n\tLD	0,136(,13)",
+ 	   i - 4, i - 4 );
+     }
+   else
+     {
+       mvs_check_page (0, 10, 4);
+       sprintf ( temp, "LA	1,%d(,13)\n\tL	15,%%0\n\tBALR	14,15", i );
+     }
+   return temp;
+ #endif
+ }
+ }
+ 
+ static const char *output_132 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_132 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+ #ifdef TARGET_LINUX
+ #ifdef STACK_GROWS_DOWNWARD
+   static char temp[128];
+   int i = STACK_POINTER_OFFSET;
+   CC_STATUS_INIT;
+ 
+   check_label_emit ();
+   mvs_check_page (0, 10, 4);
+   sprintf ( temp, "LA	r2,%d(,sp)\n\tL	15,%%1\n\tBASR	14,15", i );
+   return temp;
+ 
+ #else /* STACK_GROWS_DOWNWARD */
+   CC_STATUS_INIT;
+   check_label_emit ();
+   mvs_check_page (0, 6, 4);
+   return "L	15,%1\n\tBASR	14,15";
+ #endif /* STACK_GROWS_DOWNWARD */
+ 
+ #else
+ 
+   static char temp[128];
+   int i = STACK_POINTER_OFFSET;
+   CC_STATUS_INIT;
+ 
+   check_label_emit ();
+   if (mvs_function_check (XSTR (operands[1], 0)))
+     {
+       mvs_check_page (0, 22, 4);
+       sprintf ( temp, "LA	1,136(,13)\n\tST	1,%d(,13)\n\tLA	1,%d(,13)\n\tL	15,%%1\n\tBALR	14,15\n\tLD	0,136(,13)",
+ 	   i - 4, i - 4 );
+     }
+   else
+     {
+       mvs_check_page (0, 10, 4);
+       sprintf ( temp, "LA	1,%d(,13)\n\tL	15,%%1\n\tBALR	14,15", i );
+     }
+   return temp;
+ #endif
+ }
+ }
+ 
+ static const char *output_133 PARAMS ((rtx *, rtx));
+ 
+ static const char *
+ output_133 (operands, insn)
+      rtx *operands ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+ 
+ {
+   check_label_emit ();
+   mvs_check_page (0, 2, 0);
+   return "NOPR	0";
+ }
+ }
+ 
+ 
+ extern int register_operand PARAMS ((rtx, enum machine_mode));
+ extern int general_operand PARAMS ((rtx, enum machine_mode));
+ extern int r_or_s_operand PARAMS ((rtx, enum machine_mode));
+ extern int s_operand PARAMS ((rtx, enum machine_mode));
+ extern int immediate_operand PARAMS ((rtx, enum machine_mode));
+ extern int nonimmediate_operand PARAMS ((rtx, enum machine_mode));
+ extern int const_int_operand PARAMS ((rtx, enum machine_mode));
+ extern int memory_operand PARAMS ((rtx, enum machine_mode));
+ 
+ 
+ 
+ static const struct insn_operand_data operand_data[] = 
+ {
+   {
+     0,
+     "",
+     VOIDmode,
+     0,
+     0
+   },
+   {
+     register_operand,
+     "d",
+     DImode,
+     0,
+     1
+   },
+   {
+     register_operand,
+     "d",
+     SImode,
+     0,
+     1
+   },
+   {
+     register_operand,
+     "d",
+     HImode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "f",
+     DFmode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "f",
+     SFmode,
+     0,
+     1
+   },
+   {
+     register_operand,
+     "d",
+     SImode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "md",
+     SImode,
+     0,
+     1
+   },
+   {
+     register_operand,
+     "d",
+     HImode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "???diS",
+     HImode,
+     0,
+     1
+   },
+   {
+     r_or_s_operand,
+     "dS",
+     QImode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "diS",
+     QImode,
+     0,
+     1
+   },
+   {
+     register_operand,
+     "d",
+     QImode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "di",
+     QImode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "f,mF",
+     DFmode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "fmF,f",
+     DFmode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "f,mF",
+     SFmode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "fmF,f",
+     SFmode,
+     0,
+     1
+   },
+   {
+     register_operand,
+     "=d",
+     SImode,
+     0,
+     1
+   },
+   {
+     s_operand,
+     "S",
+     BLKmode,
+     0,
+     1
+   },
+   {
+     s_operand,
+     "S",
+     BLKmode,
+     0,
+     1
+   },
+   {
+     immediate_operand,
+     "i",
+     SImode,
+     0,
+     1
+   },
+   {
+     register_operand,
+     "+d",
+     SImode,
+     0,
+     1
+   },
+   {
+     register_operand,
+     "+d",
+     DImode,
+     0,
+     1
+   },
+   {
+     register_operand,
+     "+d",
+     DImode,
+     0,
+     1
+   },
+   {
+     nonimmediate_operand,
+     "=d,m,S",
+     DImode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "g,d,SF",
+     DImode,
+     0,
+     1
+   },
+   {
+     nonimmediate_operand,
+     "=d,dm",
+     DImode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "dimF,*fd",
+     DImode,
+     0,
+     1
+   },
+   {
+     nonimmediate_operand,
+     "=d,dm,R",
+     SImode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "dimF,*fd,R",
+     SImode,
+     0,
+     1
+   },
+   {
+     r_or_s_operand,
+     "=R,d",
+     HImode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "R,g",
+     HImode,
+     0,
+     1
+   },
+   {
+     nonimmediate_operand,
+     "=d,m",
+     HImode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "g,d",
+     HImode,
+     0,
+     1
+   },
+   {
+     r_or_s_operand,
+     "=R,d",
+     QImode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "R,g",
+     QImode,
+     0,
+     1
+   },
+   {
+     nonimmediate_operand,
+     "=d,m",
+     QImode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "g,d",
+     QImode,
+     0,
+     1
+   },
+   {
+     nonimmediate_operand,
+     "+dm",
+     HImode,
+     1,
+     1
+   },
+   {
+     general_operand,
+     "d",
+     HImode,
+     0,
+     1
+   },
+   {
+     nonimmediate_operand,
+     "=f,m,fS,*dS,???d",
+     DFmode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "fmF,f,*dS,fSF,???d",
+     DFmode,
+     0,
+     1
+   },
+   {
+     nonimmediate_operand,
+     "=f,m,fS,*d,???d",
+     DFmode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "fmF,f,*d,SfF,???d",
+     DFmode,
+     0,
+     1
+   },
+   {
+     nonimmediate_operand,
+     "=f*d,fm,S,???d",
+     SFmode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "fmF,fF*d,S,???d",
+     SFmode,
+     0,
+     1
+   },
+   {
+     nonimmediate_operand,
+     "=f,fm,m,*d",
+     SFmode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "fmF,*d,f,fmF",
+     SFmode,
+     0,
+     1
+   },
+   {
+     s_operand,
+     "=S",
+     BLKmode,
+     0,
+     1
+   },
+   {
+     s_operand,
+     "S",
+     BLKmode,
+     0,
+     1
+   },
+   {
+     immediate_operand,
+     "i",
+     VOIDmode,
+     0,
+     1
+   },
+   {
+     nonimmediate_operand,
+     "=d,m",
+     SImode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "g,d",
+     HImode,
+     0,
+     1
+   },
+   {
+     register_operand,
+     "=d",
+     SImode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "0mi",
+     QImode,
+     0,
+     1
+   },
+   {
+     register_operand,
+     "=d",
+     HImode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "0m",
+     QImode,
+     0,
+     1
+   },
+   {
+     register_operand,
+     "=d",
+     SImode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "0",
+     HImode,
+     0,
+     1
+   },
+   {
+     register_operand,
+     "=d,&d",
+     SImode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "0i,m",
+     QImode,
+     0,
+     1
+   },
+   {
+     register_operand,
+     "=d,&d",
+     HImode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "0i,m",
+     QImode,
+     0,
+     1
+   },
+   {
+     nonimmediate_operand,
+     "=d,m",
+     HImode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "0,d",
+     SImode,
+     0,
+     1
+   },
+   {
+     register_operand,
+     "=d",
+     SImode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "f",
+     DFmode,
+     0,
+     1
+   },
+   {
+     register_operand,
+     "=f",
+     DFmode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "d",
+     SImode,
+     0,
+     1
+   },
+   {
+     register_operand,
+     "=f",
+     SFmode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "f",
+     DFmode,
+     0,
+     1
+   },
+   {
+     register_operand,
+     "=f",
+     DFmode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "fmF",
+     SFmode,
+     0,
+     1
+   },
+   {
+     register_operand,
+     "=d",
+     SImode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "%0",
+     SImode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "g",
+     SImode,
+     0,
+     1
+   },
+   {
+     0,
+     "",
+     VOIDmode,
+     0,
+     1
+   },
+   {
+     register_operand,
+     "=d",
+     SImode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "%a",
+     SImode,
+     0,
+     1
+   },
+   {
+     immediate_operand,
+     "J",
+     SImode,
+     0,
+     1
+   },
+   {
+     register_operand,
+     "=d",
+     SImode,
+     0,
+     1
+   },
+   {
+     register_operand,
+     "%a",
+     SImode,
+     0,
+     1
+   },
+   {
+     immediate_operand,
+     "i",
+     SImode,
+     0,
+     1
+   },
+   {
+     register_operand,
+     "=d",
+     HImode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "%0",
+     HImode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "dmi",
+     HImode,
+     0,
+     1
+   },
+   {
+     register_operand,
+     "=d",
+     QImode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "%a",
+     QImode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "ai",
+     QImode,
+     0,
+     1
+   },
+   {
+     register_operand,
+     "=f",
+     DFmode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "%0",
+     DFmode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "fmF",
+     DFmode,
+     0,
+     1
+   },
+   {
+     register_operand,
+     "=f",
+     SFmode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "%0",
+     SFmode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "fmF",
+     SFmode,
+     0,
+     1
+   },
+   {
+     register_operand,
+     "=d",
+     SImode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "0",
+     SImode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "g",
+     SImode,
+     0,
+     1
+   },
+   {
+     0,
+     "",
+     VOIDmode,
+     0,
+     1
+   },
+   {
+     register_operand,
+     "=d",
+     HImode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "0",
+     HImode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "g",
+     HImode,
+     0,
+     1
+   },
+   {
+     register_operand,
+     "=d",
+     QImode,
+     0,
+     1
+   },
+   {
+     register_operand,
+     "0",
+     QImode,
+     0,
+     1
+   },
+   {
+     register_operand,
+     "d",
+     QImode,
+     0,
+     1
+   },
+   {
+     register_operand,
+     "=f",
+     DFmode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "0",
+     DFmode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "fmF",
+     DFmode,
+     0,
+     1
+   },
+   {
+     register_operand,
+     "=f",
+     SFmode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "0",
+     SFmode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "fmF",
+     SFmode,
+     0,
+     1
+   },
+   {
+     register_operand,
+     "=d",
+     SImode,
+     0,
+     1
+   },
+   {
+     register_operand,
+     "0",
+     SImode,
+     0,
+     1
+   },
+   {
+     const_int_operand,
+     "K",
+     SImode,
+     0,
+     1
+   },
+   {
+     register_operand,
+     "=d",
+     DImode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "0",
+     DImode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "g",
+     SImode,
+     0,
+     1
+   },
+   {
+     register_operand,
+     "=d",
+     DImode,
+     0,
+     1
+   },
+   {
+     register_operand,
+     "0",
+     DImode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "dm",
+     SImode,
+     0,
+     1
+   },
+   {
+     r_or_s_operand,
+     "=d,R",
+     SImode,
+     0,
+     1
+   },
+   {
+     r_or_s_operand,
+     "%0,0",
+     SImode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "g,Si",
+     SImode,
+     0,
+     1
+   },
+   {
+     r_or_s_operand,
+     "=d,S",
+     HImode,
+     0,
+     1
+   },
+   {
+     r_or_s_operand,
+     "%0,0",
+     HImode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "di,Si",
+     HImode,
+     0,
+     1
+   },
+   {
+     register_operand,
+     "=d",
+     HImode,
+     0,
+     1
+   },
+   {
+     register_operand,
+     "%0",
+     HImode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "di",
+     HImode,
+     0,
+     1
+   },
+   {
+     r_or_s_operand,
+     "=d,S",
+     QImode,
+     0,
+     1
+   },
+   {
+     r_or_s_operand,
+     "%0,0",
+     QImode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "di,Si",
+     QImode,
+     0,
+     1
+   },
+   {
+     register_operand,
+     "=d",
+     QImode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "%0",
+     QImode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "di",
+     QImode,
+     0,
+     1
+   },
+   {
+     register_operand,
+     "=d",
+     SImode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "d",
+     SImode,
+     0,
+     1
+   },
+   {
+     register_operand,
+     "=d",
+     HImode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "d",
+     HImode,
+     0,
+     1
+   },
+   {
+     register_operand,
+     "=f",
+     DFmode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "f",
+     DFmode,
+     0,
+     1
+   },
+   {
+     register_operand,
+     "=f",
+     SFmode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "f",
+     SFmode,
+     0,
+     1
+   },
+   {
+     r_or_s_operand,
+     "=dm",
+     SImode,
+     0,
+     1
+   },
+   {
+     r_or_s_operand,
+     "0",
+     SImode,
+     0,
+     1
+   },
+   {
+     r_or_s_operand,
+     "=dm",
+     HImode,
+     0,
+     1
+   },
+   {
+     r_or_s_operand,
+     "0",
+     HImode,
+     0,
+     1
+   },
+   {
+     r_or_s_operand,
+     "=dm",
+     QImode,
+     0,
+     1
+   },
+   {
+     r_or_s_operand,
+     "0",
+     QImode,
+     0,
+     1
+   },
+   {
+     register_operand,
+     "=d",
+     QImode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "0",
+     QImode,
+     0,
+     1
+   },
+   {
+     register_operand,
+     "=d",
+     DImode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "0",
+     DImode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "Ja",
+     SImode,
+     0,
+     1
+   },
+   {
+     register_operand,
+     "=d",
+     SImode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "0",
+     SImode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "Ja",
+     SImode,
+     0,
+     1
+   },
+   {
+     register_operand,
+     "=d",
+     HImode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "0",
+     HImode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "Ja",
+     SImode,
+     0,
+     1
+   },
+   {
+     register_operand,
+     "=d",
+     QImode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "0",
+     QImode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "Ja",
+     SImode,
+     0,
+     1
+   },
+   {
+     register_operand,
+     "+d",
+     SImode,
+     0,
+     1
+   },
+   {
+     0,
+     "",
+     VOIDmode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "rm",
+     SImode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "am",
+     SImode,
+     0,
+     1
+   },
+   {
+     0,
+     "",
+     VOIDmode,
+     0,
+     1
+   },
+   {
+     memory_operand,
+     "m",
+     QImode,
+     0,
+     1
+   },
+   {
+     immediate_operand,
+     "i",
+     SImode,
+     0,
+     1
+   },
+   {
+     0,
+     "=rf",
+     VOIDmode,
+     0,
+     1
+   },
+   {
+     memory_operand,
+     "m",
+     QImode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "i",
+     SImode,
+     0,
+     1
+   },
+   {
+     0,
+     "i",
+     SImode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "g",
+     SImode,
+     0,
+     1
+   },
+   {
+     0,
+     "=rf",
+     VOIDmode,
+     0,
+     1
+   },
+   {
+     0,
+     "i",
+     SImode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "g",
+     SImode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "",
+     SImode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "",
+     BLKmode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "",
+     BLKmode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "",
+     SImode,
+     0,
+     1
+   },
+   {
+     0,
+     "",
+     SImode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "g",
+     BLKmode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "",
+     SImode,
+     0,
+     1
+   },
+   {
+     0,
+     "",
+     VOIDmode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "",
+     BLKmode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "",
+     BLKmode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "",
+     SImode,
+     0,
+     1
+   },
+   {
+     0,
+     "",
+     VOIDmode,
+     0,
+     1
+   },
+   {
+     register_operand,
+     "=d",
+     DImode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "",
+     SImode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "",
+     DImode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "",
+     DImode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "",
+     DImode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "",
+     SImode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "",
+     SImode,
+     0,
+     1
+   },
+   {
+     general_operand,
+     "",
+     SImode,
+     0,
+     1
+   },
+   {
+     0,
+     "",
+     VOIDmode,
+     0,
+     1
+   },
+   {
+     0,
+     "",
+     VOIDmode,
+     0,
+     1
+   },
+   {
+     0,
+     "",
+     VOIDmode,
+     0,
+     1
+   },
+ };
+ 
+ 
+ 
+ const struct insn_data insn_data[] = 
+ {
+   {
+     "tstdi",
+     __extension__ (const PTR) output_0,
+     (insn_gen_fn) gen_tstdi,
+     &operand_data[1],
+     1,
+     0,
+     1,
+     3
+   },
+   {
+     "tstsi",
+     __extension__ (const PTR) output_1,
+     (insn_gen_fn) gen_tstsi,
+     &operand_data[2],
+     1,
+     0,
+     1,
+     3
+   },
+   {
+     "tsthi",
+     __extension__ (const PTR) output_2,
+     (insn_gen_fn) gen_tsthi,
+     &operand_data[3],
+     1,
+     0,
+     1,
+     3
+   },
+   {
+     "tstdf",
+     __extension__ (const PTR) output_3,
+     (insn_gen_fn) gen_tstdf,
+     &operand_data[4],
+     1,
+     0,
+     1,
+     3
+   },
+   {
+     "tstsf",
+     __extension__ (const PTR) output_4,
+     (insn_gen_fn) gen_tstsf,
+     &operand_data[5],
+     1,
+     0,
+     1,
+     3
+   },
+   {
+     "cmpsi",
+     __extension__ (const PTR) output_5,
+     (insn_gen_fn) gen_cmpsi,
+     &operand_data[6],
+     2,
+     0,
+     1,
+     3
+   },
+   {
+     "cmphi",
+     __extension__ (const PTR) output_6,
+     (insn_gen_fn) gen_cmphi,
+     &operand_data[8],
+     2,
+     0,
+     1,
+     3
+   },
+   {
+     "*i370.md:522",
+     __extension__ (const PTR) output_7,
+     0,
+     &operand_data[10],
+     2,
+     0,
+     1,
+     3
+   },
+   {
+     "cmpqi",
+     __extension__ (const PTR) output_8,
+     (insn_gen_fn) gen_cmpqi,
+     &operand_data[12],
+     2,
+     0,
+     1,
+     3
+   },
+   {
+     "cmpdf",
+     __extension__ (const PTR) output_9,
+     (insn_gen_fn) gen_cmpdf,
+     &operand_data[14],
+     2,
+     0,
+     2,
+     3
+   },
+   {
+     "cmpsf",
+     __extension__ (const PTR) output_10,
+     (insn_gen_fn) gen_cmpsf,
+     &operand_data[16],
+     2,
+     0,
+     2,
+     3
+   },
+   {
+     "*i370.md:746",
+     __extension__ (const PTR) output_11,
+     0,
+     &operand_data[18],
+     4,
+     0,
+     1,
+     3
+   },
+   {
+     "cmpstrsi_1",
+     __extension__ (const PTR) output_12,
+     (insn_gen_fn) gen_cmpstrsi_1,
+     &operand_data[22],
+     3,
+     4,
+     1,
+     3
+   },
+   {
+     "*i370.md:792",
+     __extension__ (const PTR) output_13,
+     0,
+     &operand_data[25],
+     2,
+     0,
+     3,
+     3
+   },
+   {
+     "movdi",
+     __extension__ (const PTR) output_14,
+     (insn_gen_fn) gen_movdi,
+     &operand_data[27],
+     2,
+     0,
+     2,
+     3
+   },
+   {
+     "movsi",
+     __extension__ (const PTR) output_15,
+     (insn_gen_fn) gen_movsi,
+     &operand_data[29],
+     2,
+     0,
+     3,
+     3
+   },
+   {
+     "*i370.md:1010",
+     __extension__ (const PTR) output_16,
+     0,
+     &operand_data[31],
+     2,
+     0,
+     2,
+     3
+   },
+   {
+     "movhi",
+     __extension__ (const PTR) output_17,
+     (insn_gen_fn) gen_movhi,
+     &operand_data[33],
+     2,
+     0,
+     2,
+     3
+   },
+   {
+     "*i370.md:1104",
+     __extension__ (const PTR) output_18,
+     0,
+     &operand_data[35],
+     2,
+     0,
+     2,
+     3
+   },
+   {
+     "movqi",
+     __extension__ (const PTR) output_19,
+     (insn_gen_fn) gen_movqi,
+     &operand_data[37],
+     2,
+     0,
+     2,
+     3
+   },
+   {
+     "movstricthi",
+     __extension__ (const PTR) output_20,
+     (insn_gen_fn) gen_movstricthi,
+     &operand_data[39],
+     2,
+     0,
+     1,
+     3
+   },
+   {
+     "*i370.md:1285",
+     __extension__ (const PTR) output_21,
+     0,
+     &operand_data[41],
+     2,
+     0,
+     5,
+     3
+   },
+   {
+     "movdf",
+     __extension__ (const PTR) output_22,
+     (insn_gen_fn) gen_movdf,
+     &operand_data[43],
+     2,
+     0,
+     5,
+     3
+   },
+   {
+     "*i370.md:1410",
+     __extension__ (const PTR) output_23,
+     0,
+     &operand_data[45],
+     2,
+     0,
+     4,
+     3
+   },
+   {
+     "movsf",
+     __extension__ (const PTR) output_24,
+     (insn_gen_fn) gen_movsf,
+     &operand_data[47],
+     2,
+     0,
+     4,
+     3
+   },
+   {
+     "*i370.md:1630",
+     __extension__ (const PTR) output_25,
+     0,
+     &operand_data[49],
+     3,
+     0,
+     1,
+     3
+   },
+   {
+     "movstrsi_1",
+     __extension__ (const PTR) output_26,
+     (insn_gen_fn) gen_movstrsi_1,
+     &operand_data[23],
+     2,
+     4,
+     1,
+     3
+   },
+   {
+     "extendhisi2",
+     __extension__ (const PTR) output_27,
+     (insn_gen_fn) gen_extendhisi2,
+     &operand_data[52],
+     2,
+     0,
+     2,
+     3
+   },
+   {
+     "extendqisi2",
+     __extension__ (const PTR) output_28,
+     (insn_gen_fn) gen_extendqisi2,
+     &operand_data[54],
+     2,
+     0,
+     1,
+     3
+   },
+   {
+     "extendqihi2",
+     __extension__ (const PTR) output_29,
+     (insn_gen_fn) gen_extendqihi2,
+     &operand_data[56],
+     2,
+     0,
+     1,
+     3
+   },
+   {
+     "zero_extendhisi2",
+     __extension__ (const PTR) output_30,
+     (insn_gen_fn) gen_zero_extendhisi2,
+     &operand_data[58],
+     2,
+     0,
+     1,
+     3
+   },
+   {
+     "zero_extendqisi2",
+     __extension__ (const PTR) output_31,
+     (insn_gen_fn) gen_zero_extendqisi2,
+     &operand_data[60],
+     2,
+     0,
+     2,
+     3
+   },
+   {
+     "zero_extendqihi2",
+     __extension__ (const PTR) output_32,
+     (insn_gen_fn) gen_zero_extendqihi2,
+     &operand_data[62],
+     2,
+     0,
+     2,
+     3
+   },
+   {
+     "truncsihi2",
+     __extension__ (const PTR) output_33,
+     (insn_gen_fn) gen_truncsihi2,
+     &operand_data[64],
+     2,
+     0,
+     2,
+     3
+   },
+   {
+     "fix_truncdfsi2",
+     __extension__ (const PTR) output_34,
+     (insn_gen_fn) gen_fix_truncdfsi2,
+     &operand_data[66],
+     2,
+     0,
+     1,
+     3
+   },
+   {
+     "floatsidf2",
+     __extension__ (const PTR) output_35,
+     (insn_gen_fn) gen_floatsidf2,
+     &operand_data[68],
+     2,
+     0,
+     1,
+     3
+   },
+   {
+     "truncdfsf2",
+     __extension__ (const PTR) output_36,
+     (insn_gen_fn) gen_truncdfsf2,
+     &operand_data[70],
+     2,
+     0,
+     1,
+     3
+   },
+   {
+     "extendsfdf2",
+     __extension__ (const PTR) output_37,
+     (insn_gen_fn) gen_extendsfdf2,
+     &operand_data[72],
+     2,
+     0,
+     1,
+     3
+   },
+   {
+     "*i370.md:2064",
+     __extension__ (const PTR) output_38,
+     0,
+     &operand_data[74],
+     4,
+     0,
+     1,
+     3
+   },
+   {
+     "*i370.md:2117",
+     __extension__ (const PTR) output_39,
+     0,
+     &operand_data[78],
+     3,
+     0,
+     1,
+     3
+   },
+   {
+     "*i370.md:2134",
+     __extension__ (const PTR) output_40,
+     0,
+     &operand_data[81],
+     3,
+     0,
+     1,
+     3
+   },
+   {
+     "addsi3",
+     __extension__ (const PTR) output_41,
+     (insn_gen_fn) gen_addsi3,
+     &operand_data[74],
+     3,
+     0,
+     1,
+     3
+   },
+   {
+     "addhi3",
+     __extension__ (const PTR) output_42,
+     (insn_gen_fn) gen_addhi3,
+     &operand_data[84],
+     3,
+     0,
+     1,
+     3
+   },
+   {
+     "addqi3",
+     __extension__ (const PTR) output_43,
+     (insn_gen_fn) gen_addqi3,
+     &operand_data[87],
+     3,
+     0,
+     1,
+     3
+   },
+   {
+     "adddf3",
+     __extension__ (const PTR) output_44,
+     (insn_gen_fn) gen_adddf3,
+     &operand_data[90],
+     3,
+     0,
+     1,
+     3
+   },
+   {
+     "addsf3",
+     __extension__ (const PTR) output_45,
+     (insn_gen_fn) gen_addsf3,
+     &operand_data[93],
+     3,
+     0,
+     1,
+     3
+   },
+   {
+     "*i370.md:2333",
+     __extension__ (const PTR) output_46,
+     0,
+     &operand_data[96],
+     4,
+     0,
+     1,
+     3
+   },
+   {
+     "subsi3",
+     __extension__ (const PTR) output_47,
+     (insn_gen_fn) gen_subsi3,
+     &operand_data[96],
+     3,
+     0,
+     1,
+     3
+   },
+   {
+     "subhi3",
+     __extension__ (const PTR) output_48,
+     (insn_gen_fn) gen_subhi3,
+     &operand_data[100],
+     3,
+     0,
+     1,
+     3
+   },
+   {
+     "subqi3",
+     __extension__ (const PTR) output_49,
+     (insn_gen_fn) gen_subqi3,
+     &operand_data[103],
+     3,
+     0,
+     1,
+     3
+   },
+   {
+     "subdf3",
+     __extension__ (const PTR) output_50,
+     (insn_gen_fn) gen_subdf3,
+     &operand_data[106],
+     3,
+     0,
+     1,
+     3
+   },
+   {
+     "subsf3",
+     __extension__ (const PTR) output_51,
+     (insn_gen_fn) gen_subsf3,
+     &operand_data[109],
+     3,
+     0,
+     1,
+     3
+   },
+   {
+     "*i370.md:2595",
+     __extension__ (const PTR) output_52,
+     0,
+     &operand_data[112],
+     3,
+     0,
+     1,
+     3
+   },
+   {
+     "*i370.md:2611",
+     __extension__ (const PTR) output_53,
+     0,
+     &operand_data[115],
+     3,
+     0,
+     1,
+     3
+   },
+   {
+     "muldf3",
+     __extension__ (const PTR) output_54,
+     (insn_gen_fn) gen_muldf3,
+     &operand_data[90],
+     3,
+     0,
+     1,
+     3
+   },
+   {
+     "mulsf3",
+     __extension__ (const PTR) output_55,
+     (insn_gen_fn) gen_mulsf3,
+     &operand_data[93],
+     3,
+     0,
+     1,
+     3
+   },
+   {
+     "*i370.md:2774",
+     __extension__ (const PTR) output_56,
+     0,
+     &operand_data[118],
+     3,
+     0,
+     1,
+     3
+   },
+   {
+     "divdf3",
+     __extension__ (const PTR) output_57,
+     (insn_gen_fn) gen_divdf3,
+     &operand_data[106],
+     3,
+     0,
+     1,
+     3
+   },
+   {
+     "divsf3",
+     __extension__ (const PTR) output_58,
+     (insn_gen_fn) gen_divsf3,
+     &operand_data[109],
+     3,
+     0,
+     1,
+     3
+   },
+   {
+     "*i370.md:2940",
+     __extension__ (const PTR) output_59,
+     0,
+     &operand_data[118],
+     3,
+     0,
+     1,
+     3
+   },
+   {
+     "*i370.md:2989",
+     __extension__ (const PTR) output_60,
+     0,
+     &operand_data[121],
+     3,
+     0,
+     2,
+     3
+   },
+   {
+     "andsi3",
+     __extension__ (const PTR) output_61,
+     (insn_gen_fn) gen_andsi3,
+     &operand_data[74],
+     3,
+     0,
+     1,
+     3
+   },
+   {
+     "*i370.md:3038",
+     __extension__ (const PTR) output_62,
+     0,
+     &operand_data[124],
+     3,
+     0,
+     2,
+     3
+   },
+   {
+     "andhi3",
+     __extension__ (const PTR) output_63,
+     (insn_gen_fn) gen_andhi3,
+     &operand_data[127],
+     3,
+     0,
+     1,
+     3
+   },
+   {
+     "*i370.md:3099",
+     __extension__ (const PTR) output_64,
+     0,
+     &operand_data[130],
+     3,
+     0,
+     2,
+     3
+   },
+   {
+     "andqi3",
+     __extension__ (const PTR) output_65,
+     (insn_gen_fn) gen_andqi3,
+     &operand_data[133],
+     3,
+     0,
+     1,
+     3
+   },
+   {
+     "*i370.md:3179",
+     __extension__ (const PTR) output_66,
+     0,
+     &operand_data[121],
+     3,
+     0,
+     2,
+     3
+   },
+   {
+     "iorsi3",
+     __extension__ (const PTR) output_67,
+     (insn_gen_fn) gen_iorsi3,
+     &operand_data[74],
+     3,
+     0,
+     1,
+     3
+   },
+   {
+     "*i370.md:3228",
+     __extension__ (const PTR) output_68,
+     0,
+     &operand_data[124],
+     3,
+     0,
+     2,
+     3
+   },
+   {
+     "iorhi3",
+     __extension__ (const PTR) output_69,
+     (insn_gen_fn) gen_iorhi3,
+     &operand_data[127],
+     3,
+     0,
+     1,
+     3
+   },
+   {
+     "*i370.md:3289",
+     __extension__ (const PTR) output_70,
+     0,
+     &operand_data[130],
+     3,
+     0,
+     2,
+     3
+   },
+   {
+     "iorqi3",
+     __extension__ (const PTR) output_71,
+     (insn_gen_fn) gen_iorqi3,
+     &operand_data[133],
+     3,
+     0,
+     1,
+     3
+   },
+   {
+     "*i370.md:3369",
+     __extension__ (const PTR) output_72,
+     0,
+     &operand_data[121],
+     3,
+     0,
+     2,
+     3
+   },
+   {
+     "xorsi3",
+     __extension__ (const PTR) output_73,
+     (insn_gen_fn) gen_xorsi3,
+     &operand_data[74],
+     3,
+     0,
+     1,
+     3
+   },
+   {
+     "*i370.md:3418",
+     __extension__ (const PTR) output_74,
+     0,
+     &operand_data[124],
+     3,
+     0,
+     2,
+     3
+   },
+   {
+     "xorhi3",
+     __extension__ (const PTR) output_75,
+     (insn_gen_fn) gen_xorhi3,
+     &operand_data[127],
+     3,
+     0,
+     1,
+     3
+   },
+   {
+     "*i370.md:3479",
+     __extension__ (const PTR) output_76,
+     0,
+     &operand_data[130],
+     3,
+     0,
+     2,
+     3
+   },
+   {
+     "xorqi3",
+     __extension__ (const PTR) output_77,
+     (insn_gen_fn) gen_xorqi3,
+     &operand_data[133],
+     3,
+     0,
+     1,
+     3
+   },
+   {
+     "negsi2",
+     __extension__ (const PTR) output_78,
+     (insn_gen_fn) gen_negsi2,
+     &operand_data[136],
+     2,
+     0,
+     1,
+     3
+   },
+   {
+     "neghi2",
+     __extension__ (const PTR) output_79,
+     (insn_gen_fn) gen_neghi2,
+     &operand_data[138],
+     2,
+     0,
+     1,
+     3
+   },
+   {
+     "negdf2",
+     __extension__ (const PTR) output_80,
+     (insn_gen_fn) gen_negdf2,
+     &operand_data[140],
+     2,
+     0,
+     1,
+     3
+   },
+   {
+     "negsf2",
+     __extension__ (const PTR) output_81,
+     (insn_gen_fn) gen_negsf2,
+     &operand_data[142],
+     2,
+     0,
+     1,
+     3
+   },
+   {
+     "abssi2",
+     __extension__ (const PTR) output_82,
+     (insn_gen_fn) gen_abssi2,
+     &operand_data[136],
+     2,
+     0,
+     1,
+     3
+   },
+   {
+     "abshi2",
+     __extension__ (const PTR) output_83,
+     (insn_gen_fn) gen_abshi2,
+     &operand_data[138],
+     2,
+     0,
+     1,
+     3
+   },
+   {
+     "absdf2",
+     __extension__ (const PTR) output_84,
+     (insn_gen_fn) gen_absdf2,
+     &operand_data[140],
+     2,
+     0,
+     1,
+     3
+   },
+   {
+     "abssf2",
+     __extension__ (const PTR) output_85,
+     (insn_gen_fn) gen_abssf2,
+     &operand_data[142],
+     2,
+     0,
+     1,
+     3
+   },
+   {
+     "*i370.md:3700",
+     __extension__ (const PTR) output_86,
+     0,
+     &operand_data[144],
+     2,
+     0,
+     1,
+     3
+   },
+   {
+     "one_cmplsi2",
+     __extension__ (const PTR) output_87,
+     (insn_gen_fn) gen_one_cmplsi2,
+     &operand_data[96],
+     2,
+     0,
+     1,
+     3
+   },
+   {
+     "*i370.md:3738",
+     __extension__ (const PTR) output_88,
+     0,
+     &operand_data[146],
+     2,
+     0,
+     1,
+     3
+   },
+   {
+     "one_cmplhi2",
+     __extension__ (const PTR) output_89,
+     (insn_gen_fn) gen_one_cmplhi2,
+     &operand_data[100],
+     2,
+     0,
+     1,
+     3
+   },
+   {
+     "*i370.md:3775",
+     __extension__ (const PTR) output_90,
+     0,
+     &operand_data[148],
+     2,
+     0,
+     1,
+     3
+   },
+   {
+     "one_cmplqi2",
+     __extension__ (const PTR) output_91,
+     (insn_gen_fn) gen_one_cmplqi2,
+     &operand_data[150],
+     2,
+     0,
+     1,
+     3
+   },
+   {
+     "ashldi3",
+     __extension__ (const PTR) output_92,
+     (insn_gen_fn) gen_ashldi3,
+     &operand_data[152],
+     3,
+     0,
+     1,
+     3
+   },
+   {
+     "ashrdi3",
+     __extension__ (const PTR) output_93,
+     (insn_gen_fn) gen_ashrdi3,
+     &operand_data[152],
+     3,
+     0,
+     1,
+     3
+   },
+   {
+     "ashlsi3",
+     __extension__ (const PTR) output_94,
+     (insn_gen_fn) gen_ashlsi3,
+     &operand_data[155],
+     3,
+     0,
+     1,
+     3
+   },
+   {
+     "ashrsi3",
+     __extension__ (const PTR) output_95,
+     (insn_gen_fn) gen_ashrsi3,
+     &operand_data[155],
+     3,
+     0,
+     1,
+     3
+   },
+   {
+     "ashlhi3",
+     __extension__ (const PTR) output_96,
+     (insn_gen_fn) gen_ashlhi3,
+     &operand_data[158],
+     3,
+     0,
+     1,
+     3
+   },
+   {
+     "ashrhi3",
+     __extension__ (const PTR) output_97,
+     (insn_gen_fn) gen_ashrhi3,
+     &operand_data[158],
+     3,
+     0,
+     1,
+     3
+   },
+   {
+     "ashlqi3",
+     __extension__ (const PTR) output_98,
+     (insn_gen_fn) gen_ashlqi3,
+     &operand_data[161],
+     3,
+     0,
+     1,
+     3
+   },
+   {
+     "ashrqi3",
+     __extension__ (const PTR) output_99,
+     (insn_gen_fn) gen_ashrqi3,
+     &operand_data[161],
+     3,
+     0,
+     1,
+     3
+   },
+   {
+     "lshrdi3",
+     __extension__ (const PTR) output_100,
+     (insn_gen_fn) gen_lshrdi3,
+     &operand_data[152],
+     3,
+     0,
+     1,
+     3
+   },
+   {
+     "lshrsi3",
+     __extension__ (const PTR) output_101,
+     (insn_gen_fn) gen_lshrsi3,
+     &operand_data[155],
+     3,
+     0,
+     1,
+     3
+   },
+   {
+     "lshrhi3",
+     __extension__ (const PTR) output_102,
+     (insn_gen_fn) gen_lshrhi3,
+     &operand_data[158],
+     3,
+     0,
+     1,
+     3
+   },
+   {
+     "lshrqi3",
+     __extension__ (const PTR) output_103,
+     (insn_gen_fn) gen_lshrqi3,
+     &operand_data[161],
+     3,
+     0,
+     1,
+     3
+   },
+   {
+     "beq",
+     __extension__ (const PTR) output_104,
+     (insn_gen_fn) gen_beq,
+     &operand_data[77],
+     1,
+     0,
+     0,
+     3
+   },
+   {
+     "bne",
+     __extension__ (const PTR) output_105,
+     (insn_gen_fn) gen_bne,
+     &operand_data[77],
+     1,
+     0,
+     0,
+     3
+   },
+   {
+     "bgt",
+     __extension__ (const PTR) output_106,
+     (insn_gen_fn) gen_bgt,
+     &operand_data[77],
+     1,
+     0,
+     0,
+     3
+   },
+   {
+     "bgtu",
+     __extension__ (const PTR) output_107,
+     (insn_gen_fn) gen_bgtu,
+     &operand_data[77],
+     1,
+     0,
+     0,
+     3
+   },
+   {
+     "blt",
+     __extension__ (const PTR) output_108,
+     (insn_gen_fn) gen_blt,
+     &operand_data[77],
+     1,
+     0,
+     0,
+     3
+   },
+   {
+     "bltu",
+     __extension__ (const PTR) output_109,
+     (insn_gen_fn) gen_bltu,
+     &operand_data[77],
+     1,
+     0,
+     0,
+     3
+   },
+   {
+     "bge",
+     __extension__ (const PTR) output_110,
+     (insn_gen_fn) gen_bge,
+     &operand_data[77],
+     1,
+     0,
+     0,
+     3
+   },
+   {
+     "bgeu",
+     __extension__ (const PTR) output_111,
+     (insn_gen_fn) gen_bgeu,
+     &operand_data[77],
+     1,
+     0,
+     0,
+     3
+   },
+   {
+     "ble",
+     __extension__ (const PTR) output_112,
+     (insn_gen_fn) gen_ble,
+     &operand_data[77],
+     1,
+     0,
+     0,
+     3
+   },
+   {
+     "bleu",
+     __extension__ (const PTR) output_113,
+     (insn_gen_fn) gen_bleu,
+     &operand_data[77],
+     1,
+     0,
+     0,
+     3
+   },
+   {
+     "*i370.md:4347",
+     __extension__ (const PTR) output_114,
+     0,
+     &operand_data[77],
+     1,
+     0,
+     0,
+     3
+   },
+   {
+     "*i370.md:4370",
+     __extension__ (const PTR) output_115,
+     0,
+     &operand_data[77],
+     1,
+     0,
+     0,
+     3
+   },
+   {
+     "*i370.md:4393",
+     __extension__ (const PTR) output_116,
+     0,
+     &operand_data[77],
+     1,
+     0,
+     0,
+     3
+   },
+   {
+     "*i370.md:4416",
+     __extension__ (const PTR) output_117,
+     0,
+     &operand_data[77],
+     1,
+     0,
+     0,
+     3
+   },
+   {
+     "*i370.md:4439",
+     __extension__ (const PTR) output_118,
+     0,
+     &operand_data[77],
+     1,
+     0,
+     0,
+     3
+   },
+   {
+     "*i370.md:4462",
+     __extension__ (const PTR) output_119,
+     0,
+     &operand_data[77],
+     1,
+     0,
+     0,
+     3
+   },
+   {
+     "*i370.md:4485",
+     __extension__ (const PTR) output_120,
+     0,
+     &operand_data[77],
+     1,
+     0,
+     0,
+     3
+   },
+   {
+     "*i370.md:4508",
+     __extension__ (const PTR) output_121,
+     0,
+     &operand_data[77],
+     1,
+     0,
+     0,
+     3
+   },
+   {
+     "*i370.md:4531",
+     __extension__ (const PTR) output_122,
+     0,
+     &operand_data[77],
+     1,
+     0,
+     0,
+     3
+   },
+   {
+     "*i370.md:4554",
+     __extension__ (const PTR) output_123,
+     0,
+     &operand_data[77],
+     1,
+     0,
+     0,
+     3
+   },
+   {
+     "*i370.md:4582",
+     __extension__ (const PTR) output_124,
+     0,
+     &operand_data[164],
+     2,
+     2,
+     1,
+     3
+   },
+   {
+     "*i370.md:4610",
+     __extension__ (const PTR) output_125,
+     0,
+     &operand_data[164],
+     2,
+     2,
+     1,
+     3
+   },
+   {
+     "jump",
+     __extension__ (const PTR) output_126,
+     (insn_gen_fn) gen_jump,
+     &operand_data[77],
+     1,
+     0,
+     0,
+     3
+   },
+   {
+     "indirect_jump",
+     __extension__ (const PTR) output_127,
+     (insn_gen_fn) gen_indirect_jump,
+     &operand_data[166],
+     1,
+     0,
+     1,
+     3
+   },
+   {
+     "tablejump",
+     __extension__ (const PTR) output_128,
+     (insn_gen_fn) gen_tablejump,
+     &operand_data[167],
+     2,
+     0,
+     1,
+     3
+   },
+   {
+     "call",
+     __extension__ (const PTR) output_129,
+     (insn_gen_fn) gen_call,
+     &operand_data[169],
+     2,
+     0,
+     1,
+     3
+   },
+   {
+     "call_value",
+     __extension__ (const PTR) output_130,
+     (insn_gen_fn) gen_call_value,
+     &operand_data[171],
+     3,
+     0,
+     1,
+     3
+   },
+   {
+     "*i370.md:4836",
+     __extension__ (const PTR) output_131,
+     0,
+     &operand_data[174],
+     2,
+     0,
+     1,
+     3
+   },
+   {
+     "*i370.md:4884",
+     __extension__ (const PTR) output_132,
+     0,
+     &operand_data[176],
+     3,
+     0,
+     1,
+     3
+   },
+   {
+     "nop",
+     __extension__ (const PTR) output_133,
+     (insn_gen_fn) gen_nop,
+     &operand_data[0],
+     0,
+     0,
+     0,
+     3
+   },
+   {
+     "cmpstrsi",
+     0,
+     (insn_gen_fn) gen_cmpstrsi,
+     &operand_data[179],
+     5,
+     0,
+     0,
+     0
+   },
+   {
+     "clrstrsi",
+     0,
+     (insn_gen_fn) gen_clrstrsi,
+     &operand_data[184],
+     3,
+     0,
+     1,
+     0
+   },
+   {
+     "movstrsi",
+     0,
+     (insn_gen_fn) gen_movstrsi,
+     &operand_data[187],
+     4,
+     0,
+     0,
+     0
+   },
+   {
+     "extendsidi2",
+     0,
+     (insn_gen_fn) gen_extendsidi2,
+     &operand_data[191],
+     2,
+     0,
+     1,
+     0
+   },
+   {
+     "zero_extendsidi2",
+     0,
+     (insn_gen_fn) gen_zero_extendsidi2,
+     &operand_data[191],
+     2,
+     0,
+     1,
+     0
+   },
+   {
+     "adddi3",
+     0,
+     (insn_gen_fn) gen_adddi3,
+     &operand_data[193],
+     3,
+     0,
+     0,
+     0
+   },
+   {
+     "mulsi3",
+     0,
+     (insn_gen_fn) gen_mulsi3,
+     &operand_data[196],
+     3,
+     0,
+     0,
+     0
+   },
+   {
+     "divsi3",
+     0,
+     (insn_gen_fn) gen_divsi3,
+     &operand_data[196],
+     3,
+     0,
+     0,
+     0
+   },
+   {
+     "udivsi3",
+     0,
+     (insn_gen_fn) gen_udivsi3,
+     &operand_data[196],
+     3,
+     0,
+     0,
+     0
+   },
+   {
+     "modsi3",
+     0,
+     (insn_gen_fn) gen_modsi3,
+     &operand_data[196],
+     3,
+     0,
+     0,
+     0
+   },
+   {
+     "umodsi3",
+     0,
+     (insn_gen_fn) gen_umodsi3,
+     &operand_data[196],
+     3,
+     0,
+     0,
+     0
+   },
+   {
+     "untyped_call",
+     0,
+     (insn_gen_fn) gen_untyped_call,
+     &operand_data[199],
+     3,
+     0,
+     0,
+     0
+   },
+ };
+ 
+ 
+ const char *
+ get_insn_name (code)
+      int code;
+ {
+   return insn_data[code].name;
+ }
Index: gcc/gcc/insn-peep.c
diff -c nul gcc/gcc/insn-peep.c:1.1
*** nul	Tue Oct 01 16:28:46 2019
--- gcc/gcc/insn-peep.c	Tue Nov 07 21:43:19 2006
***************
*** 0 ****
--- 1,36 ----
+ /* Generated automatically by the program `genpeep'
+ from the machine description file `md'.  */
+ 
+ #include "config.h"
+ #include "system.h"
+ #include "insn-config.h"
+ #include "rtl.h"
+ #include "tm_p.h"
+ #include "regs.h"
+ #include "output.h"
+ #include "real.h"
+ #include "recog.h"
+ #include "except.h"
+ 
+ #include "function.h"
+ 
+ #ifdef HAVE_peephole
+ extern rtx peep_operand[];
+ 
+ #define operands peep_operand
+ 
+ rtx
+ peephole (ins1)
+      rtx ins1;
+ {
+   rtx insn ATTRIBUTE_UNUSED, x ATTRIBUTE_UNUSED, pat ATTRIBUTE_UNUSED;
+ 
+   if (NEXT_INSN (ins1)
+       && GET_CODE (NEXT_INSN (ins1)) == BARRIER)
+     return 0;
+ 
+   return 0;
+ }
+ 
+ rtx peep_operand[2];
+ #endif
Index: gcc/gcc/insn-recog.c
diff -c nul gcc/gcc/insn-recog.c:1.39
*** nul	Tue Oct 01 16:28:46 2019
--- gcc/gcc/insn-recog.c	Sun Sep 25 20:18:18 2016
***************
*** 0 ****
--- 1,3659 ----
+ /* Generated automatically by the program `genrecog' from the target
+    machine description file.  */
+ 
+ #include "config.h"
+ #include "system.h"
+ #include "rtl.h"
+ #include "tm_p.h"
+ #include "function.h"
+ #include "insn-config.h"
+ #include "recog.h"
+ #include "real.h"
+ #include "output.h"
+ #include "flags.h"
+ #include "hard-reg-set.h"
+ #include "resource.h"
+ #include "toplev.h"
+ #include "reload.h"
+ 
+ 
+ 
+ /* `recog' contains a decision tree that recognizes whether the rtx
+    X0 is a valid instruction.
+ 
+    recog returns -1 if the rtx is not valid.  If the rtx is valid, recog
+    returns a nonnegative number which is the insn code number for the
+    pattern that matched.  This is the same as the order in the machine
+    description of the entry that matched.  This number can be used as an
+    index into `insn_data' and other tables.
+ 
+    The third argument to recog is an optional pointer to an int.  If
+    present, recog will accept a pattern if it matches except for missing
+    CLOBBER expressions at the end.  In that case, the value pointed to by
+    the optional pointer will be set to the number of CLOBBERs that need
+    to be added (it should be initialized to zero by the caller).  If it
+    is set nonzero, the caller should allocate a PARALLEL of the
+    appropriate size, copy the initial entries, and call add_clobbers
+    (found in insn-emit.c) to fill in the CLOBBERs.
+ 
+ 
+    The function split_insns returns 0 if the rtl could not
+    be split or the split rtl in a SEQUENCE if it can be.
+ 
+    The function peephole2_insns returns 0 if the rtl could not
+    be matched. If there was a match, the new rtl is returned in a SEQUENCE,
+    and LAST_INSN will point to the last recognized insn in the old sequence.
+ */
+ 
+ 
+ 
+ 
+ 
+ static int recog_1 PARAMS ((rtx, rtx, int *));
+ static int
+ recog_1 (x0, insn, pnum_clobbers)
+      rtx x0 ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+      int *pnum_clobbers ATTRIBUTE_UNUSED;
+ {
+   rtx * const operands ATTRIBUTE_UNUSED = &recog_data.operand[0];
+   rtx x1 ATTRIBUTE_UNUSED;
+   rtx x2 ATTRIBUTE_UNUSED;
+   rtx x3 ATTRIBUTE_UNUSED;
+   rtx x4 ATTRIBUTE_UNUSED;
+   rtx x5 ATTRIBUTE_UNUSED;
+   int tem ATTRIBUTE_UNUSED;
+ 
+   x1 = XEXP (x0, 0);
+   switch (GET_MODE (x1))
+     {
+     case DImode:
+       goto L779;
+     case SImode:
+       goto L780;
+     case HImode:
+       goto L781;
+     case QImode:
+       goto L783;
+     case DFmode:
+       goto L785;
+     case SFmode:
+       goto L786;
+     default:
+       break;
+     }
+  L1: ATTRIBUTE_UNUSED_LABEL
+   switch (GET_CODE (x1))
+     {
+     case CC0:
+       goto L2;
+     case STRICT_LOW_PART:
+       goto L97;
+     case PC:
+       goto L529;
+     default:
+      break;
+    }
+  L759: ATTRIBUTE_UNUSED_LABEL
+   operands[0] = x1;
+   goto L760;
+ 
+  L779: ATTRIBUTE_UNUSED_LABEL
+   if (nonimmediate_operand (x1, DImode))
+     {
+       operands[0] = x1;
+       goto L73;
+     }
+  L792: ATTRIBUTE_UNUSED_LABEL
+   if (register_operand (x1, DImode))
+     {
+       operands[0] = x1;
+       goto L276;
+     }
+   goto L1;
+ 
+  L73: ATTRIBUTE_UNUSED_LABEL
+   x1 = XEXP (x0, 1);
+   if (general_operand (x1, DImode))
+     {
+       operands[1] = x1;
+       goto L74;
+     }
+  L77: ATTRIBUTE_UNUSED_LABEL
+   if (general_operand (x1, DImode))
+     {
+       operands[1] = x1;
+       return 14;
+     }
+   x1 = XEXP (x0, 0);
+   goto L792;
+ 
+  L74: ATTRIBUTE_UNUSED_LABEL
+   if ((TARGET_CHAR_INSTRUCTIONS))
+     {
+       return 13;
+     }
+   x1 = XEXP (x0, 1);
+   goto L77;
+ 
+  L276: ATTRIBUTE_UNUSED_LABEL
+   x1 = XEXP (x0, 1);
+   if (GET_MODE (x1) == DImode)
+     goto L795;
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L795: ATTRIBUTE_UNUSED_LABEL
+   switch (GET_CODE (x1))
+     {
+     case MULT:
+       goto L277;
+     case DIV:
+       goto L292;
+     case MOD:
+       goto L307;
+     case ASHIFT:
+       goto L470;
+     case ASHIFTRT:
+       goto L475;
+     case LSHIFTRT:
+       goto L510;
+     default:
+      break;
+    }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L277: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (general_operand (x2, DImode))
+     {
+       operands[1] = x2;
+       goto L278;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L278: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 1);
+   if (general_operand (x2, SImode))
+     {
+       operands[2] = x2;
+       return 53;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L292: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (register_operand (x2, DImode))
+     {
+       operands[1] = x2;
+       goto L293;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L293: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 1);
+   if (general_operand (x2, SImode))
+     {
+       operands[2] = x2;
+       return 56;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L307: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (register_operand (x2, DImode))
+     {
+       operands[1] = x2;
+       goto L308;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L308: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 1);
+   if (general_operand (x2, SImode))
+     {
+       operands[2] = x2;
+       return 59;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L470: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (general_operand (x2, DImode))
+     {
+       operands[1] = x2;
+       goto L471;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L471: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 1);
+   if (general_operand (x2, SImode))
+     {
+       operands[2] = x2;
+       return 92;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L475: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (general_operand (x2, DImode))
+     {
+       operands[1] = x2;
+       goto L476;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L476: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 1);
+   if (general_operand (x2, SImode))
+     {
+       operands[2] = x2;
+       return 93;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L510: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (general_operand (x2, DImode))
+     {
+       operands[1] = x2;
+       goto L511;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L511: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 1);
+   if (general_operand (x2, SImode))
+     {
+       operands[2] = x2;
+       return 100;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L780: ATTRIBUTE_UNUSED_LABEL
+   if (nonimmediate_operand (x1, SImode))
+     {
+       operands[0] = x1;
+       goto L136;
+     }
+  L787: ATTRIBUTE_UNUSED_LABEL
+   if (register_operand (x1, SImode))
+     {
+       operands[0] = x1;
+       goto L140;
+     }
+  L793: ATTRIBUTE_UNUSED_LABEL
+   if (r_or_s_operand (x1, SImode))
+     {
+       operands[0] = x1;
+       goto L311;
+     }
+  L794: ATTRIBUTE_UNUSED_LABEL
+   if (register_operand (x1, SImode))
+     {
+       operands[0] = x1;
+       goto L317;
+     }
+   goto L1;
+ 
+  L136: ATTRIBUTE_UNUSED_LABEL
+   x1 = XEXP (x0, 1);
+   if (GET_MODE (x1) == SImode
+       && GET_CODE (x1) == SIGN_EXTEND)
+     goto L137;
+   if (general_operand (x1, SImode))
+     {
+       operands[1] = x1;
+       return 15;
+     }
+   x1 = XEXP (x0, 0);
+   goto L787;
+ 
+  L137: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (general_operand (x2, HImode))
+     {
+       operands[1] = x2;
+       return 27;
+     }
+   x1 = XEXP (x0, 0);
+   goto L787;
+ 
+  L140: ATTRIBUTE_UNUSED_LABEL
+   x1 = XEXP (x0, 1);
+   if (GET_MODE (x1) == SImode)
+     goto L801;
+   x1 = XEXP (x0, 0);
+   goto L793;
+ 
+  L801: ATTRIBUTE_UNUSED_LABEL
+   switch (GET_CODE (x1))
+     {
+     case SIGN_EXTEND:
+       goto L141;
+     case ZERO_EXTEND:
+       goto L149;
+     case FIX:
+       goto L173;
+     case PLUS:
+       goto L200;
+     case MINUS:
+       goto L246;
+     case MULT:
+       goto L271;
+     default:
+      break;
+    }
+   x1 = XEXP (x0, 0);
+   goto L793;
+ 
+  L141: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (general_operand (x2, QImode))
+     {
+       operands[1] = x2;
+       return 28;
+     }
+   x1 = XEXP (x0, 0);
+   goto L793;
+ 
+  L149: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (general_operand (x2, HImode))
+     {
+       operands[1] = x2;
+       return 30;
+     }
+  L153: ATTRIBUTE_UNUSED_LABEL
+   if (general_operand (x2, QImode))
+     {
+       operands[1] = x2;
+       return 31;
+     }
+   x1 = XEXP (x0, 0);
+   goto L793;
+ 
+  L173: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (GET_MODE (x2) == DFmode
+       && GET_CODE (x2) == TRUNCATE)
+     goto L174;
+   x1 = XEXP (x0, 0);
+   goto L793;
+ 
+  L174: ATTRIBUTE_UNUSED_LABEL
+   x3 = XEXP (x2, 0);
+   if (general_operand (x3, DFmode))
+     {
+       operands[1] = x3;
+       goto L175;
+     }
+   x1 = XEXP (x0, 0);
+   goto L793;
+ 
+  L175: ATTRIBUTE_UNUSED_LABEL
+   if (pnum_clobbers != NULL)
+     {
+       *pnum_clobbers = 1;
+       return 34;
+     }
+   x1 = XEXP (x0, 0);
+   goto L793;
+ 
+  L200: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (general_operand (x2, SImode))
+     {
+       operands[1] = x2;
+       goto L201;
+     }
+  L206: ATTRIBUTE_UNUSED_LABEL
+   if (register_operand (x2, SImode))
+     {
+       operands[1] = x2;
+       goto L207;
+     }
+  L212: ATTRIBUTE_UNUSED_LABEL
+   if (general_operand (x2, SImode))
+     {
+       operands[1] = x2;
+       goto L213;
+     }
+   x1 = XEXP (x0, 0);
+   goto L793;
+ 
+  L201: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 1);
+   if (immediate_operand (x2, SImode))
+     {
+       operands[2] = x2;
+       goto L202;
+     }
+   x2 = XEXP (x1, 0);
+   goto L206;
+ 
+  L202: ATTRIBUTE_UNUSED_LABEL
+   if ((((REGNO (operands[1]) == FRAME_POINTER_REGNUM || REGNO (operands[1]) == ARG_POINTER_REGNUM || REGNO (operands[1]) == STACK_POINTER_REGNUM) && (unsigned) INTVAL (operands[2]) < 4096)))
+     {
+       return 39;
+     }
+   x1 = XEXP (x0, 1);
+   x2 = XEXP (x1, 0);
+   goto L206;
+ 
+  L207: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 1);
+   if (immediate_operand (x2, SImode))
+     {
+       operands[2] = x2;
+       goto L208;
+     }
+   x2 = XEXP (x1, 0);
+   goto L212;
+ 
+  L208: ATTRIBUTE_UNUSED_LABEL
+   if ((REGNO (operands[1]) == FRAME_POINTER_REGNUM))
+     {
+       return 40;
+     }
+   x1 = XEXP (x0, 1);
+   x2 = XEXP (x1, 0);
+   goto L212;
+ 
+  L213: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 1);
+   if (general_operand (x2, SImode))
+     {
+       operands[2] = x2;
+       return 41;
+     }
+   x1 = XEXP (x0, 0);
+   goto L793;
+ 
+  L246: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (general_operand (x2, SImode))
+     {
+       operands[1] = x2;
+       goto L247;
+     }
+   x1 = XEXP (x0, 0);
+   goto L793;
+ 
+  L247: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 1);
+   if (general_operand (x2, SImode))
+     {
+       operands[2] = x2;
+       return 47;
+     }
+   x1 = XEXP (x0, 0);
+   goto L793;
+ 
+  L271: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (register_operand (x2, SImode))
+     {
+       operands[1] = x2;
+       goto L272;
+     }
+   x1 = XEXP (x0, 0);
+   goto L793;
+ 
+  L272: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 1);
+   if (const_int_operand (x2, SImode))
+     {
+       operands[2] = x2;
+       goto L273;
+     }
+   x1 = XEXP (x0, 0);
+   goto L793;
+ 
+  L273: ATTRIBUTE_UNUSED_LABEL
+   if ((CONST_OK_FOR_LETTER_P (INTVAL (operands[2]), 'K')))
+     {
+       return 52;
+     }
+   x1 = XEXP (x0, 0);
+   goto L793;
+ 
+  L311: ATTRIBUTE_UNUSED_LABEL
+   x1 = XEXP (x0, 1);
+   if (GET_MODE (x1) == SImode)
+     goto L807;
+   x1 = XEXP (x0, 0);
+   goto L794;
+ 
+  L807: ATTRIBUTE_UNUSED_LABEL
+   switch (GET_CODE (x1))
+     {
+     case AND:
+       goto L312;
+     case IOR:
+       goto L345;
+     case XOR:
+       goto L378;
+     case NOT:
+       goto L443;
+     default:
+      break;
+    }
+   x1 = XEXP (x0, 0);
+   goto L794;
+ 
+  L312: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (r_or_s_operand (x2, SImode))
+     {
+       operands[1] = x2;
+       goto L313;
+     }
+   x1 = XEXP (x0, 0);
+   goto L794;
+ 
+  L313: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 1);
+   if (general_operand (x2, SImode))
+     {
+       operands[2] = x2;
+       goto L314;
+     }
+   x1 = XEXP (x0, 0);
+   goto L794;
+ 
+  L314: ATTRIBUTE_UNUSED_LABEL
+   if ((TARGET_CHAR_INSTRUCTIONS))
+     {
+       return 60;
+     }
+   x1 = XEXP (x0, 0);
+   goto L794;
+ 
+  L345: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (r_or_s_operand (x2, SImode))
+     {
+       operands[1] = x2;
+       goto L346;
+     }
+   x1 = XEXP (x0, 0);
+   goto L794;
+ 
+  L346: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 1);
+   if (general_operand (x2, SImode))
+     {
+       operands[2] = x2;
+       goto L347;
+     }
+   x1 = XEXP (x0, 0);
+   goto L794;
+ 
+  L347: ATTRIBUTE_UNUSED_LABEL
+   if ((TARGET_CHAR_INSTRUCTIONS))
+     {
+       return 66;
+     }
+   x1 = XEXP (x0, 0);
+   goto L794;
+ 
+  L378: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (r_or_s_operand (x2, SImode))
+     {
+       operands[1] = x2;
+       goto L379;
+     }
+   x1 = XEXP (x0, 0);
+   goto L794;
+ 
+  L379: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 1);
+   if (general_operand (x2, SImode))
+     {
+       operands[2] = x2;
+       goto L380;
+     }
+   x1 = XEXP (x0, 0);
+   goto L794;
+ 
+  L380: ATTRIBUTE_UNUSED_LABEL
+   if ((TARGET_CHAR_INSTRUCTIONS))
+     {
+       return 72;
+     }
+   x1 = XEXP (x0, 0);
+   goto L794;
+ 
+  L443: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (r_or_s_operand (x2, SImode))
+     {
+       operands[1] = x2;
+       goto L444;
+     }
+   x1 = XEXP (x0, 0);
+   goto L794;
+ 
+  L444: ATTRIBUTE_UNUSED_LABEL
+   if ((TARGET_CHAR_INSTRUCTIONS))
+     {
+       return 86;
+     }
+   x1 = XEXP (x0, 0);
+   goto L794;
+ 
+  L317: ATTRIBUTE_UNUSED_LABEL
+   x1 = XEXP (x0, 1);
+   if (GET_MODE (x1) == SImode)
+     goto L811;
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L811: ATTRIBUTE_UNUSED_LABEL
+   switch (GET_CODE (x1))
+     {
+     case AND:
+       goto L318;
+     case IOR:
+       goto L351;
+     case XOR:
+       goto L384;
+     case NEG:
+       goto L411;
+     case ABS:
+       goto L427;
+     case NOT:
+       goto L448;
+     case ASHIFT:
+       goto L480;
+     case ASHIFTRT:
+       goto L485;
+     case LSHIFTRT:
+       goto L515;
+     default:
+      break;
+    }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L318: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (general_operand (x2, SImode))
+     {
+       operands[1] = x2;
+       goto L319;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L319: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 1);
+   if (general_operand (x2, SImode))
+     {
+       operands[2] = x2;
+       return 61;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L351: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (general_operand (x2, SImode))
+     {
+       operands[1] = x2;
+       goto L352;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L352: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 1);
+   if (general_operand (x2, SImode))
+     {
+       operands[2] = x2;
+       return 67;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L384: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (general_operand (x2, SImode))
+     {
+       operands[1] = x2;
+       goto L385;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L385: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 1);
+   if (general_operand (x2, SImode))
+     {
+       operands[2] = x2;
+       return 73;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L411: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (general_operand (x2, SImode))
+     {
+       operands[1] = x2;
+       return 78;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L427: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (general_operand (x2, SImode))
+     {
+       operands[1] = x2;
+       return 82;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L448: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (general_operand (x2, SImode))
+     {
+       operands[1] = x2;
+       return 87;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L480: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (general_operand (x2, SImode))
+     {
+       operands[1] = x2;
+       goto L481;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L481: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 1);
+   if (general_operand (x2, SImode))
+     {
+       operands[2] = x2;
+       return 94;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L485: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (general_operand (x2, SImode))
+     {
+       operands[1] = x2;
+       goto L486;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L486: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 1);
+   if (general_operand (x2, SImode))
+     {
+       operands[2] = x2;
+       return 95;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L515: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (general_operand (x2, SImode))
+     {
+       operands[1] = x2;
+       goto L516;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L516: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 1);
+   if (general_operand (x2, SImode))
+     {
+       operands[2] = x2;
+       return 101;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L781: ATTRIBUTE_UNUSED_LABEL
+   if (r_or_s_operand (x1, HImode))
+     {
+       operands[0] = x1;
+       goto L322;
+     }
+  L782: ATTRIBUTE_UNUSED_LABEL
+   if (nonimmediate_operand (x1, HImode))
+     {
+       operands[0] = x1;
+       goto L160;
+     }
+  L788: ATTRIBUTE_UNUSED_LABEL
+   if (register_operand (x1, HImode))
+     {
+       operands[0] = x1;
+       goto L144;
+     }
+   goto L1;
+ 
+  L322: ATTRIBUTE_UNUSED_LABEL
+   x1 = XEXP (x0, 1);
+   if (GET_MODE (x1) == HImode)
+     goto L820;
+  L83: ATTRIBUTE_UNUSED_LABEL
+   if (general_operand (x1, HImode))
+     {
+       operands[1] = x1;
+       goto L84;
+     }
+   x1 = XEXP (x0, 0);
+   goto L782;
+ 
+  L820: ATTRIBUTE_UNUSED_LABEL
+   switch (GET_CODE (x1))
+     {
+     case AND:
+       goto L323;
+     case IOR:
+       goto L356;
+     case XOR:
+       goto L389;
+     case NOT:
+       goto L452;
+     default:
+      break;
+    }
+   goto L83;
+ 
+  L323: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (r_or_s_operand (x2, HImode))
+     {
+       operands[1] = x2;
+       goto L324;
+     }
+   goto L83;
+ 
+  L324: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 1);
+   if (general_operand (x2, HImode))
+     {
+       operands[2] = x2;
+       goto L325;
+     }
+   goto L83;
+ 
+  L325: ATTRIBUTE_UNUSED_LABEL
+   if ((TARGET_CHAR_INSTRUCTIONS))
+     {
+       return 62;
+     }
+   x1 = XEXP (x0, 1);
+   goto L83;
+ 
+  L356: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (r_or_s_operand (x2, HImode))
+     {
+       operands[1] = x2;
+       goto L357;
+     }
+   goto L83;
+ 
+  L357: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 1);
+   if (general_operand (x2, HImode))
+     {
+       operands[2] = x2;
+       goto L358;
+     }
+   goto L83;
+ 
+  L358: ATTRIBUTE_UNUSED_LABEL
+   if ((TARGET_CHAR_INSTRUCTIONS))
+     {
+       return 68;
+     }
+   x1 = XEXP (x0, 1);
+   goto L83;
+ 
+  L389: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (r_or_s_operand (x2, HImode))
+     {
+       operands[1] = x2;
+       goto L390;
+     }
+   goto L83;
+ 
+  L390: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 1);
+   if (general_operand (x2, HImode))
+     {
+       operands[2] = x2;
+       goto L391;
+     }
+   goto L83;
+ 
+  L391: ATTRIBUTE_UNUSED_LABEL
+   if ((TARGET_CHAR_INSTRUCTIONS))
+     {
+       return 74;
+     }
+   x1 = XEXP (x0, 1);
+   goto L83;
+ 
+  L452: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (r_or_s_operand (x2, HImode))
+     {
+       operands[1] = x2;
+       goto L453;
+     }
+   goto L83;
+ 
+  L453: ATTRIBUTE_UNUSED_LABEL
+   if ((TARGET_CHAR_INSTRUCTIONS))
+     {
+       return 88;
+     }
+   x1 = XEXP (x0, 1);
+   goto L83;
+ 
+  L84: ATTRIBUTE_UNUSED_LABEL
+   if ((TARGET_CHAR_INSTRUCTIONS))
+     {
+       return 16;
+     }
+   x1 = XEXP (x0, 0);
+   goto L782;
+ 
+  L160: ATTRIBUTE_UNUSED_LABEL
+   x1 = XEXP (x0, 1);
+   if (GET_MODE (x1) == HImode
+       && GET_CODE (x1) == TRUNCATE)
+     goto L161;
+   if (general_operand (x1, HImode))
+     {
+       operands[1] = x1;
+       return 17;
+     }
+   x1 = XEXP (x0, 0);
+   goto L788;
+ 
+  L161: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (general_operand (x2, SImode))
+     {
+       operands[1] = x2;
+       return 33;
+     }
+   x1 = XEXP (x0, 0);
+   goto L788;
+ 
+  L144: ATTRIBUTE_UNUSED_LABEL
+   x1 = XEXP (x0, 1);
+   if (GET_MODE (x1) == HImode)
+     goto L824;
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L824: ATTRIBUTE_UNUSED_LABEL
+   switch (GET_CODE (x1))
+     {
+     case SIGN_EXTEND:
+       goto L145;
+     case ZERO_EXTEND:
+       goto L157;
+     case PLUS:
+       goto L217;
+     case MINUS:
+       goto L251;
+     case AND:
+       goto L329;
+     case IOR:
+       goto L362;
+     case XOR:
+       goto L395;
+     case NEG:
+       goto L415;
+     case ABS:
+       goto L431;
+     case NOT:
+       goto L457;
+     case ASHIFT:
+       goto L490;
+     case ASHIFTRT:
+       goto L495;
+     case LSHIFTRT:
+       goto L520;
+     default:
+      break;
+    }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L145: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (general_operand (x2, QImode))
+     {
+       operands[1] = x2;
+       return 29;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L157: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (general_operand (x2, QImode))
+     {
+       operands[1] = x2;
+       return 32;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L217: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (general_operand (x2, HImode))
+     {
+       operands[1] = x2;
+       goto L218;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L218: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 1);
+   if (general_operand (x2, HImode))
+     {
+       operands[2] = x2;
+       return 42;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L251: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (general_operand (x2, HImode))
+     {
+       operands[1] = x2;
+       goto L252;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L252: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 1);
+   if (general_operand (x2, HImode))
+     {
+       operands[2] = x2;
+       return 48;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L329: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (register_operand (x2, HImode))
+     {
+       operands[1] = x2;
+       goto L330;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L330: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 1);
+   if (general_operand (x2, HImode))
+     {
+       operands[2] = x2;
+       return 63;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L362: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (register_operand (x2, HImode))
+     {
+       operands[1] = x2;
+       goto L363;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L363: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 1);
+   if (general_operand (x2, HImode))
+     {
+       operands[2] = x2;
+       return 69;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L395: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (register_operand (x2, HImode))
+     {
+       operands[1] = x2;
+       goto L396;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L396: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 1);
+   if (general_operand (x2, HImode))
+     {
+       operands[2] = x2;
+       return 75;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L415: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (general_operand (x2, HImode))
+     {
+       operands[1] = x2;
+       return 79;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L431: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (general_operand (x2, HImode))
+     {
+       operands[1] = x2;
+       return 83;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L457: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (general_operand (x2, HImode))
+     {
+       operands[1] = x2;
+       return 89;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L490: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (general_operand (x2, HImode))
+     {
+       operands[1] = x2;
+       goto L491;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L491: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 1);
+   if (general_operand (x2, SImode))
+     {
+       operands[2] = x2;
+       return 96;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L495: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (general_operand (x2, HImode))
+     {
+       operands[1] = x2;
+       goto L496;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L496: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 1);
+   if (general_operand (x2, SImode))
+     {
+       operands[2] = x2;
+       return 97;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L520: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (general_operand (x2, HImode))
+     {
+       operands[1] = x2;
+       goto L521;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L521: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 1);
+   if (general_operand (x2, SImode))
+     {
+       operands[2] = x2;
+       return 102;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L783: ATTRIBUTE_UNUSED_LABEL
+   if (r_or_s_operand (x1, QImode))
+     {
+       operands[0] = x1;
+       goto L333;
+     }
+  L784: ATTRIBUTE_UNUSED_LABEL
+   if (nonimmediate_operand (x1, QImode))
+     {
+       operands[0] = x1;
+       goto L94;
+     }
+  L791: ATTRIBUTE_UNUSED_LABEL
+   if (register_operand (x1, QImode))
+     {
+       operands[0] = x1;
+       goto L221;
+     }
+   goto L1;
+ 
+  L333: ATTRIBUTE_UNUSED_LABEL
+   x1 = XEXP (x0, 1);
+   if (GET_MODE (x1) == QImode)
+     goto L837;
+  L90: ATTRIBUTE_UNUSED_LABEL
+   if (general_operand (x1, QImode))
+     {
+       operands[1] = x1;
+       goto L91;
+     }
+   x1 = XEXP (x0, 0);
+   goto L784;
+ 
+  L837: ATTRIBUTE_UNUSED_LABEL
+   switch (GET_CODE (x1))
+     {
+     case AND:
+       goto L334;
+     case IOR:
+       goto L367;
+     case XOR:
+       goto L400;
+     case NOT:
+       goto L461;
+     default:
+      break;
+    }
+   goto L90;
+ 
+  L334: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (r_or_s_operand (x2, QImode))
+     {
+       operands[1] = x2;
+       goto L335;
+     }
+   goto L90;
+ 
+  L335: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 1);
+   if (general_operand (x2, QImode))
+     {
+       operands[2] = x2;
+       goto L336;
+     }
+   goto L90;
+ 
+  L336: ATTRIBUTE_UNUSED_LABEL
+   if ((TARGET_CHAR_INSTRUCTIONS))
+     {
+       return 64;
+     }
+   x1 = XEXP (x0, 1);
+   goto L90;
+ 
+  L367: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (r_or_s_operand (x2, QImode))
+     {
+       operands[1] = x2;
+       goto L368;
+     }
+   goto L90;
+ 
+  L368: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 1);
+   if (general_operand (x2, QImode))
+     {
+       operands[2] = x2;
+       goto L369;
+     }
+   goto L90;
+ 
+  L369: ATTRIBUTE_UNUSED_LABEL
+   if ((TARGET_CHAR_INSTRUCTIONS))
+     {
+       return 70;
+     }
+   x1 = XEXP (x0, 1);
+   goto L90;
+ 
+  L400: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (r_or_s_operand (x2, QImode))
+     {
+       operands[1] = x2;
+       goto L401;
+     }
+   goto L90;
+ 
+  L401: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 1);
+   if (general_operand (x2, QImode))
+     {
+       operands[2] = x2;
+       goto L402;
+     }
+   goto L90;
+ 
+  L402: ATTRIBUTE_UNUSED_LABEL
+   if ((TARGET_CHAR_INSTRUCTIONS))
+     {
+       return 76;
+     }
+   x1 = XEXP (x0, 1);
+   goto L90;
+ 
+  L461: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (r_or_s_operand (x2, QImode))
+     {
+       operands[1] = x2;
+       goto L462;
+     }
+   goto L90;
+ 
+  L462: ATTRIBUTE_UNUSED_LABEL
+   if ((TARGET_CHAR_INSTRUCTIONS))
+     {
+       return 90;
+     }
+   x1 = XEXP (x0, 1);
+   goto L90;
+ 
+  L91: ATTRIBUTE_UNUSED_LABEL
+   if ((TARGET_CHAR_INSTRUCTIONS))
+     {
+       return 18;
+     }
+   x1 = XEXP (x0, 0);
+   goto L784;
+ 
+  L94: ATTRIBUTE_UNUSED_LABEL
+   x1 = XEXP (x0, 1);
+   if (general_operand (x1, QImode))
+     {
+       operands[1] = x1;
+       return 19;
+     }
+   x1 = XEXP (x0, 0);
+   goto L791;
+ 
+  L221: ATTRIBUTE_UNUSED_LABEL
+   x1 = XEXP (x0, 1);
+   if (GET_MODE (x1) == QImode)
+     goto L841;
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L841: ATTRIBUTE_UNUSED_LABEL
+   switch (GET_CODE (x1))
+     {
+     case PLUS:
+       goto L222;
+     case MINUS:
+       goto L256;
+     case AND:
+       goto L340;
+     case IOR:
+       goto L373;
+     case XOR:
+       goto L406;
+     case NOT:
+       goto L466;
+     case ASHIFT:
+       goto L500;
+     case ASHIFTRT:
+       goto L505;
+     case LSHIFTRT:
+       goto L525;
+     default:
+      break;
+    }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L222: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (general_operand (x2, QImode))
+     {
+       operands[1] = x2;
+       goto L223;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L223: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 1);
+   if (general_operand (x2, QImode))
+     {
+       operands[2] = x2;
+       return 43;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L256: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (register_operand (x2, QImode))
+     {
+       operands[1] = x2;
+       goto L257;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L257: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 1);
+   if (register_operand (x2, QImode))
+     {
+       operands[2] = x2;
+       return 49;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L340: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (general_operand (x2, QImode))
+     {
+       operands[1] = x2;
+       goto L341;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L341: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 1);
+   if (general_operand (x2, QImode))
+     {
+       operands[2] = x2;
+       return 65;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L373: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (general_operand (x2, QImode))
+     {
+       operands[1] = x2;
+       goto L374;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L374: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 1);
+   if (general_operand (x2, QImode))
+     {
+       operands[2] = x2;
+       return 71;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L406: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (general_operand (x2, QImode))
+     {
+       operands[1] = x2;
+       goto L407;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L407: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 1);
+   if (general_operand (x2, QImode))
+     {
+       operands[2] = x2;
+       return 77;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L466: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (general_operand (x2, QImode))
+     {
+       operands[1] = x2;
+       return 91;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L500: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (general_operand (x2, QImode))
+     {
+       operands[1] = x2;
+       goto L501;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L501: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 1);
+   if (general_operand (x2, SImode))
+     {
+       operands[2] = x2;
+       return 98;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L505: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (general_operand (x2, QImode))
+     {
+       operands[1] = x2;
+       goto L506;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L506: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 1);
+   if (general_operand (x2, SImode))
+     {
+       operands[2] = x2;
+       return 99;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L525: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (general_operand (x2, QImode))
+     {
+       operands[1] = x2;
+       goto L526;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L526: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 1);
+   if (general_operand (x2, SImode))
+     {
+       operands[2] = x2;
+       return 103;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L785: ATTRIBUTE_UNUSED_LABEL
+   if (nonimmediate_operand (x1, DFmode))
+     {
+       operands[0] = x1;
+       goto L101;
+     }
+  L789: ATTRIBUTE_UNUSED_LABEL
+   if (register_operand (x1, DFmode))
+     {
+       operands[0] = x1;
+       goto L178;
+     }
+   goto L1;
+ 
+  L101: ATTRIBUTE_UNUSED_LABEL
+   x1 = XEXP (x0, 1);
+   if (general_operand (x1, DFmode))
+     {
+       operands[1] = x1;
+       goto L102;
+     }
+  L105: ATTRIBUTE_UNUSED_LABEL
+   if (general_operand (x1, DFmode))
+     {
+       operands[1] = x1;
+       return 22;
+     }
+   x1 = XEXP (x0, 0);
+   goto L789;
+ 
+  L102: ATTRIBUTE_UNUSED_LABEL
+   if ((TARGET_CHAR_INSTRUCTIONS))
+     {
+       return 21;
+     }
+   x1 = XEXP (x0, 1);
+   goto L105;
+ 
+  L178: ATTRIBUTE_UNUSED_LABEL
+   x1 = XEXP (x0, 1);
+   if (GET_MODE (x1) == DFmode)
+     goto L850;
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L850: ATTRIBUTE_UNUSED_LABEL
+   switch (GET_CODE (x1))
+     {
+     case FLOAT:
+       goto L179;
+     case FLOAT_EXTEND:
+       goto L187;
+     case PLUS:
+       goto L227;
+     case MINUS:
+       goto L261;
+     case MULT:
+       goto L282;
+     case DIV:
+       goto L297;
+     case NEG:
+       goto L419;
+     case ABS:
+       goto L435;
+     default:
+      break;
+    }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L179: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (general_operand (x2, SImode))
+     {
+       operands[1] = x2;
+       return 35;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L187: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (general_operand (x2, SFmode))
+     {
+       operands[1] = x2;
+       return 37;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L227: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (general_operand (x2, DFmode))
+     {
+       operands[1] = x2;
+       goto L228;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L228: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 1);
+   if (general_operand (x2, DFmode))
+     {
+       operands[2] = x2;
+       return 44;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L261: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (general_operand (x2, DFmode))
+     {
+       operands[1] = x2;
+       goto L262;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L262: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 1);
+   if (general_operand (x2, DFmode))
+     {
+       operands[2] = x2;
+       return 50;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L282: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (general_operand (x2, DFmode))
+     {
+       operands[1] = x2;
+       goto L283;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L283: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 1);
+   if (general_operand (x2, DFmode))
+     {
+       operands[2] = x2;
+       return 54;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L297: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (general_operand (x2, DFmode))
+     {
+       operands[1] = x2;
+       goto L298;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L298: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 1);
+   if (general_operand (x2, DFmode))
+     {
+       operands[2] = x2;
+       return 57;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L419: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (general_operand (x2, DFmode))
+     {
+       operands[1] = x2;
+       return 80;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L435: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (general_operand (x2, DFmode))
+     {
+       operands[1] = x2;
+       return 84;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L786: ATTRIBUTE_UNUSED_LABEL
+   if (nonimmediate_operand (x1, SFmode))
+     {
+       operands[0] = x1;
+       goto L108;
+     }
+  L790: ATTRIBUTE_UNUSED_LABEL
+   if (register_operand (x1, SFmode))
+     {
+       operands[0] = x1;
+       goto L182;
+     }
+   goto L1;
+ 
+  L108: ATTRIBUTE_UNUSED_LABEL
+   x1 = XEXP (x0, 1);
+   if (general_operand (x1, SFmode))
+     {
+       operands[1] = x1;
+       goto L109;
+     }
+  L112: ATTRIBUTE_UNUSED_LABEL
+   if (general_operand (x1, SFmode))
+     {
+       operands[1] = x1;
+       return 24;
+     }
+   x1 = XEXP (x0, 0);
+   goto L790;
+ 
+  L109: ATTRIBUTE_UNUSED_LABEL
+   if ((TARGET_CHAR_INSTRUCTIONS))
+     {
+       return 23;
+     }
+   x1 = XEXP (x0, 1);
+   goto L112;
+ 
+  L182: ATTRIBUTE_UNUSED_LABEL
+   x1 = XEXP (x0, 1);
+   if (GET_MODE (x1) == SFmode)
+     goto L858;
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L858: ATTRIBUTE_UNUSED_LABEL
+   switch (GET_CODE (x1))
+     {
+     case FLOAT_TRUNCATE:
+       goto L183;
+     case PLUS:
+       goto L232;
+     case MINUS:
+       goto L266;
+     case MULT:
+       goto L287;
+     case DIV:
+       goto L302;
+     case NEG:
+       goto L423;
+     case ABS:
+       goto L439;
+     default:
+      break;
+    }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L183: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (general_operand (x2, DFmode))
+     {
+       operands[1] = x2;
+       return 36;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L232: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (general_operand (x2, SFmode))
+     {
+       operands[1] = x2;
+       goto L233;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L233: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 1);
+   if (general_operand (x2, SFmode))
+     {
+       operands[2] = x2;
+       return 45;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L266: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (general_operand (x2, SFmode))
+     {
+       operands[1] = x2;
+       goto L267;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L267: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 1);
+   if (general_operand (x2, SFmode))
+     {
+       operands[2] = x2;
+       return 51;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L287: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (general_operand (x2, SFmode))
+     {
+       operands[1] = x2;
+       goto L288;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L288: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 1);
+   if (general_operand (x2, SFmode))
+     {
+       operands[2] = x2;
+       return 55;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L302: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (general_operand (x2, SFmode))
+     {
+       operands[1] = x2;
+       goto L303;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L303: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 1);
+   if (general_operand (x2, SFmode))
+     {
+       operands[2] = x2;
+       return 58;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L423: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (general_operand (x2, SFmode))
+     {
+       operands[1] = x2;
+       return 81;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L439: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (general_operand (x2, SFmode))
+     {
+       operands[1] = x2;
+       return 85;
+     }
+   x1 = XEXP (x0, 0);
+   goto L1;
+ 
+  L2: ATTRIBUTE_UNUSED_LABEL
+   x1 = XEXP (x0, 1);
+   switch (GET_MODE (x1))
+     {
+     case DImode:
+       goto L865;
+     case SImode:
+       goto L866;
+     case HImode:
+       goto L867;
+     default:
+       break;
+     }
+  L17: ATTRIBUTE_UNUSED_LABEL
+   if (GET_CODE (x1) == COMPARE)
+     goto L18;
+   if (general_operand (x1, DFmode))
+     {
+       operands[0] = x1;
+       return 3;
+     }
+  L14: ATTRIBUTE_UNUSED_LABEL
+   if (general_operand (x1, SFmode))
+     {
+       operands[0] = x1;
+       return 4;
+     }
+   x1 = XEXP (x0, 0);
+   goto L759;
+ 
+  L865: ATTRIBUTE_UNUSED_LABEL
+   if (register_operand (x1, DImode))
+     {
+       operands[0] = x1;
+       return 0;
+     }
+   goto L17;
+ 
+  L866: ATTRIBUTE_UNUSED_LABEL
+   if (register_operand (x1, SImode))
+     {
+       operands[0] = x1;
+       return 1;
+     }
+   goto L17;
+ 
+  L867: ATTRIBUTE_UNUSED_LABEL
+   if (register_operand (x1, HImode))
+     {
+       operands[0] = x1;
+       return 2;
+     }
+   goto L17;
+ 
+  L18: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   switch (GET_MODE (x2))
+     {
+     case SImode:
+       goto L868;
+     case HImode:
+       goto L869;
+     case QImode:
+       goto L870;
+     default:
+       break;
+     }
+   if (general_operand (x2, DFmode))
+     {
+       operands[0] = x2;
+       goto L40;
+     }
+  L44: ATTRIBUTE_UNUSED_LABEL
+   if (general_operand (x2, SFmode))
+     {
+       operands[0] = x2;
+       goto L45;
+     }
+   x1 = XEXP (x0, 0);
+   goto L759;
+ 
+  L868: ATTRIBUTE_UNUSED_LABEL
+   if (register_operand (x2, SImode))
+     {
+       operands[0] = x2;
+       goto L19;
+     }
+   x1 = XEXP (x0, 0);
+   goto L759;
+ 
+  L19: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 1);
+   if (general_operand (x2, SImode))
+     {
+       operands[1] = x2;
+       return 5;
+     }
+   x1 = XEXP (x0, 0);
+   goto L759;
+ 
+  L869: ATTRIBUTE_UNUSED_LABEL
+   if (register_operand (x2, HImode))
+     {
+       operands[0] = x2;
+       goto L24;
+     }
+   x1 = XEXP (x0, 0);
+   goto L759;
+ 
+  L24: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 1);
+   if (general_operand (x2, HImode))
+     {
+       operands[1] = x2;
+       return 6;
+     }
+   x1 = XEXP (x0, 0);
+   goto L759;
+ 
+  L870: ATTRIBUTE_UNUSED_LABEL
+   if (r_or_s_operand (x2, QImode))
+     {
+       operands[0] = x2;
+       goto L29;
+     }
+  L871: ATTRIBUTE_UNUSED_LABEL
+   if (register_operand (x2, QImode))
+     {
+       operands[0] = x2;
+       goto L35;
+     }
+   x1 = XEXP (x0, 0);
+   goto L759;
+ 
+  L29: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 1);
+   if (general_operand (x2, QImode))
+     {
+       operands[1] = x2;
+       goto L30;
+     }
+   x2 = XEXP (x1, 0);
+   goto L871;
+ 
+  L30: ATTRIBUTE_UNUSED_LABEL
+   if ((unsigned_jump_follows_p (insn)))
+     {
+       return 7;
+     }
+   x1 = XEXP (x0, 1);
+   x2 = XEXP (x1, 0);
+   goto L871;
+ 
+  L35: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 1);
+   if (general_operand (x2, QImode))
+     {
+       operands[1] = x2;
+       return 8;
+     }
+   x1 = XEXP (x0, 0);
+   goto L759;
+ 
+  L40: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 1);
+   if (general_operand (x2, DFmode))
+     {
+       operands[1] = x2;
+       return 9;
+     }
+   x2 = XEXP (x1, 0);
+   goto L44;
+ 
+  L45: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 1);
+   if (general_operand (x2, SFmode))
+     {
+       operands[1] = x2;
+       return 10;
+     }
+   x1 = XEXP (x0, 0);
+   goto L759;
+ 
+  L97: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (nonimmediate_operand (x2, HImode))
+     {
+       operands[0] = x2;
+       goto L98;
+     }
+   goto L759;
+ 
+  L98: ATTRIBUTE_UNUSED_LABEL
+   x1 = XEXP (x0, 1);
+   if (general_operand (x1, HImode))
+     {
+       operands[1] = x1;
+       return 20;
+     }
+   x1 = XEXP (x0, 0);
+   goto L759;
+ 
+  L529: ATTRIBUTE_UNUSED_LABEL
+   x1 = XEXP (x0, 1);
+   switch (GET_CODE (x1))
+     {
+     case IF_THEN_ELSE:
+       goto L530;
+     case LABEL_REF:
+       goto L744;
+     default:
+      break;
+    }
+  L747: ATTRIBUTE_UNUSED_LABEL
+   if (general_operand (x1, SImode))
+     {
+       operands[0] = x1;
+       return 127;
+     }
+   x1 = XEXP (x0, 0);
+   goto L759;
+ 
+  L530: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   switch (GET_CODE (x2))
+     {
+     case EQ:
+       goto L531;
+     case NE:
+       goto L540;
+     case GT:
+       goto L549;
+     case GTU:
+       goto L558;
+     case LT:
+       goto L567;
+     case LTU:
+       goto L576;
+     case GE:
+       goto L585;
+     case GEU:
+       goto L594;
+     case LE:
+       goto L603;
+     case LEU:
+       goto L612;
+     default:
+      break;
+    }
+   x1 = XEXP (x0, 0);
+   goto L759;
+ 
+  L531: ATTRIBUTE_UNUSED_LABEL
+   x3 = XEXP (x2, 0);
+   if (GET_CODE (x3) == CC0)
+     goto L532;
+   x1 = XEXP (x0, 0);
+   goto L759;
+ 
+  L532: ATTRIBUTE_UNUSED_LABEL
+   x3 = XEXP (x2, 1);
+   if (GET_CODE (x3) == CONST_INT
+       && XWINT (x3, 0) == 0)
+     goto L533;
+   x1 = XEXP (x0, 0);
+   goto L759;
+ 
+  L533: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 1);
+   switch (GET_CODE (x2))
+     {
+     case LABEL_REF:
+       goto L534;
+     case PC:
+       goto L624;
+     default:
+      break;
+    }
+   x1 = XEXP (x0, 0);
+   goto L759;
+ 
+  L534: ATTRIBUTE_UNUSED_LABEL
+   x3 = XEXP (x2, 0);
+   operands[0] = x3;
+   goto L535;
+ 
+  L535: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 2);
+   if (GET_CODE (x2) == PC)
+     {
+       return 104;
+     }
+   x1 = XEXP (x0, 0);
+   goto L759;
+ 
+  L624: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 2);
+   if (GET_CODE (x2) == LABEL_REF)
+     goto L625;
+   x1 = XEXP (x0, 0);
+   goto L759;
+ 
+  L625: ATTRIBUTE_UNUSED_LABEL
+   x3 = XEXP (x2, 0);
+   operands[0] = x3;
+   return 114;
+ 
+  L540: ATTRIBUTE_UNUSED_LABEL
+   x3 = XEXP (x2, 0);
+   if (GET_CODE (x3) == CC0)
+     goto L541;
+   x1 = XEXP (x0, 0);
+   goto L759;
+ 
+  L541: ATTRIBUTE_UNUSED_LABEL
+   x3 = XEXP (x2, 1);
+   if (GET_CODE (x3) == CONST_INT
+       && XWINT (x3, 0) == 0)
+     goto L542;
+   x1 = XEXP (x0, 0);
+   goto L759;
+ 
+  L542: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 1);
+   switch (GET_CODE (x2))
+     {
+     case LABEL_REF:
+       goto L543;
+     case PC:
+       goto L633;
+     default:
+      break;
+    }
+   x1 = XEXP (x0, 0);
+   goto L759;
+ 
+  L543: ATTRIBUTE_UNUSED_LABEL
+   x3 = XEXP (x2, 0);
+   operands[0] = x3;
+   goto L544;
+ 
+  L544: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 2);
+   if (GET_CODE (x2) == PC)
+     {
+       return 105;
+     }
+   x1 = XEXP (x0, 0);
+   goto L759;
+ 
+  L633: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 2);
+   if (GET_CODE (x2) == LABEL_REF)
+     goto L634;
+   x1 = XEXP (x0, 0);
+   goto L759;
+ 
+  L634: ATTRIBUTE_UNUSED_LABEL
+   x3 = XEXP (x2, 0);
+   operands[0] = x3;
+   return 115;
+ 
+  L549: ATTRIBUTE_UNUSED_LABEL
+   x3 = XEXP (x2, 0);
+   if (GET_CODE (x3) == CC0)
+     goto L550;
+   x1 = XEXP (x0, 0);
+   goto L759;
+ 
+  L550: ATTRIBUTE_UNUSED_LABEL
+   x3 = XEXP (x2, 1);
+   if (GET_CODE (x3) == CONST_INT
+       && XWINT (x3, 0) == 0)
+     goto L551;
+   x1 = XEXP (x0, 0);
+   goto L759;
+ 
+  L551: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 1);
+   switch (GET_CODE (x2))
+     {
+     case LABEL_REF:
+       goto L552;
+     case PC:
+       goto L642;
+     default:
+      break;
+    }
+   x1 = XEXP (x0, 0);
+   goto L759;
+ 
+  L552: ATTRIBUTE_UNUSED_LABEL
+   x3 = XEXP (x2, 0);
+   operands[0] = x3;
+   goto L553;
+ 
+  L553: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 2);
+   if (GET_CODE (x2) == PC)
+     {
+       return 106;
+     }
+   x1 = XEXP (x0, 0);
+   goto L759;
+ 
+  L642: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 2);
+   if (GET_CODE (x2) == LABEL_REF)
+     goto L643;
+   x1 = XEXP (x0, 0);
+   goto L759;
+ 
+  L643: ATTRIBUTE_UNUSED_LABEL
+   x3 = XEXP (x2, 0);
+   operands[0] = x3;
+   return 116;
+ 
+  L558: ATTRIBUTE_UNUSED_LABEL
+   x3 = XEXP (x2, 0);
+   if (GET_CODE (x3) == CC0)
+     goto L559;
+   x1 = XEXP (x0, 0);
+   goto L759;
+ 
+  L559: ATTRIBUTE_UNUSED_LABEL
+   x3 = XEXP (x2, 1);
+   if (GET_CODE (x3) == CONST_INT
+       && XWINT (x3, 0) == 0)
+     goto L560;
+   x1 = XEXP (x0, 0);
+   goto L759;
+ 
+  L560: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 1);
+   switch (GET_CODE (x2))
+     {
+     case LABEL_REF:
+       goto L561;
+     case PC:
+       goto L651;
+     default:
+      break;
+    }
+   x1 = XEXP (x0, 0);
+   goto L759;
+ 
+  L561: ATTRIBUTE_UNUSED_LABEL
+   x3 = XEXP (x2, 0);
+   operands[0] = x3;
+   goto L562;
+ 
+  L562: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 2);
+   if (GET_CODE (x2) == PC)
+     {
+       return 107;
+     }
+   x1 = XEXP (x0, 0);
+   goto L759;
+ 
+  L651: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 2);
+   if (GET_CODE (x2) == LABEL_REF)
+     goto L652;
+   x1 = XEXP (x0, 0);
+   goto L759;
+ 
+  L652: ATTRIBUTE_UNUSED_LABEL
+   x3 = XEXP (x2, 0);
+   operands[0] = x3;
+   return 117;
+ 
+  L567: ATTRIBUTE_UNUSED_LABEL
+   x3 = XEXP (x2, 0);
+   if (GET_CODE (x3) == CC0)
+     goto L568;
+   x1 = XEXP (x0, 0);
+   goto L759;
+ 
+  L568: ATTRIBUTE_UNUSED_LABEL
+   x3 = XEXP (x2, 1);
+   if (GET_CODE (x3) == CONST_INT
+       && XWINT (x3, 0) == 0)
+     goto L569;
+   x1 = XEXP (x0, 0);
+   goto L759;
+ 
+  L569: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 1);
+   switch (GET_CODE (x2))
+     {
+     case LABEL_REF:
+       goto L570;
+     case PC:
+       goto L660;
+     default:
+      break;
+    }
+   x1 = XEXP (x0, 0);
+   goto L759;
+ 
+  L570: ATTRIBUTE_UNUSED_LABEL
+   x3 = XEXP (x2, 0);
+   operands[0] = x3;
+   goto L571;
+ 
+  L571: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 2);
+   if (GET_CODE (x2) == PC)
+     {
+       return 108;
+     }
+   x1 = XEXP (x0, 0);
+   goto L759;
+ 
+  L660: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 2);
+   if (GET_CODE (x2) == LABEL_REF)
+     goto L661;
+   x1 = XEXP (x0, 0);
+   goto L759;
+ 
+  L661: ATTRIBUTE_UNUSED_LABEL
+   x3 = XEXP (x2, 0);
+   operands[0] = x3;
+   return 118;
+ 
+  L576: ATTRIBUTE_UNUSED_LABEL
+   x3 = XEXP (x2, 0);
+   if (GET_CODE (x3) == CC0)
+     goto L577;
+   x1 = XEXP (x0, 0);
+   goto L759;
+ 
+  L577: ATTRIBUTE_UNUSED_LABEL
+   x3 = XEXP (x2, 1);
+   if (GET_CODE (x3) == CONST_INT
+       && XWINT (x3, 0) == 0)
+     goto L578;
+   x1 = XEXP (x0, 0);
+   goto L759;
+ 
+  L578: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 1);
+   switch (GET_CODE (x2))
+     {
+     case LABEL_REF:
+       goto L579;
+     case PC:
+       goto L669;
+     default:
+      break;
+    }
+   x1 = XEXP (x0, 0);
+   goto L759;
+ 
+  L579: ATTRIBUTE_UNUSED_LABEL
+   x3 = XEXP (x2, 0);
+   operands[0] = x3;
+   goto L580;
+ 
+  L580: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 2);
+   if (GET_CODE (x2) == PC)
+     {
+       return 109;
+     }
+   x1 = XEXP (x0, 0);
+   goto L759;
+ 
+  L669: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 2);
+   if (GET_CODE (x2) == LABEL_REF)
+     goto L670;
+   x1 = XEXP (x0, 0);
+   goto L759;
+ 
+  L670: ATTRIBUTE_UNUSED_LABEL
+   x3 = XEXP (x2, 0);
+   operands[0] = x3;
+   return 119;
+ 
+  L585: ATTRIBUTE_UNUSED_LABEL
+   x3 = XEXP (x2, 0);
+   if (GET_CODE (x3) == CC0)
+     goto L586;
+   x1 = XEXP (x0, 0);
+   goto L759;
+ 
+  L586: ATTRIBUTE_UNUSED_LABEL
+   x3 = XEXP (x2, 1);
+   if (GET_CODE (x3) == CONST_INT
+       && XWINT (x3, 0) == 0)
+     goto L587;
+   x1 = XEXP (x0, 0);
+   goto L759;
+ 
+  L587: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 1);
+   switch (GET_CODE (x2))
+     {
+     case LABEL_REF:
+       goto L588;
+     case PC:
+       goto L678;
+     default:
+      break;
+    }
+   x1 = XEXP (x0, 0);
+   goto L759;
+ 
+  L588: ATTRIBUTE_UNUSED_LABEL
+   x3 = XEXP (x2, 0);
+   operands[0] = x3;
+   goto L589;
+ 
+  L589: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 2);
+   if (GET_CODE (x2) == PC)
+     {
+       return 110;
+     }
+   x1 = XEXP (x0, 0);
+   goto L759;
+ 
+  L678: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 2);
+   if (GET_CODE (x2) == LABEL_REF)
+     goto L679;
+   x1 = XEXP (x0, 0);
+   goto L759;
+ 
+  L679: ATTRIBUTE_UNUSED_LABEL
+   x3 = XEXP (x2, 0);
+   operands[0] = x3;
+   return 120;
+ 
+  L594: ATTRIBUTE_UNUSED_LABEL
+   x3 = XEXP (x2, 0);
+   if (GET_CODE (x3) == CC0)
+     goto L595;
+   x1 = XEXP (x0, 0);
+   goto L759;
+ 
+  L595: ATTRIBUTE_UNUSED_LABEL
+   x3 = XEXP (x2, 1);
+   if (GET_CODE (x3) == CONST_INT
+       && XWINT (x3, 0) == 0)
+     goto L596;
+   x1 = XEXP (x0, 0);
+   goto L759;
+ 
+  L596: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 1);
+   switch (GET_CODE (x2))
+     {
+     case LABEL_REF:
+       goto L597;
+     case PC:
+       goto L687;
+     default:
+      break;
+    }
+   x1 = XEXP (x0, 0);
+   goto L759;
+ 
+  L597: ATTRIBUTE_UNUSED_LABEL
+   x3 = XEXP (x2, 0);
+   operands[0] = x3;
+   goto L598;
+ 
+  L598: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 2);
+   if (GET_CODE (x2) == PC)
+     {
+       return 111;
+     }
+   x1 = XEXP (x0, 0);
+   goto L759;
+ 
+  L687: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 2);
+   if (GET_CODE (x2) == LABEL_REF)
+     goto L688;
+   x1 = XEXP (x0, 0);
+   goto L759;
+ 
+  L688: ATTRIBUTE_UNUSED_LABEL
+   x3 = XEXP (x2, 0);
+   operands[0] = x3;
+   return 121;
+ 
+  L603: ATTRIBUTE_UNUSED_LABEL
+   x3 = XEXP (x2, 0);
+   if (GET_CODE (x3) == CC0)
+     goto L604;
+   x1 = XEXP (x0, 0);
+   goto L759;
+ 
+  L604: ATTRIBUTE_UNUSED_LABEL
+   x3 = XEXP (x2, 1);
+   if (GET_CODE (x3) == CONST_INT
+       && XWINT (x3, 0) == 0)
+     goto L605;
+   x1 = XEXP (x0, 0);
+   goto L759;
+ 
+  L605: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 1);
+   switch (GET_CODE (x2))
+     {
+     case LABEL_REF:
+       goto L606;
+     case PC:
+       goto L696;
+     default:
+      break;
+    }
+   x1 = XEXP (x0, 0);
+   goto L759;
+ 
+  L606: ATTRIBUTE_UNUSED_LABEL
+   x3 = XEXP (x2, 0);
+   operands[0] = x3;
+   goto L607;
+ 
+  L607: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 2);
+   if (GET_CODE (x2) == PC)
+     {
+       return 112;
+     }
+   x1 = XEXP (x0, 0);
+   goto L759;
+ 
+  L696: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 2);
+   if (GET_CODE (x2) == LABEL_REF)
+     goto L697;
+   x1 = XEXP (x0, 0);
+   goto L759;
+ 
+  L697: ATTRIBUTE_UNUSED_LABEL
+   x3 = XEXP (x2, 0);
+   operands[0] = x3;
+   return 122;
+ 
+  L612: ATTRIBUTE_UNUSED_LABEL
+   x3 = XEXP (x2, 0);
+   if (GET_CODE (x3) == CC0)
+     goto L613;
+   x1 = XEXP (x0, 0);
+   goto L759;
+ 
+  L613: ATTRIBUTE_UNUSED_LABEL
+   x3 = XEXP (x2, 1);
+   if (GET_CODE (x3) == CONST_INT
+       && XWINT (x3, 0) == 0)
+     goto L614;
+   x1 = XEXP (x0, 0);
+   goto L759;
+ 
+  L614: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 1);
+   switch (GET_CODE (x2))
+     {
+     case LABEL_REF:
+       goto L615;
+     case PC:
+       goto L705;
+     default:
+      break;
+    }
+   x1 = XEXP (x0, 0);
+   goto L759;
+ 
+  L615: ATTRIBUTE_UNUSED_LABEL
+   x3 = XEXP (x2, 0);
+   operands[0] = x3;
+   goto L616;
+ 
+  L616: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 2);
+   if (GET_CODE (x2) == PC)
+     {
+       return 113;
+     }
+   x1 = XEXP (x0, 0);
+   goto L759;
+ 
+  L705: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 2);
+   if (GET_CODE (x2) == LABEL_REF)
+     goto L706;
+   x1 = XEXP (x0, 0);
+   goto L759;
+ 
+  L706: ATTRIBUTE_UNUSED_LABEL
+   x3 = XEXP (x2, 0);
+   operands[0] = x3;
+   return 123;
+ 
+  L744: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   operands[0] = x2;
+   return 126;
+ 
+  L760: ATTRIBUTE_UNUSED_LABEL
+   x1 = XEXP (x0, 1);
+   if (GET_CODE (x1) == CALL)
+     goto L761;
+   goto ret0;
+ 
+  L761: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (GET_MODE (x2) == QImode)
+     goto L872;
+   goto ret0;
+ 
+  L872: ATTRIBUTE_UNUSED_LABEL
+   if (memory_operand (x2, QImode))
+     {
+       operands[1] = x2;
+       goto L762;
+     }
+  L873: ATTRIBUTE_UNUSED_LABEL
+   if (GET_CODE (x2) == MEM)
+     goto L772;
+   goto ret0;
+ 
+  L762: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 1);
+   if (general_operand (x2, SImode))
+     {
+       operands[2] = x2;
+       return 130;
+     }
+   x2 = XEXP (x1, 0);
+   goto L873;
+ 
+  L772: ATTRIBUTE_UNUSED_LABEL
+   x3 = XEXP (x2, 0);
+   operands[1] = x3;
+   goto L773;
+ 
+  L773: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 1);
+   if (general_operand (x2, SImode))
+     {
+       operands[2] = x2;
+       goto L774;
+     }
+   goto ret0;
+ 
+  L774: ATTRIBUTE_UNUSED_LABEL
+   if ((GET_CODE (operands[1]) == SYMBOL_REF))
+     {
+       return 132;
+     }
+   goto ret0;
+  ret0:
+   return -1;
+ }
+ 
+ int recog PARAMS ((rtx, rtx, int *));
+ int
+ recog (x0, insn, pnum_clobbers)
+      rtx x0 ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+      int *pnum_clobbers ATTRIBUTE_UNUSED;
+ {
+   rtx * const operands ATTRIBUTE_UNUSED = &recog_data.operand[0];
+   rtx x1 ATTRIBUTE_UNUSED;
+   rtx x2 ATTRIBUTE_UNUSED;
+   rtx x3 ATTRIBUTE_UNUSED;
+   rtx x4 ATTRIBUTE_UNUSED;
+   rtx x5 ATTRIBUTE_UNUSED;
+   int tem ATTRIBUTE_UNUSED;
+   recog_data.insn = NULL_RTX;
+ 
+   switch (GET_CODE (x0))
+     {
+     case SET:
+       goto L72;
+     case PARALLEL:
+       goto L776;
+     case CALL:
+       goto L756;
+     case CONST_INT:
+       goto L778;
+     default:
+      break;
+    }
+   goto ret0;
+ 
+  L72: ATTRIBUTE_UNUSED_LABEL
+   return recog_1 (x0, insn, pnum_clobbers);
+ 
+  L776: ATTRIBUTE_UNUSED_LABEL
+   switch (XVECLEN (x0, 0))
+     {
+     case 2:
+       goto L47;
+     case 5:
+       goto L56;
+     default:
+       break;
+     }
+   goto ret0;
+ 
+  L47: ATTRIBUTE_UNUSED_LABEL
+   x1 = XVECEXP (x0, 0, 0);
+   if (GET_CODE (x1) == SET)
+     goto L48;
+   goto ret0;
+ 
+  L48: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   switch (GET_MODE (x2))
+     {
+     case SImode:
+       goto L874;
+     case BLKmode:
+       goto L875;
+     default:
+       break;
+     }
+  L709: ATTRIBUTE_UNUSED_LABEL
+   if (GET_CODE (x2) == PC)
+     goto L710;
+   goto ret0;
+ 
+  L874: ATTRIBUTE_UNUSED_LABEL
+   if (register_operand (x2, SImode))
+     {
+       operands[0] = x2;
+       goto L49;
+     }
+   goto L709;
+ 
+  L49: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 1);
+   if (GET_MODE (x2) == SImode)
+     goto L876;
+   x2 = XEXP (x1, 0);
+   goto L709;
+ 
+  L876: ATTRIBUTE_UNUSED_LABEL
+   switch (GET_CODE (x2))
+     {
+     case COMPARE:
+       goto L50;
+     case FIX:
+       goto L166;
+     case PLUS:
+       goto L192;
+     case MINUS:
+       goto L238;
+     default:
+      break;
+    }
+   x2 = XEXP (x1, 0);
+   goto L709;
+ 
+  L50: ATTRIBUTE_UNUSED_LABEL
+   x3 = XEXP (x2, 0);
+   if (s_operand (x3, BLKmode))
+     {
+       operands[1] = x3;
+       goto L51;
+     }
+   x2 = XEXP (x1, 0);
+   goto L709;
+ 
+  L51: ATTRIBUTE_UNUSED_LABEL
+   x3 = XEXP (x2, 1);
+   if (s_operand (x3, BLKmode))
+     {
+       operands[2] = x3;
+       goto L52;
+     }
+   x2 = XEXP (x1, 0);
+   goto L709;
+ 
+  L52: ATTRIBUTE_UNUSED_LABEL
+   x1 = XVECEXP (x0, 0, 1);
+   if (GET_CODE (x1) == USE)
+     goto L53;
+   x1 = XVECEXP (x0, 0, 0);
+   x2 = XEXP (x1, 0);
+   goto L709;
+ 
+  L53: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (immediate_operand (x2, SImode))
+     {
+       operands[3] = x2;
+       goto L54;
+     }
+   x1 = XVECEXP (x0, 0, 0);
+   x2 = XEXP (x1, 0);
+   goto L709;
+ 
+  L54: ATTRIBUTE_UNUSED_LABEL
+   if ((((unsigned) INTVAL (operands[3]) <= 256)))
+     {
+       return 11;
+     }
+   x1 = XVECEXP (x0, 0, 0);
+   x2 = XEXP (x1, 0);
+   goto L709;
+ 
+  L166: ATTRIBUTE_UNUSED_LABEL
+   x3 = XEXP (x2, 0);
+   if (GET_MODE (x3) == DFmode
+       && GET_CODE (x3) == TRUNCATE)
+     goto L167;
+   x2 = XEXP (x1, 0);
+   goto L709;
+ 
+  L167: ATTRIBUTE_UNUSED_LABEL
+   x4 = XEXP (x3, 0);
+   if (general_operand (x4, DFmode))
+     {
+       operands[1] = x4;
+       goto L168;
+     }
+   x2 = XEXP (x1, 0);
+   goto L709;
+ 
+  L168: ATTRIBUTE_UNUSED_LABEL
+   x1 = XVECEXP (x0, 0, 1);
+   if (GET_CODE (x1) == CLOBBER)
+     goto L169;
+   x1 = XVECEXP (x0, 0, 0);
+   x2 = XEXP (x1, 0);
+   goto L709;
+ 
+  L169: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (GET_MODE (x2) == DFmode
+       && GET_CODE (x2) == REG
+       && XINT (x2, 0) == 16)
+     {
+       return 34;
+     }
+   x1 = XVECEXP (x0, 0, 0);
+   x2 = XEXP (x1, 0);
+   goto L709;
+ 
+  L192: ATTRIBUTE_UNUSED_LABEL
+   x3 = XEXP (x2, 0);
+   if (general_operand (x3, SImode))
+     {
+       operands[1] = x3;
+       goto L193;
+     }
+   x2 = XEXP (x1, 0);
+   goto L709;
+ 
+  L193: ATTRIBUTE_UNUSED_LABEL
+   x3 = XEXP (x2, 1);
+   if (general_operand (x3, SImode))
+     {
+       operands[2] = x3;
+       goto L194;
+     }
+   x2 = XEXP (x1, 0);
+   goto L709;
+ 
+  L194: ATTRIBUTE_UNUSED_LABEL
+   x1 = XVECEXP (x0, 0, 1);
+   if (GET_CODE (x1) == USE)
+     goto L195;
+   x1 = XVECEXP (x0, 0, 0);
+   x2 = XEXP (x1, 0);
+   goto L709;
+ 
+  L195: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (GET_CODE (x2) == LABEL_REF)
+     goto L196;
+   x1 = XVECEXP (x0, 0, 0);
+   x2 = XEXP (x1, 0);
+   goto L709;
+ 
+  L196: ATTRIBUTE_UNUSED_LABEL
+   x3 = XEXP (x2, 0);
+   operands[3] = x3;
+   return 38;
+ 
+  L238: ATTRIBUTE_UNUSED_LABEL
+   x3 = XEXP (x2, 0);
+   if (general_operand (x3, SImode))
+     {
+       operands[1] = x3;
+       goto L239;
+     }
+   x2 = XEXP (x1, 0);
+   goto L709;
+ 
+  L239: ATTRIBUTE_UNUSED_LABEL
+   x3 = XEXP (x2, 1);
+   if (general_operand (x3, SImode))
+     {
+       operands[2] = x3;
+       goto L240;
+     }
+   x2 = XEXP (x1, 0);
+   goto L709;
+ 
+  L240: ATTRIBUTE_UNUSED_LABEL
+   x1 = XVECEXP (x0, 0, 1);
+   if (GET_CODE (x1) == USE)
+     goto L241;
+   x1 = XVECEXP (x0, 0, 0);
+   x2 = XEXP (x1, 0);
+   goto L709;
+ 
+  L241: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (GET_CODE (x2) == LABEL_REF)
+     goto L242;
+   x1 = XVECEXP (x0, 0, 0);
+   x2 = XEXP (x1, 0);
+   goto L709;
+ 
+  L242: ATTRIBUTE_UNUSED_LABEL
+   x3 = XEXP (x2, 0);
+   operands[3] = x3;
+   return 46;
+ 
+  L875: ATTRIBUTE_UNUSED_LABEL
+   if (s_operand (x2, BLKmode))
+     {
+       operands[0] = x2;
+       goto L116;
+     }
+   goto L709;
+ 
+  L116: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 1);
+   if (s_operand (x2, BLKmode))
+     {
+       operands[1] = x2;
+       goto L117;
+     }
+   x2 = XEXP (x1, 0);
+   goto L709;
+ 
+  L117: ATTRIBUTE_UNUSED_LABEL
+   x1 = XVECEXP (x0, 0, 1);
+   if (GET_CODE (x1) == USE)
+     goto L118;
+   x1 = XVECEXP (x0, 0, 0);
+   x2 = XEXP (x1, 0);
+   goto L709;
+ 
+  L118: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (immediate_operand (x2, VOIDmode))
+     {
+       operands[2] = x2;
+       goto L119;
+     }
+   x1 = XVECEXP (x0, 0, 0);
+   x2 = XEXP (x1, 0);
+   goto L709;
+ 
+  L119: ATTRIBUTE_UNUSED_LABEL
+   if ((((unsigned) INTVAL (operands[2]) <= 256)))
+     {
+       return 25;
+     }
+   x1 = XVECEXP (x0, 0, 0);
+   x2 = XEXP (x1, 0);
+   goto L709;
+ 
+  L710: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 1);
+   if (GET_CODE (x2) == IF_THEN_ELSE)
+     goto L711;
+   if (general_operand (x2, SImode))
+     {
+       operands[0] = x2;
+       goto L752;
+     }
+   goto ret0;
+ 
+  L711: ATTRIBUTE_UNUSED_LABEL
+   x3 = XEXP (x2, 0);
+   switch (GET_CODE (x3))
+     {
+     case NE:
+       goto L712;
+     case EQ:
+       goto L729;
+     default:
+      break;
+    }
+   goto ret0;
+ 
+  L712: ATTRIBUTE_UNUSED_LABEL
+   x4 = XEXP (x3, 0);
+   if (GET_MODE (x4) == SImode
+       && GET_CODE (x4) == PLUS)
+     goto L713;
+   goto ret0;
+ 
+  L713: ATTRIBUTE_UNUSED_LABEL
+   x5 = XEXP (x4, 0);
+   if (register_operand (x5, SImode))
+     {
+       operands[0] = x5;
+       goto L714;
+     }
+   goto ret0;
+ 
+  L714: ATTRIBUTE_UNUSED_LABEL
+   x5 = XEXP (x4, 1);
+   if (GET_CODE (x5) == CONST_INT
+       && XWINT (x5, 0) == -1)
+     goto L715;
+   goto ret0;
+ 
+  L715: ATTRIBUTE_UNUSED_LABEL
+   x4 = XEXP (x3, 1);
+   if (GET_CODE (x4) == CONST_INT
+       && XWINT (x4, 0) == 0)
+     goto L716;
+   goto ret0;
+ 
+  L716: ATTRIBUTE_UNUSED_LABEL
+   x3 = XEXP (x2, 1);
+   if (GET_CODE (x3) == LABEL_REF)
+     goto L717;
+   goto ret0;
+ 
+  L717: ATTRIBUTE_UNUSED_LABEL
+   x4 = XEXP (x3, 0);
+   operands[1] = x4;
+   goto L718;
+ 
+  L718: ATTRIBUTE_UNUSED_LABEL
+   x3 = XEXP (x2, 2);
+   if (GET_CODE (x3) == PC)
+     goto L719;
+   goto ret0;
+ 
+  L719: ATTRIBUTE_UNUSED_LABEL
+   x1 = XVECEXP (x0, 0, 1);
+   if (GET_CODE (x1) == SET)
+     goto L720;
+   goto ret0;
+ 
+  L720: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (rtx_equal_p (x2, operands[0]))
+     goto L721;
+   goto ret0;
+ 
+  L721: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 1);
+   if (GET_MODE (x2) == SImode
+       && GET_CODE (x2) == PLUS)
+     goto L722;
+   goto ret0;
+ 
+  L722: ATTRIBUTE_UNUSED_LABEL
+   x3 = XEXP (x2, 0);
+   if (rtx_equal_p (x3, operands[0]))
+     goto L723;
+   goto ret0;
+ 
+  L723: ATTRIBUTE_UNUSED_LABEL
+   x3 = XEXP (x2, 1);
+   if (GET_CODE (x3) == CONST_INT
+       && XWINT (x3, 0) == -1)
+     {
+       return 124;
+     }
+   goto ret0;
+ 
+  L729: ATTRIBUTE_UNUSED_LABEL
+   x4 = XEXP (x3, 0);
+   if (GET_MODE (x4) == SImode
+       && GET_CODE (x4) == PLUS)
+     goto L730;
+   goto ret0;
+ 
+  L730: ATTRIBUTE_UNUSED_LABEL
+   x5 = XEXP (x4, 0);
+   if (register_operand (x5, SImode))
+     {
+       operands[0] = x5;
+       goto L731;
+     }
+   goto ret0;
+ 
+  L731: ATTRIBUTE_UNUSED_LABEL
+   x5 = XEXP (x4, 1);
+   if (GET_CODE (x5) == CONST_INT
+       && XWINT (x5, 0) == -1)
+     goto L732;
+   goto ret0;
+ 
+  L732: ATTRIBUTE_UNUSED_LABEL
+   x4 = XEXP (x3, 1);
+   if (GET_CODE (x4) == CONST_INT
+       && XWINT (x4, 0) == 0)
+     goto L733;
+   goto ret0;
+ 
+  L733: ATTRIBUTE_UNUSED_LABEL
+   x3 = XEXP (x2, 1);
+   if (GET_CODE (x3) == PC)
+     goto L734;
+   goto ret0;
+ 
+  L734: ATTRIBUTE_UNUSED_LABEL
+   x3 = XEXP (x2, 2);
+   if (GET_CODE (x3) == LABEL_REF)
+     goto L735;
+   goto ret0;
+ 
+  L735: ATTRIBUTE_UNUSED_LABEL
+   x4 = XEXP (x3, 0);
+   operands[1] = x4;
+   goto L736;
+ 
+  L736: ATTRIBUTE_UNUSED_LABEL
+   x1 = XVECEXP (x0, 0, 1);
+   if (GET_CODE (x1) == SET)
+     goto L737;
+   goto ret0;
+ 
+  L737: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (rtx_equal_p (x2, operands[0]))
+     goto L738;
+   goto ret0;
+ 
+  L738: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 1);
+   if (GET_MODE (x2) == SImode
+       && GET_CODE (x2) == PLUS)
+     goto L739;
+   goto ret0;
+ 
+  L739: ATTRIBUTE_UNUSED_LABEL
+   x3 = XEXP (x2, 0);
+   if (rtx_equal_p (x3, operands[0]))
+     goto L740;
+   goto ret0;
+ 
+  L740: ATTRIBUTE_UNUSED_LABEL
+   x3 = XEXP (x2, 1);
+   if (GET_CODE (x3) == CONST_INT
+       && XWINT (x3, 0) == -1)
+     {
+       return 125;
+     }
+   goto ret0;
+ 
+  L752: ATTRIBUTE_UNUSED_LABEL
+   x1 = XVECEXP (x0, 0, 1);
+   if (GET_CODE (x1) == USE)
+     goto L753;
+   goto ret0;
+ 
+  L753: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (GET_CODE (x2) == LABEL_REF)
+     goto L754;
+   goto ret0;
+ 
+  L754: ATTRIBUTE_UNUSED_LABEL
+   x3 = XEXP (x2, 0);
+   operands[1] = x3;
+   return 128;
+ 
+  L56: ATTRIBUTE_UNUSED_LABEL
+   x1 = XVECEXP (x0, 0, 0);
+   if (GET_CODE (x1) == SET)
+     goto L57;
+   goto ret0;
+ 
+  L57: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   switch (GET_MODE (x2))
+     {
+     case SImode:
+       goto L880;
+     case BLKmode:
+       goto L881;
+     default:
+       break;
+     }
+   goto ret0;
+ 
+  L880: ATTRIBUTE_UNUSED_LABEL
+   if (register_operand (x2, SImode))
+     {
+       operands[0] = x2;
+       goto L58;
+     }
+   goto ret0;
+ 
+  L58: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 1);
+   if (GET_MODE (x2) == SImode
+       && GET_CODE (x2) == COMPARE)
+     goto L59;
+   goto ret0;
+ 
+  L59: ATTRIBUTE_UNUSED_LABEL
+   x3 = XEXP (x2, 0);
+   if (GET_MODE (x3) == BLKmode
+       && GET_CODE (x3) == MEM)
+     goto L60;
+   goto ret0;
+ 
+  L60: ATTRIBUTE_UNUSED_LABEL
+   x4 = XEXP (x3, 0);
+   if (register_operand (x4, DImode))
+     {
+       operands[1] = x4;
+       goto L61;
+     }
+   goto ret0;
+ 
+  L61: ATTRIBUTE_UNUSED_LABEL
+   x3 = XEXP (x2, 1);
+   if (GET_MODE (x3) == BLKmode
+       && GET_CODE (x3) == MEM)
+     goto L62;
+   goto ret0;
+ 
+  L62: ATTRIBUTE_UNUSED_LABEL
+   x4 = XEXP (x3, 0);
+   if (register_operand (x4, DImode))
+     {
+       operands[2] = x4;
+       goto L63;
+     }
+   goto ret0;
+ 
+  L63: ATTRIBUTE_UNUSED_LABEL
+   x1 = XVECEXP (x0, 0, 1);
+   if (GET_CODE (x1) == USE)
+     goto L64;
+   goto ret0;
+ 
+  L64: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (rtx_equal_p (x2, operands[1]))
+     goto L65;
+   goto ret0;
+ 
+  L65: ATTRIBUTE_UNUSED_LABEL
+   x1 = XVECEXP (x0, 0, 2);
+   if (GET_CODE (x1) == USE)
+     goto L66;
+   goto ret0;
+ 
+  L66: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (rtx_equal_p (x2, operands[2]))
+     goto L67;
+   goto ret0;
+ 
+  L67: ATTRIBUTE_UNUSED_LABEL
+   x1 = XVECEXP (x0, 0, 3);
+   if (GET_CODE (x1) == CLOBBER)
+     goto L68;
+   goto ret0;
+ 
+  L68: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (rtx_equal_p (x2, operands[1]))
+     goto L69;
+   goto ret0;
+ 
+  L69: ATTRIBUTE_UNUSED_LABEL
+   x1 = XVECEXP (x0, 0, 4);
+   if (GET_CODE (x1) == CLOBBER)
+     goto L70;
+   goto ret0;
+ 
+  L70: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (rtx_equal_p (x2, operands[2]))
+     {
+       return 12;
+     }
+   goto ret0;
+ 
+  L881: ATTRIBUTE_UNUSED_LABEL
+   if (GET_CODE (x2) == MEM)
+     goto L123;
+   goto ret0;
+ 
+  L123: ATTRIBUTE_UNUSED_LABEL
+   x3 = XEXP (x2, 0);
+   if (register_operand (x3, DImode))
+     {
+       operands[0] = x3;
+       goto L124;
+     }
+   goto ret0;
+ 
+  L124: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 1);
+   if (GET_MODE (x2) == BLKmode
+       && GET_CODE (x2) == MEM)
+     goto L125;
+   goto ret0;
+ 
+  L125: ATTRIBUTE_UNUSED_LABEL
+   x3 = XEXP (x2, 0);
+   if (register_operand (x3, DImode))
+     {
+       operands[1] = x3;
+       goto L126;
+     }
+   goto ret0;
+ 
+  L126: ATTRIBUTE_UNUSED_LABEL
+   x1 = XVECEXP (x0, 0, 1);
+   if (GET_CODE (x1) == USE)
+     goto L127;
+   goto ret0;
+ 
+  L127: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (rtx_equal_p (x2, operands[0]))
+     goto L128;
+   goto ret0;
+ 
+  L128: ATTRIBUTE_UNUSED_LABEL
+   x1 = XVECEXP (x0, 0, 2);
+   if (GET_CODE (x1) == USE)
+     goto L129;
+   goto ret0;
+ 
+  L129: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (rtx_equal_p (x2, operands[1]))
+     goto L130;
+   goto ret0;
+ 
+  L130: ATTRIBUTE_UNUSED_LABEL
+   x1 = XVECEXP (x0, 0, 3);
+   if (GET_CODE (x1) == CLOBBER)
+     goto L131;
+   goto ret0;
+ 
+  L131: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (rtx_equal_p (x2, operands[0]))
+     goto L132;
+   goto ret0;
+ 
+  L132: ATTRIBUTE_UNUSED_LABEL
+   x1 = XVECEXP (x0, 0, 4);
+   if (GET_CODE (x1) == CLOBBER)
+     goto L133;
+   goto ret0;
+ 
+  L133: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   if (rtx_equal_p (x2, operands[1]))
+     {
+       return 26;
+     }
+   goto ret0;
+ 
+  L756: ATTRIBUTE_UNUSED_LABEL
+   x1 = XEXP (x0, 0);
+   if (GET_MODE (x1) == QImode)
+     goto L882;
+   goto ret0;
+ 
+  L882: ATTRIBUTE_UNUSED_LABEL
+   if (memory_operand (x1, QImode))
+     {
+       operands[0] = x1;
+       goto L757;
+     }
+  L883: ATTRIBUTE_UNUSED_LABEL
+   if (GET_CODE (x1) == MEM)
+     goto L765;
+   goto ret0;
+ 
+  L757: ATTRIBUTE_UNUSED_LABEL
+   x1 = XEXP (x0, 1);
+   if (immediate_operand (x1, SImode))
+     {
+       operands[1] = x1;
+       return 129;
+     }
+   x1 = XEXP (x0, 0);
+   goto L883;
+ 
+  L765: ATTRIBUTE_UNUSED_LABEL
+   x2 = XEXP (x1, 0);
+   operands[0] = x2;
+   goto L766;
+ 
+  L766: ATTRIBUTE_UNUSED_LABEL
+   x1 = XEXP (x0, 1);
+   if (general_operand (x1, SImode))
+     {
+       operands[1] = x1;
+       goto L767;
+     }
+   goto ret0;
+ 
+  L767: ATTRIBUTE_UNUSED_LABEL
+   if ((GET_CODE (operands[0]) == SYMBOL_REF))
+     {
+       return 131;
+     }
+   goto ret0;
+ 
+  L778: ATTRIBUTE_UNUSED_LABEL
+   if (XWINT (x0, 0) == 0)
+     {
+       return 133;
+     }
+   goto ret0;
+  ret0:
+   return -1;
+ }
+ 
+ rtx split_insns PARAMS ((rtx, rtx));
+ rtx
+ split_insns (x0, insn)
+      rtx x0 ATTRIBUTE_UNUSED;
+      rtx insn ATTRIBUTE_UNUSED;
+ {
+   rtx * const operands ATTRIBUTE_UNUSED = &recog_data.operand[0];
+   rtx x1 ATTRIBUTE_UNUSED;
+   rtx x2 ATTRIBUTE_UNUSED;
+   rtx x3 ATTRIBUTE_UNUSED;
+   rtx x4 ATTRIBUTE_UNUSED;
+   rtx x5 ATTRIBUTE_UNUSED;
+   rtx tem ATTRIBUTE_UNUSED;
+   recog_data.insn = NULL_RTX;
+   goto ret0;
+  ret0:
+   return 0;
+ }
+ 
Index: gcc/gcc/instvse.bat
diff -c nul gcc/gcc/instvse.bat:1.1
*** nul	Tue Oct 01 16:28:46 2019
--- gcc/gcc/instvse.bat	Fri Dec 31 22:49:44 2010
***************
*** 0 ****
--- 1 ----
+ call runvse instvse.jcl outputi.txt gccvse-exe.obj
Index: gcc/gcc/instvse.jcl
diff -c nul gcc/gcc/instvse.jcl:1.4
*** nul	Tue Oct 01 16:28:46 2019
--- gcc/gcc/instvse.jcl	Sat Jan 01 02:19:15 2011
***************
*** 0 ****
--- 1,157 ----
+ * $$ JOB JNM=VSEJOB
+ * $$ LST LST=SYSLST,CLASS=A,RBM=999999
+ // JOB VSEJOB
+ *
+ *
+ * Install GCCVSE
+ *
+ * Note that the first step to get the file off tape should
+ * instead be changed to whatever is suitable for your site.
+ * Also note that this puts stuff into the system CIL.
+ *
+ * 10000,2000 SPACE-PHASE
+ * 12000,1000 SPACE-PUNCH
+ *
+ *
+ *
+ * Standard assignments for C programs
+ *
+ // ASSGN SYS000,SYSLNK
+ // ASSGN SYS005,SYSLST
+ // ASSGN SYS007,SYSPCH
+ // OPTION DUMP
+ *
+ *
+ *
+ *
+ * First we get the main phases off tape, and into 80-byte blocks
+ * using objmaint
+ *
+ // UPSI 1
+ // ASSGN SYS004,TAPE
+ // DLBL UOUT,'PDPPUNCH.DAT',0,SD
+ // EXTENT SYS005,,,,10000,2000 SPACE-PHASE
+ // ASSGN SYS005,SYS000
+ // EXEC OBJMAINT,SIZE=AUTO
+ ./COPY
+ /*
+ // UPSI 0
+ // ASSGN SYS005,SYSLST
+ // ASSGN SYS004,UA
+ *
+ *
+ *
+ *
+ *
+ *
+ *
+ * Then we put the phases into the CIL, using LNKEDT
+ *
+ // DLBL IJSYSLN,,0,SD
+ // EXTENT SYSLNK,,,,12000,2000 SPACE-LINK
+ ASSGN SYSLNK,SYS000
+ // OPTION CATAL
+ // DLBL IJSYSIN,'PDPPUNCH.DAT'
+ ASSGN SYSIPT,SYS000
+  INCLUDE
+ CLOSE SYSIPT,READER
+ // EXEC LNKEDT
+ ASSGN SYSLNK,UA
+ *
+ *
+ *
+ *
+ *
+ * Now we get a single punched file (object code) out of the CIL
+ *
+ // DLBL SDO1,'PDPPUNCH.DAT',0,SD
+ // EXTENT SYS000,,,,10000,2000 SPACE-PHASE
+ // EXEC COPYFILE,SIZE=AUTO,PARM='-bb dd:in(pdpobj) dd:sdo1f80'
+ *
+ *
+ *
+ * And then stick that into the relocatable library using MAINT
+ *
+ // DLBL IJSYSIN,'PDPPUNCH.DAT'
+ ASSGN SYSIPT,SYS000
+ // EXEC MAINT                                         
+ CLOSE SYSIPT,READER
+ *
+ *
+ *
+ *
+ *
+ *
+ * Now we get a single punched file (header files) out of the CIL
+ *
+ // DLBL SDO1,'PDPPUNCH.DAT',0,SD
+ // EXTENT SYS000,,,,10000,2000 SPACE-PHASE
+ // EXEC COPYFILE,SIZE=AUTO,PARM='-bb dd:in(pdpi) dd:sdo1f80'
+ *
+ *
+ *
+ * And then stick that into the CIL using LNKEDT
+ *
+ * Then we put the phases into the CIL, using LNKEDT
+ *
+ // DLBL IJSYSLN,,0,SD
+ // EXTENT SYSLNK,,,,12000,2000 SPACE-LINK
+ ASSGN SYSLNK,SYS000
+ // OPTION CATAL
+ // DLBL IJSYSIN,'PDPPUNCH.DAT'
+ ASSGN SYSIPT,SYS000
+  INCLUDE
+ CLOSE SYSIPT,READER
+ // EXEC LNKEDT
+ ASSGN SYSLNK,UA
+ *
+ *
+ *
+ *
+ *
+ *
+ *
+ *
+ * Now we get a single punched file (copybooks) out of the CIL
+ *
+ // DLBL SDO1,'PDPPUNCH.DAT',0,SD
+ // EXTENT SYS000,,,,10000,2000 SPACE-PHASE
+ // EXEC COPYFILE,SIZE=AUTO,PARM='-bb dd:in(pdpcopy) dd:sdo1f80'
+ *
+ *
+ *
+ * And then stick that into the source statement library using MAINT
+ *
+ // DLBL IJSYSIN,'PDPPUNCH.DAT'
+ ASSGN SYSIPT,SYS000
+ // EXEC MAINT                                         
+ CLOSE SYSIPT,READER
+ *
+ *
+ *
+ *
+ *
+ *
+ * Now we get a single punched file (macros) out of the CIL
+ *
+ // DLBL SDO1,'PDPPUNCH.DAT',0,SD
+ // EXTENT SYS000,,,,10000,2000 SPACE-PHASE
+ // EXEC COPYFILE,SIZE=AUTO,PARM='-bb dd:in(pdpmacs) dd:sdo1f80'
+ *
+ *
+ *
+ *
+ * Put them into the assembler macro library
+ *
+ // DLBL IJSYSIN,'PDPPUNCH.DAT'
+ ASSGN SYSIPT,SYS000
+ // EXEC MAINT
+ CLOSE SYSIPT,READER
+ *
+ *
+ *
+ *
+ *
+ *
+ /&
+ * $$ EOJ
Index: gcc/gcc/itergcc.exec
diff -c nul gcc/gcc/itergcc.exec:1.1
*** nul	Tue Oct 01 16:28:46 2019
--- gcc/gcc/itergcc.exec	Thu Oct 23 17:05:04 2008
***************
*** 0 ****
--- 1,189 ----
+ *******************************************************************
+ *
+ * This EXEC iterates over all the assembler source
+ * Usage: ITERGCC <EXEC> <GCC> <PDP> <ASM> <MEM> [PARMS]
+ *
+ * where EXEC = name of EXEC you wish to run
+ *       GCC = Y/N if you want to run GCC proper
+ *       PDP = Y/N if you want to run PDPCLIB C code
+ *       ASM = Y/N if you want to run PDPCLIB assembler
+ *       MEM = Y/N if you want to run MEMMGR
+ *
+ *
+ *******************************************************************
+ 
+ &SCRIPT = &1
+ &GCC = &2
+ &PDP = &3
+ &ASM = &4
+ &MEM = &5
+ 
+ &IF &ASM = N &GOTO -FINASM
+  EXEC &SCRIPT CMSSTART  &6 &7 &8 &9
+  EXEC &SCRIPT CMSSUPA   &6 &7 &8 &9
+ -FINASM
+ 
+ &IF &PDP = N &GOTO -FINPDP
+  EXEC &SCRIPT START     &6 &7 &8 &9
+  EXEC &SCRIPT STDIO     &6 &7 &8 &9
+  EXEC &SCRIPT STDLIB    &6 &7 &8 &9
+  EXEC &SCRIPT CTYPE     &6 &7 &8 &9
+  EXEC &SCRIPT STRING    &6 &7 &8 &9
+  EXEC &SCRIPT TIME      &6 &7 &8 &9
+  EXEC &SCRIPT ERRNO     &6 &7 &8 &9
+  EXEC &SCRIPT ASSERT    &6 &7 &8 &9
+  EXEC &SCRIPT LOCALE    &6 &7 &8 &9
+  EXEC &SCRIPT MATH      &6 &7 &8 &9
+  EXEC &SCRIPT SETJMP    &6 &7 &8 &9
+  EXEC &SCRIPT SIGNAL    &6 &7 &8 &9
+ -FINPDP
+ 
+ &IF &MEM = N &GOTO -FINMEM
+  EXEC &SCRIPT __MEMMGR  &6 &7 &8 &9
+ -FINMEM
+ 
+ &IF &GCC = N &GOTO -FINGCC
+  EXEC &SCRIPT ALIAS     &6 &7 &8 &9
+  EXEC &SCRIPT ATTRIBS   &6 &7 &8 &9
+  EXEC &SCRIPT BB-REORD  &6 &7 &8 &9
+  EXEC &SCRIPT BITMAP    &6 &7 &8 &9
+  EXEC &SCRIPT BUILTINS  &6 &7 &8 &9
+  EXEC &SCRIPT C-AUX-IN  &6 &7 &8 &9
+  EXEC &SCRIPT C-COMMON  &6 &7 &8 &9
+  EXEC &SCRIPT C-CONVER  &6 &7 &8 &9
+  EXEC &SCRIPT C-DECL    &6 &7 &8 &9
+  EXEC &SCRIPT C-ERRORS  &6 &7 &8 &9
+  EXEC &SCRIPT C-FORMAT  &6 &7 &8 &9
+  EXEC &SCRIPT C-LANG    &6 &7 &8 &9
+  EXEC &SCRIPT C-LEX     &6 &7 &8 &9
+  EXEC &SCRIPT C-OBJC-C  &6 &7 &8 &9
+  EXEC &SCRIPT C-PARSE   &6 &7 &8 &9
+  EXEC &SCRIPT C-PRAGMA  &6 &7 &8 &9
+  EXEC &SCRIPT C-SEMANT  &6 &7 &8 &9
+  EXEC &SCRIPT C-TYPECK  &6 &7 &8 &9
+  EXEC &SCRIPT CALLER-S  &6 &7 &8 &9
+  EXEC &SCRIPT CALLS     &6 &7 &8 &9
+  EXEC &SCRIPT CFG       &6 &7 &8 &9
+  EXEC &SCRIPT CFGANAL   &6 &7 &8 &9
+  EXEC &SCRIPT CFGBUILD  &6 &7 &8 &9
+  EXEC &SCRIPT CFGCLEAN  &6 &7 &8 &9
+  EXEC &SCRIPT CFGLAYOU  &6 &7 &8 &9
+  EXEC &SCRIPT CFGLOOP   &6 &7 &8 &9
+  EXEC &SCRIPT CFGRTL    &6 &7 &8 &9
+  EXEC &SCRIPT COMBINE   &6 &7 &8 &9
+  EXEC &SCRIPT CONFLICT  &6 &7 &8 &9
+  EXEC &SCRIPT CONVERT   &6 &7 &8 &9
+  EXEC &SCRIPT CPPDEFAU  &6 &7 &8 &9
+  EXEC &SCRIPT CPPERROR  &6 &7 &8 &9
+  EXEC &SCRIPT CPPEXP    &6 &7 &8 &9
+  EXEC &SCRIPT CPPFILES  &6 &7 &8 &9
+  EXEC &SCRIPT CPPHASH   &6 &7 &8 &9
+  EXEC &SCRIPT CPPINIT   &6 &7 &8 &9
+  EXEC &SCRIPT CPPLEX    &6 &7 &8 &9
+  EXEC &SCRIPT CPPLIB    &6 &7 &8 &9
+  EXEC &SCRIPT CPPMACRO  &6 &7 &8 &9
+  EXEC &SCRIPT CPPMAIN   &6 &7 &8 &9
+  EXEC &SCRIPT CPPSPEC   &6 &7 &8 &9
+  EXEC &SCRIPT CSE       &6 &7 &8 &9
+  EXEC &SCRIPT CSELIB    &6 &7 &8 &9
+  EXEC &SCRIPT DEBUG     &6 &7 &8 &9
+  EXEC &SCRIPT DEPENDEN  &6 &7 &8 &9
+  EXEC &SCRIPT DF        &6 &7 &8 &9
+  EXEC &SCRIPT DIAGNOST  &6 &7 &8 &9
+  EXEC &SCRIPT DOMINANC  &6 &7 &8 &9
+  EXEC &SCRIPT DWARF2AS  &6 &7 &8 &9
+  EXEC &SCRIPT DWARF2OU  &6 &7 &8 &9
+  EXEC &SCRIPT EMIT-RTL  &6 &7 &8 &9
+  EXEC &SCRIPT EXCEPT    &6 &7 &8 &9
+  EXEC &SCRIPT EXPLOW    &6 &7 &8 &9
+  EXEC &SCRIPT EXPMED    &6 &7 &8 &9
+  EXEC &SCRIPT EXPR      &6 &7 &8 &9
+  EXEC &SCRIPT FINAL     &6 &7 &8 &9
+  EXEC &SCRIPT FLOW      &6 &7 &8 &9
+  EXEC &SCRIPT FOLD-CON  &6 &7 &8 &9
+  EXEC &SCRIPT FUNCTION  &6 &7 &8 &9
+  EXEC &SCRIPT GCC       &6 &7 &8 &9
+  EXEC &SCRIPT GCCSPEC   &6 &7 &8 &9
+  EXEC &SCRIPT GCSE      &6 &7 &8 &9
+  EXEC &SCRIPT GENRTL    &6 &7 &8 &9
+  EXEC &SCRIPT GGC-COMM  &6 &7 &8 &9
+  EXEC &SCRIPT GGC-PAGE  &6 &7 &8 &9
+  EXEC &SCRIPT GLOBAL    &6 &7 &8 &9
+  EXEC &SCRIPT GRAPH     &6 &7 &8 &9
+  EXEC &SCRIPT HASH      &6 &7 &8 &9
+  EXEC &SCRIPT HASHTABL  &6 &7 &8 &9
+  EXEC &SCRIPT HOOKS     &6 &7 &8 &9
+  EXEC &SCRIPT IFCVT     &6 &7 &8 &9
+  EXEC &SCRIPT INSN-ATT  &6 &7 &8 &9
+  EXEC &SCRIPT INSN-EMI  &6 &7 &8 &9
+  EXEC &SCRIPT INSN-EXT  &6 &7 &8 &9
+  EXEC &SCRIPT INSN-OPI  &6 &7 &8 &9
+  EXEC &SCRIPT INSN-OUT  &6 &7 &8 &9
+  EXEC &SCRIPT INSN-REC  &6 &7 &8 &9
+  EXEC &SCRIPT INTEGRAT  &6 &7 &8 &9
+  EXEC &SCRIPT JUMP      &6 &7 &8 &9
+  EXEC &SCRIPT LANGHOOK  &6 &7 &8 &9
+  EXEC &SCRIPT LCM       &6 &7 &8 &9
+  EXEC &SCRIPT LINE-MAP  &6 &7 &8 &9
+  EXEC &SCRIPT LISTS     &6 &7 &8 &9
+  EXEC &SCRIPT LOCAL-AL  &6 &7 &8 &9
+  EXEC &SCRIPT LOOP      &6 &7 &8 &9
+  EXEC &SCRIPT MKDEPS    &6 &7 &8 &9
+  EXEC &SCRIPT OPTABS    &6 &7 &8 &9
+  EXEC &SCRIPT PARAMS    &6 &7 &8 &9
+  EXEC &SCRIPT PREDICT   &6 &7 &8 &9
+  EXEC &SCRIPT PREFIX    &6 &7 &8 &9
+  EXEC &SCRIPT PRINT-RT  &6 &7 &8 &9
+  EXEC &SCRIPT PRINT-TR  &6 &7 &8 &9
+  EXEC &SCRIPT PROFILE   &6 &7 &8 &9
+  EXEC &SCRIPT REAL      &6 &7 &8 &9
+  EXEC &SCRIPT RECOG     &6 &7 &8 &9
+  EXEC &SCRIPT REGCLASS  &6 &7 &8 &9
+  EXEC &SCRIPT REGMOVE   &6 &7 &8 &9
+  EXEC &SCRIPT REGRENAM  &6 &7 &8 &9
+  EXEC &SCRIPT RELOAD    &6 &7 &8 &9
+  EXEC &SCRIPT RELOAD1   &6 &7 &8 &9
+  EXEC &SCRIPT RESOURCE  &6 &7 &8 &9
+  EXEC &SCRIPT RTL-ERRO  &6 &7 &8 &9
+  EXEC &SCRIPT RTL       &6 &7 &8 &9
+  EXEC &SCRIPT RTLANAL   &6 &7 &8 &9
+  EXEC &SCRIPT SBITMAP   &6 &7 &8 &9
+  EXEC &SCRIPT SIBCALL   &6 &7 &8 &9
+  EXEC &SCRIPT SIMPLIFY  &6 &7 &8 &9
+  EXEC &SCRIPT SSA-CCP   &6 &7 &8 &9
+  EXEC &SCRIPT SSA-DCE   &6 &7 &8 &9
+  EXEC &SCRIPT SSA       &6 &7 &8 &9
+  EXEC &SCRIPT STMT      &6 &7 &8 &9
+  EXEC &SCRIPT STOR-LAY  &6 &7 &8 &9
+  EXEC &SCRIPT STRINGPO  &6 &7 &8 &9
+  EXEC &SCRIPT TIMEVAR   &6 &7 &8 &9
+  EXEC &SCRIPT TOPLEV    &6 &7 &8 &9
+  EXEC &SCRIPT TREE-DUM  &6 &7 &8 &9
+  EXEC &SCRIPT TREE-INL  &6 &7 &8 &9
+  EXEC &SCRIPT TREE      &6 &7 &8 &9
+  EXEC &SCRIPT UNROLL    &6 &7 &8 &9
+  EXEC &SCRIPT VARASM    &6 &7 &8 &9
+  EXEC &SCRIPT VARRAY    &6 &7 &8 &9
+  EXEC &SCRIPT VERSION   &6 &7 &8 &9
+  EXEC &SCRIPT XMALLOC   &6 &7 &8 &9
+  EXEC &SCRIPT XSTRERRO  &6 &7 &8 &9
+  EXEC &SCRIPT XSTRDUP   &6 &7 &8 &9
+  EXEC &SCRIPT XEXIT     &6 &7 &8 &9
+  EXEC &SCRIPT CONCAT    &6 &7 &8 &9
+  EXEC &SCRIPT HEX       &6 &7 &8 &9
+  EXEC &SCRIPT ALLOCA    &6 &7 &8 &9
+  EXEC &SCRIPT LBASENAM  &6 &7 &8 &9
+  EXEC &SCRIPT OBSTACK   &6 &7 &8 &9
+  EXEC &SCRIPT STRSIGNA  &6 &7 &8 &9
+  EXEC &SCRIPT SAFE-CTY  &6 &7 &8 &9
+  EXEC &SCRIPT SPLAY-TR  &6 &7 &8 &9
+  EXEC &SCRIPT FIBHEAP   &6 &7 &8 &9
+  EXEC &SCRIPT HASHTAB   &6 &7 &8 &9
+  EXEC &SCRIPT ASPRINTF  &6 &7 &8 &9
+  EXEC &SCRIPT VASPRINT  &6 &7 &8 &9
+  EXEC &SCRIPT GETPAGES  &6 &7 &8 &9
+  EXEC &SCRIPT PARTITIO  &6 &7 &8 &9
+  EXEC &SCRIPT I370-C    &6 &7 &8 &9
+  EXEC &SCRIPT I370      &6 &7 &8 &9
+  EXEC &SCRIPT UNIXIO    &6 &7 &8 &9
+ -FINGCC
Index: gcc/gcc/longlong.h
diff -c gcc/gcc/longlong.h:1.1.1.1 gcc/gcc/longlong.h:1.6
*** gcc/gcc/longlong.h:1.1.1.1	Wed Feb 15 21:22:25 2006
--- gcc/gcc/longlong.h	Mon Dec 13 22:49:28 2010
***************
*** 400,417 ****
    } while (0)
  #endif
  
! #if (defined (__i370__) || defined (__mvs__)) && W_TYPE_SIZE == 32
  #define umul_ppmm(xh, xl, m0, m1) \
    do {									\
      union {UDItype __ll;						\
  	   struct {USItype __h, __l;} __i;				\
  	  } __xx;							\
      USItype __m0 = (m0), __m1 = (m1);					\
!     __asm__ ("mr %0,%3"							\
! 	     : "=r" (__xx.__i.__h),					\
! 	       "=r" (__xx.__i.__l)					\
! 	     : "%1" (__m0),						\
! 	       "r" (__m1));						\
      (xh) = __xx.__i.__h; (xl) = __xx.__i.__l;				\
      (xh) += ((((SItype) __m0 >> 31) & __m1)				\
  	     + (((SItype) __m1 >> 31) & __m0));				\
--- 400,418 ----
    } while (0)
  #endif
  
! #if (defined (__i370__) || defined(__s390__) \
!      || defined (__VSE__) \
!      || defined (__MVS__) || defined(__CMS__)) && W_TYPE_SIZE == 32
  #define umul_ppmm(xh, xl, m0, m1) \
    do {									\
      union {UDItype __ll;						\
  	   struct {USItype __h, __l;} __i;				\
  	  } __xx;							\
      USItype __m0 = (m0), __m1 = (m1);					\
!      __asm__ ("LR	%N0,%1\
!      MR	%0,%2"								\
!  	     : "=&r" (__xx.__ll)					\
!  	     : "r" (__m0), "r" (__m1));					\
      (xh) = __xx.__i.__h; (xl) = __xx.__i.__l;				\
      (xh) += ((((SItype) __m0 >> 31) & __m1)				\
  	     + (((SItype) __m1 >> 31) & __m0));				\
***************
*** 421,431 ****
      union {DItype __ll;							\
  	   struct {USItype __h, __l;} __i;				\
  	  } __xx;							\
!     __asm__ ("mr %0,%3"							\
! 	     : "=r" (__xx.__i.__h),					\
! 	       "=r" (__xx.__i.__l)					\
! 	     : "%1" (m0),						\
! 	       "r" (m1));						\
      (xh) = __xx.__i.__h; (xl) = __xx.__i.__l;				\
    } while (0)
  #define sdiv_qrnnd(q, r, n1, n0, d) \
--- 422,431 ----
      union {DItype __ll;							\
  	   struct {USItype __h, __l;} __i;				\
  	  } __xx;							\
!      __asm__ ("LR %N0,%1\
!      MR %0,%2"								\
!  	     : "=&r" (__xx.__ll)					\
!  	     : "r" (m0), "r" (m1));					\
      (xh) = __xx.__i.__h; (xl) = __xx.__i.__l;				\
    } while (0)
  #define sdiv_qrnnd(q, r, n1, n0, d) \
***************
*** 434,442 ****
  	   struct {USItype __h, __l;} __i;				\
  	  } __xx;							\
      __xx.__i.__h = n1; __xx.__i.__l = n0;				\
!     __asm__ ("dr %0,%2"							\
! 	     : "=r" (__xx.__ll)						\
! 	     : "0" (__xx.__ll), "r" (d));				\
      (q) = __xx.__i.__l; (r) = __xx.__i.__h;				\
    } while (0)
  #endif
--- 434,442 ----
  	   struct {USItype __h, __l;} __i;				\
  	  } __xx;							\
      __xx.__i.__h = n1; __xx.__i.__l = n0;				\
!     __asm__ ("DR	%0,%2"						\
! 	     : "=d" (__xx.__ll)						\
! 	     : "0" (__xx.__ll), "d" (d));				\
      (q) = __xx.__i.__l; (r) = __xx.__i.__h;				\
    } while (0)
  #endif
Index: gcc/gcc/make380.exec
diff -c nul gcc/gcc/make380.exec:1.3
*** nul	Tue Oct 01 16:28:46 2019
--- gcc/gcc/make380.exec	Sat May 26 17:24:39 2018
***************
*** 0 ****
--- 1,30 ----
+ &TRACE OFF
+ 
+ * Usage - MAKE380 <SRC>
+ 
+ * This script builds a 380 version of PDPCLIB
+ 
+ &SRC = A
+ 
+ &IF &INDEX EQ 0 &GOTO -FINARGS
+ &SRC = &1
+ 
+ -FINARGS
+ 
+ COPY PDP380 MAC &SRC PDPTOP COPY = (REPL LRECL 80 RECFM F
+ MACLIB GEN PDPCLIB PDPPRLG PDPEPIL PDPTOP PDPMAIN
+ GLOBAL MACLIB OSMACRO DMSGPI PDPCLIB
+ &ASMNAME = ASMAHL
+ 
+ * Generate PDPCLIB TXTLIB
+ EXEC MKPDPC &SRC &ASMNAME STD380
+ 
+ GLOBAL TXTLIB PDPCLIB
+ 
+ * Compile example program
+ EXEC GCCE PDPTEST C &SRC
+ LOAD PDPTEST (NOAUTO NOMAP
+ GENMOD PDPTEST
+ 
+ * Quick test using pdptest
+ PDPTEST PaulEdwards was Here
Index: gcc/gcc/makeutil.bat
diff -c nul gcc/gcc/makeutil.bat:1.6
*** nul	Tue Oct 01 16:28:46 2019
--- gcc/gcc/makeutil.bat	Sun Sep 29 17:14:21 2019
***************
*** 0 ****
--- 1,12 ----
+ rem before running this, make sure that pdptop is set
+ rem to S/370 and that you are not using memmgr, so as
+ rem to produce 24-bit targets
+ rem something like this:
+ rem (in pdpclib)
+ rem copy pdp370.mac pdptop.mac
+ rem (in minizip)
+ rem compile
+ rem (in GCC)
+ rem call compmvs -UUSE_MEMMGR -ansi -pedantic-errors
+ 
+ m4 -I ../../pdos/pdpclib -I ../../zlib/contrib/minizip makeutil.m4 >makeutil.jcl
Index: gcc/gcc/makeutil.m4
diff -c nul gcc/gcc/makeutil.m4:1.30
*** nul	Tue Oct 01 16:28:46 2019
--- gcc/gcc/makeutil.m4	Sun Sep 29 17:23:28 2019
***************
*** 0 ****
--- 1,488 ----
+ //HERC01A  JOB CLASS=C,REGION=0K
+ //*
+ //* Compile some useful utilities
+ //* Change the last step to copy into a load library
+ //* you have (or else delete it).
+ //* You may need to change ASMA90 to IEV90 or ASMBLR or
+ //* IFOX00 or something else if your site doesn't have ASMA90.
+ //*
+ //* These utilities come from GCCMVS
+ //*
+ //PDPASM   PROC MEMBER=''
+ //ASM      EXEC PGM=ASMA90,
+ //   PARM='DECK,NOLIST'
+ //SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR
+ //         DD DSN=&&MACLIB,DISP=(OLD,PASS)
+ //         DD DSN=SYS1.MODGEN,DISP=SHR
+ //SYSUT1   DD UNIT=SYSALLDA,SPACE=(CYL,(20,10))
+ //SYSUT2   DD UNIT=SYSALLDA,SPACE=(CYL,(10,10))
+ //SYSUT3   DD UNIT=SYSALLDA,SPACE=(CYL,(10,10))
+ //SYSPRINT DD SYSOUT=*
+ //SYSLIN   DD DUMMY
+ //SYSGO    DD DUMMY
+ //SYSPUNCH DD DSN=&&OBJLIB(&MEMBER),DISP=(OLD,PASS)
+ //*
+ //         PEND
+ //CREATE   EXEC PGM=IEFBR14
+ //DD1      DD DSN=&&OBJLIB,DISP=(,PASS),
+ // DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200),
+ // SPACE=(3200,(60,60,44)),UNIT=SYSALLDA
+ //DD2      DD DSN=&&MACLIB,DISP=(,PASS),
+ // DCB=(RECFM=FB,LRECL=80,BLKSIZE=6160),
+ // SPACE=(6160,(60,60,44)),UNIT=SYSALLDA
+ //DD3      DD DSN=&&LOADLIB,DISP=(,PASS),
+ // DCB=(RECFM=U,LRECL=0,BLKSIZE=6144),
+ // SPACE=(6144,(600,600,44)),UNIT=SYSALLDA
+ //*
+ //PDPTOP   EXEC PGM=IEBGENER
+ //SYSUT2   DD  DSN=&&MACLIB(PDPTOP),DISP=(OLD,PASS)
+ //SYSUT1   DD  *
+ undivert(pdptop.mac)dnl
+ /*
+ //SYSPRINT DD  SYSOUT=*
+ //SYSIN    DD  DUMMY
+ //*
+ //PDPMAIN  EXEC PGM=IEBGENER
+ //SYSUT2   DD  DSN=&&MACLIB(PDPMAIN),DISP=(OLD,PASS)
+ //SYSUT1   DD  *
+ undivert(pdpmain.mac)dnl
+ /*
+ //SYSPRINT DD  SYSOUT=*
+ //SYSIN    DD  DUMMY
+ //*
+ //PDPPRLG  EXEC PGM=IEBGENER
+ //SYSUT2   DD  DSN=&&MACLIB(PDPPRLG),DISP=(OLD,PASS)
+ //SYSUT1   DD  *
+ undivert(pdpprlg.mac)dnl
+ /*
+ //SYSPRINT DD  SYSOUT=*
+ //SYSIN    DD  DUMMY
+ //*
+ //PDPEPIL  EXEC PGM=IEBGENER
+ //SYSUT2   DD  DSN=&&MACLIB(PDPEPIL),DISP=(OLD,PASS)
+ //SYSUT1   DD  *
+ undivert(pdpepil.mac)dnl
+ /*
+ //SYSPRINT DD  SYSOUT=*
+ //SYSIN    DD  DUMMY
+ //*
+ //MVSSTART EXEC PDPASM,MEMBER=MVSSTART
+ //SYSIN  DD  *
+ undivert(mvsstart.asm)dnl
+ /*
+ //MVSSUPA  EXEC PDPASM,MEMBER=MVSSUPA
+ //SYSIN  DD  *
+ undivert(mvssupa.asm)dnl
+ /*
+ //START    EXEC PDPASM,MEMBER=START
+ //SYSIN  DD *
+ undivert(start.s)dnl
+ /*
+ //STDIO    EXEC PDPASM,MEMBER=STDIO
+ //SYSIN  DD *
+ undivert(stdio.s)dnl
+ /*
+ //STDLIB   EXEC PDPASM,MEMBER=STDLIB
+ //SYSIN  DD  *
+ undivert(stdlib.s)dnl
+ /*
+ //CTYPE    EXEC PDPASM,MEMBER=CTYPE
+ //SYSIN  DD  *
+ undivert(ctype.s)dnl
+ /*
+ //STRING   EXEC PDPASM,MEMBER=STRING
+ //SYSIN  DD  *
+ undivert(string.s)dnl
+ /*
+ //TIME     EXEC PDPASM,MEMBER=TIME
+ //SYSIN  DD  *
+ undivert(time.s)dnl
+ /*
+ //ERRNO    EXEC PDPASM,MEMBER=ERRNO
+ //SYSIN  DD  *
+ undivert(errno.s)dnl
+ /*
+ //ASSERT   EXEC PDPASM,MEMBER=ASSERT
+ //SYSIN  DD  *
+ undivert(assert.s)dnl
+ /*
+ //LOCALE   EXEC PDPASM,MEMBER=LOCALE
+ //SYSIN  DD  *
+ undivert(locale.s)dnl
+ /*
+ //MATH     EXEC PDPASM,MEMBER=MATH
+ //SYSIN  DD  *
+ undivert(math.s)dnl
+ /*
+ //SETJMP   EXEC PDPASM,MEMBER=SETJMP
+ //SYSIN  DD  *
+ undivert(setjmp.s)dnl
+ /*
+ //SIGNAL   EXEC PDPASM,MEMBER=SIGNAL
+ //SYSIN  DD  *
+ undivert(signal.s)dnl
+ /*
+ //@@MEMMGR EXEC PDPASM,MEMBER=@@MEMMGR
+ //SYSIN  DD  *
+ undivert(__memmgr.s)dnl
+ /*
+ //*
+ //* The above are the required C Runtime Library.
+ //* Now we start compiling our utilities
+ //*
+ //* mvsunzip (compile)
+ //*
+ //MVSUNZIP EXEC PDPASM,MEMBER=MVSUNZIP
+ //SYSIN  DD  *
+ undivert(mvsunzip.s)dnl
+ /*
+ /*
+ //*
+ //* mvsunzip (link)
+ //*
+ //LKED     EXEC PGM=IEWL,PARM='MAP,LIST'
+ //SYSLIN   DD DDNAME=SYSIN
+ //OBJLIB   DD DSN=&&OBJLIB,DISP=(OLD,PASS)
+ //SYSLMOD  DD DSN=&&LOADLIB(MVSUNZIP),DISP=(OLD,PASS)
+ //SYSUT1   DD UNIT=SYSALLDA,SPACE=(CYL,(2,1))
+ //SYSPRINT DD SYSOUT=*
+ //SYSIN DD *
+  INCLUDE OBJLIB(MVSSTART)
+  INCLUDE OBJLIB(START)
+  INCLUDE OBJLIB(MVSSUPA)
+  INCLUDE OBJLIB(STDIO)
+  INCLUDE OBJLIB(STDLIB)
+  INCLUDE OBJLIB(CTYPE)
+  INCLUDE OBJLIB(STRING)
+  INCLUDE OBJLIB(TIME)
+  INCLUDE OBJLIB(ERRNO)
+  INCLUDE OBJLIB(ASSERT)
+  INCLUDE OBJLIB(LOCALE)
+  INCLUDE OBJLIB(MATH)
+  INCLUDE OBJLIB(SETJMP)
+  INCLUDE OBJLIB(SIGNAL)
+  INCLUDE OBJLIB(MVSUNZIP)
+ /*
+ //*
+ //* mvsendec (compile)
+ //*
+ //MVSENDEC EXEC PDPASM,MEMBER=MVSENDEC
+ //SYSIN  DD  *
+ undivert(mvsendec.s)dnl
+ /*
+ //*
+ //* mvsendec (link)
+ //*
+ //LKED     EXEC PGM=IEWL,PARM='MAP,LIST'
+ //SYSLIN   DD DDNAME=SYSIN
+ //OBJLIB   DD DSN=&&OBJLIB,DISP=(OLD,PASS)
+ //SYSLMOD  DD DSN=&&LOADLIB(MVSENDEC),DISP=(OLD,PASS)
+ //SYSUT1   DD UNIT=SYSALLDA,SPACE=(CYL,(2,1))
+ //SYSPRINT DD SYSOUT=*
+ //SYSIN DD *
+  INCLUDE OBJLIB(MVSSTART)
+  INCLUDE OBJLIB(START)
+  INCLUDE OBJLIB(MVSSUPA)
+  INCLUDE OBJLIB(STDIO)
+  INCLUDE OBJLIB(STDLIB)
+  INCLUDE OBJLIB(CTYPE)
+  INCLUDE OBJLIB(STRING)
+  INCLUDE OBJLIB(TIME)
+  INCLUDE OBJLIB(ERRNO)
+  INCLUDE OBJLIB(ASSERT)
+  INCLUDE OBJLIB(LOCALE)
+  INCLUDE OBJLIB(MATH)
+  INCLUDE OBJLIB(SETJMP)
+  INCLUDE OBJLIB(SIGNAL)
+  INCLUDE OBJLIB(MVSENDEC)
+ /*
+ //*
+ //* hexdump (compile)
+ //*
+ //HEXDUMP  EXEC PDPASM,MEMBER=HEXDUMP
+ //SYSIN  DD  *
+ undivert(hexdump.s)dnl
+ /*
+ //*
+ //* hexdump (link)
+ //*
+ //LKED     EXEC PGM=IEWL,PARM='MAP,LIST'
+ //SYSLIN   DD DDNAME=SYSIN
+ //OBJLIB   DD DSN=&&OBJLIB,DISP=(OLD,PASS)
+ //SYSLMOD  DD DSN=&&LOADLIB(HEXDUMP),DISP=(OLD,PASS)
+ //SYSUT1   DD UNIT=SYSALLDA,SPACE=(CYL,(2,1))
+ //SYSPRINT DD SYSOUT=*
+ //SYSIN DD *
+  INCLUDE OBJLIB(MVSSTART)
+  INCLUDE OBJLIB(START)
+  INCLUDE OBJLIB(MVSSUPA)
+  INCLUDE OBJLIB(STDIO)
+  INCLUDE OBJLIB(STDLIB)
+  INCLUDE OBJLIB(CTYPE)
+  INCLUDE OBJLIB(STRING)
+  INCLUDE OBJLIB(TIME)
+  INCLUDE OBJLIB(ERRNO)
+  INCLUDE OBJLIB(ASSERT)
+  INCLUDE OBJLIB(LOCALE)
+  INCLUDE OBJLIB(MATH)
+  INCLUDE OBJLIB(SETJMP)
+  INCLUDE OBJLIB(SIGNAL)
+  INCLUDE OBJLIB(HEXDUMP)
+ /*
+ //*
+ //* dssrenam (compile)
+ //*
+ //DSSRENAM EXEC PDPASM,MEMBER=DSSRENAM
+ //SYSIN  DD  *
+ undivert(dssrenam.s)dnl
+ /*
+ //*
+ //* dssrenam (link)
+ //*
+ //LKED     EXEC PGM=IEWL,PARM='MAP,LIST'
+ //SYSLIN   DD DDNAME=SYSIN
+ //OBJLIB   DD DSN=&&OBJLIB,DISP=(OLD,PASS)
+ //SYSLMOD  DD DSN=&&LOADLIB(DSSRENAM),DISP=(OLD,PASS)
+ //SYSUT1   DD UNIT=SYSALLDA,SPACE=(CYL,(2,1))
+ //SYSPRINT DD SYSOUT=*
+ //SYSIN DD *
+  INCLUDE OBJLIB(MVSSTART)
+  INCLUDE OBJLIB(START)
+  INCLUDE OBJLIB(MVSSUPA)
+  INCLUDE OBJLIB(STDIO)
+  INCLUDE OBJLIB(STDLIB)
+  INCLUDE OBJLIB(CTYPE)
+  INCLUDE OBJLIB(STRING)
+  INCLUDE OBJLIB(TIME)
+  INCLUDE OBJLIB(ERRNO)
+  INCLUDE OBJLIB(ASSERT)
+  INCLUDE OBJLIB(LOCALE)
+  INCLUDE OBJLIB(MATH)
+  INCLUDE OBJLIB(SETJMP)
+  INCLUDE OBJLIB(SIGNAL)
+  INCLUDE OBJLIB(DSSRENAM)
+ /*
+ //*
+ //* copyfile (compile)
+ //*
+ //COPYFILE EXEC PDPASM,MEMBER=COPYFILE
+ //SYSIN  DD  *
+ undivert(copyfile.s)dnl
+ /*
+ //*
+ //* copyfile (link)
+ //*
+ //LKED     EXEC PGM=IEWL,PARM='MAP,LIST'
+ //SYSLIN   DD DDNAME=SYSIN
+ //OBJLIB   DD DSN=&&OBJLIB,DISP=(OLD,PASS)
+ //SYSLMOD  DD DSN=&&LOADLIB(COPYFILE),DISP=(OLD,PASS)
+ //SYSUT1   DD UNIT=SYSALLDA,SPACE=(CYL,(2,1))
+ //SYSPRINT DD SYSOUT=*
+ //SYSIN DD *
+  INCLUDE OBJLIB(MVSSTART)
+  INCLUDE OBJLIB(START)
+  INCLUDE OBJLIB(MVSSUPA)
+  INCLUDE OBJLIB(STDIO)
+  INCLUDE OBJLIB(STDLIB)
+  INCLUDE OBJLIB(CTYPE)
+  INCLUDE OBJLIB(STRING)
+  INCLUDE OBJLIB(TIME)
+  INCLUDE OBJLIB(ERRNO)
+  INCLUDE OBJLIB(ASSERT)
+  INCLUDE OBJLIB(LOCALE)
+  INCLUDE OBJLIB(MATH)
+  INCLUDE OBJLIB(SETJMP)
+  INCLUDE OBJLIB(SIGNAL)
+  INCLUDE OBJLIB(COPYFILE)
+ /*
+ //*
+ //* miniunz and minizip (compile)
+ //*
+ //MINIUNZ  EXEC PDPASM,MEMBER=MINIUNZ
+ //SYSIN  DD  *
+ undivert(miniunz.s)dnl
+ /*
+ //UNZIP    EXEC PDPASM,MEMBER=UNZIP
+ //SYSIN  DD  *
+ undivert(unzip.s)dnl
+ /*
+ //UNSHRINK EXEC PDPASM,MEMBER=UNSHRINK
+ //SYSIN  DD  *
+ undivert(unshrink.s)dnl
+ /*
+ //EXTRA    EXEC PDPASM,MEMBER=EXTRA
+ //SYSIN  DD  *
+ undivert(extra.s)dnl
+ /*
+ //CRC32    EXEC PDPASM,MEMBER=CRC32
+ //SYSIN  DD  *
+ undivert(crc32.s)dnl
+ /*
+ //INFLATE  EXEC PDPASM,MEMBER=INFLATE
+ //SYSIN  DD  *
+ undivert(inflate.s)dnl
+ /*
+ //INFBLOCK EXEC PDPASM,MEMBER=INFBLOCK
+ //SYSIN  DD  *
+ undivert(infblock.s)dnl
+ /*
+ //INFCODES EXEC PDPASM,MEMBER=INFCODES
+ //SYSIN  DD  *
+ undivert(infcodes.s)dnl
+ /*
+ //INFTREES EXEC PDPASM,MEMBER=INFTREES
+ //SYSIN  DD  *
+ undivert(inftrees.s)dnl
+ /*
+ //INFUTIL  EXEC PDPASM,MEMBER=INFUTIL
+ //SYSIN  DD  *
+ undivert(infutil.s)dnl
+ /*
+ //INFFAST  EXEC PDPASM,MEMBER=INFFAST
+ //SYSIN  DD  *
+ undivert(inffast.s)dnl
+ /*
+ //ZUTIL    EXEC PDPASM,MEMBER=ZUTIL
+ //SYSIN  DD  *
+ undivert(zutil.s)dnl
+ /*
+ //ADLER32  EXEC PDPASM,MEMBER=ADLER32
+ //SYSIN  DD  *
+ undivert(adler32.s)dnl
+ /*
+ //MINIZIP  EXEC PDPASM,MEMBER=MINIZIP
+ //SYSIN  DD  *
+ undivert(minizip.s)dnl
+ /*
+ //ZIP      EXEC PDPASM,MEMBER=ZIP
+ //SYSIN  DD  *
+ undivert(zip.s)dnl
+ /*
+ //DEFLATE  EXEC PDPASM,MEMBER=DEFLATE
+ //SYSIN  DD  *
+ undivert(deflate.s)dnl
+ /*
+ //TREES    EXEC PDPASM,MEMBER=TREES
+ //SYSIN  DD  *
+ undivert(trees.s)dnl
+ /*
+ //*
+ //* miniunz (link)
+ //*
+ //LKED     EXEC PGM=IEWL,PARM='MAP,LIST'
+ //SYSLIN   DD DDNAME=SYSIN
+ //OBJLIB   DD DSN=&&OBJLIB,DISP=(OLD,PASS)
+ //SYSLMOD  DD DSN=&&LOADLIB(MINIUNZ),DISP=(OLD,PASS)
+ //SYSUT1   DD UNIT=SYSALLDA,SPACE=(CYL,(2,1))
+ //SYSPRINT DD SYSOUT=*
+ //SYSIN DD *
+  INCLUDE OBJLIB(MVSSTART)
+  INCLUDE OBJLIB(START)
+  INCLUDE OBJLIB(MVSSUPA)
+  INCLUDE OBJLIB(STDIO)
+  INCLUDE OBJLIB(STDLIB)
+  INCLUDE OBJLIB(CTYPE)
+  INCLUDE OBJLIB(STRING)
+  INCLUDE OBJLIB(TIME)
+  INCLUDE OBJLIB(ERRNO)
+  INCLUDE OBJLIB(ASSERT)
+  INCLUDE OBJLIB(LOCALE)
+  INCLUDE OBJLIB(MATH)
+  INCLUDE OBJLIB(SETJMP)
+  INCLUDE OBJLIB(SIGNAL)
+  INCLUDE OBJLIB(MINIUNZ)
+  INCLUDE OBJLIB(UNZIP)
+  INCLUDE OBJLIB(UNSHRINK)
+  INCLUDE OBJLIB(EXTRA)
+  INCLUDE OBJLIB(CRC32)
+  INCLUDE OBJLIB(INFLATE)
+  INCLUDE OBJLIB(INFBLOCK)
+  INCLUDE OBJLIB(INFCODES)
+  INCLUDE OBJLIB(INFTREES)
+  INCLUDE OBJLIB(INFUTIL)
+  INCLUDE OBJLIB(INFFAST)
+  INCLUDE OBJLIB(ZUTIL)
+  INCLUDE OBJLIB(ADLER32)
+ /*
+ //*
+ //* minizip (link)
+ //*
+ //LKED     EXEC PGM=IEWL,PARM='MAP,LIST'
+ //SYSLIN   DD DDNAME=SYSIN
+ //OBJLIB   DD DSN=&&OBJLIB,DISP=(OLD,PASS)
+ //SYSLMOD  DD DSN=&&LOADLIB(MINIZIP),DISP=(OLD,PASS)
+ //SYSUT1   DD UNIT=SYSALLDA,SPACE=(CYL,(2,1))
+ //SYSPRINT DD SYSOUT=*
+ //SYSIN DD *
+  INCLUDE OBJLIB(MVSSTART)
+  INCLUDE OBJLIB(START)
+  INCLUDE OBJLIB(MVSSUPA)
+  INCLUDE OBJLIB(STDIO)
+  INCLUDE OBJLIB(STDLIB)
+  INCLUDE OBJLIB(CTYPE)
+  INCLUDE OBJLIB(STRING)
+  INCLUDE OBJLIB(TIME)
+  INCLUDE OBJLIB(ERRNO)
+  INCLUDE OBJLIB(ASSERT)
+  INCLUDE OBJLIB(LOCALE)
+  INCLUDE OBJLIB(MATH)
+  INCLUDE OBJLIB(SETJMP)
+  INCLUDE OBJLIB(SIGNAL)
+  INCLUDE OBJLIB(MINIZIP)
+  INCLUDE OBJLIB(ZIP)
+  INCLUDE OBJLIB(DEFLATE)
+  INCLUDE OBJLIB(CRC32)
+  INCLUDE OBJLIB(ADLER32)
+  INCLUDE OBJLIB(TREES)
+  INCLUDE OBJLIB(ZUTIL)
+ /*
+ //*
+ //* Here are some examples of how you can run some of the
+ //* utilities
+ //*
+ //HEXDUMP  EXEC PGM=HEXDUMP,PARM='dd:input'
+ //STEPLIB  DD DSN=&&LOADLIB,DISP=(OLD,PASS)
+ //INPUT    DD DSN=&&MACLIB(PDPEPIL),DISP=(OLD,PASS)
+ //SYSIN    DD DUMMY
+ //SYSPRINT DD SYSOUT=*
+ //SYSTERM  DD SYSOUT=*
+ //*
+ //MINI     EXEC PGM=MINIZIP,PARM='-a -x .h -l -o dd:output dd:input'
+ //STEPLIB  DD DSN=&&LOADLIB,DISP=(OLD,PASS)
+ //INPUT    DD DSN=&&MACLIB,DISP=(OLD,PASS)
+ //OUTPUT   DD DSN=&&TEMP,DISP=(,PASS),UNIT=SYSALLDA,
+ //         SPACE=(CYL,(20,20)),DCB=(RECFM=FB,LRECL=80,BLKSIZE=3120)
+ //SYSIN    DD DUMMY
+ //SYSPRINT DD SYSOUT=*
+ //SYSTERM  DD SYSOUT=*
+ //SYSUT1   DD DSN=&&TEMP2,DISP=(,DELETE),UNIT=SYSALLDA,
+ //         SPACE=(CYL,(20,20)),DCB=(RECFM=FB,LRECL=80,BLKSIZE=3120)
+ //*
+ //MINIUNZ  EXEC PGM=MINIUNZ,PARM='-v dd:input'
+ //STEPLIB  DD DSN=&&LOADLIB,DISP=(OLD,PASS)
+ //INPUT    DD DSN=&&TEMP,DISP=(OLD,PASS)
+ //SYSIN    DD DUMMY
+ //SYSPRINT DD SYSOUT=*
+ //SYSTERM  DD SYSOUT=*
+ //*
+ //MVSENDEC EXEC PGM=MVSENDEC,PARM='encb dd:input dd:output'
+ //STEPLIB  DD DSN=&&LOADLIB,DISP=(OLD,PASS)
+ //INPUT    DD DSN=&&TEMP,DISP=(OLD,PASS)
+ //OUTPUT   DD SYSOUT=*,DCB=(RECFM=FB,LRECL=80,BLKSIZE=3120)
+ //SYSIN    DD DUMMY
+ //SYSPRINT DD SYSOUT=*
+ //SYSTERM  DD SYSOUT=*
+ //*
+ //*
+ //* And here's an example of copying them into a pre-existing
+ //* library.
+ //*
+ //COPY     EXEC PGM=IEBCOPY
+ //SYSUT1   DD DSN=&&LOADLIB,DISP=(OLD,PASS)
+ //SYSUT2   DD DSN=SYS2.LINKLIB,DISP=SHR
+ //SYSIN    DD *
+  COPY INDD=((SYSUT1,R)),OUTDD=SYSUT2
+ /*
+ //SYSPRINT DD SYSOUT=*
+ //*
+ //
Index: gcc/gcc/makexmit.bat
diff -c nul gcc/gcc/makexmit.bat:1.1
*** nul	Tue Oct 01 16:28:46 2019
--- gcc/gcc/makexmit.bat	Mon Sep 30 07:39:24 2019
***************
*** 0 ****
--- 1,7 ----
+ del gccmvs-xmit.zip
+ rm -fr xxx
+ md xxx
+ copy xmitread.txt xxx\readme.txt
+ zip -9Xmj gccmvs-xmit gccmvs.xmi xxx\readme.txt
+ zip -9X gccmvs-xmit xmit1.jcl xmit2.jcl xmit3.jcl xmit4.jcl xmit5.jcl xmitrecv.bat
+ rd xxx
Index: gcc/gcc/mkclib.exec
diff -c nul gcc/gcc/mkclib.exec:1.4
*** nul	Tue Oct 01 16:28:46 2019
--- gcc/gcc/mkclib.exec	Fri Sep 26 21:58:39 2008
***************
*** 0 ****
--- 1,21 ----
+ * PRODUCE CLIB TEXT CONTAING ALL OF PDPCLIB              
+ * COPY THE FILES
+ 
+  &DISK = &1
+                     
+  COPY CMSSTART TEXT &DISK CLIB TEXT &DISK (REP                     
+  COPY START TEXT &DISK CLIB TEXT &DISK (APP                        
+  COPY CMSSUPA TEXT &DISK CLIB TEXT &DISK (APP                      
+  COPY STDIO TEXT &DISK CLIB TEXT &DISK (APP                        
+  COPY STDLIB TEXT &DISK CLIB TEXT &DISK (APP                       
+  COPY CTYPE TEXT &DISK CLIB TEXT &DISK (APP                        
+  COPY STRING TEXT &DISK CLIB TEXT &DISK (APP                       
+  COPY TIME TEXT &DISK CLIB TEXT &DISK (APP                         
+  COPY ERRNO TEXT &DISK CLIB TEXT &DISK (APP                        
+  COPY ASSERT TEXT &DISK CLIB TEXT &DISK (APP                       
+  COPY LOCALE TEXT &DISK CLIB TEXT &DISK (APP                       
+  COPY MATH TEXT &DISK CLIB TEXT &DISK (APP                         
+  COPY SETJMP TEXT &DISK CLIB TEXT &DISK (APP                       
+  COPY SIGNAL TEXT &DISK CLIB TEXT &DISK (APP                       
+  COPY __MEMMGR TEXT &DISK CLIB TEXT &DISK (APP                       
+ 
Index: gcc/gcc/mkpdpc.exec
diff -c nul gcc/gcc/mkpdpc.exec:1.3
*** nul	Tue Oct 01 16:28:46 2019
--- gcc/gcc/mkpdpc.exec	Sat May 26 17:16:28 2018
***************
*** 0 ****
--- 1,73 ----
+ * Usage - MKPDPC <DISK> <ASMNAME> <PARMF>
+ 
+ * This script compiles all the pdpclib modules to create
+ * a TXTLIB
+ 
+ &CONTROL
+ 
+ &DISK = &1
+ &ASMNAME = &2
+ &PARMF = &3
+ 
+ 
+ * Recompile all the C code
+ EXEC PDPONE START &DISK &PARMF
+ EXEC PDPONE STDIO &DISK &PARMF
+ EXEC PDPONE STDLIB &DISK &PARMF
+ EXEC PDPONE CTYPE &DISK &PARMF
+ EXEC PDPONE STRING &DISK &PARMF
+ EXEC PDPONE TIME &DISK &PARMF
+ EXEC PDPONE ERRNO &DISK &PARMF
+ EXEC PDPONE ASSERT &DISK &PARMF
+ EXEC PDPONE LOCALE &DISK &PARMF
+ EXEC PDPONE MATH &DISK &PARMF
+ EXEC PDPONE SETJMP &DISK &PARMF
+ EXEC PDPONE SIGNAL &DISK &PARMF
+ EXEC PDPONE __MEMMGR &DISK &PARMF
+ 
+ 
+ * And copy assembler source into generated name
+ COPY CMSSUPA ASM &DISK = S = (REPLACE
+ COPY CMSSTART ASM &DISK = S = (REPLACE
+ 
+ 
+ * Name all unnamed CSECTs and reassemble
+ EXEC FIXCSECT CMSSUPA &DISK &ASMNAME @@CMSSUP
+ EXEC FIXCSECT CMSSTART &DISK &ASMNAME @@CMSSTR
+ EXEC FIXCSECT START &DISK &ASMNAME @@PDPST
+ EXEC FIXCSECT STDIO &DISK &ASMNAME @@STDIO
+ EXEC FIXCSECT STDLIB &DISK &ASMNAME @@STDLIB
+ EXEC FIXCSECT CTYPE &DISK &ASMNAME @@CTYPE
+ EXEC FIXCSECT STRING &DISK &ASMNAME @@STRING
+ EXEC FIXCSECT TIME &DISK &ASMNAME @@PDPTIM
+ EXEC FIXCSECT ERRNO &DISK &ASMNAME @@PDPERR
+ EXEC FIXCSECT ASSERT &DISK &ASMNAME @@PDPASS
+ EXEC FIXCSECT LOCALE &DISK &ASMNAME @@PDPLOC
+ EXEC FIXCSECT MATH &DISK &ASMNAME @@MATH
+ EXEC FIXCSECT SETJMP &DISK &ASMNAME @@PDPJMP
+ EXEC FIXCSECT SIGNAL &DISK &ASMNAME @@PDPSIG
+ EXEC FIXCSECT __MEMMGR &DISK &ASMNAME @@PDPMEM
+ 
+ 
+ * Generate txtlib
+ * Put it into a temporary library to avoid issues
+ * where there is an existing library on another disk
+ 
+ TXTLIB GEN NEWCLIB CMSSUPA
+ TXTLIB ADD NEWCLIB CMSSTART
+ TXTLIB ADD NEWCLIB START
+ TXTLIB ADD NEWCLIB STDIO
+ TXTLIB ADD NEWCLIB STDLIB
+ TXTLIB ADD NEWCLIB CTYPE
+ TXTLIB ADD NEWCLIB STRING
+ TXTLIB ADD NEWCLIB TIME
+ TXTLIB ADD NEWCLIB ERRNO
+ TXTLIB ADD NEWCLIB ASSERT
+ TXTLIB ADD NEWCLIB LOCALE
+ TXTLIB ADD NEWCLIB MATH
+ TXTLIB ADD NEWCLIB SETJMP
+ TXTLIB ADD NEWCLIB SIGNAL
+ TXTLIB ADD NEWCLIB __MEMMGR
+ 
+ COPY NEWCLIB TXTLIB A PDPCLIB = &DISK (REPLACE
+ ERASE NEWCLIB TXTLIB A
Index: gcc/gcc/multilib.h
diff -c nul gcc/gcc/multilib.h:1.1
*** nul	Tue Oct 01 16:28:46 2019
--- gcc/gcc/multilib.h	Wed Feb 15 21:25:42 2006
***************
*** 0 ****
--- 1,16 ----
+ static const char *const multilib_raw[] = {
+ ". ;",
+ NULL
+ };
+ 
+ static const char *const multilib_matches_raw[] = {
+ NULL
+ };
+ 
+ static const char *multilib_extra = "";
+ 
+ static const char *const multilib_exclusions_raw[] = {
+ NULL
+ };
+ 
+ static const char *multilib_options = "";
Index: gcc/gcc/musaall.exec
diff -c nul gcc/gcc/musaall.exec:1.1
*** nul	Tue Oct 01 16:28:46 2019
--- gcc/gcc/musaall.exec	Sun Nov 22 17:22:45 2009
***************
*** 0 ****
--- 1,159 ----
+ /inc rexx
+ 'musaone alias'
+ 'musaone attribs'
+ 'musaone bb-reorder'
+ 'musaone bitmap'
+ 'musaone builtins'
+ 'musaone c-aux-info'
+ 'musaone c-common'
+ 'musaone c-convert'
+ 'musaone c-decl'
+ 'musaone c-errors'
+ 'musaone c-format'
+ 'musaone c-lang'
+ 'musaone c-lex'
+ 'musaone c-objc-common'
+ 'musaone c-parse'
+ 'musaone c-pragma'
+ 'musaone c-semantics'
+ 'musaone c-typeck'
+ 'musaone caller-save'
+ 'musaone calls'
+ 'musaone cfg'
+ 'musaone cfganal'
+ 'musaone cfgbuild'
+ 'musaone cfgcleanup'
+ 'musaone cfglayout'
+ 'musaone cfgloop'
+ 'musaone cfgrtl'
+ 'musaone combine'
+ 'musaone conflict'
+ 'musaone convert'
+ 'musaone cppdefault'
+ 'musaone cpperror'
+ 'musaone cppexp'
+ 'musaone cppfiles'
+ 'musaone cpphash'
+ 'musaone cppinit'
+ 'musaone cpplex'
+ 'musaone cpplib'
+ 'musaone cppmacro'
+ 'musaone cppmain'
+ 'musaone cppspec'
+ 'musaone cse'
+ 'musaone cselib'
+ 'musaone debug'
+ 'musaone dependence'
+ 'musaone df'
+ 'musaone diagnostic'
+ 'musaone dominance'
+ 'musaone dwarf2asm'
+ 'musaone dwarf2out'
+ 'musaone emit-rtl'
+ 'musaone except'
+ 'musaone explow'
+ 'musaone expmed'
+ 'musaone expr'
+ 'musaone final'
+ 'musaone flow'
+ 'musaone fold-const'
+ 'musaone function'
+ 'musaone gcc'
+ 'musaone gccspec'
+ 'musaone gcse'
+ 'musaone genrtl'
+ 'musaone ggc-common'
+ 'musaone ggc-page'
+ 'musaone global'
+ 'musaone graph'
+ 'musaone hash'
+ 'musaone hashtable'
+ 'musaone hooks'
+ 'musaone ifcvt'
+ 'musaone insn-attrtab'
+ 'musaone insn-emit'
+ 'musaone insn-extract'
+ 'musaone insn-opinit'
+ 'musaone insn-output'
+ 'musaone insn-recog'
+ 'musaone integrate'
+ 'musaone jump'
+ 'musaone langhooks'
+ 'musaone lcm'
+ 'musaone line-map'
+ 'musaone lists'
+ 'musaone local-alloc'
+ 'musaone loop'
+ 'musaone mkdeps'
+ 'musaone optabs'
+ 'musaone params'
+ 'musaone predict'
+ 'musaone prefix'
+ 'musaone print-rtl'
+ 'musaone print-tree'
+ 'musaone profile'
+ 'musaone real'
+ 'musaone recog'
+ 'musaone regclass'
+ 'musaone regmove'
+ 'musaone regrename'
+ 'musaone reload'
+ 'musaone reload1'
+ 'musaone resource'
+ 'musaone rtl-error'
+ 'musaone rtl'
+ 'musaone rtlanal'
+ 'musaone sbitmap'
+ 'musaone sibcall'
+ 'musaone simplify-rtx'
+ 'musaone ssa-ccp'
+ 'musaone ssa-dce'
+ 'musaone ssa'
+ 'musaone stmt'
+ 'musaone stor-layout'
+ 'musaone stringpool'
+ 'musaone timevar'
+ 'musaone toplev'
+ 'musaone tree-dump'
+ 'musaone tree-inline'
+ 'musaone tree'
+ 'musaone unroll'
+ 'musaone varasm'
+ 'musaone varray'
+ 'musaone version'
+ 'musaone xmalloc'
+ 'musaone xstrerror'
+ 'musaone xstrdup'
+ 'musaone xexit'
+ 'musaone concat'
+ 'musaone hex'
+ 'musaone alloca'
+ 'musaone lbasename'
+ 'musaone obstack'
+ 'musaone strsignal'
+ 'musaone safe-ctype'
+ 'musaone splay-tree'
+ 'musaone fibheap'
+ 'musaone hashtab'
+ 'musaone asprintf'
+ 'musaone vasprintf'
+ 'musaone getpagesize'
+ 'musaone partition'
+ 'musaone i370-c'
+ 'musaone i370'
+ 'musaone unixio'
+ 'musaone stdio'
+ 'musaone stdlib'
+ 'musaone ctype'
+ 'musaone string'
+ 'musaone time'
+ 'musaone errno'
+ 'musaone assert'
+ 'musaone locale'
+ 'musaone math'
+ 'musaone setjmp'
+ 'musaone signal'
+ 'musaone start'
+ 'musaone __memmgr'
+ 'musaone musstart'
+ 'musaone mussupa'
Index: gcc/gcc/musaone.exec
diff -c nul gcc/gcc/musaone.exec:1.1
*** nul	Tue Oct 01 16:28:46 2019
--- gcc/gcc/musaone.exec	Sun Nov 22 12:43:40 2009
***************
*** 0 ****
--- 1,11 ----
+ /inc rexx
+ parse arg name
+ queue "/file syspunch n("name".obj) new(repl) sp(50) secsp(100%)"
+ queue "/file syslib pds(@BLD000:*.M,$MCU:*.M,$MCM:*.M)"
+ queue "/load asm"
+ queue "/job nogo"
+ queue "/opt deck,list"
+ queue "/inc" name".s"
+ "EXEC"
+ 
+ exit rc
Index: gcc/gcc/musdall.exec
diff -c nul gcc/gcc/musdall.exec:1.1
*** nul	Tue Oct 01 16:28:46 2019
--- gcc/gcc/musdall.exec	Tue Nov 24 09:02:38 2009
***************
*** 0 ****
--- 1,159 ----
+ /inc rexx
+ 'musdone alias'
+ 'musdone attribs'
+ 'musdone bb-reorder'
+ 'musdone bitmap'
+ 'musdone builtins'
+ 'musdone c-aux-info'
+ 'musdone c-common'
+ 'musdone c-convert'
+ 'musdone c-decl'
+ 'musdone c-errors'
+ 'musdone c-format'
+ 'musdone c-lang'
+ 'musdone c-lex'
+ 'musdone c-objc-common'
+ 'musdone c-parse'
+ 'musdone c-pragma'
+ 'musdone c-semantics'
+ 'musdone c-typeck'
+ 'musdone caller-save'
+ 'musdone calls'
+ 'musdone cfg'
+ 'musdone cfganal'
+ 'musdone cfgbuild'
+ 'musdone cfgcleanup'
+ 'musdone cfglayout'
+ 'musdone cfgloop'
+ 'musdone cfgrtl'
+ 'musdone combine'
+ 'musdone conflict'
+ 'musdone convert'
+ 'musdone cppdefault'
+ 'musdone cpperror'
+ 'musdone cppexp'
+ 'musdone cppfiles'
+ 'musdone cpphash'
+ 'musdone cppinit'
+ 'musdone cpplex'
+ 'musdone cpplib'
+ 'musdone cppmacro'
+ 'musdone cppmain'
+ 'musdone cppspec'
+ 'musdone cse'
+ 'musdone cselib'
+ 'musdone debug'
+ 'musdone dependence'
+ 'musdone df'
+ 'musdone diagnostic'
+ 'musdone dominance'
+ 'musdone dwarf2asm'
+ 'musdone dwarf2out'
+ 'musdone emit-rtl'
+ 'musdone except'
+ 'musdone explow'
+ 'musdone expmed'
+ 'musdone expr'
+ 'musdone final'
+ 'musdone flow'
+ 'musdone fold-const'
+ 'musdone function'
+ 'musdone gcc'
+ 'musdone gccspec'
+ 'musdone gcse'
+ 'musdone genrtl'
+ 'musdone ggc-common'
+ 'musdone ggc-page'
+ 'musdone global'
+ 'musdone graph'
+ 'musdone hash'
+ 'musdone hashtable'
+ 'musdone hooks'
+ 'musdone ifcvt'
+ 'musdone insn-attrtab'
+ 'musdone insn-emit'
+ 'musdone insn-extract'
+ 'musdone insn-opinit'
+ 'musdone insn-output'
+ 'musdone insn-recog'
+ 'musdone integrate'
+ 'musdone jump'
+ 'musdone langhooks'
+ 'musdone lcm'
+ 'musdone line-map'
+ 'musdone lists'
+ 'musdone local-alloc'
+ 'musdone loop'
+ 'musdone mkdeps'
+ 'musdone optabs'
+ 'musdone params'
+ 'musdone predict'
+ 'musdone prefix'
+ 'musdone print-rtl'
+ 'musdone print-tree'
+ 'musdone profile'
+ 'musdone real'
+ 'musdone recog'
+ 'musdone regclass'
+ 'musdone regmove'
+ 'musdone regrename'
+ 'musdone reload'
+ 'musdone reload1'
+ 'musdone resource'
+ 'musdone rtl-error'
+ 'musdone rtl'
+ 'musdone rtlanal'
+ 'musdone sbitmap'
+ 'musdone sibcall'
+ 'musdone simplify-rtx'
+ 'musdone ssa-ccp'
+ 'musdone ssa-dce'
+ 'musdone ssa'
+ 'musdone stmt'
+ 'musdone stor-layout'
+ 'musdone stringpool'
+ 'musdone timevar'
+ 'musdone toplev'
+ 'musdone tree-dump'
+ 'musdone tree-inline'
+ 'musdone tree'
+ 'musdone unroll'
+ 'musdone varasm'
+ 'musdone varray'
+ 'musdone version'
+ 'musdone xmalloc'
+ 'musdone xstrerror'
+ 'musdone xstrdup'
+ 'musdone xexit'
+ 'musdone concat'
+ 'musdone hex'
+ 'musdone alloca'
+ 'musdone lbasename'
+ 'musdone obstack'
+ 'musdone strsignal'
+ 'musdone safe-ctype'
+ 'musdone splay-tree'
+ 'musdone fibheap'
+ 'musdone hashtab'
+ 'musdone asprintf'
+ 'musdone vasprintf'
+ 'musdone getpagesize'
+ 'musdone partition'
+ 'musdone i370-c'
+ 'musdone i370'
+ 'musdone unixio'
+ 'musdone stdio'
+ 'musdone stdlib'
+ 'musdone ctype'
+ 'musdone string'
+ 'musdone time'
+ 'musdone errno'
+ 'musdone assert'
+ 'musdone locale'
+ 'musdone math'
+ 'musdone setjmp'
+ 'musdone signal'
+ 'musdone start'
+ 'musdone __memmgr'
+ 'musdone musstart'
+ 'musdone mussupa'
Index: gcc/gcc/musdone.exec
diff -c nul gcc/gcc/musdone.exec:1.1
*** nul	Tue Oct 01 16:28:46 2019
--- gcc/gcc/musdone.exec	Tue Nov 24 09:00:45 2009
***************
*** 0 ****
--- 1,5 ----
+ /inc rexx
+ parse arg name
+ 
+ "comp old\"name".s new\"name".s"
+ exit rc
Index: gcc/gcc/musutil.bat
diff -c nul gcc/gcc/musutil.bat:1.3
*** nul	Tue Oct 01 16:28:46 2019
--- gcc/gcc/musutil.bat	Sun Nov 01 14:08:14 2009
***************
*** 0 ****
--- 1,15 ----
+ cd ..\..\pdos\pdpclib
+ del *.o
+ copy pdptop.mac backup.mac
+ copy pdp370.mac pdptop.mac
+ make -f makefile.w32
+ cd ..\..\gcc\gcc
+ call compile
+ call compmvs -DMUSIC -UUSE_MEMMGR
+ m4 -I ../../pdos/pdpclib musutil.m4 >musutil.job
+ cd ..\..\pdos\pdpclib
+ copy backup.mac pdptop.mac
+ del backup.mac
+ cd ..\..\gcc\gcc
+ 
+ call runmus musutil.job output.txt
Index: gcc/gcc/musutil.m4
diff -c nul gcc/gcc/musutil.m4:1.3
*** nul	Tue Oct 01 16:28:46 2019
--- gcc/gcc/musutil.m4	Tue Dec 29 20:14:51 2015
***************
*** 0 ****
--- 1,325 ----
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /PARM *
+ /INC PURGE
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /SAVE PDPASM REPL
+ /inc rexx
+ parse arg name
+ queue "/file syspunch n("name".obj) new(repl) sp(100) secsp(100%)"
+ queue "/file syslib pds(@BLD000:*.M,$MCU:*.M)"
+ queue "/load asm"
+ queue "/job nogo"
+ queue "/opt deck,list"
+ queue "/inc" name".asm"
+ "EXEC"
+ 
+ exit rc
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /SAVE PDPTOP.M REPL
+ undivert(pdptop.mac)dnl
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /SAVE PDPMAIN.M REPL
+ undivert(pdpmain.mac)dnl
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /SAVE PDPPRLG.M REPL
+ undivert(pdpprlg.mac)dnl
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /SAVE PDPEPIL.M REPL
+ undivert(pdpepil.mac)dnl
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /SAVE MUSSTART.ASM REPL
+ undivert(musstart.asm)dnl
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /SAVE MUSSUPA.ASM REPL
+ undivert(mussupa.asm)dnl
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /SAVE START.ASM REPL
+ undivert(start.s)dnl
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /SAVE STDIO.ASM REPL
+ undivert(stdio.s)dnl
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /SAVE STDLIB.ASM REPL
+ undivert(stdlib.s)dnl
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /SAVE CTYPE.ASM REPL
+ undivert(ctype.s)dnl
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /SAVE STRING.ASM REPL
+ undivert(string.s)dnl
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /SAVE TIME.ASM REPL
+ undivert(time.s)dnl
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /SAVE ERRNO.ASM REPL
+ undivert(errno.s)dnl
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /SAVE ASSERT.ASM REPL
+ undivert(assert.s)dnl
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /SAVE LOCALE.ASM REPL
+ undivert(locale.s)dnl
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /SAVE MATH.ASM REPL
+ undivert(math.s)dnl
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /SAVE SETJMP.ASM REPL
+ undivert(setjmp.s)dnl
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /SAVE SIGNAL.ASM REPL
+ undivert(signal.s)dnl
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /SAVE __MEMMGR.ASM REPL
+ undivert(__memmgr.s)dnl
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /SAVE COPYFILE.ASM REPL
+ undivert(copyfile.s)dnl
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /SAVE HEXDUMP.ASM REPL
+ undivert(hexdump.s)dnl
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /SAVE MVSUNZIP.ASM REPL
+ undivert(mvsunzip.s)dnl
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /SAVE MVSENDEC.ASM REPL
+ undivert(mvsendec.s)dnl
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /inc rexx
+ 'pdpasm start'
+ 'pdpasm stdio'
+ 'pdpasm stdlib'
+ 'pdpasm ctype'
+ 'pdpasm string'
+ 'pdpasm time'
+ 'pdpasm errno'
+ 'pdpasm assert'
+ 'pdpasm locale'
+ 'pdpasm math'
+ 'pdpasm setjmp'
+ 'pdpasm signal'
+ 'pdpasm __memmgr'
+ 'pdpasm mussupa'
+ 'pdpasm musstart'
+ 'pdpasm copyfile'
+ 'pdpasm hexdump'
+ 'pdpasm mvsunzip'
+ 'pdpasm mvsendec'
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999
+ /file lmod n(copyfile.lmod) new(repl) lr(128) recfm(f) sp(100) shr
+ /load lked
+ /job map,nogo,print,stats,mode=os,name=copyfile
+ .org 4a00
+ /inc copyfile.obj
+ /inc musstart.obj
+ /inc mussupa.obj
+ /inc __memmgr.obj
+ /inc assert.obj
+ /inc ctype.obj
+ /inc errno.obj
+ /inc locale.obj
+ /inc math.obj
+ /inc setjmp.obj
+ /inc signal.obj
+ /inc start.obj
+ /inc stdio.obj
+ /inc stdlib.obj
+ /inc string.obj
+ /inc time.obj
+  ENTRY @@MAIN
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999
+ /file lmod n(hexdump.lmod) new(repl) lr(128) recfm(f) sp(100) shr
+ /load lked
+ /job map,nogo,print,stats,mode=os,name=hexdump
+ .org 4a00
+ /inc hexdump.obj
+ /inc musstart.obj
+ /inc mussupa.obj
+ /inc __memmgr.obj
+ /inc assert.obj
+ /inc ctype.obj
+ /inc errno.obj
+ /inc locale.obj
+ /inc math.obj
+ /inc setjmp.obj
+ /inc signal.obj
+ /inc start.obj
+ /inc stdio.obj
+ /inc stdlib.obj
+ /inc string.obj
+ /inc time.obj
+  ENTRY @@MAIN
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999
+ /file lmod n(mvsunzip.lmod) new(repl) lr(128) recfm(f) sp(100) shr
+ /load lked
+ /job map,nogo,print,stats,mode=os,name=mvsunzip
+ .org 4a00
+ /inc mvsunzip.obj
+ /inc musstart.obj
+ /inc mussupa.obj
+ /inc __memmgr.obj
+ /inc assert.obj
+ /inc ctype.obj
+ /inc errno.obj
+ /inc locale.obj
+ /inc math.obj
+ /inc setjmp.obj
+ /inc signal.obj
+ /inc start.obj
+ /inc stdio.obj
+ /inc stdlib.obj
+ /inc string.obj
+ /inc time.obj
+  ENTRY @@MAIN
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999
+ /file lmod n(mvsendec.lmod) new(repl) lr(128) recfm(f) sp(100) shr
+ /load lked
+ /job map,nogo,print,stats,mode=os,name=mvsendec
+ .org 4a00
+ /inc mvsendec.obj
+ /inc musstart.obj
+ /inc mussupa.obj
+ /inc __memmgr.obj
+ /inc assert.obj
+ /inc ctype.obj
+ /inc errno.obj
+ /inc locale.obj
+ /inc math.obj
+ /inc setjmp.obj
+ /inc signal.obj
+ /inc start.obj
+ /inc stdio.obj
+ /inc stdlib.obj
+ /inc string.obj
+ /inc time.obj
+  ENTRY @@MAIN
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file myin n(assert.asm) shr
+ /file myout n(temp.txt) recfm(f) lrecl(80) blksize(800)
+ /etc new(repl) sp(100) secsp(100%)
+ /parm -tt dd:myin dd:myout
+ /load xmon
+ copyfile n(copyfile.lmod) lcparm v(256)
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /file myin n(temp.txt) shr
+ /parm dd:myin
+ /load xmon
+ hexdump n(hexdump.lmod) lcparm v(256)
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /load xmon
+ mvsendec n(mvsendec.lmod) lcparm v(256)
+ /END
+ 
+ /ID SAVE-JOB-123456 @BLD000 9999 9999 9999 9999
+ /PASSWORD=BLD000
+ /sys region=9999,xregion=64m
+ /file sysprint prt osrecfm(f) oslrecl(256)
+ /load xmon
+ mvsunzip n(mvsunzip.lmod) lcparm v(256)
+ /END
Index: gcc/gcc/mvstest.bat
diff -c nul gcc/gcc/mvstest.bat:1.2
*** nul	Tue Oct 01 16:28:46 2019
--- gcc/gcc/mvstest.bat	Tue Oct 31 18:26:20 2006
***************
*** 0 ****
--- 1 ----
+ gccmvs -S -o - mvstest.c
Index: gcc/gcc/mvstest.c
diff -c nul gcc/gcc/mvstest.c:1.1
*** nul	Tue Oct 01 16:28:46 2019
--- gcc/gcc/mvstest.c	Wed Feb 15 21:25:42 2006
***************
*** 0 ****
--- 1,7 ----
+ #include "mvstest.h"
+ 
+ int main(void)
+ {
+     mary("hello, world\n");
+     return (0);
+ }
Index: gcc/gcc/mvstest.h
diff -c nul gcc/gcc/mvstest.h:1.1
*** nul	Tue Oct 01 16:28:46 2019
--- gcc/gcc/mvstest.h	Wed Feb 15 21:25:42 2006
***************
*** 0 ****
--- 1,3 ----
+ int x;
+ 
+ #define mary printf
Index: gcc/gcc/optabs.h
diff -c gcc/gcc/optabs.h:1.1.1.1 gcc/gcc/optabs.h:1.4
*** gcc/gcc/optabs.h:1.1.1.1	Wed Feb 15 21:22:25 2006
--- gcc/gcc/optabs.h	Fri Nov 03 18:10:08 2006
***************
*** 51,56 ****
--- 51,61 ----
     the body of that kind of insn.  */
  #define GEN_FCN(CODE) (*insn_data[(int) (CODE)].genfun)
  
+ /* Allow for compilers that pass parameters in registers */
+ #define GEN_FN2(CODE) \
+ (*((struct rtx_def *(*) PARAMS ((struct rtx_def *, struct rtx_def *)))\
+ (insn_data[(int) (CODE)].genfun)))
+ 
  /* Enumeration of valid indexes into optab_table.  */
  enum optab_index
  {
Index: gcc/gcc/options.h
diff -c nul gcc/gcc/options.h:1.1
*** nul	Tue Oct 01 16:28:46 2019
--- gcc/gcc/options.h	Wed Feb 15 21:25:42 2006
***************
*** 0 ****
--- 1 ----
+ /* empty file, don't know what it is for */
Index: gcc/gcc/pdpone.exec
diff -c nul gcc/gcc/pdpone.exec:1.2
*** nul	Tue Oct 01 16:28:46 2019
--- gcc/gcc/pdpone.exec	Sat May 26 17:20:39 2018
***************
*** 0 ****
--- 1,31 ----
+ *******************************************************************
+ *
+ * This EXEC compiles a single C file
+ * Usage: PDPONE <FILE> <DISK> <PARM>
+ *
+ *******************************************************************
+ &CONTROL
+ 
+ &FILE = &1
+ &DISK = &2
+ &PARMF = &3
+ 
+ FILEDEF SYSPRINT TERM (LRECL 80
+ FILEDEF SYSPARM DISK &PARMF PARM &DISK
+ FILEDEF OUT DISK &FILE WORK &DISK (LRECL 2000 RECFM V
+ FILEDEF SYSIN DISK &FILE C &DISK
+ GCC
+ 
+ *
+ * NOW RENAME OUTPUT FILE IF GCC WORKED
+ *
+ &IF &RETCODE NE 0 &EXIT &RETCODE
+ STATE &FILE S &DISK
+ &IF &RETCODE NE 0 &GOTO -COPYFILE
+ ERASE &FILE S &DISK
+ -COPYFILE
+ RENAME &FILE WORK &DISK = S =
+ FILEDEF SYSPRINT CLEAR
+ FILEDEF SYSPARM CLEAR
+ FILEDEF OUT CLEAR
+ FILEDEF SYSIN CLEAR
Index: gcc/gcc/postgen.jcl
diff -c nul gcc/gcc/postgen.jcl:1.8
*** nul	Tue Oct 01 16:28:46 2019
--- gcc/gcc/postgen.jcl	Tue Aug 18 22:22:56 2009
***************
*** 0 ****
--- 1,54 ----
+ //GCCGEN   JOB CLASS=C,REGION=0K
+ //*
+ //CREATE   PROC PDPPREF='PDPCLIB',GCCPREF='GCC'
+ //DELETE   EXEC PGM=IEFBR14
+ //DD5      DD DSN=&GCCPREF..SOURCE2,DISP=(MOD,DELETE),
+ //       UNIT=SYSALLDA,SPACE=(TRK,(0))
+ //DD6      DD DSN=&GCCPREF..INCLUDE2,DISP=(MOD,DELETE),
+ //       UNIT=SYSALLDA,SPACE=(TRK,(0))
+ //DD10     DD DSN=&GCCPREF..LINKLIB,DISP=(MOD,DELETE),
+ //       UNIT=SYSALLDA,SPACE=(TRK,(0))
+ //DD12     DD DSN=&PDPPREF..NCALIB,DISP=(MOD,DELETE),
+ //       UNIT=SYSALLDA,SPACE=(TRK,(0))
+ //*
+ //ALLOC    EXEC PGM=IEFBR14
+ //DD5      DD DSN=&GCCPREF..SOURCE2,DISP=(,CATLG),
+ // DCB=(RECFM=VB,LRECL=255,BLKSIZE=6233),
+ // SPACE=(6233,(2600,2600,44)),UNIT=SYSALLDA
+ //DD6      DD DSN=&GCCPREF..INCLUDE2,DISP=(,CATLG),
+ // DCB=(RECFM=VB,LRECL=255,BLKSIZE=6233),
+ // SPACE=(6233,(346,346,44)),UNIT=SYSALLDA
+ //DD10     DD DSN=&GCCPREF..LINKLIB,DISP=(,CATLG),
+ // DCB=(RECFM=U,LRECL=0,BLKSIZE=6144),
+ // SPACE=(6144,(1548,1548,44)),UNIT=SYSALLDA
+ //DD12     DD DSN=&PDPPREF..NCALIB,DISP=(,CATLG),
+ // DCB=(RECFM=U,LRECL=0,BLKSIZE=6144),
+ // SPACE=(6144,(61,61,44)),UNIT=SYSALLDA
+ //         PEND
+ //*
+ //COPY     PROC GCCPREF='GCC',LIB=''
+ //IEBCPY   EXEC PGM=IEBCOPY
+ //SYSUT1   DD DSN=&GCCPREF..&LIB,DISP=SHR
+ //SYSUT2   DD DSN=&GCCPREF..&LIB.2,DISP=SHR
+ //SYSIN    DD DUMMY
+ //SYSPRINT DD SYSOUT=*
+ //         PEND
+ //*
+ //MACCOPY  PROC PDPPREF='PDPCLIB'
+ //GENER1   EXEC PGM=IEBGENER
+ //SYSUT1   DD DSN=&PDPPREF..MACLIB(PDPORIG),DISP=SHR
+ //SYSUT2   DD DSN=&PDPPREF..MACLIB(PDPTOP),DISP=SHR
+ //SYSIN    DD DUMMY
+ //SYSPRINT DD SYSOUT=*
+ //*
+ //         PEND
+ //*
+ //S1       EXEC CREATE
+ //*
+ //S2       EXEC COPY,LIB='SOURCE'
+ //*
+ //S3       EXEC COPY,LIB='INCLUDE'
+ //*
+ //S4       EXEC MACCOPY
+ //*
+ //
Index: gcc/gcc/predict.c
diff -c gcc/gcc/predict.c:1.1.1.1 gcc/gcc/predict.c:1.4
*** gcc/gcc/predict.c:1.1.1.1	Wed Feb 15 21:22:25 2006
--- gcc/gcc/predict.c	Wed Sep 28 19:11:27 2016
***************
*** 626,632 ****
    basic_block next;
  
    /* True if block needs to be visited in prop_freqency.  */
!   int tovisit:1;
  
    /* Number of predecessors we need to visit first.  */
    int npredecessors;
--- 626,632 ----
    basic_block next;
  
    /* True if block needs to be visited in prop_freqency.  */
!   unsigned int tovisit:1;
  
    /* Number of predecessors we need to visit first.  */
    int npredecessors;
***************
*** 643,649 ****
       builds on machines where FP registers are wider than double.  */
    volatile double back_edge_prob;
    /* True if the edge is an loopback edge in the natural loop.  */
!   int back_edge:1;
  } *edge_info;
  
  #define BLOCK_INFO(B)	((block_info) (B)->aux)
--- 643,649 ----
       builds on machines where FP registers are wider than double.  */
    volatile double back_edge_prob;
    /* True if the edge is an loopback edge in the natural loop.  */
!   unsigned int back_edge:1;
  } *edge_info;
  
  #define BLOCK_INFO(B)	((block_info) (B)->aux)
Index: gcc/gcc/pregen.jcl
diff -c nul gcc/gcc/pregen.jcl:1.1
*** nul	Tue Oct 01 16:28:46 2019
--- gcc/gcc/pregen.jcl	Mon Feb 25 00:22:43 2008
***************
*** 0 ****
--- 1,17 ----
+ //GCCGEN   JOB CLASS=C,REGION=0K
+ //*
+ //COPY     PROC GCCPREF='GCC'
+ //IEBCPY   EXEC PGM=IEBCOPY
+ //FROM     DD DSN=&GCCPREF..TMPLOAD,DISP=SHR
+ //TO       DD DSN=&GCCPREF..LINKLIB,DISP=SHR
+ //SYSIN    DD DUMMY
+ //SYSPRINT DD SYSOUT=*
+ //         PEND
+ //*
+ //*
+ //CPY      EXEC COPY
+ //SYSIN    DD *
+  COPY OUTDD=TO,INDD=FROM
+  SELECT MEMBER=((STAGE1,GCC))
+ /*
+ //
Index: gcc/gcc/read-rtl.c
diff -c gcc/gcc/read-rtl.c:1.1.1.1 gcc/gcc/read-rtl.c:1.3
*** gcc/gcc/read-rtl.c:1.1.1.1	Wed Feb 15 21:22:26 2006
--- gcc/gcc/read-rtl.c	Sun Nov 05 23:26:09 2006
***************
*** 88,94 ****
  	   read_rtx_filename, read_rtx_lineno, context);
  
    VA_CLOSE (ap);
!   exit (1);
  }
  
  /* Dump code after printing a message.  Used when read_rtx finds
--- 88,94 ----
  	   read_rtx_filename, read_rtx_lineno, context);
  
    VA_CLOSE (ap);
!   exit (FATAL_EXIT_CODE);
  }
  
  /* Dump code after printing a message.  Used when read_rtx finds
Index: gcc/gcc/readme.txt
diff -c nul gcc/gcc/readme.txt:1.2
*** nul	Tue Oct 01 16:28:47 2019
--- gcc/gcc/readme.txt	Tue Apr 27 21:53:43 2010
***************
*** 0 ****
--- 1,4 ----
+ Please see gccmvs.txt for MVS installation instructions
+ and gcccms.txt for CMS installation instructions.
+ and gccmus.txt for MUSIC/SP installation instructions.
+ and gccvse.txt for DOS/VSE installation instructions.
Index: gcc/gcc/runsed.bat
diff -c nul gcc/gcc/runsed.bat:1.10
*** nul	Tue Oct 01 16:28:47 2019
--- gcc/gcc/runsed.bat	Sat Jan 05 00:39:14 2008
***************
*** 0 ****
--- 1,3 ----
+ sed "s/'-DUSE_MEMMGR/'-DXXX_MEMMGR/g" <%1 >sed.tmp
+ del %1
+ ren sed.tmp %1
Index: gcc/gcc/runspool.exec
diff -c nul gcc/gcc/runspool.exec:1.7
*** nul	Tue Oct 01 16:28:47 2019
--- gcc/gcc/runspool.exec	Wed Nov 12 22:22:50 2008
***************
*** 0 ****
--- 1,50 ----
+ * Run a job, spooling the output
+ *
+ * First connect to the z/VM system with something like this:
+ *
+ * c3270 -mono 66.139.111.222 3333
+ *
+ * Then press ctrl-] to get the c3270 prompt
+ *
+ * Then transfer the file to the b disk as such:
+ *
+ * c3270> transfer localfile=xfer.card "hostfile=xfer card b" 
+ *        direction=send mode=binary exist=replace
+ *
+ * Then enter to return
+ *
+ * Now assuming this file, plus CMSUTIL have already been
+ * placed on your A disk, make your A disk become D, e.g.
+ *
+ * access 191 D
+ *
+ * Then type "RUNSPOOL" (assuming you have corrected the
+ * hardcoded numbers below - note that it erases your disks!)
+ *
+ * You probably want to rename this file so that after a
+ * fresh extraction, you don't use your unmodified version
+ * if you attempt a rerun.
+ *
+ 
+ CP MSG * START REDIRECTED JOB
+ 
+ CP SPOOL CONS TO * START NOTERM
+ 
+ MVSENDEC DECB "XFER CARD B" "ALL ZIP D"
+ 
+ ACCESS 291 A (ERASE
+ ACCESS 192 B (ERASE
+ ACCESS 193 C
+ 
+ MVSUNZIP "ALL ZIP D" A
+ 
+ SET LDRTBLS 25
+ 
+ * e.g. EXEC ALLCMS A B C
+ 
+ *&1 &2 &3 &4 &5 &6 &7 &8 &9
+ EXEC ALLCMS A B C
+ 
+ CP SPOOL CONS STOP CLOSE
+ 
+ CP MSG * END REDIRECTED JOB
Index: gcc/gcc/sdbout.c
diff -c gcc/gcc/sdbout.c:1.1.1.1 gcc/gcc/sdbout.c:1.2
*** gcc/gcc/sdbout.c:1.1.1.1	Wed Feb 15 21:22:26 2006
--- gcc/gcc/sdbout.c	Mon Jun 18 04:21:06 2018
***************
*** 251,257 ****
  /* Set the sdb tag identifier string for TYPE to NAME.  */
  
  #define SET_KNOWN_TYPE_TAG(TYPE, NAME) \
!   TYPE_SYMTAB_POINTER (TYPE) = (NAME)
  
  /* Return the name (a string) of the struct, union or enum tag
     described by the TREE_LIST node LINK.  This is 0 for an anonymous one.  */
--- 251,257 ----
  /* Set the sdb tag identifier string for TYPE to NAME.  */
  
  #define SET_KNOWN_TYPE_TAG(TYPE, NAME) \
!   TYPE_SYMTAB_POINTER (TYPE) = (char *)(NAME)
  
  /* Return the name (a string) of the struct, union or enum tag
     described by the TREE_LIST node LINK.  This is 0 for an anonymous one.  */
Index: gcc/gcc/simplify-rtx.c
diff -c gcc/gcc/simplify-rtx.c:1.1.1.1 gcc/gcc/simplify-rtx.c:1.4
*** gcc/gcc/simplify-rtx.c:1.1.1.1	Wed Feb 15 21:22:26 2006
--- gcc/gcc/simplify-rtx.c	Thu Jul 02 02:11:32 2009
***************
*** 822,828 ****
      case DIV:
  #ifndef REAL_INFINITY
        if (f1 == 0)
! 	return 0;
  #endif
        value = f0 / f1;
        break;
--- 822,831 ----
      case DIV:
  #ifndef REAL_INFINITY
        if (f1 == 0)
!         {
!           args->result = 0;
!           return;
!         }
  #endif
        value = f0 / f1;
        break;
Index: gcc/gcc/specs.h
diff -c nul gcc/gcc/specs.h:1.3
*** nul	Tue Oct 01 16:28:47 2019
--- gcc/gcc/specs.h	Tue Oct 31 19:15:25 2006
***************
*** 0 ****
--- 1 ----
+ /* list of extensions and which compiler to run */
Index: gcc/gcc/stage0a.jcl
diff -c nul gcc/gcc/stage0a.jcl:1.22
*** nul	Tue Oct 01 16:28:47 2019
--- gcc/gcc/stage0a.jcl	Sun Apr 26 15:37:54 2009
***************
*** 0 ****
--- 1,15 ----
+ //GCCGEN   JOB CLASS=C,REGION=0K
+ //*
+ //* Define aliases for High-level qualifiers suitable
+ //* for your site.
+ //*
+ //IDCAMS   EXEC PGM=IDCAMS
+ //SYSPRINT DD  SYSOUT=*
+ //SYSIN    DD  *
+   DEFINE ALIAS (NAME(GCC) RELATE(SYS1.UCAT.TSO)) -
+          CATALOG(SYS1.VMASTCAT/SECRET)
+   DEFINE ALIAS (NAME(PDPCLIB) RELATE(SYS1.UCAT.TSO)) -
+          CATALOG(SYS1.VMASTCAT/SECRET)
+   SET MAXCC=0
+ /*
+ //
Index: gcc/gcc/stage0b.jcl
diff -c nul gcc/gcc/stage0b.jcl:1.35
*** nul	Tue Oct 01 16:28:47 2019
--- gcc/gcc/stage0b.jcl	Thu Sep 12 21:24:42 2019
***************
*** 0 ****
--- 1,90 ----
+ //GCCGEN   JOB CLASS=C,REGION=0K
+ //*
+ //CREATE   PROC PDPPREF='PDPCLIB',GCCPREF='GCC'
+ //DELETE   EXEC PGM=IEFBR14
+ //DD1      DD DSN=&PDPPREF..INCLUDE,DISP=(MOD,DELETE),
+ //       UNIT=SYSALLDA,SPACE=(TRK,(0))
+ //DD2      DD DSN=&PDPPREF..SOURCE,DISP=(MOD,DELETE),
+ //       UNIT=SYSALLDA,SPACE=(TRK,(0))
+ //DD3      DD DSN=&PDPPREF..DOC,DISP=(MOD,DELETE),
+ //       UNIT=SYSALLDA,SPACE=(TRK,(0))
+ //DD4      DD DSN=&GCCPREF..PROCLIB,DISP=(MOD,DELETE),
+ //       UNIT=SYSALLDA,SPACE=(TRK,(0))
+ //DD5      DD DSN=&GCCPREF..SOURCE,DISP=(MOD,DELETE),
+ //       UNIT=SYSALLDA,SPACE=(TRK,(0))
+ //DD6      DD DSN=&GCCPREF..INCLUDE,DISP=(MOD,DELETE),
+ //       UNIT=SYSALLDA,SPACE=(TRK,(0))
+ //DD7      DD DSN=&GCCPREF..DOC,DISP=(MOD,DELETE),
+ //       UNIT=SYSALLDA,SPACE=(TRK,(0))
+ //DD8      DD DSN=&GCCPREF..JCL,DISP=(MOD,DELETE),
+ //       UNIT=SYSALLDA,SPACE=(TRK,(0))
+ //DD9      DD DSN=&GCCPREF..S,DISP=(MOD,DELETE),
+ //       UNIT=SYSALLDA,SPACE=(TRK,(0))
+ //DD10     DD DSN=&GCCPREF..LINKLIB,DISP=(MOD,DELETE),
+ //       UNIT=SYSALLDA,SPACE=(TRK,(0))
+ //DD12     DD DSN=&PDPPREF..NCALIB,DISP=(MOD,DELETE),
+ //       UNIT=SYSALLDA,SPACE=(TRK,(0))
+ //DD13     DD DSN=&PDPPREF..MACLIB,DISP=(MOD,DELETE),
+ //       UNIT=SYSALLDA,SPACE=(TRK,(0))
+ //DD14     DD DSN=&GCCPREF..S2,DISP=(MOD,DELETE),
+ //       UNIT=SYSALLDA,SPACE=(TRK,(0))
+ //DD15     DD DSN=&GCCPREF..S3,DISP=(MOD,DELETE),
+ //       UNIT=SYSALLDA,SPACE=(TRK,(0))
+ //DD16     DD DSN=&PDPPREF..LINKLIB,DISP=(MOD,DELETE),
+ //       UNIT=SYSALLDA,SPACE=(TRK,(0))
+ //DD17     DD DSN=&GCCPREF..TMPLOAD,DISP=(MOD,DELETE),
+ //       UNIT=SYSALLDA,SPACE=(TRK,(0))
+ //*
+ //ALLOC    EXEC PGM=IEFBR14
+ //DD1      DD DSN=&PDPPREF..INCLUDE,DISP=(,CATLG),
+ // DCB=(RECFM=FB,LRECL=80,BLKSIZE=6160),
+ // SPACE=(6160,(32,32,44)),UNIT=SYSALLDA
+ //DD2      DD DSN=&PDPPREF..SOURCE,DISP=(,CATLG),
+ // DCB=(RECFM=FB,LRECL=80,BLKSIZE=6160),
+ // SPACE=(6160,(400,400,44)),UNIT=SYSALLDA
+ //DD3      DD DSN=&PDPPREF..DOC,DISP=(,CATLG),
+ // DCB=(RECFM=FB,LRECL=80,BLKSIZE=6160),
+ // SPACE=(6160,(23,23,44)),UNIT=SYSALLDA
+ //DD4      DD DSN=&GCCPREF..PROCLIB,DISP=(,CATLG),
+ // DCB=(RECFM=FB,LRECL=80,BLKSIZE=6160),
+ // SPACE=(6160,(15,15,44)),UNIT=SYSALLDA
+ //DD5      DD DSN=&GCCPREF..SOURCE,DISP=(,CATLG),
+ // DCB=(RECFM=VB,LRECL=255,BLKSIZE=6233),
+ // SPACE=(6233,(2600,2600,44)),UNIT=SYSALLDA
+ //DD6      DD DSN=&GCCPREF..INCLUDE,DISP=(,CATLG),
+ // DCB=(RECFM=VB,LRECL=255,BLKSIZE=6233),
+ // SPACE=(6233,(346,346,44)),UNIT=SYSALLDA
+ //DD7      DD DSN=&GCCPREF..DOC,DISP=(,CATLG),
+ // DCB=(RECFM=VB,LRECL=255,BLKSIZE=6233),
+ // SPACE=(6233,(100,100,44)),UNIT=SYSALLDA
+ //DD8      DD DSN=&GCCPREF..JCL,DISP=(,CATLG),
+ // DCB=(RECFM=FB,LRECL=80,BLKSIZE=6160),
+ // SPACE=(6160,(69,69,44)),UNIT=SYSALLDA
+ //DD9      DD DSN=&GCCPREF..S,DISP=(,CATLG),
+ // DCB=(RECFM=FB,LRECL=80,BLKSIZE=6160),
+ // SPACE=(6160,(10500,10500,44)),UNIT=SYSALLDA
+ //DD10     DD DSN=&GCCPREF..LINKLIB,DISP=(,CATLG),
+ // DCB=(RECFM=U,LRECL=0,BLKSIZE=6144),
+ // SPACE=(6144,(774,774,44),,,ROUND),UNIT=SYSALLDA
+ //DD12     DD DSN=&PDPPREF..NCALIB,DISP=(,CATLG),
+ // DCB=(RECFM=U,LRECL=0,BLKSIZE=6144),
+ // SPACE=(6144,(61,61,44)),UNIT=SYSALLDA
+ //DD13     DD DSN=&PDPPREF..MACLIB,DISP=(,CATLG),
+ // DCB=(RECFM=FB,LRECL=80,BLKSIZE=6160),
+ // SPACE=(6160,(10,10,44)),UNIT=SYSALLDA
+ //DD14     DD DSN=&GCCPREF..S2,DISP=(,CATLG),
+ // DCB=(RECFM=FB,LRECL=80,BLKSIZE=6160),
+ // SPACE=(6160,(10500,10500,44)),UNIT=SYSALLDA
+ //DD15     DD DSN=&GCCPREF..S3,DISP=(,CATLG),
+ // DCB=(RECFM=FB,LRECL=80,BLKSIZE=6160),
+ // SPACE=(6160,(10500,10500,44)),UNIT=SYSALLDA
+ //DD16     DD DSN=&PDPPREF..LINKLIB,DISP=(,CATLG),
+ // DCB=(RECFM=U,LRECL=0,BLKSIZE=6144),
+ // SPACE=(6144,(77,77,44),,,ROUND),UNIT=SYSALLDA
+ //DD17     DD DSN=&GCCPREF..TMPLOAD,DISP=(,CATLG),
+ // DCB=(RECFM=U,LRECL=0,BLKSIZE=6144),
+ // SPACE=(6144,(2000,2000,44),,,ROUND),UNIT=SYSALLDA
+ //         PEND
+ //*
+ //S1 EXEC CREATE
+ //
Index: gcc/gcc/stage0c.jcl
diff -c nul gcc/gcc/stage0c.jcl:1.9
*** nul	Tue Oct 01 16:28:47 2019
--- gcc/gcc/stage0c.jcl	Sat Apr 01 20:00:31 2017
***************
*** 0 ****
--- 1,21 ----
+ //GCCGEN   JOB CLASS=C,REGION=0K
+ //*
+ //TRANSFER PROC GCCPREF='GCC'
+ //DELETE   EXEC PGM=IEFBR14
+ //DD1      DD DSN=&GCCPREF..ALLZIPS,DISP=(MOD,DELETE),
+ //       UNIT=SYSALLDA,SPACE=(TRK,(0))
+ //*
+ //COPY     EXEC PGM=COPYFILE,PARM='-bb dd:sysut1 dd:sysut2'
+ //SYSUT1   DD DSN=HERC01.IN,DISP=OLD,
+ //         UNIT=TAPE,VOL=SER=PCTOMF,LABEL=(1,NL),
+ //         DCB=(RECFM=U,LRECL=0,BLKSIZE=32760)
+ //SYSUT2   DD DSN=&GCCPREF..ALLZIPS,DISP=(,CATLG),
+ //         SPACE=(6233,(7000,7000),RLSE),UNIT=SYSALLDA,
+ //         DCB=(RECFM=U,LRECL=0,BLKSIZE=6233)
+ //SYSIN    DD DUMMY
+ //SYSPRINT DD SYSOUT=*
+ //SYSTERM  DD SYSOUT=*
+ //         PEND
+ //*
+ //S1 EXEC TRANSFER
+ //
Index: gcc/gcc/stage0d.jcl
diff -c nul gcc/gcc/stage0d.jcl:1.11
*** nul	Tue Oct 01 16:28:47 2019
--- gcc/gcc/stage0d.jcl	Thu Oct 29 23:59:22 2009
***************
*** 0 ****
--- 1,56 ----
+ //GCCGEN   JOB CLASS=C,REGION=0K
+ //*
+ //CREATE   EXEC PGM=IEFBR14
+ //DD1      DD DSN=&&ZIPS,DISP=(,PASS),
+ // DCB=(RECFM=U,LRECL=0,BLKSIZE=6233),
+ // SPACE=(6233,(7000,7000,44)),UNIT=SYSALLDA
+ //*
+ //UNZIPA   PROC MINPREF='MINIZIP',GCCPREF='GCC'
+ //UNZIPA   EXEC PGM=MINIUNZ,PARM='dd:input dd:output'
+ //STEPLIB  DD DSN=&MINPREF..LINKLIB,DISP=SHR
+ //INPUT    DD DSN=&GCCPREF..ALLZIPS,DISP=SHR
+ //OUTPUT   DD DSN=&&ZIPS,DISP=(OLD,PASS)
+ //SYSIN    DD DUMMY
+ //SYSPRINT DD SYSOUT=*
+ //SYSTERM  DD SYSOUT=*
+ //         PEND
+ //*
+ //UNZIPP   PROC MINPREF='MINIZIP',PDPPREF='PDPCLIB',IN=,OUT=
+ //UNZIPP   EXEC PGM=MINIUNZ,PARM='-a dd:input dd:output'
+ //STEPLIB  DD DSN=&MINPREF..LINKLIB,DISP=SHR
+ //INPUT    DD DSN=&&ZIPS(&IN),DISP=(OLD,PASS)
+ //OUTPUT   DD DSN=&PDPPREF..&OUT,DISP=SHR
+ //SYSIN    DD DUMMY
+ //SYSPRINT DD SYSOUT=*
+ //SYSTERM  DD SYSOUT=*
+ //         PEND
+ //*
+ //UNZIPG   PROC MINPREF='MINIZIP',GCCPREF='GCC',IN=,OUT=
+ //UNZIPG   EXEC PGM=MINIUNZ,PARM='-a dd:input dd:output'
+ //STEPLIB  DD DSN=&MINPREF..LINKLIB,DISP=SHR
+ //INPUT    DD DSN=&&ZIPS(&IN),DISP=(OLD,PASS)
+ //OUTPUT   DD DSN=&GCCPREF..&OUT,DISP=SHR
+ //SYSIN    DD DUMMY
+ //SYSPRINT DD SYSOUT=*
+ //SYSTERM  DD SYSOUT=*
+ //         PEND
+ //*
+ //CLEAN    PROC GCCPREF='GCC'
+ //DELETE   EXEC PGM=IEFBR14
+ //DD1      DD DSN=&GCCPREF..ALLZIPS,DISP=(MOD,DELETE),
+ //       UNIT=SYSALLDA,SPACE=(TRK,(0))
+ //         PEND
+ //*
+ //S0 EXEC UNZIPA
+ //S1 EXEC UNZIPP,IN='PDPI',OUT='INCLUDE'
+ //S2 EXEC UNZIPP,IN='PDPSRC',OUT='SOURCE'
+ //S3 EXEC UNZIPG,IN='GCCSRC',OUT='SOURCE'
+ //S4 EXEC UNZIPG,IN='GCCI',OUT='INCLUDE'
+ //S5 EXEC UNZIPG,IN='GCCS',OUT='S'
+ //S6 EXEC UNZIPG,IN='GCCPRC',OUT='PROCLIB'
+ //S7 EXEC UNZIPG,IN='GCCJCL',OUT='JCL'
+ //S8 EXEC UNZIPG,IN='GCCDOC',OUT='DOC'
+ //S9 EXEC UNZIPP,IN='PDPDOC',OUT='DOC'
+ //S10 EXEC UNZIPP,IN='PDPMAC',OUT='MACLIB'
+ //S11 EXEC CLEAN
+ //
Index: gcc/gcc/stage1.jcl
diff -c nul gcc/gcc/stage1.jcl:1.1
*** nul	Tue Oct 01 16:28:47 2019
--- gcc/gcc/stage1.jcl	Thu Sep 12 07:25:49 2019
***************
*** 0 ****
--- 1,198 ----
+ //GCCGEN   JOB CLASS=C,REGION=0K
+ //*
+ //* This is the first job of the stage 1 build
+ //* Note that PDPCLIB is hardcoded in two places and you
+ //* will need to adjust that.
+ //*
+ //ST1CMP   PROC GCCPREF='GCC',MEMBER='',LIST='NOLIST',
+ //         PDPPREF='PDPCLIB'
+ //ASM      EXEC PGM=ASMA90,
+ //         PARM='DECK,&LIST'
+ //SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR,DCB=BLKSIZE=32720
+ //         DD DSN=SYS1.MODGEN,DISP=SHR
+ //         DD DSN=&PDPPREF..MACLIB,DISP=SHR
+ //SYSUT1   DD UNIT=SYSALLDA,SPACE=(CYL,(20,10))
+ //SYSUT2   DD UNIT=SYSALLDA,SPACE=(CYL,(10,10))
+ //SYSUT3   DD UNIT=SYSALLDA,SPACE=(CYL,(10,10))
+ //SYSPRINT DD SYSOUT=*
+ //SYSLIN   DD DUMMY
+ //SYSGO    DD DUMMY
+ //SYSPUNCH DD DSN=&&OBJSET,UNIT=SYSALLDA,SPACE=(80,(70000,0)),
+ //            DISP=(MOD,PASS)
+ //SYSIN    DD DSN=&GCCPREF..S(&MEMBER),DISP=SHR
+ //         PEND
+ //*
+ //LINK     PROC GCCPREF='GCC',MODULE=''
+ //LKED     EXEC PGM=IEWL,
+ // PARM='MAP,LIST,SIZE=(999424,65536),AMODE=31,RMODE=ANY'
+ //SYSUT1   DD UNIT=SYSALLDA,SPACE=(CYL,(30,10))
+ //SYSPRINT DD SYSOUT=*
+ //*SYSLIB not needed
+ //SYSLIN   DD DSN=&&OBJSET,DISP=(OLD,DELETE)
+ //SYSLMOD  DD DSN=&GCCPREF..TMPLOAD(&MODULE),DISP=SHR
+ //         PEND
+ //*
+ //MVSSTART EXEC ST1CMP,MEMBER=MVSSTART
+ //SYSIN    DD   DSN=PDPCLIB.SOURCE(MVSSTART),DISP=SHR
+ //MVSSUPA  EXEC ST1CMP,MEMBER=MVSSUPA,LIST='LIST'
+ //SYSIN    DD   DSN=PDPCLIB.SOURCE(MVSSUPA),DISP=SHR
+ //START    EXEC ST1CMP,MEMBER=START
+ //STDIO    EXEC ST1CMP,MEMBER=STDIO
+ //STDLIB   EXEC ST1CMP,MEMBER=STDLIB
+ //CTYPE    EXEC ST1CMP,MEMBER=CTYPE
+ //STRING   EXEC ST1CMP,MEMBER=STRING
+ //TIME     EXEC ST1CMP,MEMBER=TIME
+ //ERRNO    EXEC ST1CMP,MEMBER=ERRNO
+ //ASSERT   EXEC ST1CMP,MEMBER=ASSERT
+ //LOCALE   EXEC ST1CMP,MEMBER=LOCALE
+ //MATH     EXEC ST1CMP,MEMBER=MATH  
+ //SETJMP   EXEC ST1CMP,MEMBER=SETJMP
+ //SIGNAL   EXEC ST1CMP,MEMBER=SIGNAL
+ //@@MEMMGR EXEC ST1CMP,MEMBER=@@MEMMGR
+ //ALIAS    EXEC ST1CMP,MEMBER=ALIAS        
+ //ATTRIBS  EXEC ST1CMP,MEMBER=ATTRIBS        
+ //BB@REORD EXEC ST1CMP,MEMBER=BB@REORD        
+ //BITMAP   EXEC ST1CMP,MEMBER=BITMAP        
+ //BUILTINS EXEC ST1CMP,MEMBER=BUILTINS        
+ //C@AUX@IN EXEC ST1CMP,MEMBER=C@AUX@IN        
+ //C@COMMON EXEC ST1CMP,MEMBER=C@COMMON        
+ //C@CONVER EXEC ST1CMP,MEMBER=C@CONVER        
+ //C@DECL   EXEC ST1CMP,MEMBER=C@DECL        
+ //C@ERRORS EXEC ST1CMP,MEMBER=C@ERRORS        
+ //C@FORMAT EXEC ST1CMP,MEMBER=C@FORMAT        
+ //C@LANG   EXEC ST1CMP,MEMBER=C@LANG        
+ //C@LEX    EXEC ST1CMP,MEMBER=C@LEX        
+ //C@OBJC@C EXEC ST1CMP,MEMBER=C@OBJC@C        
+ //C@PARSE  EXEC ST1CMP,MEMBER=C@PARSE        
+ //C@PRAGMA EXEC ST1CMP,MEMBER=C@PRAGMA        
+ //C@SEMANT EXEC ST1CMP,MEMBER=C@SEMANT        
+ //C@TYPECK EXEC ST1CMP,MEMBER=C@TYPECK        
+ //CALLER@S EXEC ST1CMP,MEMBER=CALLER@S        
+ //CALLS    EXEC ST1CMP,MEMBER=CALLS        
+ //CFG      EXEC ST1CMP,MEMBER=CFG        
+ //CFGANAL  EXEC ST1CMP,MEMBER=CFGANAL        
+ //CFGBUILD EXEC ST1CMP,MEMBER=CFGBUILD        
+ //CFGCLEAN EXEC ST1CMP,MEMBER=CFGCLEAN        
+ //CFGLAYOU EXEC ST1CMP,MEMBER=CFGLAYOU        
+ //CFGLOOP  EXEC ST1CMP,MEMBER=CFGLOOP        
+ //CFGRTL   EXEC ST1CMP,MEMBER=CFGRTL        
+ //COMBINE  EXEC ST1CMP,MEMBER=COMBINE        
+ //CONFLICT EXEC ST1CMP,MEMBER=CONFLICT        
+ //CONVERT  EXEC ST1CMP,MEMBER=CONVERT        
+ //CPPDEFAU EXEC ST1CMP,MEMBER=CPPDEFAU        
+ //CPPERROR EXEC ST1CMP,MEMBER=CPPERROR        
+ //CPPEXP   EXEC ST1CMP,MEMBER=CPPEXP        
+ //CPPFILES EXEC ST1CMP,MEMBER=CPPFILES        
+ //CPPHASH  EXEC ST1CMP,MEMBER=CPPHASH        
+ //CPPINIT  EXEC ST1CMP,MEMBER=CPPINIT        
+ //CPPLEX   EXEC ST1CMP,MEMBER=CPPLEX        
+ //CPPLIB   EXEC ST1CMP,MEMBER=CPPLIB        
+ //CPPMACRO EXEC ST1CMP,MEMBER=CPPMACRO        
+ //CPPMAIN  EXEC ST1CMP,MEMBER=CPPMAIN        
+ //CPPSPEC  EXEC ST1CMP,MEMBER=CPPSPEC        
+ //CSE      EXEC ST1CMP,MEMBER=CSE        
+ //CSELIB   EXEC ST1CMP,MEMBER=CSELIB        
+ //DEBUG    EXEC ST1CMP,MEMBER=DEBUG        
+ //DEPENDEN EXEC ST1CMP,MEMBER=DEPENDEN        
+ //DF       EXEC ST1CMP,MEMBER=DF        
+ //DIAGNOST EXEC ST1CMP,MEMBER=DIAGNOST        
+ //DOMINANC EXEC ST1CMP,MEMBER=DOMINANC        
+ //DWARF2AS EXEC ST1CMP,MEMBER=DWARF2AS        
+ //DWARF2OU EXEC ST1CMP,MEMBER=DWARF2OU        
+ //EMIT@RTL EXEC ST1CMP,MEMBER=EMIT@RTL        
+ //EXCEPT   EXEC ST1CMP,MEMBER=EXCEPT        
+ //EXPLOW   EXEC ST1CMP,MEMBER=EXPLOW        
+ //EXPMED   EXEC ST1CMP,MEMBER=EXPMED        
+ //EXPR     EXEC ST1CMP,MEMBER=EXPR        
+ //FINAL    EXEC ST1CMP,MEMBER=FINAL        
+ //FLOW     EXEC ST1CMP,MEMBER=FLOW        
+ //FOLD@CON EXEC ST1CMP,MEMBER=FOLD@CON        
+ //FUNCTION EXEC ST1CMP,MEMBER=FUNCTION        
+ //GCC      EXEC ST1CMP,MEMBER=GCC        
+ //GCCSPEC  EXEC ST1CMP,MEMBER=GCCSPEC        
+ //GCSE     EXEC ST1CMP,MEMBER=GCSE        
+ //GENRTL   EXEC ST1CMP,MEMBER=GENRTL        
+ //GGC@COMM EXEC ST1CMP,MEMBER=GGC@COMM        
+ //GGC@PAGE EXEC ST1CMP,MEMBER=GGC@PAGE        
+ //GLOBAL   EXEC ST1CMP,MEMBER=GLOBAL        
+ //GRAPH    EXEC ST1CMP,MEMBER=GRAPH        
+ //HASH     EXEC ST1CMP,MEMBER=HASH        
+ //HASHTABL EXEC ST1CMP,MEMBER=HASHTABL        
+ //HOOKS    EXEC ST1CMP,MEMBER=HOOKS        
+ //IFCVT    EXEC ST1CMP,MEMBER=IFCVT        
+ //INSN@ATT EXEC ST1CMP,MEMBER=INSN@ATT        
+ //INSN@EMI EXEC ST1CMP,MEMBER=INSN@EMI        
+ //INSN@EXT EXEC ST1CMP,MEMBER=INSN@EXT        
+ //INSN@OPI EXEC ST1CMP,MEMBER=INSN@OPI        
+ //INSN@OUT EXEC ST1CMP,MEMBER=INSN@OUT        
+ //INSN@REC EXEC ST1CMP,MEMBER=INSN@REC        
+ //INTEGRAT EXEC ST1CMP,MEMBER=INTEGRAT        
+ //JUMP     EXEC ST1CMP,MEMBER=JUMP        
+ //LANGHOOK EXEC ST1CMP,MEMBER=LANGHOOK        
+ //LCM      EXEC ST1CMP,MEMBER=LCM        
+ //LINE@MAP EXEC ST1CMP,MEMBER=LINE@MAP        
+ //LISTS    EXEC ST1CMP,MEMBER=LISTS        
+ //LOCAL@AL EXEC ST1CMP,MEMBER=LOCAL@AL        
+ //LOOP     EXEC ST1CMP,MEMBER=LOOP        
+ //MKDEPS   EXEC ST1CMP,MEMBER=MKDEPS        
+ //OPTABS   EXEC ST1CMP,MEMBER=OPTABS        
+ //PARAMS   EXEC ST1CMP,MEMBER=PARAMS        
+ //PREDICT  EXEC ST1CMP,MEMBER=PREDICT        
+ //PREFIX   EXEC ST1CMP,MEMBER=PREFIX        
+ //PRINT@RT EXEC ST1CMP,MEMBER=PRINT@RT        
+ //PRINT@TR EXEC ST1CMP,MEMBER=PRINT@TR        
+ //PROFILE  EXEC ST1CMP,MEMBER=PROFILE        
+ //REAL     EXEC ST1CMP,MEMBER=REAL        
+ //RECOG    EXEC ST1CMP,MEMBER=RECOG        
+ //REGCLASS EXEC ST1CMP,MEMBER=REGCLASS        
+ //REGMOVE  EXEC ST1CMP,MEMBER=REGMOVE        
+ //REGRENAM EXEC ST1CMP,MEMBER=REGRENAM        
+ //RELOAD   EXEC ST1CMP,MEMBER=RELOAD        
+ //RELOAD1  EXEC ST1CMP,MEMBER=RELOAD1        
+ //RESOURCE EXEC ST1CMP,MEMBER=RESOURCE        
+ //RTL@ERRO EXEC ST1CMP,MEMBER=RTL@ERRO        
+ //RTL      EXEC ST1CMP,MEMBER=RTL        
+ //RTLANAL  EXEC ST1CMP,MEMBER=RTLANAL        
+ //SBITMAP  EXEC ST1CMP,MEMBER=SBITMAP        
+ //SIBCALL  EXEC ST1CMP,MEMBER=SIBCALL        
+ //SIMPLIFY EXEC ST1CMP,MEMBER=SIMPLIFY        
+ //SSA@CCP  EXEC ST1CMP,MEMBER=SSA@CCP        
+ //SSA@DCE  EXEC ST1CMP,MEMBER=SSA@DCE        
+ //SSA      EXEC ST1CMP,MEMBER=SSA        
+ //STMT     EXEC ST1CMP,MEMBER=STMT        
+ //STOR@LAY EXEC ST1CMP,MEMBER=STOR@LAY        
+ //STRINGPO EXEC ST1CMP,MEMBER=STRINGPO        
+ //TIMEVAR  EXEC ST1CMP,MEMBER=TIMEVAR        
+ //TOPLEV   EXEC ST1CMP,MEMBER=TOPLEV        
+ //TREE@DUM EXEC ST1CMP,MEMBER=TREE@DUM        
+ //TREE@INL EXEC ST1CMP,MEMBER=TREE@INL        
+ //TREE     EXEC ST1CMP,MEMBER=TREE        
+ //UNROLL   EXEC ST1CMP,MEMBER=UNROLL        
+ //VARASM   EXEC ST1CMP,MEMBER=VARASM        
+ //VARRAY   EXEC ST1CMP,MEMBER=VARRAY        
+ //VERSION  EXEC ST1CMP,MEMBER=VERSION        
+ //XMALLOC  EXEC ST1CMP,MEMBER=XMALLOC        
+ //XSTRERRO EXEC ST1CMP,MEMBER=XSTRERRO        
+ //XSTRDUP  EXEC ST1CMP,MEMBER=XSTRDUP        
+ //XEXIT    EXEC ST1CMP,MEMBER=XEXIT        
+ //CONCAT   EXEC ST1CMP,MEMBER=CONCAT        
+ //HEX      EXEC ST1CMP,MEMBER=HEX        
+ //ALLOCA   EXEC ST1CMP,MEMBER=ALLOCA        
+ //LBASENAM EXEC ST1CMP,MEMBER=LBASENAM        
+ //OBSTACK  EXEC ST1CMP,MEMBER=OBSTACK        
+ //STRSIGNA EXEC ST1CMP,MEMBER=STRSIGNA        
+ //SAFE@CTY EXEC ST1CMP,MEMBER=SAFE@CTY        
+ //SPLAY@TR EXEC ST1CMP,MEMBER=SPLAY@TR        
+ //FIBHEAP  EXEC ST1CMP,MEMBER=FIBHEAP        
+ //HASHTAB  EXEC ST1CMP,MEMBER=HASHTAB        
+ //ASPRINTF EXEC ST1CMP,MEMBER=ASPRINTF        
+ //VASPRINT EXEC ST1CMP,MEMBER=VASPRINT        
+ //GETPAGES EXEC ST1CMP,MEMBER=GETPAGES        
+ //PARTITIO EXEC ST1CMP,MEMBER=PARTITIO        
+ //I370@C   EXEC ST1CMP,MEMBER=I370@C        
+ //I370     EXEC ST1CMP,MEMBER=I370        
+ //UNIXIO   EXEC ST1CMP,MEMBER=UNIXIO
+ //*
+ //DOLINK   EXEC LINK,MODULE='STAGE1'
+ //*
+ //
Index: gcc/gcc/stage2a.jcl
diff -c nul gcc/gcc/stage2a.jcl:1.59
*** nul	Tue Oct 01 16:28:47 2019
--- gcc/gcc/stage2a.jcl	Thu Sep 12 19:18:09 2019
***************
*** 0 ****
--- 1,129 ----
+ //GCCGEN   JOB CLASS=C,REGION=0K,TIME=1440
+ //*
+ //CREATE   PROC GCCPREF='GCC'
+ //DELETE   EXEC PGM=IEFBR14
+ //DD11     DD DSN=&GCCPREF..OBJ,DISP=(MOD,DELETE),
+ //       UNIT=SYSALLDA,SPACE=(TRK,(0))
+ //*
+ //ALLOC    EXEC PGM=IEFBR14
+ //DD11     DD DSN=&GCCPREF..OBJ,DISP=(,CATLG),
+ // DCB=(RECFM=FB,LRECL=80,BLKSIZE=6160),
+ // SPACE=(80,(70000,0)),UNIT=SYSALLDA
+ //         PEND
+ //*
+ //ST2CMP   PROC GCCPREF='GCC',MEMBER='',
+ // PDPPREF='PDPCLIB',
+ // COS1='-Os -S -ansi -pedantic-errors -remap -DHAVE_CONFIG_H',
+ // COS2='-DIN_GCC -DPUREISO -o dd:out -'
+ //*
+ //COMP     EXEC PGM=STAGE1,
+ // PARM='&COS1 &COS2'
+ //STEPLIB  DD DSN=&GCCPREF..TMPLOAD,DISP=SHR
+ //SYSIN    DD DSN=&GCCPREF..SOURCE(&MEMBER),DISP=SHR
+ //INCLUDE  DD DSN=&GCCPREF..INCLUDE,DISP=SHR,DCB=BLKSIZE=32720
+ //         DD DSN=&PDPPREF..INCLUDE,DISP=SHR
+ //SYSINCL  DD DSN=&GCCPREF..INCLUDE,DISP=SHR,DCB=BLKSIZE=32720
+ //         DD DSN=&PDPPREF..INCLUDE,DISP=SHR
+ //OUT      DD DSN=&GCCPREF..S2(&MEMBER),DISP=SHR
+ //SYSPRINT DD SYSOUT=*
+ //SYSTERM  DD SYSOUT=*
+ //SYSABEND DD SYSOUT=*
+ //*
+ //ASM      EXEC PGM=ASMA90,
+ //            PARM='DECK,NOLIST',
+ //            COND=(4,LT,COMP)
+ //SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR,DCB=BLKSIZE=32720
+ //         DD DSN=&PDPPREF..MACLIB,DISP=SHR
+ //SYSUT1   DD UNIT=SYSALLDA,SPACE=(CYL,(20,10))
+ //SYSUT2   DD UNIT=SYSALLDA,SPACE=(CYL,(10,10))
+ //SYSUT3   DD UNIT=SYSALLDA,SPACE=(CYL,(10,10))
+ //SYSPRINT DD SYSOUT=*
+ //SYSLIN   DD DUMMY
+ //SYSGO    DD DUMMY
+ //SYSPUNCH DD DSN=&GCCPREF..OBJ,DISP=MOD
+ //SYSIN    DD DSN=&GCCPREF..S2(&MEMBER),DISP=SHR
+ //*
+ //         PEND
+ //*
+ //NEWOBJ   EXEC CREATE
+ //*
+ //ALIAS    EXEC ST2CMP,MEMBER=ALIAS
+ //ALLOCA   EXEC ST2CMP,MEMBER=ALLOCA
+ //ASPRINTF EXEC ST2CMP,MEMBER=ASPRINTF
+ //ATTRIBS  EXEC ST2CMP,MEMBER=ATTRIBS
+ //BB@REORD EXEC ST2CMP,MEMBER=BB@REORD
+ //BITMAP   EXEC ST2CMP,MEMBER=BITMAP
+ //BUILTINS EXEC ST2CMP,MEMBER=BUILTINS
+ //C@AUX@IN EXEC ST2CMP,MEMBER=C@AUX@IN
+ //C@COMMON EXEC ST2CMP,MEMBER=C@COMMON
+ //C@CONVER EXEC ST2CMP,MEMBER=C@CONVER
+ //C@DECL   EXEC ST2CMP,MEMBER=C@DECL
+ //C@ERRORS EXEC ST2CMP,MEMBER=C@ERRORS
+ //C@FORMAT EXEC ST2CMP,MEMBER=C@FORMAT
+ //C@LANG   EXEC ST2CMP,MEMBER=C@LANG
+ //C@LEX    EXEC ST2CMP,MEMBER=C@LEX
+ //C@OBJC@C EXEC ST2CMP,MEMBER=C@OBJC@C
+ //C@PARSE  EXEC ST2CMP,MEMBER=C@PARSE
+ //C@PRAGMA EXEC ST2CMP,MEMBER=C@PRAGMA
+ //C@SEMANT EXEC ST2CMP,MEMBER=C@SEMANT
+ //C@TYPECK EXEC ST2CMP,MEMBER=C@TYPECK
+ //CALLER@S EXEC ST2CMP,MEMBER=CALLER@S
+ //CALLS    EXEC ST2CMP,MEMBER=CALLS
+ //CFG      EXEC ST2CMP,MEMBER=CFG
+ //CFGANAL  EXEC ST2CMP,MEMBER=CFGANAL
+ //CFGBUILD EXEC ST2CMP,MEMBER=CFGBUILD
+ //CFGCLEAN EXEC ST2CMP,MEMBER=CFGCLEAN
+ //CFGLAYOU EXEC ST2CMP,MEMBER=CFGLAYOU
+ //CFGLOOP  EXEC ST2CMP,MEMBER=CFGLOOP
+ //CFGRTL   EXEC ST2CMP,MEMBER=CFGRTL
+ //COMBINE  EXEC ST2CMP,MEMBER=COMBINE
+ //CONFLICT EXEC ST2CMP,MEMBER=CONFLICT
+ //CONVERT  EXEC ST2CMP,MEMBER=CONVERT
+ //CPPDEFAU EXEC ST2CMP,MEMBER=CPPDEFAU
+ //CPPERROR EXEC ST2CMP,MEMBER=CPPERROR
+ //CPPEXP   EXEC ST2CMP,MEMBER=CPPEXP
+ //CPPFILES EXEC ST2CMP,MEMBER=CPPFILES
+ //CPPHASH  EXEC ST2CMP,MEMBER=CPPHASH
+ //CPPINIT  EXEC ST2CMP,MEMBER=CPPINIT
+ //CPPLEX   EXEC ST2CMP,MEMBER=CPPLEX
+ //CPPLIB   EXEC ST2CMP,MEMBER=CPPLIB
+ //CPPMACRO EXEC ST2CMP,MEMBER=CPPMACRO
+ //CPPMAIN  EXEC ST2CMP,MEMBER=CPPMAIN
+ //CPPSPEC  EXEC ST2CMP,MEMBER=CPPSPEC
+ //CSE      EXEC ST2CMP,MEMBER=CSE
+ //CSELIB   EXEC ST2CMP,MEMBER=CSELIB
+ //DEBUG    EXEC ST2CMP,MEMBER=DEBUG
+ //DEPENDEN EXEC ST2CMP,MEMBER=DEPENDEN
+ //DF       EXEC ST2CMP,MEMBER=DF
+ //DIAGNOST EXEC ST2CMP,MEMBER=DIAGNOST
+ //DOMINANC EXEC ST2CMP,MEMBER=DOMINANC
+ //DWARF2AS EXEC ST2CMP,MEMBER=DWARF2AS
+ //DWARF2OU EXEC ST2CMP,MEMBER=DWARF2OU
+ //EMIT@RTL EXEC ST2CMP,MEMBER=EMIT@RTL
+ //EXCEPT   EXEC ST2CMP,MEMBER=EXCEPT
+ //EXPLOW   EXEC ST2CMP,MEMBER=EXPLOW
+ //EXPMED   EXEC ST2CMP,MEMBER=EXPMED
+ //EXPR     EXEC ST2CMP,MEMBER=EXPR
+ //FIBHEAP  EXEC ST2CMP,MEMBER=FIBHEAP
+ //FINAL    EXEC ST2CMP,MEMBER=FINAL
+ //FLOW     EXEC ST2CMP,MEMBER=FLOW
+ //FOLD@CON EXEC ST2CMP,MEMBER=FOLD@CON
+ //FUNCTION EXEC ST2CMP,MEMBER=FUNCTION
+ //GCC      EXEC ST2CMP,MEMBER=GCC
+ //GCCSPEC  EXEC ST2CMP,MEMBER=GCCSPEC
+ //GCSE     EXEC ST2CMP,MEMBER=GCSE
+ //GENRTL   EXEC ST2CMP,MEMBER=GENRTL
+ //GETPAGES EXEC ST2CMP,MEMBER=GETPAGES
+ //GGC@COMM EXEC ST2CMP,MEMBER=GGC@COMM
+ //GGC@PAGE EXEC ST2CMP,MEMBER=GGC@PAGE
+ //GLOBAL   EXEC ST2CMP,MEMBER=GLOBAL
+ //GRAPH    EXEC ST2CMP,MEMBER=GRAPH
+ //HASH     EXEC ST2CMP,MEMBER=HASH
+ //HASHTAB  EXEC ST2CMP,MEMBER=HASHTAB
+ //HASHTABL EXEC ST2CMP,MEMBER=HASHTABL
+ //HEX      EXEC ST2CMP,MEMBER=HEX
+ //HOOKS    EXEC ST2CMP,MEMBER=HOOKS
+ //I370     EXEC ST2CMP,MEMBER=I370
+ //I370@C   EXEC ST2CMP,MEMBER=I370@C
+ //IFCVT    EXEC ST2CMP,MEMBER=IFCVT
+ //
Index: gcc/gcc/stage2b.jcl
diff -c nul gcc/gcc/stage2b.jcl:1.51
*** nul	Tue Oct 01 16:28:47 2019
--- gcc/gcc/stage2b.jcl	Thu Sep 12 21:22:54 2019
***************
*** 0 ****
--- 1,177 ----
+ //GCCGEN   JOB CLASS=C,REGION=0K,TIME=1440
+ //*
+ //ST2CMP   PROC GCCPREF='GCC',MEMBER='',
+ // PDPPREF='PDPCLIB',
+ // COS1='-Os -S -ansi -pedantic-errors -remap -DHAVE_CONFIG_H',
+ // COS2='-DIN_GCC -DPUREISO -o dd:out -'
+ //*
+ //COMP     EXEC PGM=STAGE1,
+ // PARM='&COS1 &COS2'
+ //STEPLIB  DD DSN=&GCCPREF..TMPLOAD,DISP=SHR
+ //SYSIN    DD DSN=&GCCPREF..SOURCE(&MEMBER),DISP=SHR
+ //INCLUDE  DD DSN=&GCCPREF..INCLUDE,DISP=SHR,DCB=BLKSIZE=32720
+ //         DD DSN=&PDPPREF..INCLUDE,DISP=SHR
+ //SYSINCL  DD DSN=&GCCPREF..INCLUDE,DISP=SHR,DCB=BLKSIZE=32720
+ //         DD DSN=&PDPPREF..INCLUDE,DISP=SHR
+ //OUT      DD DSN=&GCCPREF..S2(&MEMBER),DISP=SHR
+ //SYSPRINT DD SYSOUT=*
+ //SYSTERM  DD SYSOUT=*
+ //*
+ //ASM      EXEC PGM=ASMA90,
+ //            PARM='DECK,NOLIST',
+ //            COND=(4,LT,COMP)
+ //SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR,DCB=BLKSIZE=32720
+ //         DD DSN=&PDPPREF..MACLIB,DISP=SHR
+ //SYSUT1   DD UNIT=SYSALLDA,SPACE=(CYL,(20,10))
+ //SYSUT2   DD UNIT=SYSALLDA,SPACE=(CYL,(10,10))
+ //SYSUT3   DD UNIT=SYSALLDA,SPACE=(CYL,(10,10))
+ //SYSPRINT DD SYSOUT=*
+ //SYSLIN   DD DUMMY
+ //SYSGO    DD DUMMY
+ //SYSPUNCH DD DSN=&GCCPREF..OBJ,DISP=MOD
+ //SYSIN    DD DSN=&GCCPREF..S2(&MEMBER),DISP=SHR
+ //*
+ //         PEND
+ //*
+ //ST2PDP   PROC GCCPREF='GCC',PDPPREF='PDPCLIB',MEMBER='',
+ // COS1='-Os -S -ansi -pedantic-errors',
+ // COS2='-DXXX_MEMMGR -o dd:out -'
+ //*
+ //COMP     EXEC PGM=STAGE1,
+ // PARM='&COS1 &COS2'
+ //STEPLIB  DD DSN=&GCCPREF..TMPLOAD,DISP=SHR
+ //SYSIN    DD DSN=&PDPPREF..SOURCE(&MEMBER),DISP=SHR
+ //INCLUDE  DD DSN=&PDPPREF..INCLUDE,DISP=SHR
+ //SYSINCL  DD DSN=&PDPPREF..INCLUDE,DISP=SHR
+ //OUT      DD DSN=&GCCPREF..S2(&MEMBER),DISP=SHR
+ //SYSPRINT DD SYSOUT=*
+ //SYSTERM  DD SYSOUT=*
+ //*
+ //ASM      EXEC PGM=ASMA90,
+ //            PARM='DECK,NOLIST',
+ //            COND=(4,LT,COMP)
+ //SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR,DCB=BLKSIZE=32720
+ //         DD DSN=&PDPPREF..MACLIB,DISP=SHR
+ //SYSUT1   DD UNIT=SYSALLDA,SPACE=(CYL,(20,10))
+ //SYSUT2   DD UNIT=SYSALLDA,SPACE=(CYL,(10,10))
+ //SYSUT3   DD UNIT=SYSALLDA,SPACE=(CYL,(10,10))
+ //SYSPRINT DD SYSOUT=*
+ //SYSLIN   DD DUMMY
+ //SYSGO    DD DUMMY
+ //SYSPUNCH DD DSN=&GCCPREF..OBJ,DISP=MOD
+ //SYSIN    DD DSN=&GCCPREF..S2(&MEMBER),DISP=SHR
+ //*
+ //         PEND
+ //*
+ //PDPASM   PROC GCCPREF='GCC',PDPPREF='PDPCLIB',MEMBER=''
+ //*
+ //ASM      EXEC PGM=ASMA90,
+ //            PARM='DECK,NOLIST'
+ //SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR,DCB=BLKSIZE=32720
+ //         DD DSN=SYS1.MODGEN,DISP=SHR
+ //         DD DSN=&PDPPREF..MACLIB,DISP=SHR
+ //SYSUT1   DD UNIT=SYSALLDA,SPACE=(CYL,(20,10))
+ //SYSUT2   DD UNIT=SYSALLDA,SPACE=(CYL,(10,10))
+ //SYSUT3   DD UNIT=SYSALLDA,SPACE=(CYL,(10,10))
+ //SYSPRINT DD SYSOUT=*
+ //SYSLIN   DD DUMMY
+ //SYSGO    DD DUMMY
+ //SYSPUNCH DD DSN=&GCCPREF..OBJ,DISP=MOD
+ //SYSIN    DD DSN=&PDPPREF..SOURCE(&MEMBER),DISP=SHR
+ //*
+ //         PEND
+ //*
+ //LINK     PROC GCCPREF='GCC',MODULE=''
+ //LKED     EXEC PGM=IEWL,
+ //  PARM='MAP,LIST,SIZE=(999424,65536),AMODE=31,RMODE=ANY'
+ //SYSUT1   DD UNIT=SYSALLDA,SPACE=(CYL,(30,10))
+ //SYSPRINT DD SYSOUT=*
+ //SYSLIN   DD DSN=&GCCPREF..OBJ,DISP=(OLD,DELETE)
+ //*SYSLIB not needed
+ //SYSLMOD  DD DSN=&GCCPREF..TMPLOAD(&MODULE),DISP=SHR
+ //         PEND
+ //*
+ //INSN@ATT EXEC ST2CMP,MEMBER=INSN@ATT
+ //INSN@EMI EXEC ST2CMP,MEMBER=INSN@EMI
+ //INSN@EXT EXEC ST2CMP,MEMBER=INSN@EXT
+ //INSN@OPI EXEC ST2CMP,MEMBER=INSN@OPI
+ //INSN@OUT EXEC ST2CMP,MEMBER=INSN@OUT
+ //INSN@REC EXEC ST2CMP,MEMBER=INSN@REC
+ //INTEGRAT EXEC ST2CMP,MEMBER=INTEGRAT
+ //JUMP     EXEC ST2CMP,MEMBER=JUMP
+ //LANGHOOK EXEC ST2CMP,MEMBER=LANGHOOK
+ //LBASENAM EXEC ST2CMP,MEMBER=LBASENAM
+ //LCM      EXEC ST2CMP,MEMBER=LCM
+ //LINE@MAP EXEC ST2CMP,MEMBER=LINE@MAP
+ //LISTS    EXEC ST2CMP,MEMBER=LISTS
+ //LOCAL@AL EXEC ST2CMP,MEMBER=LOCAL@AL
+ //LOOP     EXEC ST2CMP,MEMBER=LOOP
+ //MKDEPS   EXEC ST2CMP,MEMBER=MKDEPS
+ //OBSTACK  EXEC ST2CMP,MEMBER=OBSTACK
+ //OPTABS   EXEC ST2CMP,MEMBER=OPTABS
+ //PARAMS   EXEC ST2CMP,MEMBER=PARAMS
+ //PARTITIO EXEC ST2CMP,MEMBER=PARTITIO
+ //PREDICT  EXEC ST2CMP,MEMBER=PREDICT
+ //PREFIX   EXEC ST2CMP,MEMBER=PREFIX
+ //PRINT@RT EXEC ST2CMP,MEMBER=PRINT@RT
+ //PRINT@TR EXEC ST2CMP,MEMBER=PRINT@TR
+ //PROFILE  EXEC ST2CMP,MEMBER=PROFILE
+ //REAL     EXEC ST2CMP,MEMBER=REAL
+ //RECOG    EXEC ST2CMP,MEMBER=RECOG
+ //REGCLASS EXEC ST2CMP,MEMBER=REGCLASS
+ //REGMOVE  EXEC ST2CMP,MEMBER=REGMOVE
+ //REGRENAM EXEC ST2CMP,MEMBER=REGRENAM
+ //RELOAD   EXEC ST2CMP,MEMBER=RELOAD
+ //RELOAD1  EXEC ST2CMP,MEMBER=RELOAD1
+ //RESOURCE EXEC ST2CMP,MEMBER=RESOURCE
+ //RTL@ERRO EXEC ST2CMP,MEMBER=RTL@ERRO
+ //RTL      EXEC ST2CMP,MEMBER=RTL
+ //RTLANAL  EXEC ST2CMP,MEMBER=RTLANAL
+ //SAFE@CTY EXEC ST2CMP,MEMBER=SAFE@CTY
+ //SBITMAP  EXEC ST2CMP,MEMBER=SBITMAP
+ //SIBCALL  EXEC ST2CMP,MEMBER=SIBCALL
+ //SIMPLIFY EXEC ST2CMP,MEMBER=SIMPLIFY
+ //SPLAY@TR EXEC ST2CMP,MEMBER=SPLAY@TR
+ //SSA@CCP  EXEC ST2CMP,MEMBER=SSA@CCP
+ //SSA@DCE  EXEC ST2CMP,MEMBER=SSA@DCE
+ //SSA      EXEC ST2CMP,MEMBER=SSA
+ //STMT     EXEC ST2CMP,MEMBER=STMT
+ //STOR@LAY EXEC ST2CMP,MEMBER=STOR@LAY
+ //STRINGPO EXEC ST2CMP,MEMBER=STRINGPO
+ //STRSIGNA EXEC ST2CMP,MEMBER=STRSIGNA
+ //TIMEVAR  EXEC ST2CMP,MEMBER=TIMEVAR
+ //TOPLEV   EXEC ST2CMP,MEMBER=TOPLEV
+ //TREE@DUM EXEC ST2CMP,MEMBER=TREE@DUM
+ //TREE@INL EXEC ST2CMP,MEMBER=TREE@INL
+ //TREE     EXEC ST2CMP,MEMBER=TREE
+ //UNIXIO   EXEC ST2CMP,MEMBER=UNIXIO
+ //UNROLL   EXEC ST2CMP,MEMBER=UNROLL
+ //VARASM   EXEC ST2CMP,MEMBER=VARASM
+ //VARRAY   EXEC ST2CMP,MEMBER=VARRAY
+ //VASPRINT EXEC ST2CMP,MEMBER=VASPRINT
+ //VERSION  EXEC ST2CMP,MEMBER=VERSION
+ //XMALLOC  EXEC ST2CMP,MEMBER=XMALLOC
+ //XSTRERRO EXEC ST2CMP,MEMBER=XSTRERRO
+ //XSTRDUP  EXEC ST2CMP,MEMBER=XSTRDUP
+ //XEXIT    EXEC ST2CMP,MEMBER=XEXIT
+ //CONCAT   EXEC ST2CMP,MEMBER=CONCAT
+ //*
+ //MVSSTART EXEC PDPASM,MEMBER=MVSSTART
+ //MVSSUPA  EXEC PDPASM,MEMBER=MVSSUPA
+ //*
+ //START    EXEC ST2PDP,MEMBER=START
+ //STDIO    EXEC ST2PDP,MEMBER=STDIO
+ //STDLIB   EXEC ST2PDP,MEMBER=STDLIB
+ //CTYPE    EXEC ST2PDP,MEMBER=CTYPE
+ //STRING   EXEC ST2PDP,MEMBER=STRING
+ //TIME     EXEC ST2PDP,MEMBER=TIME
+ //ERRNO    EXEC ST2PDP,MEMBER=ERRNO
+ //ASSERT   EXEC ST2PDP,MEMBER=ASSERT
+ //LOCALE   EXEC ST2PDP,MEMBER=LOCALE
+ //MATH     EXEC ST2PDP,MEMBER=MATH
+ //SETJMP   EXEC ST2PDP,MEMBER=SETJMP
+ //SIGNAL   EXEC ST2PDP,MEMBER=SIGNAL
+ //@@MEMMGR EXEC ST2PDP,MEMBER=@@MEMMGR
+ //*
+ //DOLINK   EXEC LINK,COND=(4,LT),MODULE='STAGE2'
+ //
Index: gcc/gcc/stage2c.jcl
diff -c nul gcc/gcc/stage2c.jcl:1.70
*** nul	Tue Oct 01 16:28:47 2019
--- gcc/gcc/stage2c.jcl	Thu Sep 12 21:23:00 2019
***************
*** 0 ****
--- 1,31 ----
+ //GCCGEN   JOB CLASS=C,REGION=0K
+ //*
+ //COMPARE  PROC GCCPREF='GCC',ONE='',TWO=''
+ //COMPR    EXEC PGM=IEBCOMPR
+ //SYSPRINT DD SYSOUT=*
+ //SYSUT1   DD DSN=&GCCPREF..&ONE,DISP=SHR
+ //SYSUT2   DD DSN=&GCCPREF..&TWO,DISP=SHR
+ //SYSIN    DD DUMMY
+ //         PEND
+ //*
+ //COPY     PROC GCCPREF='GCC'
+ //IEBCPY   EXEC PGM=IEBCOPY
+ //FROM     DD DSN=&GCCPREF..TMPLOAD,DISP=SHR
+ //TO       DD DSN=&GCCPREF..LINKLIB,DISP=SHR
+ //SYSIN    DD DUMMY
+ //SYSPRINT DD SYSOUT=*
+ //         PEND
+ //*
+ //*
+ //*
+ //CMP      EXEC COMPARE,ONE='S2',TWO='S'
+ //SYSIN    DD *
+  COMPARE TYPORG=PO
+ /*
+ //*
+ //CPY      EXEC COPY,COND=(4,LT)
+ //SYSIN    DD *
+  COPY OUTDD=TO,INDD=FROM
+  SELECT MEMBER=((STAGE1,GCC))
+ /*
+ //
Index: gcc/gcc/stage3a.jcl
diff -c nul gcc/gcc/stage3a.jcl:1.52
*** nul	Tue Oct 01 16:28:47 2019
--- gcc/gcc/stage3a.jcl	Thu Sep 12 19:18:09 2019
***************
*** 0 ****
--- 1,129 ----
+ //GCCGEN   JOB CLASS=C,REGION=0K,TIME=1440
+ //*
+ //CREATE   PROC GCCPREF='GCC'
+ //DELETE   EXEC PGM=IEFBR14
+ //DD11     DD DSN=&GCCPREF..OBJ,DISP=(MOD,DELETE),
+ //       UNIT=SYSALLDA,SPACE=(TRK,(0))
+ //*
+ //ALLOC    EXEC PGM=IEFBR14
+ //DD11     DD DSN=&GCCPREF..OBJ,DISP=(,CATLG),
+ // DCB=(RECFM=FB,LRECL=80,BLKSIZE=6160),
+ // SPACE=(80,(70000,0)),UNIT=SYSALLDA
+ //         PEND
+ //*
+ //ST3CMP   PROC GCCPREF='GCC',MEMBER='',
+ // PDPPREF='PDPCLIB',
+ // COS1='-Os -S -ansi -pedantic-errors -remap -DHAVE_CONFIG_H',
+ // COS2='-DIN_GCC -DPUREISO -o dd:out -'
+ //*
+ //COMP     EXEC PGM=STAGE2,
+ // PARM='&COS1 &COS2'
+ //STEPLIB  DD DSN=&GCCPREF..TMPLOAD,DISP=SHR
+ //SYSIN    DD DSN=&GCCPREF..SOURCE(&MEMBER),DISP=SHR
+ //INCLUDE  DD DSN=&GCCPREF..INCLUDE,DISP=SHR,DCB=BLKSIZE=32720
+ //         DD DSN=&PDPPREF..INCLUDE,DISP=SHR
+ //SYSINCL  DD DSN=&GCCPREF..INCLUDE,DISP=SHR,DCB=BLKSIZE=32720
+ //         DD DSN=&PDPPREF..INCLUDE,DISP=SHR
+ //OUT      DD DSN=&GCCPREF..S3(&MEMBER),DISP=SHR
+ //SYSPRINT DD SYSOUT=*
+ //SYSTERM  DD SYSOUT=*
+ //SYSABEND DD SYSOUT=*
+ //*
+ //ASM      EXEC PGM=ASMA90,
+ //            PARM='DECK,NOLIST',
+ //            COND=(4,LT,COMP)
+ //SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR,DCB=BLKSIZE=32720
+ //         DD DSN=&PDPPREF..MACLIB,DISP=SHR
+ //SYSUT1   DD UNIT=SYSALLDA,SPACE=(CYL,(20,10))
+ //SYSUT2   DD UNIT=SYSALLDA,SPACE=(CYL,(10,10))
+ //SYSUT3   DD UNIT=SYSALLDA,SPACE=(CYL,(10,10))
+ //SYSPRINT DD SYSOUT=*
+ //SYSLIN   DD DUMMY
+ //SYSGO    DD DUMMY
+ //SYSPUNCH DD DSN=&GCCPREF..OBJ,DISP=MOD
+ //SYSIN    DD DSN=&GCCPREF..S3(&MEMBER),DISP=SHR
+ //*
+ //         PEND
+ //*
+ //NEWOBJ   EXEC CREATE
+ //*
+ //ALIAS    EXEC ST3CMP,MEMBER=ALIAS
+ //ALLOCA   EXEC ST3CMP,MEMBER=ALLOCA
+ //ASPRINTF EXEC ST3CMP,MEMBER=ASPRINTF
+ //ATTRIBS  EXEC ST3CMP,MEMBER=ATTRIBS
+ //BB@REORD EXEC ST3CMP,MEMBER=BB@REORD
+ //BITMAP   EXEC ST3CMP,MEMBER=BITMAP
+ //BUILTINS EXEC ST3CMP,MEMBER=BUILTINS
+ //C@AUX@IN EXEC ST3CMP,MEMBER=C@AUX@IN
+ //C@COMMON EXEC ST3CMP,MEMBER=C@COMMON
+ //C@CONVER EXEC ST3CMP,MEMBER=C@CONVER
+ //C@DECL   EXEC ST3CMP,MEMBER=C@DECL
+ //C@ERRORS EXEC ST3CMP,MEMBER=C@ERRORS
+ //C@FORMAT EXEC ST3CMP,MEMBER=C@FORMAT
+ //C@LANG   EXEC ST3CMP,MEMBER=C@LANG
+ //C@LEX    EXEC ST3CMP,MEMBER=C@LEX
+ //C@OBJC@C EXEC ST3CMP,MEMBER=C@OBJC@C
+ //C@PARSE  EXEC ST3CMP,MEMBER=C@PARSE
+ //C@PRAGMA EXEC ST3CMP,MEMBER=C@PRAGMA
+ //C@SEMANT EXEC ST3CMP,MEMBER=C@SEMANT
+ //C@TYPECK EXEC ST3CMP,MEMBER=C@TYPECK
+ //CALLER@S EXEC ST3CMP,MEMBER=CALLER@S
+ //CALLS    EXEC ST3CMP,MEMBER=CALLS
+ //CFG      EXEC ST3CMP,MEMBER=CFG
+ //CFGANAL  EXEC ST3CMP,MEMBER=CFGANAL
+ //CFGBUILD EXEC ST3CMP,MEMBER=CFGBUILD
+ //CFGCLEAN EXEC ST3CMP,MEMBER=CFGCLEAN
+ //CFGLAYOU EXEC ST3CMP,MEMBER=CFGLAYOU
+ //CFGLOOP  EXEC ST3CMP,MEMBER=CFGLOOP
+ //CFGRTL   EXEC ST3CMP,MEMBER=CFGRTL
+ //COMBINE  EXEC ST3CMP,MEMBER=COMBINE
+ //CONFLICT EXEC ST3CMP,MEMBER=CONFLICT
+ //CONVERT  EXEC ST3CMP,MEMBER=CONVERT
+ //CPPDEFAU EXEC ST3CMP,MEMBER=CPPDEFAU
+ //CPPERROR EXEC ST3CMP,MEMBER=CPPERROR
+ //CPPEXP   EXEC ST3CMP,MEMBER=CPPEXP
+ //CPPFILES EXEC ST3CMP,MEMBER=CPPFILES
+ //CPPHASH  EXEC ST3CMP,MEMBER=CPPHASH
+ //CPPINIT  EXEC ST3CMP,MEMBER=CPPINIT
+ //CPPLEX   EXEC ST3CMP,MEMBER=CPPLEX
+ //CPPLIB   EXEC ST3CMP,MEMBER=CPPLIB
+ //CPPMACRO EXEC ST3CMP,MEMBER=CPPMACRO
+ //CPPMAIN  EXEC ST3CMP,MEMBER=CPPMAIN
+ //CPPSPEC  EXEC ST3CMP,MEMBER=CPPSPEC
+ //CSE      EXEC ST3CMP,MEMBER=CSE
+ //CSELIB   EXEC ST3CMP,MEMBER=CSELIB
+ //DEBUG    EXEC ST3CMP,MEMBER=DEBUG
+ //DEPENDEN EXEC ST3CMP,MEMBER=DEPENDEN
+ //DF       EXEC ST3CMP,MEMBER=DF
+ //DIAGNOST EXEC ST3CMP,MEMBER=DIAGNOST
+ //DOMINANC EXEC ST3CMP,MEMBER=DOMINANC
+ //DWARF2AS EXEC ST3CMP,MEMBER=DWARF2AS
+ //DWARF2OU EXEC ST3CMP,MEMBER=DWARF2OU
+ //EMIT@RTL EXEC ST3CMP,MEMBER=EMIT@RTL
+ //EXCEPT   EXEC ST3CMP,MEMBER=EXCEPT
+ //EXPLOW   EXEC ST3CMP,MEMBER=EXPLOW
+ //EXPMED   EXEC ST3CMP,MEMBER=EXPMED
+ //EXPR     EXEC ST3CMP,MEMBER=EXPR
+ //FIBHEAP  EXEC ST3CMP,MEMBER=FIBHEAP
+ //FINAL    EXEC ST3CMP,MEMBER=FINAL
+ //FLOW     EXEC ST3CMP,MEMBER=FLOW
+ //FOLD@CON EXEC ST3CMP,MEMBER=FOLD@CON
+ //FUNCTION EXEC ST3CMP,MEMBER=FUNCTION
+ //GCC      EXEC ST3CMP,MEMBER=GCC
+ //GCCSPEC  EXEC ST3CMP,MEMBER=GCCSPEC
+ //GCSE     EXEC ST3CMP,MEMBER=GCSE
+ //GENRTL   EXEC ST3CMP,MEMBER=GENRTL
+ //GETPAGES EXEC ST3CMP,MEMBER=GETPAGES
+ //GGC@COMM EXEC ST3CMP,MEMBER=GGC@COMM
+ //GGC@PAGE EXEC ST3CMP,MEMBER=GGC@PAGE
+ //GLOBAL   EXEC ST3CMP,MEMBER=GLOBAL
+ //GRAPH    EXEC ST3CMP,MEMBER=GRAPH
+ //HASH     EXEC ST3CMP,MEMBER=HASH
+ //HASHTAB  EXEC ST3CMP,MEMBER=HASHTAB
+ //HASHTABL EXEC ST3CMP,MEMBER=HASHTABL
+ //HEX      EXEC ST3CMP,MEMBER=HEX
+ //HOOKS    EXEC ST3CMP,MEMBER=HOOKS
+ //I370     EXEC ST3CMP,MEMBER=I370
+ //I370@C   EXEC ST3CMP,MEMBER=I370@C
+ //IFCVT    EXEC ST3CMP,MEMBER=IFCVT
+ //
Index: gcc/gcc/stage3b.jcl
diff -c nul gcc/gcc/stage3b.jcl:1.49
*** nul	Tue Oct 01 16:28:47 2019
--- gcc/gcc/stage3b.jcl	Thu Sep 12 21:23:33 2019
***************
*** 0 ****
--- 1,194 ----
+ //GCCGEN   JOB CLASS=C,REGION=0K,TIME=1440
+ //*
+ //ST3CMP   PROC GCCPREF='GCC',MEMBER='',
+ // PDPPREF='PDPCLIB',
+ // COS1='-Os -S -ansi -pedantic-errors -remap -DHAVE_CONFIG_H',
+ // COS2='-DIN_GCC -DPUREISO -o dd:out -'
+ //*
+ //COMP     EXEC PGM=STAGE2,
+ // PARM='&COS1 &COS2'
+ //STEPLIB  DD DSN=&GCCPREF..TMPLOAD,DISP=SHR
+ //SYSIN    DD DSN=&GCCPREF..SOURCE(&MEMBER),DISP=SHR
+ //INCLUDE  DD DSN=&GCCPREF..INCLUDE,DISP=SHR,DCB=BLKSIZE=32720
+ //         DD DSN=&PDPPREF..INCLUDE,DISP=SHR
+ //SYSINCL  DD DSN=&GCCPREF..INCLUDE,DISP=SHR,DCB=BLKSIZE=32720
+ //         DD DSN=&PDPPREF..INCLUDE,DISP=SHR
+ //OUT      DD DSN=&GCCPREF..S3(&MEMBER),DISP=SHR
+ //SYSPRINT DD SYSOUT=*
+ //SYSTERM  DD SYSOUT=*
+ //*
+ //ASM      EXEC PGM=ASMA90,
+ //            PARM='DECK,NOLIST',
+ //            COND=(4,LT,COMP)
+ //SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR,DCB=BLKSIZE=32720
+ //         DD DSN=&PDPPREF..MACLIB,DISP=SHR
+ //SYSUT1   DD UNIT=SYSALLDA,SPACE=(CYL,(20,10))
+ //SYSUT2   DD UNIT=SYSALLDA,SPACE=(CYL,(10,10))
+ //SYSUT3   DD UNIT=SYSALLDA,SPACE=(CYL,(10,10))
+ //SYSPRINT DD SYSOUT=*
+ //SYSLIN   DD DUMMY
+ //SYSGO    DD DUMMY
+ //SYSPUNCH DD DSN=&GCCPREF..OBJ,DISP=MOD
+ //SYSIN    DD DSN=&GCCPREF..S3(&MEMBER),DISP=SHR
+ //*
+ //         PEND
+ //*
+ //ST3PDP   PROC GCCPREF='GCC',PDPPREF='PDPCLIB',MEMBER='',
+ // COS1='-Os -S -ansi -pedantic-errors',
+ // COS2='-DXXX_MEMMGR -o dd:out -'
+ //*
+ //COMP     EXEC PGM=STAGE2,
+ // PARM='&COS1 &COS2'
+ //STEPLIB  DD DSN=&GCCPREF..TMPLOAD,DISP=SHR
+ //SYSIN    DD DSN=&PDPPREF..SOURCE(&MEMBER),DISP=SHR
+ //INCLUDE  DD DSN=&PDPPREF..INCLUDE,DISP=SHR
+ //SYSINCL  DD DSN=&PDPPREF..INCLUDE,DISP=SHR
+ //OUT      DD DSN=&GCCPREF..S3(&MEMBER),DISP=SHR
+ //SYSPRINT DD SYSOUT=*
+ //SYSTERM  DD SYSOUT=*
+ //*
+ //ASM      EXEC PGM=ASMA90,
+ //            PARM='DECK,NOLIST',
+ //            COND=(4,LT,COMP)
+ //SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR,DCB=BLKSIZE=32720
+ //         DD DSN=&PDPPREF..MACLIB,DISP=SHR
+ //SYSUT1   DD UNIT=SYSALLDA,SPACE=(CYL,(20,10))
+ //SYSUT2   DD UNIT=SYSALLDA,SPACE=(CYL,(10,10))
+ //SYSUT3   DD UNIT=SYSALLDA,SPACE=(CYL,(10,10))
+ //SYSPRINT DD SYSOUT=*
+ //SYSLIN   DD DUMMY
+ //SYSGO    DD DUMMY
+ //SYSPUNCH DD DSN=&GCCPREF..OBJ,DISP=MOD
+ //SYSIN    DD DSN=&GCCPREF..S3(&MEMBER),DISP=SHR
+ //*
+ //         PEND
+ //*
+ //PDPASM   PROC GCCPREF='GCC',PDPPREF='PDPCLIB',MEMBER=''
+ //*
+ //ASM      EXEC PGM=ASMA90,
+ //            PARM='DECK,NOLIST'
+ //SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR,DCB=BLKSIZE=32720
+ //         DD DSN=SYS1.MODGEN,DISP=SHR
+ //         DD DSN=&PDPPREF..MACLIB,DISP=SHR
+ //SYSUT1   DD UNIT=SYSALLDA,SPACE=(CYL,(20,10))
+ //SYSUT2   DD UNIT=SYSALLDA,SPACE=(CYL,(10,10))
+ //SYSUT3   DD UNIT=SYSALLDA,SPACE=(CYL,(10,10))
+ //SYSPRINT DD SYSOUT=*
+ //SYSLIN   DD DUMMY
+ //SYSGO    DD DUMMY
+ //SYSPUNCH DD DSN=&GCCPREF..OBJ,DISP=MOD
+ //SYSIN    DD DSN=&PDPPREF..SOURCE(&MEMBER),DISP=SHR
+ //*
+ //         PEND
+ //*
+ //LINK     PROC GCCPREF='GCC',MODULE=''
+ //LKED     EXEC PGM=IEWL,
+ // PARM='MAP,LIST,SIZE=(999424,65536),AMODE=31,RMODE=ANY'
+ //SYSUT1   DD UNIT=SYSALLDA,SPACE=(CYL,(30,10))
+ //SYSPRINT DD SYSOUT=*
+ //SYSLIN   DD DSN=&GCCPREF..OBJ,DISP=(OLD,DELETE)
+ //*SYSLIB not needed
+ //SYSLMOD  DD DSN=&GCCPREF..LINKLIB(&MODULE),DISP=SHR
+ //         PEND
+ //*
+ //COMPARE  PROC GCCPREF='GCC',ONE='',TWO=''
+ //COMPR    EXEC PGM=IEBCOMPR
+ //SYSPRINT DD SYSOUT=*
+ //SYSUT1   DD DSN=&GCCPREF..&ONE,DISP=SHR
+ //SYSUT2   DD DSN=&GCCPREF..&TWO,DISP=SHR
+ //SYSIN    DD DUMMY
+ //         PEND
+ //*
+ //INSN@ATT EXEC ST3CMP,MEMBER=INSN@ATT
+ //INSN@EMI EXEC ST3CMP,MEMBER=INSN@EMI
+ //INSN@EXT EXEC ST3CMP,MEMBER=INSN@EXT
+ //INSN@OPI EXEC ST3CMP,MEMBER=INSN@OPI
+ //INSN@OUT EXEC ST3CMP,MEMBER=INSN@OUT
+ //INSN@REC EXEC ST3CMP,MEMBER=INSN@REC
+ //INTEGRAT EXEC ST3CMP,MEMBER=INTEGRAT
+ //JUMP     EXEC ST3CMP,MEMBER=JUMP
+ //LANGHOOK EXEC ST3CMP,MEMBER=LANGHOOK
+ //LBASENAM EXEC ST3CMP,MEMBER=LBASENAM
+ //LCM      EXEC ST3CMP,MEMBER=LCM
+ //LINE@MAP EXEC ST3CMP,MEMBER=LINE@MAP
+ //LISTS    EXEC ST3CMP,MEMBER=LISTS
+ //LOCAL@AL EXEC ST3CMP,MEMBER=LOCAL@AL
+ //LOOP     EXEC ST3CMP,MEMBER=LOOP
+ //MKDEPS   EXEC ST3CMP,MEMBER=MKDEPS
+ //OBSTACK  EXEC ST3CMP,MEMBER=OBSTACK
+ //OPTABS   EXEC ST3CMP,MEMBER=OPTABS
+ //PARAMS   EXEC ST3CMP,MEMBER=PARAMS
+ //PARTITIO EXEC ST3CMP,MEMBER=PARTITIO
+ //PREDICT  EXEC ST3CMP,MEMBER=PREDICT
+ //PREFIX   EXEC ST3CMP,MEMBER=PREFIX
+ //PRINT@RT EXEC ST3CMP,MEMBER=PRINT@RT
+ //PRINT@TR EXEC ST3CMP,MEMBER=PRINT@TR
+ //PROFILE  EXEC ST3CMP,MEMBER=PROFILE
+ //REAL     EXEC ST3CMP,MEMBER=REAL
+ //RECOG    EXEC ST3CMP,MEMBER=RECOG
+ //REGCLASS EXEC ST3CMP,MEMBER=REGCLASS
+ //REGMOVE  EXEC ST3CMP,MEMBER=REGMOVE
+ //REGRENAM EXEC ST3CMP,MEMBER=REGRENAM
+ //RELOAD   EXEC ST3CMP,MEMBER=RELOAD
+ //RELOAD1  EXEC ST3CMP,MEMBER=RELOAD1
+ //RESOURCE EXEC ST3CMP,MEMBER=RESOURCE
+ //RTL@ERRO EXEC ST3CMP,MEMBER=RTL@ERRO
+ //RTL      EXEC ST3CMP,MEMBER=RTL
+ //RTLANAL  EXEC ST3CMP,MEMBER=RTLANAL
+ //SAFE@CTY EXEC ST3CMP,MEMBER=SAFE@CTY
+ //SBITMAP  EXEC ST3CMP,MEMBER=SBITMAP
+ //SIBCALL  EXEC ST3CMP,MEMBER=SIBCALL
+ //SIMPLIFY EXEC ST3CMP,MEMBER=SIMPLIFY
+ //SPLAY@TR EXEC ST3CMP,MEMBER=SPLAY@TR
+ //SSA@CCP  EXEC ST3CMP,MEMBER=SSA@CCP
+ //SSA@DCE  EXEC ST3CMP,MEMBER=SSA@DCE
+ //SSA      EXEC ST3CMP,MEMBER=SSA
+ //STMT     EXEC ST3CMP,MEMBER=STMT
+ //STOR@LAY EXEC ST3CMP,MEMBER=STOR@LAY
+ //STRINGPO EXEC ST3CMP,MEMBER=STRINGPO
+ //STRSIGNA EXEC ST3CMP,MEMBER=STRSIGNA
+ //TIMEVAR  EXEC ST3CMP,MEMBER=TIMEVAR
+ //TOPLEV   EXEC ST3CMP,MEMBER=TOPLEV
+ //TREE@DUM EXEC ST3CMP,MEMBER=TREE@DUM
+ //TREE@INL EXEC ST3CMP,MEMBER=TREE@INL
+ //TREE     EXEC ST3CMP,MEMBER=TREE
+ //UNIXIO   EXEC ST3CMP,MEMBER=UNIXIO
+ //UNROLL   EXEC ST3CMP,MEMBER=UNROLL
+ //VARASM   EXEC ST3CMP,MEMBER=VARASM
+ //VARRAY   EXEC ST3CMP,MEMBER=VARRAY
+ //VASPRINT EXEC ST3CMP,MEMBER=VASPRINT
+ //VERSION  EXEC ST3CMP,MEMBER=VERSION
+ //XMALLOC  EXEC ST3CMP,MEMBER=XMALLOC
+ //XSTRERRO EXEC ST3CMP,MEMBER=XSTRERRO
+ //XSTRDUP  EXEC ST3CMP,MEMBER=XSTRDUP
+ //XEXIT    EXEC ST3CMP,MEMBER=XEXIT
+ //CONCAT   EXEC ST3CMP,MEMBER=CONCAT
+ //*
+ //MVSSTART EXEC PDPASM,MEMBER=MVSSTART
+ //MVSSUPA  EXEC PDPASM,MEMBER=MVSSUPA
+ //*
+ //START    EXEC ST3PDP,MEMBER=START
+ //STDIO    EXEC ST3PDP,MEMBER=STDIO
+ //STDLIB   EXEC ST3PDP,MEMBER=STDLIB
+ //CTYPE    EXEC ST3PDP,MEMBER=CTYPE
+ //STRING   EXEC ST3PDP,MEMBER=STRING
+ //TIME     EXEC ST3PDP,MEMBER=TIME
+ //ERRNO    EXEC ST3PDP,MEMBER=ERRNO
+ //ASSERT   EXEC ST3PDP,MEMBER=ASSERT
+ //LOCALE   EXEC ST3PDP,MEMBER=LOCALE
+ //MATH     EXEC ST3PDP,MEMBER=MATH
+ //SETJMP   EXEC ST3PDP,MEMBER=SETJMP
+ //SIGNAL   EXEC ST3PDP,MEMBER=SIGNAL
+ //@@MEMMGR EXEC ST3PDP,MEMBER=@@MEMMGR
+ //*
+ //CMP      EXEC COMPARE,ONE='S2',TWO='S3'
+ //SYSIN    DD *
+  COMPARE TYPORG=PO
+ /*
+ //*
+ //* If the STAGE3 assembler files don't match the STAGE2
+ //* assembler files, then failsafe by not producing a GCC
+ //* module, as there is a compiler bug somewhere.
+ //*
+ //DOLINK   EXEC LINK,COND=(4,LT),MODULE='GCC'
+ //
Index: gcc/gcc/stage4.jcl
diff -c nul gcc/gcc/stage4.jcl:1.44
*** nul	Tue Oct 01 16:28:47 2019
--- gcc/gcc/stage4.jcl	Wed Sep 11 01:42:20 2019
***************
*** 0 ****
--- 1,285 ----
+ //GCCGEN   JOB CLASS=C,REGION=0K
+ //*
+ //PDPCMP   PROC GCCPREF='GCC',PDPPREF='PDPCLIB',MEMBER='',
+ // COS1='-Os -S -ansi -pedantic-errors',
+ // COS2='-o dd:out -'
+ //*
+ //COMP     EXEC PGM=GCC,
+ // PARM='&COS1 &COS2'
+ //STEPLIB  DD DSN=&GCCPREF..LINKLIB,DISP=SHR
+ //INCLUDE  DD DSN=&PDPPREF..INCLUDE,DISP=SHR
+ //SYSINCL  DD DSN=&PDPPREF..INCLUDE,DISP=SHR
+ //OUT      DD DSN=&&TEMP,DISP=(,PASS),UNIT=SYSALLDA,
+ //            DCB=(LRECL=80,BLKSIZE=6160,RECFM=FB),
+ //            SPACE=(6160,(500,500))
+ //SYSIN    DD DSN=&PDPPREF..SOURCE(&MEMBER),DISP=SHR
+ //SYSPRINT DD SYSOUT=*
+ //SYSTERM  DD SYSOUT=*
+ //*
+ //ASM      EXEC PGM=ASMA90,
+ //            PARM='DECK,NOLIST',
+ //            COND=(4,LT,COMP)
+ //SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR,DCB=BLKSIZE=32720
+ //         DD DSN=&PDPPREF..MACLIB,DISP=SHR
+ //SYSUT1   DD UNIT=SYSALLDA,SPACE=(CYL,(20,10))
+ //SYSUT2   DD UNIT=SYSALLDA,SPACE=(CYL,(10,10))
+ //SYSUT3   DD UNIT=SYSALLDA,SPACE=(CYL,(10,10))
+ //SYSPRINT DD SYSOUT=*
+ //SYSLIN   DD DUMMY
+ //SYSGO    DD DUMMY
+ //SYSPUNCH DD DSN=&&OBJSET,UNIT=SYSALLDA,SPACE=(80,(4000,4000)),
+ //            DISP=(,PASS)
+ //SYSIN    DD DSN=&&TEMP,DISP=(OLD,DELETE)
+ //*
+ //LKED     EXEC PGM=IEWL,PARM='NCAL',
+ //            COND=((4,LT,COMP),(4,LT,ASM))
+ //SYSLIN   DD DSN=&&OBJSET,DISP=(OLD,DELETE)
+ //         DD DDNAME=SYSIN
+ //SYSIN    DD DUMMY
+ //SYSLMOD  DD DSN=&PDPPREF..NCALIB(&MEMBER),DISP=SHR
+ //SYSUT1   DD UNIT=SYSALLDA,SPACE=(CYL,(2,1))
+ //SYSPRINT DD SYSOUT=*
+ //         PEND
+ //*
+ //PDPASM   PROC PDPPREF='PDPCLIB',MEMBER=''
+ //*
+ //ASM      EXEC PGM=ASMA90,
+ //         PARM='DECK,NOLIST'
+ //SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR,DCB=BLKSIZE=32720
+ //         DD DSN=SYS1.MODGEN,DISP=SHR
+ //         DD DSN=&PDPPREF..MACLIB,DISP=SHR
+ //SYSUT1   DD UNIT=SYSALLDA,SPACE=(CYL,(20,10))
+ //SYSUT2   DD UNIT=SYSALLDA,SPACE=(CYL,(20,10))
+ //SYSUT3   DD UNIT=SYSALLDA,SPACE=(CYL,(20,10))
+ //SYSPRINT DD SYSOUT=*
+ //SYSLIN   DD DUMMY
+ //SYSGO    DD DUMMY
+ //SYSPUNCH DD DSN=&&OBJSET,UNIT=SYSALLDA,SPACE=(80,(4000,4000)),
+ //            DISP=(,PASS)
+ //SYSIN    DD DSN=&PDPPREF..SOURCE(&MEMBER),DISP=SHR
+ //*
+ //LKED     EXEC PGM=IEWL,PARM='NCAL',
+ //            COND=(4,LT,ASM)
+ //SYSLIN   DD DSN=&&OBJSET,DISP=(OLD,DELETE)
+ //         DD DDNAME=SYSIN
+ //SYSIN    DD DUMMY
+ //SYSLMOD  DD DSN=&PDPPREF..NCALIB(&MEMBER),DISP=SHR
+ //SYSUT1   DD UNIT=SYSALLDA,SPACE=(CYL,(2,1))
+ //SYSPRINT DD SYSOUT=*
+ //         PEND
+ //*
+ //MVSSTART EXEC PDPASM,MEMBER=MVSSTART
+ //LKED.SYSIN DD *
+  ALIAS @@CRT0
+  ALIAS @@EXITA
+ /*
+ //MVSSUPA  EXEC PDPASM,MEMBER=MVSSUPA
+ //LKED.SYSIN DD *
+  ALIAS @@AOPEN
+  ALIAS @@AREAD
+  ALIAS @@AWRITE
+  ALIAS @@ACLOSE
+  ALIAS @@GETM
+  ALIAS @@FREEM
+  ALIAS @@GETCLK
+  ALIAS @@SAVER
+  ALIAS @@MANSTK
+  ALIAS @@LOADR
+  ALIAS @@SYSTEM
+  ALIAS @@IDCAMS
+  ALIAS @@DYNAL
+ /*
+ //*
+ //START    EXEC PDPCMP,MEMBER=START
+ //LKED.SYSIN DD *
+  ALIAS @@START
+  ALIAS @@EXIT
+ /*
+ //STDIO    EXEC PDPCMP,MEMBER=STDIO
+ //LKED.SYSIN DD *
+  ALIAS STDIN
+  ALIAS STDOUT
+  ALIAS STDERR
+  ALIAS PRINTF
+  ALIAS FPRINTF
+  ALIAS VFPRINTF
+  ALIAS FOPEN
+  ALIAS FCLOSE
+  ALIAS FPUTC
+  ALIAS REMOVE
+  ALIAS RENAME
+  ALIAS SPRINTF
+  ALIAS VSPRINTF
+  ALIAS UNGETC
+  ALIAS FGETC
+  ALIAS FSEEK
+  ALIAS FTELL
+  ALIAS FSETPOS
+  ALIAS FGETPOS
+  ALIAS REWIND
+  ALIAS CLEARERR
+  ALIAS PERROR
+  ALIAS SETVBUF
+  ALIAS SETBUF
+  ALIAS FREOPEN
+  ALIAS FFLUSH
+  ALIAS TMPNAM
+  ALIAS TMPFILE
+  ALIAS FSCANF
+  ALIAS SCANF
+  ALIAS SSCANF
+  ALIAS GETS
+  ALIAS PUTS
+  ALIAS GETC
+  ALIAS PUTC
+  ALIAS GETCHAR
+  ALIAS PUTCHAR
+  ALIAS FEOF
+  ALIAS FERROR
+  ALIAS FGETS
+  ALIAS FPUTS
+  ALIAS FWRITE
+  ALIAS FREAD
+  ALIAS @@USERFI
+ /*
+ //STDLIB   EXEC PDPCMP,MEMBER=STDLIB
+ //LKED.SYSIN DD *
+  ALIAS MALLOC
+  ALIAS CALLOC
+  ALIAS REALLOC
+  ALIAS FREE
+  ALIAS ABORT
+  ALIAS EXIT
+  ALIAS QSORT
+  ALIAS SRAND
+  ALIAS RAND
+  ALIAS ATOF
+  ALIAS STRTOD
+  ALIAS ATOI
+  ALIAS ATOL
+  ALIAS STRTOL
+  ALIAS STRTOUL
+  ALIAS MBLEN
+  ALIAS MBTOWC
+  ALIAS WCTOMB
+  ALIAS MBSTOWCS
+  ALIAS WCSTOMBS
+  ALIAS ABS
+  ALIAS DIV
+  ALIAS LABS
+  ALIAS LDIV
+  ALIAS ATEXIT
+  ALIAS GETENV
+  ALIAS SYSTEM
+  ALIAS BSEARCH
+  ALIAS @@USEREX
+ /*
+ //CTYPE    EXEC PDPCMP,MEMBER=CTYPE
+ //LKED.SYSIN DD *
+  ALIAS @@ISBUF
+  ALIAS @@TOLOW
+  ALIAS @@TOUP
+  ALIAS ISALNUM
+  ALIAS ISALPHA
+  ALIAS ISCNTRL
+  ALIAS ISDIGIT
+  ALIAS ISGRAPH
+  ALIAS ISLOWER
+  ALIAS ISPRINT
+  ALIAS ISPUNCT
+  ALIAS ISSPACE
+  ALIAS ISUPPER
+  ALIAS ISXDIGIT
+  ALIAS TOLOWER
+  ALIAS TOUPPER
+ /*
+ //STRING   EXEC PDPCMP,MEMBER=STRING
+ //LKED.SYSIN DD *
+  ALIAS MEMMOVE
+  ALIAS STRCPY
+  ALIAS STRNCPY
+  ALIAS STRCAT
+  ALIAS STRNCAT
+  ALIAS MEMCMP
+  ALIAS STRCMP
+  ALIAS STRCOLL
+  ALIAS STRNCMP
+  ALIAS STRXFRM
+  ALIAS MEMCHR
+  ALIAS STRCHR
+  ALIAS STRCSPN
+  ALIAS STRPBRK
+  ALIAS STRRCHR
+  ALIAS STRSPN
+  ALIAS STRSTR
+  ALIAS STRTOK
+  ALIAS MEMSET
+  ALIAS STRERROR
+  ALIAS STRLEN
+  ALIAS MEMCPY
+ /*
+ //TIME     EXEC PDPCMP,MEMBER=TIME
+ //LKED.SYSIN DD *
+  ALIAS CLOCK
+  ALIAS DIFFTIME
+  ALIAS MKTIME
+  ALIAS ASCTIME
+  ALIAS CTIME
+  ALIAS GMTIME
+  ALIAS LOCALTIM
+  ALIAS STRFTIME
+ /*
+ //ERRNO    EXEC PDPCMP,MEMBER=ERRNO
+ //LKED.SYSIN DD *
+  ALIAS @@GET@ER
+ /*
+ //ASSERT   EXEC PDPCMP,MEMBER=ASSERT
+ //LKED.SYSIN DD *
+  ALIAS @ASSERT
+ /*
+ //LOCALE   EXEC PDPCMP,MEMBER=LOCALE
+ //LKED.SYSIN DD *
+  ALIAS SETLOCAL
+  ALIAS LOCALECO
+ /*
+ //MATH     EXEC PDPCMP,MEMBER=MATH  
+ //LKED.SYSIN DD *
+  ALIAS CEIL
+  ALIAS FABS
+  ALIAS FLOOR
+  ALIAS FMOD
+  ALIAS ACOS
+  ALIAS ASIN
+  ALIAS ATAN
+  ALIAS ATAN2
+  ALIAS COS
+  ALIAS SIN
+  ALIAS TAN
+  ALIAS COSH
+  ALIAS SINH
+  ALIAS TANH
+  ALIAS EXP
+  ALIAS LOG
+  ALIAS LOG10
+  ALIAS POW
+  ALIAS SQRT
+  ALIAS FREXP
+  ALIAS LDEXP
+  ALIAS MODF
+ /*
+ //SETJMP   EXEC PDPCMP,MEMBER=SETJMP
+ //LKED.SYSIN DD *
+  ALIAS LONGJMP
+ /*
+ //SIGNAL   EXEC PDPCMP,MEMBER=SIGNAL
+ //LKED.SYSIN DD *
+  ALIAS RAISE
+  ALIAS @@SIGDFL
+  ALIAS @@SIGERR
+  ALIAS @@SIGIGN
+ /*
+ //@@MEMMGR EXEC PDPCMP,MEMBER=@@MEMMGR
+ //LKED.SYSIN DD *
+ /*
+ //*
+ //
Index: gcc/gcc/stage4z.jcl
diff -c nul gcc/gcc/stage4z.jcl:1.50
*** nul	Tue Oct 01 16:28:47 2019
--- gcc/gcc/stage4z.jcl	Wed Sep 11 01:42:20 2019
***************
*** 0 ****
--- 1,315 ----
+ //GCCGEN   JOB CLASS=C,REGION=0K
+ //*
+ //PDPCMP   PROC GCCPREF='GCC',PDPPREF='PDPCLIB',MEMBER='',
+ // COS1='-Os -S -ansi -pedantic-errors',
+ // COS2='-DXXX_MEMMGR -o dd:out -'
+ //*
+ //COMP     EXEC PGM=GCC,
+ // PARM='&COS1 &COS2'
+ //STEPLIB  DD DSN=&GCCPREF..LINKLIB,DISP=SHR
+ //INCLUDE  DD DSN=&PDPPREF..INCLUDE,DISP=SHR
+ //SYSINCL  DD DSN=&PDPPREF..INCLUDE,DISP=SHR
+ //OUT      DD DSN=&&TEMP,DISP=(,PASS),UNIT=SYSALLDA,
+ //            DCB=(LRECL=80,BLKSIZE=6160,RECFM=FB),
+ //            SPACE=(6160,(500,500))
+ //SYSIN    DD DSN=&PDPPREF..SOURCE(&MEMBER),DISP=SHR
+ //SYSPRINT DD SYSOUT=*
+ //SYSTERM  DD SYSOUT=*
+ //*
+ //ASM      EXEC PGM=ASMA90,
+ //            PARM='DECK,NOLIST',
+ //            COND=(4,LT,COMP)
+ //SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR,DCB=BLKSIZE=32720
+ //         DD DSN=&PDPPREF..MACLIB,DISP=SHR
+ //SYSUT1   DD UNIT=SYSALLDA,SPACE=(CYL,(20,10))
+ //SYSUT2   DD UNIT=SYSALLDA,SPACE=(CYL,(10,10))
+ //SYSUT3   DD UNIT=SYSALLDA,SPACE=(CYL,(10,10))
+ //SYSPRINT DD SYSOUT=*
+ //SYSLIN   DD DUMMY
+ //SYSGO    DD DUMMY
+ //SYSPUNCH DD DSN=&&OBJSET,UNIT=SYSALLDA,SPACE=(80,(4000,4000)),
+ //            DISP=(,PASS)
+ //SYSIN    DD DSN=&&TEMP,DISP=(OLD,DELETE)
+ //*
+ //LKED     EXEC PGM=IEWL,PARM='NCAL',
+ //            COND=((4,LT,COMP),(4,LT,ASM))
+ //SYSLIN   DD DSN=&&OBJSET,DISP=(OLD,DELETE)
+ //         DD DDNAME=SYSIN
+ //SYSIN    DD DUMMY
+ //SYSLMOD  DD DSN=&PDPPREF..NCALIB,DISP=SHR
+ //SYSUT1   DD UNIT=SYSALLDA,SPACE=(CYL,(2,1))
+ //SYSPRINT DD SYSOUT=*
+ //         PEND
+ //*
+ //PDPASM   PROC PDPPREF='PDPCLIB',MEMBER=''
+ //*
+ //ASM      EXEC PGM=ASMA90,
+ //         PARM='DECK,NOLIST'
+ //SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR,DCB=BLKSIZE=32720
+ //         DD DSN=SYS1.MODGEN,DISP=SHR
+ //         DD DSN=&PDPPREF..MACLIB,DISP=SHR
+ //SYSUT1   DD UNIT=SYSALLDA,SPACE=(CYL,(20,10))
+ //SYSUT2   DD UNIT=SYSALLDA,SPACE=(CYL,(10,10))
+ //SYSUT3   DD UNIT=SYSALLDA,SPACE=(CYL,(10,10))
+ //SYSPRINT DD SYSOUT=*
+ //SYSLIN   DD DUMMY
+ //SYSGO    DD DUMMY
+ //SYSPUNCH DD DSN=&&OBJSET,UNIT=SYSALLDA,SPACE=(80,(4000,4000)),
+ //            DISP=(,PASS)
+ //SYSIN    DD DSN=&PDPPREF..SOURCE(&MEMBER),DISP=SHR
+ //*
+ //LKED     EXEC PGM=IEWL,PARM='NCAL',
+ //            COND=(4,LT,ASM)
+ //SYSLIN   DD DSN=&&OBJSET,DISP=(OLD,DELETE)
+ //         DD DDNAME=SYSIN
+ //SYSIN    DD DUMMY
+ //SYSLMOD  DD DSN=&PDPPREF..NCALIB(&MEMBER),DISP=SHR
+ //SYSUT1   DD UNIT=SYSALLDA,SPACE=(CYL,(2,1))
+ //SYSPRINT DD SYSOUT=*
+ //         PEND
+ //*
+ //MVSSTART EXEC PDPASM,MEMBER=MVSSTART
+ //LKED.SYSLIN DD
+ //            DD *
+  ALIAS @@CRT0
+  ALIAS @@EXITA
+ /*
+ //MVSSUPA  EXEC PDPASM,MEMBER=MVSSUPA
+ //LKED.SYSLIN DD
+ //            DD *
+  ALIAS @@AOPEN
+  ALIAS @@AREAD
+  ALIAS @@AWRITE
+  ALIAS @@ACLOSE
+  ALIAS @@GETM
+  ALIAS @@FREEM
+  ALIAS @@GETCLK
+  ALIAS @@SAVER
+  ALIAS @@MANSTK
+  ALIAS @@LOADR
+  ALIAS @@SYSTEM
+  ALIAS @@IDCAMS
+  ALIAS @@DYNAL
+ /*
+ //*
+ //START    EXEC PDPCMP,MEMBER=START
+ //LKED.SYSIN DD *
+  ALIAS @@START
+  ALIAS @@EXIT
+  NAME START(R)
+ /*
+ //STDIO    EXEC PDPCMP,MEMBER=STDIO
+ //LKED.SYSIN DD *
+  ALIAS STDIN
+  ALIAS STDOUT
+  ALIAS STDERR
+  ALIAS PRINTF
+  ALIAS FPRINTF
+  ALIAS VFPRINTF
+  ALIAS FOPEN
+  ALIAS FCLOSE
+  ALIAS FPUTC
+  ALIAS REMOVE
+  ALIAS RENAME
+  ALIAS SPRINTF
+  ALIAS VSPRINTF
+  ALIAS UNGETC
+  ALIAS FGETC
+  ALIAS FSEEK
+  NAME STDIO(R)
+ //STDIO2   EXEC PDPCMP,MEMBER=STDIO
+ //LKED.SYSIN DD *
+  ALIAS FTELL
+  ALIAS FSETPOS
+  ALIAS FGETPOS
+  ALIAS REWIND
+  ALIAS CLEARERR
+  ALIAS PERROR
+  ALIAS SETVBUF
+  ALIAS SETBUF
+  ALIAS FREOPEN
+  ALIAS FFLUSH
+  ALIAS TMPNAM
+  ALIAS TMPFILE
+  ALIAS FSCANF
+  ALIAS SCANF
+  ALIAS SSCANF
+  ALIAS GETS
+  NAME STDIO2(R)
+ //STDIO3   EXEC PDPCMP,MEMBER=STDIO
+ //LKED.SYSIN DD *
+  ALIAS PUTS
+  ALIAS GETC
+  ALIAS PUTC
+  ALIAS GETCHAR
+  ALIAS PUTCHAR
+  ALIAS FEOF
+  ALIAS FERROR
+  ALIAS FGETS
+  ALIAS FPUTS
+  ALIAS FWRITE
+  ALIAS FREAD
+  ALIAS @@USERFI
+  NAME STDIO3(R)
+ /*
+ //STDLIB   EXEC PDPCMP,MEMBER=STDLIB
+ //LKED.SYSIN DD *
+  ALIAS MALLOC
+  ALIAS CALLOC
+  ALIAS REALLOC
+  ALIAS FREE
+  ALIAS ABORT
+  ALIAS EXIT
+  ALIAS QSORT
+  ALIAS SRAND
+  ALIAS RAND
+  ALIAS ATOF
+  ALIAS STRTOD
+  ALIAS ATOI
+  ALIAS ATOL
+  ALIAS STRTOL
+  ALIAS STRTOUL
+  ALIAS MBLEN
+  NAME STDLIB(R)
+ //STDLIB2  EXEC PDPCMP,MEMBER=STDLIB
+ //LKED.SYSIN DD *
+  ALIAS MBTOWC
+  ALIAS WCTOMB
+  ALIAS MBSTOWCS
+  ALIAS WCSTOMBS
+  ALIAS ABS
+  ALIAS DIV
+  ALIAS LABS
+  ALIAS LDIV
+  ALIAS ATEXIT
+  ALIAS GETENV
+  ALIAS SYSTEM
+  ALIAS BSEARCH
+  ALIAS @@USEREX
+  NAME STDLIB2(R)
+ /*
+ //CTYPE    EXEC PDPCMP,MEMBER=CTYPE
+ //LKED.SYSIN DD *
+  ALIAS @@ISBUF
+  ALIAS @@TOLOW
+  ALIAS @@TOUP
+  ALIAS ISALNUM
+  ALIAS ISALPHA
+  ALIAS ISCNTRL
+  ALIAS ISDIGIT
+  ALIAS ISGRAPH
+  ALIAS ISLOWER
+  ALIAS ISPRINT
+  ALIAS ISPUNCT
+  ALIAS ISSPACE
+  ALIAS ISUPPER
+  ALIAS ISXDIGIT
+  ALIAS TOLOWER
+  ALIAS TOUPPER
+  NAME CTYPE(R)
+ /*
+ //STRING   EXEC PDPCMP,MEMBER=STRING
+ //LKED.SYSIN DD *
+  ALIAS MEMMOVE
+  ALIAS STRCPY
+  ALIAS STRNCPY
+  ALIAS STRCAT
+  ALIAS STRNCAT
+  ALIAS MEMCMP
+  ALIAS STRCMP
+  ALIAS STRCOLL
+  ALIAS STRNCMP
+  ALIAS STRXFRM
+  ALIAS MEMCHR
+  ALIAS STRCHR
+  ALIAS STRCSPN
+  ALIAS STRPBRK
+  ALIAS STRRCHR
+  ALIAS STRSPN
+  NAME STRING(R)
+ //STRING2  EXEC PDPCMP,MEMBER=STRING
+ //LKED.SYSIN DD *
+  ALIAS STRSTR
+  ALIAS STRTOK
+  ALIAS MEMSET
+  ALIAS STRERROR
+  ALIAS STRLEN
+  ALIAS MEMCPY
+  NAME STRING2(R)
+ /*
+ //TIME     EXEC PDPCMP,MEMBER=TIME
+ //LKED.SYSIN DD *
+  ALIAS CLOCK
+  ALIAS DIFFTIME
+  ALIAS MKTIME
+  ALIAS ASCTIME
+  ALIAS CTIME
+  ALIAS GMTIME
+  ALIAS LOCALTIM
+  ALIAS STRFTIME
+  NAME TIME(R)
+ /*
+ //ERRNO    EXEC PDPCMP,MEMBER=ERRNO
+ //LKED.SYSIN DD *
+  ALIAS @@GET@ER
+  NAME ERRNO(R)
+ /*
+ //ASSERT   EXEC PDPCMP,MEMBER=ASSERT
+ //LKED.SYSIN DD *
+  ALIAS @ASSERT
+  NAME ASSERT(R)
+ /*
+ //LOCALE   EXEC PDPCMP,MEMBER=LOCALE
+ //LKED.SYSIN DD *
+  ALIAS SETLOCAL
+  ALIAS LOCALECO
+  NAME LOCALE(R)
+ /*
+ //MATH     EXEC PDPCMP,MEMBER=MATH  
+ //LKED.SYSIN DD *
+  ALIAS CEIL
+  ALIAS FABS
+  ALIAS FLOOR
+  ALIAS FMOD
+  ALIAS ACOS
+  ALIAS ASIN
+  ALIAS ATAN
+  ALIAS ATAN2
+  ALIAS COS
+  ALIAS SIN
+  ALIAS TAN
+  ALIAS COSH
+  ALIAS SINH
+  ALIAS TANH
+  ALIAS EXP
+  ALIAS LOG
+  NAME MATH(R)
+ //MATH2    EXEC PDPCMP,MEMBER=MATH  
+ //LKED.SYSIN DD *
+  ALIAS LOG10
+  ALIAS POW
+  ALIAS SQRT
+  ALIAS FREXP
+  ALIAS LDEXP
+  ALIAS MODF
+  NAME MATH2(R)
+ /*
+ //SETJMP   EXEC PDPCMP,MEMBER=SETJMP
+ //LKED.SYSIN DD *
+  ALIAS LONGJMP
+  NAME SETJMP(R)
+ /*
+ //SIGNAL   EXEC PDPCMP,MEMBER=SIGNAL
+ //LKED.SYSIN DD *
+  ALIAS RAISE
+  ALIAS @@SIGDFL
+  ALIAS @@SIGERR
+  ALIAS @@SIGIGN
+  NAME SIGNAL(R)
+ /*
+ //@@MEMMGR EXEC PDPCMP,MEMBER=@@MEMMGR
+ //LKED.SYSIN DD *
+  NAME @@MEMMGR(R)
+ /*
+ //*
+ //
Index: gcc/gcc/stage5a.jcl
diff -c nul gcc/gcc/stage5a.jcl:1.9
*** nul	Tue Oct 01 16:28:47 2019
--- gcc/gcc/stage5a.jcl	Thu Sep 12 19:18:09 2019
***************
*** 0 ****
--- 1,23 ----
+ //GCCGEN   JOB CLASS=C,REGION=0K
+ //*
+ //* Delete datasets no longer required.
+ //*
+ //* We keep S2, which should be identical to S3 (if it
+ //* exists) so that people without the compiler can
+ //* take the assembler code and reassemble to create
+ //* the load module on another system.
+ //*
+ //CLEAN    PROC GCCPREF='GCC'
+ //DELETE   EXEC PGM=IEFBR14
+ //DD9      DD DSN=&GCCPREF..S,DISP=(MOD,DELETE),
+ //       UNIT=SYSALLDA,SPACE=(TRK,(0))
+ //DD15     DD DSN=&GCCPREF..S3,DISP=(MOD,DELETE),
+ //       UNIT=SYSALLDA,SPACE=(TRK,(0))
+ //DD17     DD DSN=&GCCPREF..TMPLOAD,DISP=(MOD,DELETE),
+ //       UNIT=SYSALLDA,SPACE=(TRK,(0))
+ //*
+ //         PEND
+ //*
+ //S1       EXEC CLEAN
+ //*
+ //
Index: gcc/gcc/stage5b.jcl
diff -c nul gcc/gcc/stage5b.jcl:1.23
*** nul	Tue Oct 01 16:28:47 2019
--- gcc/gcc/stage5b.jcl	Sun Jun 14 12:54:59 2015
***************
*** 0 ****
--- 1,57 ----
+ //GCCGEN   JOB CLASS=C,REGION=0K,TIME=1440
+ //*
+ //* Note - we have our own instream proc here in case
+ //* the proc hasn't been installed in sys1.proclib due
+ //* to the installer not being a systems programmer.
+ //*
+ //GCCCL   PROC PDPPREF='PDPCLIB',GCCPREF='GCC',
+ //         COPTS='',LOPTS='MAP,AMODE=31,RMODE=ANY',MEMBER='',
+ // COS1='-S -ansi -pedantic-errors',
+ // COS2='-o dd:out -'
+ //*
+ //COMP     EXEC PGM=GCC,
+ // PARM='&COS1 &COPTS &COS2'
+ //STEPLIB  DD DSN=&GCCPREF..LINKLIB,DISP=SHR
+ //*
+ //INCLUDE  DD DSN=&PDPPREF..INCLUDE,DISP=SHR
+ //SYSINCL  DD DSN=&PDPPREF..INCLUDE,DISP=SHR
+ //SYSIN    DD DSN=&PDPPREF..SOURCE(&MEMBER),DISP=SHR
+ //OUT      DD DSN=&&TEMP,DISP=(,PASS),UNIT=SYSALLDA,
+ //            DCB=(LRECL=80,BLKSIZE=6160,RECFM=FB),
+ //            SPACE=(6160,(500,500))
+ //SYSPRINT DD SYSOUT=*
+ //SYSTERM  DD SYSOUT=*
+ //*
+ //ASM      EXEC PGM=ASMA90,
+ //            PARM='DECK,NOLIST',
+ //            COND=(4,LT,COMP)
+ //SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR,DCB=BLKSIZE=32720
+ //         DD DSN=&PDPPREF..MACLIB,DISP=SHR
+ //SYSUT1   DD UNIT=SYSALLDA,SPACE=(CYL,(20,10))
+ //SYSUT2   DD UNIT=SYSALLDA,SPACE=(CYL,(10,10))
+ //SYSUT3   DD UNIT=SYSALLDA,SPACE=(CYL,(10,10))
+ //SYSPRINT DD SYSOUT=*
+ //SYSLIN   DD DUMMY
+ //SYSGO    DD DUMMY
+ //SYSPUNCH DD DSN=&&OBJSET,UNIT=SYSALLDA,SPACE=(80,(4000,4000)),
+ //            DISP=(,PASS)
+ //SYSIN    DD DSN=&&TEMP,DISP=(OLD,DELETE)
+ //*
+ //LKED     EXEC PGM=IEWL,PARM='&LOPTS',
+ //            COND=((4,LT,COMP),(4,LT,ASM))
+ //SYSLIN   DD DSN=&&OBJSET,DISP=(OLD,DELETE)
+ //         DD DDNAME=SYSIN
+ //SYSIN    DD DUMMY
+ //SYSLIB   DD DSN=&PDPPREF..NCALIB,DISP=SHR
+ //SYSLMOD  DD DSN=&PDPPREF..LINKLIB(&MEMBER),DISP=SHR
+ //SYSUT1   DD UNIT=SYSALLDA,SPACE=(CYL,(2,1))
+ //SYSPRINT DD SYSOUT=*
+ //*
+ //         PEND
+ //*
+ //S1 EXEC GCCCL,MEMBER=MVSENDEC
+ //S2 EXEC GCCCL,MEMBER=HEXDUMP
+ //S3 EXEC GCCCL,MEMBER=MVSUNZIP
+ //S4 EXEC GCCCL,MEMBER=COPYFILE
+ //S5 EXEC GCCCL,MEMBER=DSSRENAM
+ //
Index: gcc/gcc/stage5c.jcl
diff -c nul gcc/gcc/stage5c.jcl:1.4
*** nul	Tue Oct 01 16:28:47 2019
--- gcc/gcc/stage5c.jcl	Wed Mar 05 19:44:43 2008
***************
*** 0 ****
--- 1,17 ----
+ //GCCGEN   JOB CLASS=C,REGION=0K
+ //*
+ //INSTPROC PROC GCCPREF='GCC',MEMBER=''
+ //*
+ //IEBGENER EXEC PGM=IEBGENER
+ //SYSUT1   DD DSN=&GCCPREF..PROCLIB(&MEMBER),DISP=SHR
+ //SYSUT2   DD DSN=SYS2.PROCLIB(&MEMBER),DISP=SHR
+ //SYSIN    DD DUMMY
+ //SYSPRINT DD SYSOUT=*
+ //*
+ //         PEND
+ //*
+ //S1       EXEC INSTPROC,MEMBER=GCCC
+ //S2       EXEC INSTPROC,MEMBER=GCCCL
+ //S3       EXEC INSTPROC,MEMBER=GCCCLG
+ //*
+ //
Index: gcc/gcc/stage6.jcl
diff -c nul gcc/gcc/stage6.jcl:1.20
*** nul	Tue Oct 01 16:28:47 2019
--- gcc/gcc/stage6.jcl	Thu Sep 12 21:24:43 2019
***************
*** 0 ****
--- 1,81 ----
+ //GCCGEN   JOB CLASS=C,REGION=0K
+ //*
+ //CREATE   PROC PDPPREF='PDPCLIB',GCCPREF='GCC'
+ //DELETE   EXEC PGM=IEFBR14
+ //DD1      DD DSN=&PDPPREF..INCLUDE,DISP=(MOD,DELETE),
+ //       UNIT=SYSALLDA,SPACE=(TRK,(0))
+ //DD2      DD DSN=&PDPPREF..SOURCE,DISP=(MOD,DELETE),
+ //       UNIT=SYSALLDA,SPACE=(TRK,(0))
+ //DD3      DD DSN=&PDPPREF..DOC,DISP=(MOD,DELETE),
+ //       UNIT=SYSALLDA,SPACE=(TRK,(0))
+ //DD4      DD DSN=&GCCPREF..PROCLIB,DISP=(MOD,DELETE),
+ //       UNIT=SYSALLDA,SPACE=(TRK,(0))
+ //DD5      DD DSN=&GCCPREF..SOURCE,DISP=(MOD,DELETE),
+ //       UNIT=SYSALLDA,SPACE=(TRK,(0))
+ //DD6      DD DSN=&GCCPREF..INCLUDE,DISP=(MOD,DELETE),
+ //       UNIT=SYSALLDA,SPACE=(TRK,(0))
+ //DD7      DD DSN=&GCCPREF..DOC,DISP=(MOD,DELETE),
+ //       UNIT=SYSALLDA,SPACE=(TRK,(0))
+ //DD8      DD DSN=&GCCPREF..JCL,DISP=(MOD,DELETE),
+ //       UNIT=SYSALLDA,SPACE=(TRK,(0))
+ //DD9      DD DSN=&GCCPREF..S,DISP=(MOD,DELETE),
+ //       UNIT=SYSALLDA,SPACE=(TRK,(0))
+ //DD10     DD DSN=&GCCPREF..LINKLIB,DISP=(MOD,DELETE),
+ //       UNIT=SYSALLDA,SPACE=(TRK,(0))
+ //DD12     DD DSN=&PDPPREF..NCALIB,DISP=(MOD,DELETE),
+ //       UNIT=SYSALLDA,SPACE=(TRK,(0))
+ //DD13     DD DSN=&PDPPREF..MACLIB,DISP=(MOD,DELETE),
+ //       UNIT=SYSALLDA,SPACE=(TRK,(0))
+ //DD14     DD DSN=&GCCPREF..S2,DISP=(MOD,DELETE),
+ //       UNIT=SYSALLDA,SPACE=(TRK,(0))
+ //DD15     DD DSN=&GCCPREF..S3,DISP=(MOD,DELETE),
+ //       UNIT=SYSALLDA,SPACE=(TRK,(0))
+ //DD16     DD DSN=&PDPPREF..LINKLIB,DISP=(MOD,DELETE),
+ //       UNIT=SYSALLDA,SPACE=(TRK,(0))
+ //DD17     DD DSN=&GCCPREF..TMPLOAD,DISP=(MOD,DELETE),
+ //       UNIT=SYSALLDA,SPACE=(TRK,(0))
+ //*
+ //ALLOC    EXEC PGM=IEFBR14
+ //DD1      DD DSN=&PDPPREF..INCLUDE,DISP=(,CATLG),
+ // DCB=(RECFM=FB,LRECL=80,BLKSIZE=6160),
+ // SPACE=(6160,(32,32,44)),UNIT=SYSALLDA
+ //DD2      DD DSN=&PDPPREF..SOURCE,DISP=(,CATLG),
+ // DCB=(RECFM=FB,LRECL=80,BLKSIZE=6160),
+ // SPACE=(6160,(400,400,44)),UNIT=SYSALLDA
+ //DD3      DD DSN=&PDPPREF..DOC,DISP=(,CATLG),
+ // DCB=(RECFM=FB,LRECL=80,BLKSIZE=6160),
+ // SPACE=(6160,(23,23,44)),UNIT=SYSALLDA
+ //DD4      DD DSN=&GCCPREF..PROCLIB,DISP=(,CATLG),
+ // DCB=(RECFM=FB,LRECL=80,BLKSIZE=6160),
+ // SPACE=(6160,(15,15,44)),UNIT=SYSALLDA
+ //DD5      DD DSN=&GCCPREF..SOURCE,DISP=(,CATLG),
+ // DCB=(RECFM=VB,LRECL=255,BLKSIZE=6233),
+ // SPACE=(6233,(2600,2600,44)),UNIT=SYSALLDA
+ //DD6      DD DSN=&GCCPREF..INCLUDE,DISP=(,CATLG),
+ // DCB=(RECFM=VB,LRECL=255,BLKSIZE=6233),
+ // SPACE=(6233,(346,346,44)),UNIT=SYSALLDA
+ //DD7      DD DSN=&GCCPREF..DOC,DISP=(,CATLG),
+ // DCB=(RECFM=VB,LRECL=255,BLKSIZE=6233),
+ // SPACE=(6233,(100,100,44)),UNIT=SYSALLDA
+ //DD8      DD DSN=&GCCPREF..JCL,DISP=(,CATLG),
+ // DCB=(RECFM=FB,LRECL=80,BLKSIZE=6160),
+ // SPACE=(6160,(69,69,44)),UNIT=SYSALLDA
+ //DD10     DD DSN=&GCCPREF..LINKLIB,DISP=(,CATLG),
+ // DCB=(RECFM=U,LRECL=0,BLKSIZE=6144),
+ // SPACE=(6144,(774,774,44),,,ROUND),UNIT=SYSALLDA
+ //DD12     DD DSN=&PDPPREF..NCALIB,DISP=(,CATLG),
+ // DCB=(RECFM=U,LRECL=0,BLKSIZE=6144),
+ // SPACE=(6144,(61,61,44)),UNIT=SYSALLDA
+ //DD13     DD DSN=&PDPPREF..MACLIB,DISP=(,CATLG),
+ // DCB=(RECFM=FB,LRECL=80,BLKSIZE=6160),
+ // SPACE=(6160,(10,10,44)),UNIT=SYSALLDA
+ //DD14     DD DSN=&GCCPREF..S2,DISP=(,CATLG),
+ // DCB=(RECFM=FB,LRECL=80,BLKSIZE=6160),
+ // SPACE=(6160,(10500,10500,44)),UNIT=SYSALLDA
+ //DD16     DD DSN=&PDPPREF..LINKLIB,DISP=(,CATLG),
+ // DCB=(RECFM=U,LRECL=0,BLKSIZE=6144),
+ // SPACE=(6144,(77,77,44),,,ROUND),UNIT=SYSALLDA
+ //         PEND
+ //*
+ //S1 EXEC CREATE
+ //
Index: gcc/gcc/std380.parm
diff -c nul gcc/gcc/std380.parm:1.1
*** nul	Tue Oct 01 16:28:47 2019
--- gcc/gcc/std380.parm	Sat May 26 17:15:23 2018
***************
*** 0 ****
--- 1 ----
+ -Os -DUSE_MEMMGR -o dd:out - -S -ansi -pedantic-errors
Index: gcc/gcc/stdcomp.bat
diff -c nul gcc/gcc/stdcomp.bat:1.2
*** nul	Tue Oct 01 16:28:47 2019
--- gcc/gcc/stdcomp.bat	Sun Nov 19 00:01:04 2006
***************
*** 0 ****
--- 1 ----
+ call stdcompp %2 %3 %4 %5 %6 %7 %8 %9 %1
Index: gcc/gcc/stdcomp.parm
diff -c nul gcc/gcc/stdcomp.parm:1.3
*** nul	Tue Oct 01 16:28:47 2019
--- gcc/gcc/stdcomp.parm	Tue Jun 02 14:21:18 2009
***************
*** 0 ****
--- 1 ----
+ -Os -o dd:out - -S -ansi -pedantic-errors -remap -DUSE_MEMMGR -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DTARGET_CMS
Index: gcc/gcc/stdcompb.bat
diff -c nul gcc/gcc/stdcompb.bat:1.1
*** nul	Tue Oct 01 16:28:47 2019
--- gcc/gcc/stdcompb.bat	Wed Feb 15 21:25:43 2006
***************
*** 0 ****
--- 1 ----
+ bcc32 -w- -A -c -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -I. -Iconfig\i370 -I..\include %1 %2 %3 %4 %5 %6 %7 %8 %9
Index: gcc/gcc/stdcompc.bat
diff -c nul gcc/gcc/stdcompc.bat:1.11
*** nul	Tue Oct 01 16:28:47 2019
--- gcc/gcc/stdcompc.bat	Fri Aug 01 20:31:40 2008
***************
*** 0 ****
--- 1 ----
+ gccmvs -DUSE_MEMMGR -Os -S -ansi -pedantic-errors -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -DTARGET_CMS -I ../../pdos/pdpclib -I . -I config/i370 -I ../include %2 %3 %4 %5 %6 %7 %8 %9 %1
Index: gcc/gcc/stdcompg.bat
diff -c nul gcc/gcc/stdcompg.bat:1.5
*** nul	Tue Oct 01 16:28:47 2019
--- gcc/gcc/stdcompg.bat	Thu Aug 20 19:09:30 2009
***************
*** 0 ****
--- 1 ----
+ gcc -O2 -c -ansi -pedantic -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -I . -I config/i370 -I ../include %1 %2 %3 %4 %5 %6 %7 %8 %9
Index: gcc/gcc/stdcompi.bat
diff -c nul gcc/gcc/stdcompi.bat:1.6
*** nul	Tue Oct 01 16:28:47 2019
--- gcc/gcc/stdcompi.bat	Tue Sep 10 17:57:08 2019
***************
*** 0 ****
--- 1 ----
+ gcc386 -fno-common -O2 -S -D__32BIT__ -D__PDOS386__ -DI386 -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -I ../../pdos/pdpclib -I ../../pdos/src -I . -I config/i386 -I config -I ../include %2 %3 %4 %5 %6 %7 %8 %9 %1
Index: gcc/gcc/stdcompj.bat
diff -c nul gcc/gcc/stdcompj.bat:1.1
*** nul	Tue Oct 01 16:28:47 2019
--- gcc/gcc/stdcompj.bat	Thu Jul 04 16:18:06 2019
***************
*** 0 ****
--- 1 ----
+ gccwin -fno-common -O2 -S -D__WIN32__ -D__STATIC__ -D__NOBIVA__ -DI386 -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -I ../../pdos/pdpclib -I ../../pdos/src -I . -I config/i386 -I config -I ../include %2 %3 %4 %5 %6 %7 %8 %9 %1
Index: gcc/gcc/stdcompm.bat
diff -c nul gcc/gcc/stdcompm.bat:1.17
*** nul	Tue Oct 01 16:28:47 2019
--- gcc/gcc/stdcompm.bat	Tue Apr 24 18:06:38 2018
***************
*** 0 ****
--- 1 ----
+ gccmvs -DXXX_MEMMGR -Os -S -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -I ../../pdos/pdpclib -I . -I config/i370 -I ../include %2 %3 %4 %5 %6 %7 %8 %9 %1
Index: gcc/gcc/stdcompp.bat
diff -c nul gcc/gcc/stdcompp.bat:1.13
*** nul	Tue Oct 01 16:28:47 2019
--- gcc/gcc/stdcompp.bat	Fri Jun 14 09:28:36 2019
***************
*** 0 ****
--- 1,4 ----
+ @rem set EXTRA=-DI386 -D__WIN32__ -D__STATIC__ -I config/i386 -I config
+ @rem set EXTRA=-DS390 -D__WIN32__ -D__STATIC__ -I config/s390
+ @set EXTRA=-pedantic -I config/i370 -D__WIN32__ -D__STATIC__
+ gcc -O2 -c -ansi -nostdinc -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -I ../../pdos/pdpclib -I . %EXTRA% -I ../include %1 %2 %3 %4 %5 %6 %7 %8 %9
Index: gcc/gcc/stdcompv.bat
diff -c nul gcc/gcc/stdcompv.bat:1.1
*** nul	Tue Oct 01 16:28:47 2019
--- gcc/gcc/stdcompv.bat	Wed Feb 15 21:25:43 2006
***************
*** 0 ****
--- 1 ----
+ cl /w /c /Za /DHAVE_CONFIG_H /DIN_GCC /DPUREISO /I . /I config/i370 /I ..\include %1 %2 %3 %4 %5 %6 %7 %8 %9
Index: gcc/gcc/stdcompw.bat
diff -c nul gcc/gcc/stdcompw.bat:1.3
*** nul	Tue Oct 01 16:28:48 2019
--- gcc/gcc/stdcompw.bat	Fri Jun 22 21:54:42 2007
***************
*** 0 ****
--- 1,5 ----
+ rem note that due to a bug in Open Watcom 1.6, which pollutes
+ rem the namespace with "open" (and "sopen" too), we need to
+ rem work around this problem by redefining all instances of
+ rem open to xxopen
+ wcl386 -3s -zq -e=1 -za -w- -c -Dopen=xxopen -DVALIST_NOT_PTR -DHAVE_CONFIG_H -DIN_GCC -DPUREISO -I. -Iconfig\i370 -I..\include %1 %2 %3 %4 %5 %6 %7 %8 %9
Index: gcc/gcc/stdcompz.bat
diff -c nul gcc/gcc/stdcompz.bat:1.4
*** nul	Tue Oct 01 16:28:48 2019
--- gcc/gcc/stdcompz.bat	Tue Nov 28 05:32:46 2006
***************
*** 0 ****
--- 1 ----
+ call stdcompp -DNO_DETAB -DGENERATOR_FILE %2 %3 %4 %5 %6 %7 %8 %9 %1
Index: gcc/gcc/stdpdp.parm
diff -c nul gcc/gcc/stdpdp.parm:1.5
*** nul	Tue Oct 01 16:28:48 2019
--- gcc/gcc/stdpdp.parm	Tue Jun 02 14:21:18 2009
***************
*** 0 ****
--- 1 ----
+ -Os -DXXX_MEMMGR -o dd:out - -S -ansi -pedantic-errors
Index: gcc/gcc/subjobs.bat
diff -c nul gcc/gcc/subjobs.bat:1.21
*** nul	Tue Oct 01 16:28:48 2019
--- gcc/gcc/subjobs.bat	Thu Sep 12 21:24:21 2019
***************
*** 0 ****
--- 1,23 ----
+ del alljcl.jcl
+ type stage0a.jcl >>alljcl.jcl
+ type stage0b.jcl >>alljcl.jcl
+ type stage0c.jcl >>alljcl.jcl
+ type stage0d.jcl >>alljcl.jcl
+ type stage1.jcl >>alljcl.jcl
+ rem type pregen.jcl >>alljcl.jcl
+ rem type stage4z.jcl >>alljcl.jcl
+ rem type gencomp.jcl >>alljcl.jcl
+ rem type postgen.jcl >>alljcl.jcl
+ type stage2a.jcl >>alljcl.jcl
+ type stage2b.jcl >>alljcl.jcl
+ type stage2c.jcl >>alljcl.jcl
+ rem type stage3a.jcl >>alljcl.jcl
+ rem type stage3b.jcl >>alljcl.jcl
+ type stage4z.jcl >>alljcl.jcl
+ type stage5a.jcl >>alljcl.jcl
+ type stage5b.jcl >>alljcl.jcl
+ type stage5c.jcl >>alljcl.jcl
+ type example.jcl >>alljcl.jcl
+ type xmitgcc.jcl >>alljcl.jcl
+ type xmittape.jcl >>alljcl.jcl
+ call runmvs alljcl.jcl output.txt all.zip gccmvs.xmi
Index: gcc/gcc/sys-types.h
diff -c gcc/gcc/sys-types.h:1.1.1.1 gcc/gcc/sys-types.h:1.2
*** gcc/gcc/sys-types.h:1.1.1.1	Wed Feb 15 21:22:26 2006
--- gcc/gcc/sys-types.h	Wed Feb 15 21:24:29 2006
***************
*** 86,92 ****
  #include <stddef.h>
  
  /* #include "sys/types.h" */
! #define ssize_t int
  
  /* The actual types used here are mostly wrong,
     but it is not supposed to matter what types we use here.  */
--- 86,92 ----
  #include <stddef.h>
  
  /* #include "sys/types.h" */
! #define ssize_t size_t
  
  /* The actual types used here are mostly wrong,
     but it is not supposed to matter what types we use here.  */
Index: gcc/gcc/system.h
diff -c gcc/gcc/system.h:1.1.1.1 gcc/gcc/system.h:1.6
*** gcc/gcc/system.h:1.1.1.1	Wed Feb 15 21:22:26 2006
--- gcc/gcc/system.h	Thu Apr 16 20:31:55 2009
***************
*** 109,115 ****
--- 109,117 ----
     replacement instead.  */
  #include <safe-ctype.h>
  
+ #ifdef HAVE_SYS_TYPES_H
  #include <sys/types.h>
+ #endif
  
  #include <errno.h>
  
***************
*** 589,595 ****
--- 591,601 ----
  #undef realloc
  #undef calloc
  #undef strdup
+ 
+ /* causes problems on GCC 4 on Linux compiling c-parse.c */
+ #if 0
   #pragma GCC poison malloc realloc calloc strdup
+ #endif
  
  /* Old target macros that have moved to the target hooks structure.  */
   #pragma GCC poison ASM_OPEN_PAREN ASM_CLOSE_PAREN			\
Index: gcc/gcc/tape.tdf
diff -c nul gcc/gcc/tape.tdf:1.1
*** nul	Tue Oct 01 16:28:48 2019
--- gcc/gcc/tape.tdf	Wed Feb 15 21:25:43 2006
***************
*** 0 ****
--- 1,15 ----
+ @TDF
+ GCCPRC.ZIP FIXED RECSIZE 80
+ PDPDOC.ZIP FIXED RECSIZE 80
+ GCCDOC.ZIP FIXED RECSIZE 80
+ PDPI.ZIP FIXED RECSIZE 80
+ GCCJCL.ZIP FIXED RECSIZE 80
+ PDPSRC.ZIP FIXED RECSIZE 80
+ GCCI.ZIP FIXED RECSIZE 80
+ GCCSRC.ZIP FIXED RECSIZE 80
+ GCCS.ZIP FIXED RECSIZE 80
+ GCCEXEC.ZIP FIXED RECSIZE 80
+ TM
+ TM
+ EOT
+ 
Index: gcc/gcc/tapeall.bat
diff -c nul gcc/gcc/tapeall.bat:1.4
*** nul	Tue Oct 01 16:28:48 2019
--- gcc/gcc/tapeall.bat	Sat Nov 25 17:23:01 2006
***************
*** 0 ****
--- 1,58 ----
+ del gccs.aws
+ del pdpi.aws
+ del gcci.aws
+ del gccsrc.aws
+ del pdpsrc.aws
+ del gccjcl.aws
+ del gccdoc.aws
+ del pdpdoc.aws
+ del gccprc.aws
+ del gccexec.aws
+ del pdpmac.aws
+ cmstape -cvf gccs.aws *.s
+ mkdir ..\temp
+ del ..\temp\*.s
+ del ..\temp\*.h
+ del ..\temp\*.c
+ del ..\temp\*.def
+ cd ..\..\pdos\pdpclib
+ cmstape -cvf ..\..\gcc\gcc\pdpi.aws *.h
+ cmstape -rvf ..\..\gcc\gcc\gccs.aws *.asm
+ cmstape -cvf ..\..\gcc\gcc\pdpsrc.aws *.c *.asm
+ cmstape -cvf ..\..\gcc\gcc\pdpdoc.aws *.txt
+ cmstape -cvf ..\..\gcc\gcc\pdpmac.aws *.mac
+ cd ..\..\gcc\temp
+ copy ..\include\*.h
+ copy ..\gcc\*.h
+ copy ..\gcc\config\i370\*.h
+ copy ..\gcc\*.def
+ ren builtin-attrs.def builtina.h
+ ren builtin-types.def builtint.h
+ ren builtins.def builtind.h
+ ren c-common.def ccommond.h
+ ren diagnostic.def diagndef.h
+ ren machmode.def machmodd.h
+ ren params.def paramsd.h
+ ren predict.def predictd.h
+ ren rtl.def rtld.h
+ ren stab.def stabd.h
+ ren timevar.def timevard.h
+ ren tree.def treed.h
+ ren insn-constants.h i-constants.h
+ ren langhooks-def.h langhdef.h
+ cmstape -cvf ..\gcc\gcci.aws *.h
+ copy ..\libiberty\*.c
+ copy ..\gcc\*.c
+ copy ..\gcc\config\i370\*.c
+ cmstape -cvf ..\gcc\gccsrc.aws *.c
+ cd ..\gcc
+ cmstape -cvf gccjcl.aws *.jcl
+ cmstape -cvf gccdoc.aws gccmvs.txt COPYING gcccms.txt
+ cmstape -rvf gccdoc.aws config\i370\i370.md
+ cmstape -rvf gccdoc.zip c-parse.in
+ cmstape -cvf gccprc.aws *.prc
+ cmstape -cvf gccexec.aws *.exec *.parm
+ copy /b GCCEXEC.AWS + GCCPRC.AWS + PDPDOC.AWS + GCCDOC.AWS  + GCCJCL.AWS + PDPI.AWS + PDPSRC.AWS + GCCI.AWS + GCCSRC.AWS + GCCS.AWS + PDPMAC.AWS  GCCCMS.AWS
+ 
+ 
+ 
Index: gcc/gcc/tm-preds.h
diff -c nul gcc/gcc/tm-preds.h:1.2
*** nul	Tue Oct 01 16:28:48 2019
--- gcc/gcc/tm-preds.h	Fri Jun 26 09:31:10 2009
***************
*** 0 ****
--- 1,13 ----
+ /* Generated automatically by the program `genpreds'.  */
+ 
+ #ifndef GCC_TM_PREDS_H
+ #define GCC_TM_PREDS_H
+ 
+ #ifdef RTX_CODE
+ 
+ extern int r_or_s_operand PARAMS ((rtx, enum machine_mode));
+ extern int s_operand PARAMS ((rtx, enum machine_mode));
+ 
+ #endif /* RTX_CODE */
+ 
+ #endif /* GCC_TM_PREDS_H */
Index: gcc/gcc/tm_p.h
diff -c nul gcc/gcc/tm_p.h:1.3
*** nul	Tue Oct 01 16:28:48 2019
--- gcc/gcc/tm_p.h	Mon Jun 18 04:21:43 2018
***************
*** 0 ****
--- 1,10 ----
+ #ifdef IN_GCC
+ #ifdef S390
+ # include "s390-protos.h"
+ #elif defined(I386)
+ # include "i386-protos.h"
+ #else
+ # include "i370-protos.h"
+ #endif
+ #endif
+ #include "tm-preds.h"
Index: gcc/gcc/toplev.c
diff -c gcc/gcc/toplev.c:1.1.1.1 gcc/gcc/toplev.c:1.11
*** gcc/gcc/toplev.c:1.1.1.1	Wed Feb 15 21:22:26 2006
--- gcc/gcc/toplev.c	Sat Nov 07 00:53:20 2009
***************
*** 131,137 ****
--- 131,141 ----
  				       const char *, const char *));
  
  /* Length of line when printing switch values.  */
+ #ifdef TARGET_MVS
+ #define MAX_LINE 72
+ #else
  #define MAX_LINE 75
+ #endif
  
  /* Name of program invoked, sans directories.  */
  
***************
*** 386,391 ****
--- 390,403 ----
  
  int profile_arc_flag = 0;
  
+ #if IFOX
+ /* to avoid problems with the number of externals being too
+    large (more than 399) for IFOX to handle, we move a bunch
+    of them into an array */
+ int gflags[32];
+ #endif
+ 
+ #if !IFOX
  /* Nonzero if generating info for gcov to calculate line test coverage.  */
  
  int flag_test_coverage = 0;
***************
*** 402,407 ****
--- 414,420 ----
  
  int flag_rename_registers = 0;
  int flag_cprop_registers = 0;
+ #endif
  
  /* Nonzero for -pedantic switch: warn about anything
     that standard spec forbids.  */
***************
*** 464,469 ****
--- 477,483 ----
  
  int flag_pcc_struct_return = DEFAULT_PCC_STRUCT_RETURN;
  
+ #if !IFOX
  /* Nonzero for -fforce-mem: load memory value into a register
     before arithmetic on it.  This makes better cse but slower compilation.  */
  
***************
*** 569,574 ****
--- 583,589 ----
  /* Nonzero allows GCC to optimize sibling and tail recursive calls.  */
  
  int flag_optimize_sibling_calls = 0;
+ #endif
  
  /* Nonzero means the front end generally wants `errno' maintained by math
     operations, like built-in SQRT.  */
***************
*** 588,593 ****
--- 603,609 ----
  
  int flag_trapping_math = 1;
  
+ #if !IFOX
  /* 0 means straightforward implementation of complex divide acceptable.
     1 means wide ranges of inputs must work for complex divide.
     2 means C99-like requirements for complex divide (not yet implemented).  */
***************
*** 609,614 ****
--- 625,631 ----
  /* Nonzero means just do syntax checking; don't output anything.  */
  
  int flag_syntax_only = 0;
+ #endif
  
  /* Nonzero means perform global cse.  */
  
***************
*** 1691,1696 ****
--- 1708,1714 ----
  {
    jmp_buf buf;
  
+ #ifdef USE_SIGNALS
    if (setjmp (buf))
      {
        /* We got here via longjmp () caused by an exception in function
***************
*** 1698,1703 ****
--- 1716,1722 ----
        set_float_handler (NULL);
        return 0;
      }
+ #endif
  
    set_float_handler (buf);
    (*fn)(data);
***************
*** 4095,4101 ****
--- 4114,4124 ----
  		}
  	    }
  
+ #if defined(TARGET_MVS) || defined(TARGET_CMS)
+ 	  if (0)
+ #else
  	  if (type == NO_DEBUG)
+ #endif
  	    warning ("`%s': unknown or unsupported -g option", arg - 2);
  
  	  /* Does it conflict with an already selected type?  */
***************
*** 4577,4583 ****
--- 4600,4610 ----
  			       ASM_COMMENT_START, " ", "\n");
  	  /* Add a blank line here so it appears in assembler output but not
  	     screen output.  */
+ #ifdef TARGET_MVS
+ 	  fprintf (asm_out_file, "%s\n", ASM_COMMENT_START);
+ #else
  	  fprintf (asm_out_file, "\n");
+ #endif
  	}
  #endif
      }
***************
*** 4601,4606 ****
--- 4628,4634 ----
  
    gcc_init_libintl ();
  
+ #ifdef USE_SIGNALS
    /* Install handler for SIGFPE, which may be received while we do
       compile-time floating point arithmetic.  */
    signal (SIGFPE, float_signal);
***************
*** 4622,4627 ****
--- 4650,4656 ----
    signal (SIGIOT, crash_signal);
  #endif
  
+ #endif /* USE_SIGNALS */
    /* Initialize the diagnostics reporting machinery, so option parsing
       can give warnings and errors.  */
    diagnostic_initialize (global_dc);
Index: gcc/gcc/tradcpp.c
diff -c gcc/gcc/tradcpp.c:1.1.1.1 gcc/gcc/tradcpp.c:1.3
*** gcc/gcc/tradcpp.c:1.1.1.1	Wed Feb 15 21:22:26 2006
--- gcc/gcc/tradcpp.c	Mon Dec 13 22:49:28 2010
***************
*** 2490,2498 ****
  
    /* If specified file name is absolute, just open it.  */
  
!   if (IS_ABSOLUTE_PATHNAME (fbeg)) {
      strncpy (fname, (const char *)fbeg, flen);
      fname[flen] = 0;
      f = open (fname, O_RDONLY, 0666);
    } else {
      /* Search directory path, trying to open the file.
--- 2490,2524 ----
  
    /* If specified file name is absolute, just open it.  */
  
!   if (IS_ABSOLUTE_PATHNAME (fbeg) || 
!   #if defined(__MVS__) || defined(__VSE__)
!   1
!   #else
!   0
!   #endif
!   ) {
      strncpy (fname, (const char *)fbeg, flen);
      fname[flen] = 0;
+     #if defined(__MVS__) || defined(__VSE__)
+     {
+         char *p;
+         char buf[FILENAME_MAX];
+         
+         strcpy(buf, "dd:");
+         strcat(buf, system_header_p ? "sysincl" : "include");
+         strcat(buf, "(");
+         p = strrchr(fname, '/');
+         p = (p != NULL) ? p + 1 : fname;
+         strcat(buf, p);
+         p = strchr(buf, '.');
+         if (p != NULL)
+         {
+             *p = '\0';
+         }
+         strcat(buf, ")");
+         strcpy(fname, buf);
+     }
+     #endif
      f = open (fname, O_RDONLY, 0666);
    } else {
      /* Search directory path, trying to open the file.
Index: gcc/gcc/tree-check.h
diff -c nul gcc/gcc/tree-check.h:1.1
*** nul	Tue Oct 01 16:28:48 2019
--- gcc/gcc/tree-check.h	Wed Feb 15 21:25:44 2006
***************
*** 0 ****
--- 1,178 ----
+ /* This file is generated using gencheck. Do not edit. */
+ 
+ #ifndef GCC_TREE_CHECK_H
+ #define GCC_TREE_CHECK_H
+ 
+ #define ERROR_MARK_CHECK(t)	TREE_CHECK (t, ERROR_MARK)
+ #define IDENTIFIER_NODE_CHECK(t)	TREE_CHECK (t, IDENTIFIER_NODE)
+ #define TREE_LIST_CHECK(t)	TREE_CHECK (t, TREE_LIST)
+ #define TREE_VEC_CHECK(t)	TREE_CHECK (t, TREE_VEC)
+ #define BLOCK_CHECK(t)	TREE_CHECK (t, BLOCK)
+ #define VOID_TYPE_CHECK(t)	TREE_CHECK (t, VOID_TYPE)
+ #define INTEGER_TYPE_CHECK(t)	TREE_CHECK (t, INTEGER_TYPE)
+ #define REAL_TYPE_CHECK(t)	TREE_CHECK (t, REAL_TYPE)
+ #define COMPLEX_TYPE_CHECK(t)	TREE_CHECK (t, COMPLEX_TYPE)
+ #define VECTOR_TYPE_CHECK(t)	TREE_CHECK (t, VECTOR_TYPE)
+ #define ENUMERAL_TYPE_CHECK(t)	TREE_CHECK (t, ENUMERAL_TYPE)
+ #define BOOLEAN_TYPE_CHECK(t)	TREE_CHECK (t, BOOLEAN_TYPE)
+ #define CHAR_TYPE_CHECK(t)	TREE_CHECK (t, CHAR_TYPE)
+ #define POINTER_TYPE_CHECK(t)	TREE_CHECK (t, POINTER_TYPE)
+ #define OFFSET_TYPE_CHECK(t)	TREE_CHECK (t, OFFSET_TYPE)
+ #define REFERENCE_TYPE_CHECK(t)	TREE_CHECK (t, REFERENCE_TYPE)
+ #define METHOD_TYPE_CHECK(t)	TREE_CHECK (t, METHOD_TYPE)
+ #define FILE_TYPE_CHECK(t)	TREE_CHECK (t, FILE_TYPE)
+ #define ARRAY_TYPE_CHECK(t)	TREE_CHECK (t, ARRAY_TYPE)
+ #define SET_TYPE_CHECK(t)	TREE_CHECK (t, SET_TYPE)
+ #define RECORD_TYPE_CHECK(t)	TREE_CHECK (t, RECORD_TYPE)
+ #define UNION_TYPE_CHECK(t)	TREE_CHECK (t, UNION_TYPE)
+ #define QUAL_UNION_TYPE_CHECK(t)	TREE_CHECK (t, QUAL_UNION_TYPE)
+ #define FUNCTION_TYPE_CHECK(t)	TREE_CHECK (t, FUNCTION_TYPE)
+ #define LANG_TYPE_CHECK(t)	TREE_CHECK (t, LANG_TYPE)
+ #define INTEGER_CST_CHECK(t)	TREE_CHECK (t, INTEGER_CST)
+ #define REAL_CST_CHECK(t)	TREE_CHECK (t, REAL_CST)
+ #define COMPLEX_CST_CHECK(t)	TREE_CHECK (t, COMPLEX_CST)
+ #define VECTOR_CST_CHECK(t)	TREE_CHECK (t, VECTOR_CST)
+ #define STRING_CST_CHECK(t)	TREE_CHECK (t, STRING_CST)
+ #define FUNCTION_DECL_CHECK(t)	TREE_CHECK (t, FUNCTION_DECL)
+ #define LABEL_DECL_CHECK(t)	TREE_CHECK (t, LABEL_DECL)
+ #define CONST_DECL_CHECK(t)	TREE_CHECK (t, CONST_DECL)
+ #define TYPE_DECL_CHECK(t)	TREE_CHECK (t, TYPE_DECL)
+ #define VAR_DECL_CHECK(t)	TREE_CHECK (t, VAR_DECL)
+ #define PARM_DECL_CHECK(t)	TREE_CHECK (t, PARM_DECL)
+ #define RESULT_DECL_CHECK(t)	TREE_CHECK (t, RESULT_DECL)
+ #define FIELD_DECL_CHECK(t)	TREE_CHECK (t, FIELD_DECL)
+ #define NAMESPACE_DECL_CHECK(t)	TREE_CHECK (t, NAMESPACE_DECL)
+ #define COMPONENT_REF_CHECK(t)	TREE_CHECK (t, COMPONENT_REF)
+ #define BIT_FIELD_REF_CHECK(t)	TREE_CHECK (t, BIT_FIELD_REF)
+ #define INDIRECT_REF_CHECK(t)	TREE_CHECK (t, INDIRECT_REF)
+ #define BUFFER_REF_CHECK(t)	TREE_CHECK (t, BUFFER_REF)
+ #define ARRAY_REF_CHECK(t)	TREE_CHECK (t, ARRAY_REF)
+ #define ARRAY_RANGE_REF_CHECK(t)	TREE_CHECK (t, ARRAY_RANGE_REF)
+ #define VTABLE_REF_CHECK(t)	TREE_CHECK (t, VTABLE_REF)
+ #define CONSTRUCTOR_CHECK(t)	TREE_CHECK (t, CONSTRUCTOR)
+ #define COMPOUND_EXPR_CHECK(t)	TREE_CHECK (t, COMPOUND_EXPR)
+ #define MODIFY_EXPR_CHECK(t)	TREE_CHECK (t, MODIFY_EXPR)
+ #define INIT_EXPR_CHECK(t)	TREE_CHECK (t, INIT_EXPR)
+ #define TARGET_EXPR_CHECK(t)	TREE_CHECK (t, TARGET_EXPR)
+ #define COND_EXPR_CHECK(t)	TREE_CHECK (t, COND_EXPR)
+ #define BIND_EXPR_CHECK(t)	TREE_CHECK (t, BIND_EXPR)
+ #define CALL_EXPR_CHECK(t)	TREE_CHECK (t, CALL_EXPR)
+ #define METHOD_CALL_EXPR_CHECK(t)	TREE_CHECK (t, METHOD_CALL_EXPR)
+ #define WITH_CLEANUP_EXPR_CHECK(t)	TREE_CHECK (t, WITH_CLEANUP_EXPR)
+ #define CLEANUP_POINT_EXPR_CHECK(t)	TREE_CHECK (t, CLEANUP_POINT_EXPR)
+ #define PLACEHOLDER_EXPR_CHECK(t)	TREE_CHECK (t, PLACEHOLDER_EXPR)
+ #define WITH_RECORD_EXPR_CHECK(t)	TREE_CHECK (t, WITH_RECORD_EXPR)
+ #define PLUS_EXPR_CHECK(t)	TREE_CHECK (t, PLUS_EXPR)
+ #define MINUS_EXPR_CHECK(t)	TREE_CHECK (t, MINUS_EXPR)
+ #define MULT_EXPR_CHECK(t)	TREE_CHECK (t, MULT_EXPR)
+ #define TRUNC_DIV_EXPR_CHECK(t)	TREE_CHECK (t, TRUNC_DIV_EXPR)
+ #define CEIL_DIV_EXPR_CHECK(t)	TREE_CHECK (t, CEIL_DIV_EXPR)
+ #define FLOOR_DIV_EXPR_CHECK(t)	TREE_CHECK (t, FLOOR_DIV_EXPR)
+ #define ROUND_DIV_EXPR_CHECK(t)	TREE_CHECK (t, ROUND_DIV_EXPR)
+ #define TRUNC_MOD_EXPR_CHECK(t)	TREE_CHECK (t, TRUNC_MOD_EXPR)
+ #define CEIL_MOD_EXPR_CHECK(t)	TREE_CHECK (t, CEIL_MOD_EXPR)
+ #define FLOOR_MOD_EXPR_CHECK(t)	TREE_CHECK (t, FLOOR_MOD_EXPR)
+ #define ROUND_MOD_EXPR_CHECK(t)	TREE_CHECK (t, ROUND_MOD_EXPR)
+ #define RDIV_EXPR_CHECK(t)	TREE_CHECK (t, RDIV_EXPR)
+ #define EXACT_DIV_EXPR_CHECK(t)	TREE_CHECK (t, EXACT_DIV_EXPR)
+ #define FIX_TRUNC_EXPR_CHECK(t)	TREE_CHECK (t, FIX_TRUNC_EXPR)
+ #define FIX_CEIL_EXPR_CHECK(t)	TREE_CHECK (t, FIX_CEIL_EXPR)
+ #define FIX_FLOOR_EXPR_CHECK(t)	TREE_CHECK (t, FIX_FLOOR_EXPR)
+ #define FIX_ROUND_EXPR_CHECK(t)	TREE_CHECK (t, FIX_ROUND_EXPR)
+ #define FLOAT_EXPR_CHECK(t)	TREE_CHECK (t, FLOAT_EXPR)
+ #define NEGATE_EXPR_CHECK(t)	TREE_CHECK (t, NEGATE_EXPR)
+ #define MIN_EXPR_CHECK(t)	TREE_CHECK (t, MIN_EXPR)
+ #define MAX_EXPR_CHECK(t)	TREE_CHECK (t, MAX_EXPR)
+ #define ABS_EXPR_CHECK(t)	TREE_CHECK (t, ABS_EXPR)
+ #define FFS_EXPR_CHECK(t)	TREE_CHECK (t, FFS_EXPR)
+ #define LSHIFT_EXPR_CHECK(t)	TREE_CHECK (t, LSHIFT_EXPR)
+ #define RSHIFT_EXPR_CHECK(t)	TREE_CHECK (t, RSHIFT_EXPR)
+ #define LROTATE_EXPR_CHECK(t)	TREE_CHECK (t, LROTATE_EXPR)
+ #define RROTATE_EXPR_CHECK(t)	TREE_CHECK (t, RROTATE_EXPR)
+ #define BIT_IOR_EXPR_CHECK(t)	TREE_CHECK (t, BIT_IOR_EXPR)
+ #define BIT_XOR_EXPR_CHECK(t)	TREE_CHECK (t, BIT_XOR_EXPR)
+ #define BIT_AND_EXPR_CHECK(t)	TREE_CHECK (t, BIT_AND_EXPR)
+ #define BIT_ANDTC_EXPR_CHECK(t)	TREE_CHECK (t, BIT_ANDTC_EXPR)
+ #define BIT_NOT_EXPR_CHECK(t)	TREE_CHECK (t, BIT_NOT_EXPR)
+ #define TRUTH_ANDIF_EXPR_CHECK(t)	TREE_CHECK (t, TRUTH_ANDIF_EXPR)
+ #define TRUTH_ORIF_EXPR_CHECK(t)	TREE_CHECK (t, TRUTH_ORIF_EXPR)
+ #define TRUTH_AND_EXPR_CHECK(t)	TREE_CHECK (t, TRUTH_AND_EXPR)
+ #define TRUTH_OR_EXPR_CHECK(t)	TREE_CHECK (t, TRUTH_OR_EXPR)
+ #define TRUTH_XOR_EXPR_CHECK(t)	TREE_CHECK (t, TRUTH_XOR_EXPR)
+ #define TRUTH_NOT_EXPR_CHECK(t)	TREE_CHECK (t, TRUTH_NOT_EXPR)
+ #define LT_EXPR_CHECK(t)	TREE_CHECK (t, LT_EXPR)
+ #define LE_EXPR_CHECK(t)	TREE_CHECK (t, LE_EXPR)
+ #define GT_EXPR_CHECK(t)	TREE_CHECK (t, GT_EXPR)
+ #define GE_EXPR_CHECK(t)	TREE_CHECK (t, GE_EXPR)
+ #define EQ_EXPR_CHECK(t)	TREE_CHECK (t, EQ_EXPR)
+ #define NE_EXPR_CHECK(t)	TREE_CHECK (t, NE_EXPR)
+ #define UNORDERED_EXPR_CHECK(t)	TREE_CHECK (t, UNORDERED_EXPR)
+ #define ORDERED_EXPR_CHECK(t)	TREE_CHECK (t, ORDERED_EXPR)
+ #define UNLT_EXPR_CHECK(t)	TREE_CHECK (t, UNLT_EXPR)
+ #define UNLE_EXPR_CHECK(t)	TREE_CHECK (t, UNLE_EXPR)
+ #define UNGT_EXPR_CHECK(t)	TREE_CHECK (t, UNGT_EXPR)
+ #define UNGE_EXPR_CHECK(t)	TREE_CHECK (t, UNGE_EXPR)
+ #define UNEQ_EXPR_CHECK(t)	TREE_CHECK (t, UNEQ_EXPR)
+ #define IN_EXPR_CHECK(t)	TREE_CHECK (t, IN_EXPR)
+ #define SET_LE_EXPR_CHECK(t)	TREE_CHECK (t, SET_LE_EXPR)
+ #define CARD_EXPR_CHECK(t)	TREE_CHECK (t, CARD_EXPR)
+ #define RANGE_EXPR_CHECK(t)	TREE_CHECK (t, RANGE_EXPR)
+ #define CONVERT_EXPR_CHECK(t)	TREE_CHECK (t, CONVERT_EXPR)
+ #define NOP_EXPR_CHECK(t)	TREE_CHECK (t, NOP_EXPR)
+ #define NON_LVALUE_EXPR_CHECK(t)	TREE_CHECK (t, NON_LVALUE_EXPR)
+ #define VIEW_CONVERT_EXPR_CHECK(t)	TREE_CHECK (t, VIEW_CONVERT_EXPR)
+ #define SAVE_EXPR_CHECK(t)	TREE_CHECK (t, SAVE_EXPR)
+ #define UNSAVE_EXPR_CHECK(t)	TREE_CHECK (t, UNSAVE_EXPR)
+ #define RTL_EXPR_CHECK(t)	TREE_CHECK (t, RTL_EXPR)
+ #define ADDR_EXPR_CHECK(t)	TREE_CHECK (t, ADDR_EXPR)
+ #define REFERENCE_EXPR_CHECK(t)	TREE_CHECK (t, REFERENCE_EXPR)
+ #define ENTRY_VALUE_EXPR_CHECK(t)	TREE_CHECK (t, ENTRY_VALUE_EXPR)
+ #define FDESC_EXPR_CHECK(t)	TREE_CHECK (t, FDESC_EXPR)
+ #define COMPLEX_EXPR_CHECK(t)	TREE_CHECK (t, COMPLEX_EXPR)
+ #define CONJ_EXPR_CHECK(t)	TREE_CHECK (t, CONJ_EXPR)
+ #define REALPART_EXPR_CHECK(t)	TREE_CHECK (t, REALPART_EXPR)
+ #define IMAGPART_EXPR_CHECK(t)	TREE_CHECK (t, IMAGPART_EXPR)
+ #define PREDECREMENT_EXPR_CHECK(t)	TREE_CHECK (t, PREDECREMENT_EXPR)
+ #define PREINCREMENT_EXPR_CHECK(t)	TREE_CHECK (t, PREINCREMENT_EXPR)
+ #define POSTDECREMENT_EXPR_CHECK(t)	TREE_CHECK (t, POSTDECREMENT_EXPR)
+ #define POSTINCREMENT_EXPR_CHECK(t)	TREE_CHECK (t, POSTINCREMENT_EXPR)
+ #define VA_ARG_EXPR_CHECK(t)	TREE_CHECK (t, VA_ARG_EXPR)
+ #define TRY_CATCH_EXPR_CHECK(t)	TREE_CHECK (t, TRY_CATCH_EXPR)
+ #define TRY_FINALLY_EXPR_CHECK(t)	TREE_CHECK (t, TRY_FINALLY_EXPR)
+ #define GOTO_SUBROUTINE_EXPR_CHECK(t)	TREE_CHECK (t, GOTO_SUBROUTINE_EXPR)
+ #define LABEL_EXPR_CHECK(t)	TREE_CHECK (t, LABEL_EXPR)
+ #define GOTO_EXPR_CHECK(t)	TREE_CHECK (t, GOTO_EXPR)
+ #define RETURN_EXPR_CHECK(t)	TREE_CHECK (t, RETURN_EXPR)
+ #define EXIT_EXPR_CHECK(t)	TREE_CHECK (t, EXIT_EXPR)
+ #define LOOP_EXPR_CHECK(t)	TREE_CHECK (t, LOOP_EXPR)
+ #define LABELED_BLOCK_EXPR_CHECK(t)	TREE_CHECK (t, LABELED_BLOCK_EXPR)
+ #define EXIT_BLOCK_EXPR_CHECK(t)	TREE_CHECK (t, EXIT_BLOCK_EXPR)
+ #define EXPR_WITH_FILE_LOCATION_CHECK(t)	TREE_CHECK (t, EXPR_WITH_FILE_LOCATION)
+ #define SWITCH_EXPR_CHECK(t)	TREE_CHECK (t, SWITCH_EXPR)
+ #define EXC_PTR_EXPR_CHECK(t)	TREE_CHECK (t, EXC_PTR_EXPR)
+ #define SRCLOC_CHECK(t)	TREE_CHECK (t, SRCLOC)
+ #define SIZEOF_EXPR_CHECK(t)	TREE_CHECK (t, SIZEOF_EXPR)
+ #define ARROW_EXPR_CHECK(t)	TREE_CHECK (t, ARROW_EXPR)
+ #define ALIGNOF_EXPR_CHECK(t)	TREE_CHECK (t, ALIGNOF_EXPR)
+ #define EXPR_STMT_CHECK(t)	TREE_CHECK (t, EXPR_STMT)
+ #define COMPOUND_STMT_CHECK(t)	TREE_CHECK (t, COMPOUND_STMT)
+ #define DECL_STMT_CHECK(t)	TREE_CHECK (t, DECL_STMT)
+ #define IF_STMT_CHECK(t)	TREE_CHECK (t, IF_STMT)
+ #define FOR_STMT_CHECK(t)	TREE_CHECK (t, FOR_STMT)
+ #define WHILE_STMT_CHECK(t)	TREE_CHECK (t, WHILE_STMT)
+ #define DO_STMT_CHECK(t)	TREE_CHECK (t, DO_STMT)
+ #define RETURN_STMT_CHECK(t)	TREE_CHECK (t, RETURN_STMT)
+ #define BREAK_STMT_CHECK(t)	TREE_CHECK (t, BREAK_STMT)
+ #define CONTINUE_STMT_CHECK(t)	TREE_CHECK (t, CONTINUE_STMT)
+ #define SWITCH_STMT_CHECK(t)	TREE_CHECK (t, SWITCH_STMT)
+ #define GOTO_STMT_CHECK(t)	TREE_CHECK (t, GOTO_STMT)
+ #define LABEL_STMT_CHECK(t)	TREE_CHECK (t, LABEL_STMT)
+ #define ASM_STMT_CHECK(t)	TREE_CHECK (t, ASM_STMT)
+ #define SCOPE_STMT_CHECK(t)	TREE_CHECK (t, SCOPE_STMT)
+ #define FILE_STMT_CHECK(t)	TREE_CHECK (t, FILE_STMT)
+ #define CASE_LABEL_CHECK(t)	TREE_CHECK (t, CASE_LABEL)
+ #define STMT_EXPR_CHECK(t)	TREE_CHECK (t, STMT_EXPR)
+ #define COMPOUND_LITERAL_EXPR_CHECK(t)	TREE_CHECK (t, COMPOUND_LITERAL_EXPR)
+ #define CLEANUP_STMT_CHECK(t)	TREE_CHECK (t, CLEANUP_STMT)
+ 
+ #endif /* GCC_TREE_CHECK_H */
Index: gcc/gcc/unixio.c
diff -c nul gcc/gcc/unixio.c:1.5
*** nul	Tue Oct 01 16:28:48 2019
--- gcc/gcc/unixio.c	Fri Jun 26 08:08:42 2009
***************
*** 0 ****
--- 1,224 ----
+ /*********************************************************************/
+ /*                                                                   */
+ /*  This Program Written By Paul Edwards.                            */
+ /*  Released to the public domain.                                   */
+ /*                                                                   */
+ /*********************************************************************/
+ /*********************************************************************/
+ /*                                                                   */
+ /*  unixio - Unix I/O functions written in terms of standard C       */
+ /*  functions.                                                       */
+ /*                                                                   */
+ /*********************************************************************/
+ 
+ #include <stdio.h>
+ #include <time.h>
+ #include <string.h>
+ 
+ #ifdef fileno
+ #undef fileno
+ #endif
+ 
+ #include "unixio.h"
+ 
+ static FILE *files[FOPEN_MAX];
+ /*char *environ[] = { NULL };*/
+ 
+ int open(const char *fnm, int mode, ...)
+ {
+     int x;
+     char *modestr = "";
+ 
+     for (x = 3; x < FOPEN_MAX; x++)
+     {
+         if (files[x] == NULL)
+         {
+             break;
+         }
+     }
+     if (x == FOPEN_MAX)
+     {
+         return (-1);
+     }
+     if ((mode & 0x07) == O_RDONLY)
+     {
+         modestr = "r";
+     }
+     else if ((mode & 0x07) == O_WRONLY)
+     {
+         modestr = "w";
+     }
+     else if ((mode & 0x07) == O_RDWR)
+     {
+         modestr = "r+";
+     }
+     files[x] = fopen(fnm, modestr);
+     if (files[x] == NULL)
+     {
+         return (-1);
+     }
+     return (x);
+ }
+ 
+ int read(int fno, void *buf, size_t bytes)
+ {
+     size_t rb;
+ 
+     if (fno < 3)
+     {
+         rb = fread(buf, 1, bytes, stdin);
+     }
+     else
+     {
+         rb = fread(buf, 1, bytes, files[fno]);
+     }
+     return ((int)rb);
+ }
+ 
+ int write(int fno, const void *buf, size_t bytes)
+ {
+     size_t wb;
+ 
+     if (fno == 1)
+     {
+         fwrite(buf, 1, bytes, stdout);
+     }
+     else if (fno == 2)
+     {
+         fwrite(buf, 1, bytes, stderr);
+     }
+     else if (fno > 2)
+     {
+         wb = fwrite(buf, 1, bytes, files[fno]);
+     }
+     return ((int)wb);
+ }
+ 
+ int close(int fno)
+ {
+     if (fno >= 3)
+     {
+         fclose(files[fno]);
+         files[fno] = NULL;
+     }
+     return (0);
+ }
+ 
+ long lseek(int fno, long int offset, int whence)
+ {
+     return (fseek(files[fno], offset, whence));
+ }
+ 
+ FILE *fdopen(int fno, const char *mode)
+ {
+     return (files[fno]);
+ }
+ 
+ char *getcwd(char *buf, int len)
+ {
+     if (len != 0)
+     {
+         *buf = '\0';
+     }
+     return (buf);
+ }
+ 
+ void unlink(char *f)
+ {
+     remove(f);
+     return;
+ }
+ 
+ int stat(char *f, struct stat *buf)
+ {
+     memset(buf, '\0', sizeof *buf);
+     buf->st_mode = S_IFREG;
+     buf->st_size = 999999;
+     return (0);
+ }
+ 
+ int fileno(FILE *fp)
+ {
+     return (0);
+ }
+ 
+ int access(char *f, int n)
+ {
+     return (1);
+ }
+ 
+ int fstat(int fh, struct stat *buf)
+ {
+     memset(buf, '\0', sizeof *buf);
+     return (0);
+ }
+ 
+ int pwait(int a, int *b, int c)
+ {
+     return (0);
+ }
+ 
+ int putenv(const char *x)
+ {
+     return (0);
+ }
+ 
+ char *mktemp(char *s)
+ {
+     return (tmpnam(s));
+ }
+ 
+ int chdir(char *path)
+ {
+     return (0);
+ }
+ 
+ int rmdir(char *path)
+ {
+     return (0);
+ }
+ 
+ int mkdir(char *path, int permissions)
+ {
+     return (0);
+ }
+ 
+ FILE *popen(const char *s, const char *t)
+ {
+     return (NULL);
+ }
+ 
+ int pclose(FILE *f)
+ {
+     return (0);
+ }
+ 
+ int kill(int a, int b)
+ {
+     return (0);
+ }
+ 
+ int mkstemp(char *buf)
+ {
+     return (open(tmpnam(buf), O_WRONLY));
+ }
+ 
+ DIR *opendir(char *dirname)
+ {
+     return (NULL);
+ }
+ 
+ struct dirent *readdir(DIR *dir)
+ {
+     return (NULL);
+ }
+ 
+ int closedir(DIR *dir)
+ {
+     return (0);
+ }
+ 
+ int execvp(char *path, char **argv)
+ {
+     return (0);
+ }
Index: gcc/gcc/unixio.h
diff -c nul gcc/gcc/unixio.h:1.4
*** nul	Tue Oct 01 16:28:48 2019
--- gcc/gcc/unixio.h	Sun Nov 26 19:11:08 2006
***************
*** 0 ****
--- 1,74 ----
+ /* written by Paul Edwards */
+ /* released to the public domain */
+ 
+ #ifndef UNIXIO_INCLUDED
+ #define UNIXIO_INCLUDED
+ 
+ #include <stddef.h>
+ #include <time.h>
+ #include <errno.h>
+ #include <stdio.h>
+ #include <stdlib.h>
+ 
+ #define S_IFBLK 0x3000
+ #define S_IFDIR 0x4000
+ #define S_IFREG 0x8000
+ #define S_IFMT 0xf000
+ 
+ #ifndef ENOENT
+ #define ENOENT 2002
+ #endif
+ #ifndef ENOTDIR
+ #define ENOTDIR 2045
+ #endif
+ 
+ #define O_RDONLY 1
+ #define O_WRONLY 2
+ #define O_RDWR 4
+ #define O_CREAT 0x100
+ #define O_TRUNC 0x200
+ 
+ struct stat {
+   long st_size;
+   long st_mode;
+   long st_ino;
+   long st_dev;
+   long st_mtime;
+   int st_nlink;
+   int st_uid;
+   int st_gid;
+   int st_ctime;
+ };
+ 
+ typedef struct {
+   int whatever;
+ } DIR;
+ 
+ struct dirent {
+   int whatever;
+ };
+ 
+ struct direct {
+   char *d_name;
+   int d_namlen;
+ };
+ 
+ #define waitpid(a,b,c) (*(b) = 0)
+ #define getpid() (0)
+ #define geteuid() (0)
+ #define _exit(a) (exit((a)))
+ 
+ int open(const char *fnm, int mode, ...);
+ int read(int fno, void *buf, size_t bytes);
+ int write(int fno, const void *buf, size_t bytes);
+ int close(int fno);
+ long lseek(int fno, long int offset, int whence);
+ char *mktemp(char *s);
+ FILE *popen(const char *s, const char *t);
+ int kill(int a, int b);
+ DIR *opendir(char *dirname);
+ struct dirent *readdir(DIR *dir);
+ int closedir(DIR *dir);
+ int execvp(char *path, char **argv);
+ 
+ #endif
Index: gcc/gcc/varasm.c
diff -c gcc/gcc/varasm.c:1.1.1.1 gcc/gcc/varasm.c:1.2
*** gcc/gcc/varasm.c:1.1.1.1	Wed Feb 15 21:22:27 2006
--- gcc/gcc/varasm.c	Sun Mar 02 00:05:12 2008
***************
*** 944,950 ****
       whose scope is less than the whole file, unless it's a member
       of a local class (which will already be unambiguous).
       Concatenate a distinguishing number.  */
!   if (!top_level && !TREE_PUBLIC (decl)
        && ! (DECL_CONTEXT (decl) && TYPE_P (DECL_CONTEXT (decl)))
        && asmspec == 0
        && name == IDENTIFIER_POINTER (DECL_NAME (decl)))
--- 944,960 ----
       whose scope is less than the whole file, unless it's a member
       of a local class (which will already be unambiguous).
       Concatenate a distinguishing number.  */
!   if (
! /* On MVS, due to the fact that the assembler can not distinguish
!    variables that are not unique in first 8-characters, we need to
!    change variable names even at the top level. Unfortunately this
!    makes reading the generated assembler very difficult. It would
!    be good to be able to go through the list of existing names and
!    only generate a replacement name for duplicated values. */
! #if !TARGET_MVS && !TARGET_CMS
!       !top_level &&
! #endif
!       !TREE_PUBLIC (decl)
        && ! (DECL_CONTEXT (decl) && TYPE_P (DECL_CONTEXT (decl)))
        && asmspec == 0
        && name == IDENTIFIER_POINTER (DECL_NAME (decl)))
Index: gcc/gcc/version.c
diff -c gcc/gcc/version.c:1.1.1.1 gcc/gcc/version.c:1.24
*** gcc/gcc/version.c:1.1.1.1	Wed Feb 15 21:22:27 2006
--- gcc/gcc/version.c	Tue Oct 01 14:05:33 2019
***************
*** 1,4 ****
  #include "ansidecl.h"
  #include "version.h"
  
! const char *const version_string = "3.2.3";
--- 1,4 ----
  #include "ansidecl.h"
  #include "version.h"
  
! const char *const version_string = "3.2.3 MVS V9.0";
Index: gcc/gcc/vseutil.bat
diff -c nul gcc/gcc/vseutil.bat:1.13
*** nul	Tue Oct 01 16:28:48 2019
--- gcc/gcc/vseutil.bat	Thu Dec 30 23:22:36 2010
***************
*** 0 ****
--- 1,14 ----
+ cd ..\..\pdos\pdpclib
+ del *.o
+ copy pdptop.mac backup.mac
+ copy pdp370.mac pdptop.mac
+ make -f makefile.w32
+ cd ..\..\gcc\gcc
+ call compile -DTARGET_VSE
+ call compmvs -DTARGET_VSE -UUSE_MEMMGR -ansi -pedantic-errors
+ m4 -I ../../pdos/pdpclib vseutil.m4 >makeutil.jcl
+ call runvse makeutil.jcl outputz.txt none vseutil.obj
+ cd ..\..\pdos\pdpclib
+ copy backup.mac pdptop.mac
+ del backup.mac
+ cd ..\..\gcc\gcc
Index: gcc/gcc/vseutil.m4
diff -c nul gcc/gcc/vseutil.m4:1.50
*** nul	Tue Oct 01 16:28:48 2019
--- gcc/gcc/vseutil.m4	Tue Dec 29 19:49:08 2015
***************
*** 0 ****
--- 1,475 ----
+ * $$ JOB JNM=VSEJOB
+ * $$ LST LST=SYSLST,CLASS=A,RBM=999999
+ // JOB VSEJOB
+ *
+ *
+ *
+ * Standard assignments for C programs
+ *
+ // ASSGN SYS000,SYSLNK
+ // ASSGN SYS005,SYSLST
+ // ASSGN SYS007,SYSPCH
+ // OPTION DUMP
+ // OPTION NOLIST
+ *
+ *
+ * DOS/VS by default stores data in the first 4000 tracks, so
+ * steer clear of them.
+ *
+ * Assemble prolog/epilog macros
+ *
+ // OPTION EDECK,NODECK  
+ // DLBL IJSYSPH,'PDPPUNCH.DAT',0,SD
+ // EXTENT SYSPCH,,,,10000,100 SPACE-SYSPUNCH
+ ASSGN SYSPCH,SYS000
+ // EXEC ASSEMBLY
+ undivert(pdpprlg.mac)dnl
+ undivert(pdpepil.mac)dnl
+          END
+ /*
+ CLOSE SYSPCH,PUNCH
+ // OPTION NOEDECK
+ *
+ *
+ * Put them into the macro library
+ *
+ // DLBL IJSYSIN,'PDPPUNCH.DAT'
+ ASSGN SYSIPT,SYS000
+ // EXEC MAINT                                         
+ CLOSE SYSIPT,READER
+ *
+ *
+ *
+ *
+ * Put the copy lib straight in
+ *
+ // EXEC MAINT
+  CATALS A.PDPTOP
+  BKEND
+ undivert(pdptop.mac)dnl
+  BKEND
+ /*
+ *
+ *
+ *
+ *
+ * Now assemble and link copyfile
+ *
+ * // OPTION LINK
+ // OPTION CATAL
+  PHASE COPYFILE,S+80
+ // EXEC ASSEMBLY
+ undivert(vsestart.asm)dnl
+ /*
+ *
+ * assemble the subroutines
+ *
+ * // OPTION LINK
+ *  // OPTION CATAL
+ // EXEC ASSEMBLY
+ undivert(start.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(stdio.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(stdlib.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(ctype.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(string.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(time.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(errno.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(assert.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(locale.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(math.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(setjmp.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(signal.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(__memmgr.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(vsesupa.asm)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(copyfile.s)dnl
+ /*
+ *
+ * Now link copyfile
+ *
+ // EXEC LNKEDT
+ *
+ *
+ * Now assemble and link hexdump
+ *
+ * // OPTION LINK
+ // OPTION CATAL
+  PHASE HEXDUMP,S+80
+ // EXEC ASSEMBLY
+ undivert(vsestart.asm)dnl
+ /*
+ *
+ * assemble the subroutines
+ *
+ * // OPTION LINK
+ *  // OPTION CATAL
+ // EXEC ASSEMBLY
+ undivert(start.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(stdio.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(stdlib.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(ctype.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(string.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(time.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(errno.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(assert.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(locale.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(math.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(setjmp.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(signal.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(__memmgr.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(vsesupa.asm)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(hexdump.s)dnl
+ /*
+ *
+ * link hexdump
+ *
+ // EXEC LNKEDT
+ *
+ *
+ * Now assemble and link mvsendec
+ *
+ * // OPTION LINK
+ // OPTION CATAL
+  PHASE MVSENDEC,S+80
+ // EXEC ASSEMBLY
+ undivert(vsestart.asm)dnl
+ /*
+ *
+ * assemble the subroutines
+ *
+ * // OPTION LINK
+ *  // OPTION CATAL
+ // EXEC ASSEMBLY
+ undivert(start.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(stdio.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(stdlib.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(ctype.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(string.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(time.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(errno.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(assert.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(locale.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(math.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(setjmp.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(signal.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(__memmgr.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(vsesupa.asm)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(mvsendec.s)dnl
+ /*
+ *
+ * link mvsendec
+ *
+ // EXEC LNKEDT
+ *
+ *
+ *
+ *
+ * Now assemble and link mvsunzip
+ *
+ * // OPTION LINK
+ // OPTION CATAL
+  PHASE MVSUNZIP,S+80
+ // EXEC ASSEMBLY
+ undivert(vsestart.asm)dnl
+ /*
+ *
+ * assemble the subroutines
+ *
+ * // OPTION LINK
+ *  // OPTION CATAL
+ // EXEC ASSEMBLY
+ undivert(start.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(stdio.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(stdlib.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(ctype.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(string.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(time.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(errno.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(assert.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(locale.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(math.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(setjmp.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(signal.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(__memmgr.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(vsesupa.asm)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(mvsunzip.s)dnl
+ /*
+ *
+ * link mvsunzip
+ *
+ // EXEC LNKEDT
+ *
+ *
+ *
+ *
+ * Now assemble and link vseproc
+ *
+ * // OPTION LINK
+ // OPTION CATAL
+  PHASE VSEPROC,S+80
+ // EXEC ASSEMBLY
+ undivert(vsestart.asm)dnl
+ /*
+ *
+ * assemble the subroutines
+ *
+ * // OPTION LINK
+ *  // OPTION CATAL
+ // EXEC ASSEMBLY
+ undivert(start.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(stdio.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(stdlib.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(ctype.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(string.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(time.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(errno.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(assert.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(locale.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(math.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(setjmp.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(signal.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(__memmgr.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(vsesupa.asm)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(vseproc.s)dnl
+ /*
+ *
+ * link vseproc
+ *
+ // EXEC LNKEDT
+ *
+ *
+ *
+ *
+ * Now assemble and link vsemanip
+ *
+ * // OPTION LINK
+ // OPTION CATAL
+  PHASE VSEMANIP,S+80
+ // EXEC ASSEMBLY
+ undivert(vsestart.asm)dnl
+ /*
+ *
+ * assemble the subroutines
+ *
+ * // OPTION LINK
+ *  // OPTION CATAL
+ // EXEC ASSEMBLY
+ undivert(start.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(stdio.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(stdlib.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(ctype.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(string.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(time.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(errno.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(assert.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(locale.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(math.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(setjmp.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(signal.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(__memmgr.s)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(vsesupa.asm)dnl
+ /*
+ // EXEC ASSEMBLY
+ undivert(vsemanip.s)dnl
+ /*
+ *
+ * link vsemanip
+ *
+ // EXEC LNKEDT
+ *
+ *
+ *
+ *
+ * Now punch the phases
+ *
+ // DLBL IJSYSPH,'PDPPUNCH.DAT',0,SD
+ // EXTENT SYSPCH,,,,10000,1000 SPACE-SYSPUNCH
+ ASSGN SYSPCH,SYS000
+ // EXEC CSERV
+  PUNCH COPYFILE
+  PUNCH HEXDUMP
+  PUNCH MVSENDEC
+  PUNCH MVSUNZIP
+  PUNCH VSEPROC
+  PUNCH VSEMANIP
+ /*
+ CLOSE SYSPCH,PUNCH
+ *
+ *
+ * And put it to tape
+ *
+ // DLBL SDI1,'PDPPUNCH.DAT'
+ // TLBL MTO1,'HERC01.MFTOPC',0
+ // ASSGN SYS011,TAPE,VOL=MFTOPC
+ // EXEC VSEMANIP,SIZE=AUTO,PARM='dd:sdi1 dd:mto1'
+ *
+ *
+ *
+ *
+ /&
+ * $$ EOJ
Index: gcc/gcc/withbis.bat
diff -c nul gcc/gcc/withbis.bat:1.3
*** nul	Tue Oct 01 16:28:48 2019
--- gcc/gcc/withbis.bat	Tue Jun 02 14:23:11 2009
***************
*** 0 ****
--- 1,4 ----
+ sed 's/rem zip/zip/g' zipmvs.bat >zipmvs2.bat
+ sed -e 's/rem type/type/g' -e 's/type stage2d/rem type stage2d/g' subjobs.bat >subjobs2.bat
+ sed 's/subjobs/subjobs2/g' allmvs.bat | sed 's/zipmvs/zipmvs2/g' >allmvs2.bat
+ call allmvs2
Index: gcc/gcc/withbis1.bat
diff -c nul gcc/gcc/withbis1.bat:1.9
*** nul	Tue Oct 01 16:28:48 2019
--- gcc/gcc/withbis1.bat	Fri Nov 27 07:05:36 2009
***************
*** 0 ****
--- 1,49 ----
+ rem this is for use with CMS
+ 
+ cd ..\..\pdos\pdpclib
+ del *.o
+ make -f makefile.w32
+ cd ..\..\gcc\gcc
+ call compile -DTARGET_CMS
+ call compmvs -DTARGET_CMS -ansi -pedantic-errors
+ del output.txt
+ call zipmvs
+ mkdir ..\temp
+ del /q ..\temp\*.*
+ cd ..\temp
+ unzip ..\gcc\all
+ unzip *.zip
+ del *.zip
+ del ..\gcc\all.zip
+ 
+ rem for integrity, don't send these files up - let them
+ rem be generated
+ del genrtl.c
+ del insn-attrtab.c
+ del insn-emit.c
+ del insn-extract.c
+ del insn-opinit.c
+ del insn-output.c
+ del insn-peep.c
+ del insn-recog.c
+ del c-parse.c
+ del genrtl.h
+ del insn-attr.h
+ del insn-codes.h
+ del insn-config.h
+ del i-constants.h
+ del insn-flags.h
+ del tm-preds.h
+ del tree-check.h
+ 
+ del *.jcl
+ 
+ zip -0mX ..\gcc\all *
+ cd ..\gcc
+ 
+ rem for S/380 testing, use this
+ call runcms fullcms1.exec output.txt all.zip gcccms-exe.vmarc
+ 
+ rem for S/390 testing, use this
+ rem mvsendec encb all.zip all.dat
+ rem loc2ebc all.dat xfer.card
Index: gcc/gcc/withbis1.exec
diff -c nul gcc/gcc/withbis1.exec:1.4
*** nul	Tue Oct 01 16:28:48 2019
--- gcc/gcc/withbis1.exec	Thu May 21 21:57:39 2009
***************
*** 0 ****
--- 1,47 ----
+ * Usage - WITHBIS1 <SRC> <EXE> <WORK>
+ 
+ * This script compiles all the files on SRC disk (default is A),
+ * making use of bison and generating the generated files, then
+ * copies the resultant modules to the EXE disk (default B), and
+ * puts the generated assembler on to the WORK disk (default C)
+ 
+ 
+ &SRC = A
+ &EXE = B
+ &WORK = C
+ 
+ 
+ &IF &INDEX EQ 0 &GOTO -FINARGS
+ &SRC = &1
+ &ARGS &2 &3 &4 &5 &6 &7 &8 &9
+ 
+ &IF &INDEX EQ 0 &GOTO -FINARGS
+ &EXE = &1
+ &ARGS &2 &3 &4 &5 &6 &7 &8 &9
+ 
+ &IF &INDEX EQ 0 &GOTO -FINARGS
+ &WORK = &1
+ 
+ -FINARGS
+ 
+ 
+ COPY __HEADER H &SRC HEADER GCC &SRC (REPL
+ 
+ 
+ * Erase the work disk and avoid errors by copying
+ * a dummy file
+ COPY PDPTOP MAC &SRC = = &WORK (REPL
+ LIST * * &WORK (EXEC
+ EXEC CMS ERASE
+ 
+ 
+ * Build and generate generated files
+ EXEC GENCOMP &SRC
+ 
+ 
+ * Build GCC, without a source comparison, since it won't compare
+ EXEC COMPILE &SRC &EXE &SRC
+ 
+ 
+ * Save the generated assembler ourselves
+ COPY * S &SRC = = &WORK (REPL
Index: gcc/gcc/withbis2.bat
diff -c nul gcc/gcc/withbis2.bat:1.6
*** nul	Tue Oct 01 16:28:48 2019
--- gcc/gcc/withbis2.bat	Fri Nov 27 07:05:36 2009
***************
*** 0 ****
--- 1,53 ----
+ rem this is the second part for use with CMS
+ rem this proves the integrity of the compiler
+ rem produced in part 1 by reproducing it and
+ rem comparing the assembler
+ 
+ cd ..\..\pdos\pdpclib
+ del *.o
+ make -f makefile.w32
+ cd ..\..\gcc\gcc
+ call compile -DTARGET_CMS
+ call compmvs -DTARGET_CMS -ansi -pedantic-errors
+ del output.txt
+ call zipmvs
+ mkdir ..\temp
+ del /q ..\temp\*.*
+ cd ..\temp
+ unzip ..\gcc\all
+ unzip *.zip
+ del *.zip
+ del ..\gcc\all.zip
+ 
+ rem for integrity, don't send these files up - let them
+ rem be generated
+ del genrtl.c
+ del insn-attrtab.c
+ del insn-emit.c
+ del insn-extract.c
+ del insn-opinit.c
+ del insn-output.c
+ del insn-peep.c
+ del insn-recog.c
+ del c-parse.c
+ del genrtl.h
+ del insn-attr.h
+ del insn-codes.h
+ del insn-config.h
+ del i-constants.h
+ del insn-flags.h
+ del tm-preds.h
+ del tree-check.h
+ 
+ del *.jcl
+ del *.s
+ 
+ zip -0mX ..\gcc\all *
+ cd ..\gcc
+ 
+ rem for S/380 testing, use this
+ call runcms fullcms2.exec output.txt all.zip gcccms-asm.vmarc
+ 
+ rem for S/390 testing, use this
+ rem mvsendec encb all.zip all.dat
+ rem loc2ebc all.dat xfer.card
Index: gcc/gcc/withbis2.exec
diff -c nul gcc/gcc/withbis2.exec:1.3
*** nul	Tue Oct 01 16:28:48 2019
--- gcc/gcc/withbis2.exec	Fri May 22 10:08:55 2009
***************
*** 0 ****
--- 1,67 ----
+ * Usage - WITHBIS2 <SRC> <EXE> <WORK>
+ 
+ * This script compiles all the files on SRC disk (default is A),
+ * making use of bison and generating the generated files, then
+ * compares the generated assembler to what is still on the WORK 
+ * disk (default C), then copies the validated assembler plus
+ * generated files to the EXE disk (default B).
+ 
+ &SRC = A
+ &EXE = B
+ &WORK = C
+ 
+ 
+ &IF &INDEX EQ 0 &GOTO -FINARGS
+ &SRC = &1
+ &ARGS &2 &3 &4 &5 &6 &7 &8 &9
+ 
+ &IF &INDEX EQ 0 &GOTO -FINARGS
+ &EXE = &1
+ &ARGS &2 &3 &4 &5 &6 &7 &8 &9
+ 
+ &IF &INDEX EQ 0 &GOTO -FINARGS
+ &WORK = &1
+ 
+ -FINARGS
+ 
+ 
+ COPY __HEADER H &SRC HEADER GCC &SRC (REPL
+ 
+ * Get the old generated assembler back
+ COPY * S &WORK = = &SRC (REPL
+ 
+ * Build and generate generated files
+ EXEC GENCOMP &SRC
+ 
+ 
+ * Build GCC, without a source comparison or copying the
+ * executables since we are doing that separately
+ EXEC COMPILE &SRC &SRC &SRC
+ 
+ 
+ * Compare generated assembler
+ EXEC ITERGCC DIFFCMS Y Y Y Y &SRC &WORK
+ 
+ 
+ * Save generated assembler
+ COPY * S &SRC = = &EXE (REPL
+ 
+ * Save generated files
+ COPY GENRTL C &SRC = = &EXE (REPL
+ COPY INSN-ATT C &SRC = = &EXE (REPL
+ COPY INSN-EMI C &SRC = = &EXE (REPL
+ COPY INSN-EXT C &SRC = = &EXE (REPL
+ COPY INSN-OPI C &SRC = = &EXE (REPL
+ COPY INSN-OUT C &SRC = = &EXE (REPL
+ COPY INSN-PEE C &SRC = = &EXE (REPL
+ COPY INSN-REC C &SRC = = &EXE (REPL
+ COPY C-PARSE C &SRC = = &EXE (REPL
+ 
+ COPY GENRTL H &SRC = = &EXE (REPL
+ COPY INSN-ATT H &SRC = = &EXE (REPL
+ COPY INSN-COD H &SRC = = &EXE (REPL
+ COPY INSN-CON H &SRC = = &EXE (REPL
+ COPY I-CONSTA H &SRC = = &EXE (REPL
+ COPY INSN-FLA H &SRC = = &EXE (REPL
+ COPY TM-PREDS H &SRC = = &EXE (REPL
+ COPY TREE-CHE H &SRC = = &EXE (REPL
Index: gcc/gcc/xmit1.jcl
diff -c nul gcc/gcc/xmit1.jcl:1.1
*** nul	Tue Oct 01 16:28:48 2019
--- gcc/gcc/xmit1.jcl	Sun Apr 26 15:37:35 2009
***************
*** 0 ****
--- 1,15 ----
+ //GCCGEN   JOB CLASS=C,REGION=0K
+ //*
+ //* Define aliases for High-level qualifiers suitable
+ //* for your site.
+ //*
+ //IDCAMS   EXEC PGM=IDCAMS
+ //SYSPRINT DD  SYSOUT=*
+ //SYSIN    DD  *
+   DEFINE ALIAS (NAME(GCC) RELATE(SYS1.UCAT.TSO)) -
+          CATALOG(SYS1.VMASTCAT/SECRET)
+   DEFINE ALIAS (NAME(PDPCLIB) RELATE(SYS1.UCAT.TSO)) -
+          CATALOG(SYS1.VMASTCAT/SECRET)
+   SET MAXCC=0
+ /*
+ //
Index: gcc/gcc/xmit2.jcl
diff -c nul gcc/gcc/xmit2.jcl:1.4
*** nul	Tue Oct 01 16:28:48 2019
--- gcc/gcc/xmit2.jcl	Sun Jul 19 10:36:56 2009
***************
*** 0 ****
--- 1,27 ----
+ //GCCGEN   JOB CLASS=C,REGION=0K
+ //*
+ //* Allocate space for the sequential XMIT
+ //* and the PDS of XMITs that it will be converted into
+ //*
+ //CREATE   PROC GCCPREF='GCC'
+ //DELETE   EXEC PGM=IEFBR14
+ //DD1      DD DSN=&GCCPREF..GCC.SEQ.XMIT,DISP=(MOD,DELETE),
+ //       UNIT=SYSALLDA,SPACE=(TRK,(0))
+ //DD2      DD DSN=&GCCPREF..GCC.PDS.XMIT,DISP=(MOD,DELETE),
+ //       UNIT=SYSALLDA,SPACE=(TRK,(0))
+ //*
+ //ALLOC    EXEC PGM=IEFBR14
+ //* Put an explicit DSORG=PS to cater for buggy ftp programs
+ //* that inspect a new dataset when they are the ones who are
+ //* meant to be setting that attribute on the open-for-write
+ //DD1      DD DSN=&GCCPREF..GCC.SEQ.XMIT,DISP=(,CATLG),
+ // DCB=(DSORG=PS,RECFM=FB,LRECL=80,BLKSIZE=3120),
+ // SPACE=(3120,(30000,30000)),UNIT=SYSALLDA
+ //DD2      DD DSN=&GCCPREF..GCC.PDS.XMIT,DISP=(,CATLG),
+ // DCB=(RECFM=FB,LRECL=80,BLKSIZE=3120),
+ // SPACE=(3120,(30000,30000,44)),UNIT=SYSALLDA
+ //         PEND
+ //*
+ //S1 EXEC CREATE
+ //*
+ //
Index: gcc/gcc/xmit3.jcl
diff -c nul gcc/gcc/xmit3.jcl:1.5
*** nul	Tue Oct 01 16:28:49 2019
--- gcc/gcc/xmit3.jcl	Thu Oct 29 23:59:24 2009
***************
*** 0 ****
--- 1,32 ----
+ //GCCGEN   JOB CLASS=C,REGION=0K
+ //*
+ //* Note that by nature, the file from the PC is in an
+ //* undefined format, since it's contents could be
+ //* anything. We know it is in XMIT format though, but
+ //* the generic tape setup facility doesn't know that
+ //* unless you specifically tell it. This procedure
+ //* assumes it is still in undefined format, and that
+ //* this program (COPYFILE, rather that IEBGENER), will
+ //* reform it into an FB80.
+ //*
+ //* Also note that the use of COPYFILE is just an example
+ //* of assisted file transfer on one system. There's a
+ //* very good chance that you won't even have the COPYFILE
+ //* program unless you have previously installed an older
+ //* version of GCC.
+ //*
+ //TRANSFER PROC GCCPREF='GCC',PDPPREF='PDPCLIB'
+ //*
+ //COPY     EXEC PGM=COPYFILE,PARM='-bb dd:in dd:out'
+ //STEPLIB  DD DSN=&PDPPREF..LINKLIB,DISP=SHR
+ //IN       DD DSN=HERC02.IN,DISP=OLD,
+ //         UNIT=TAPE,VOL=SER=PCTOMF,LABEL=(1,NL),
+ //         DCB=(RECFM=U,LRECL=0,BLKSIZE=6233)
+ //OUT      DD DSN=&GCCPREF..GCC.SEQ.XMIT,DISP=OLD
+ //SYSIN    DD DUMMY
+ //SYSPRINT DD SYSOUT=*
+ //SYSTERM  DD SYSOUT=*
+ //         PEND
+ //*
+ //S1 EXEC TRANSFER
+ //
Index: gcc/gcc/xmit4.jcl
diff -c nul gcc/gcc/xmit4.jcl:1.7
*** nul	Tue Oct 01 16:28:49 2019
--- gcc/gcc/xmit4.jcl	Mon Sep 30 12:56:17 2019
***************
*** 0 ****
--- 1,26 ----
+ //GCCGEN   JOB CLASS=C,REGION=0K
+ //*
+ //* Receive the XMIT. Adjust the HLQs appropriately.
+ //*
+ //RECV1    PROC
+ //*
+ //RECV     EXEC PGM=IKJEFT01,DYNAMNBR=60
+ //SYSTSPRT DD  SYSOUT=*
+ //SYSTSIN  DD  DUMMY
+ //SYSPROC  DD  DSN=SYS1.CMDPROC,DISP=SHR
+ //SYSPRINT DD  SYSOUT=*,DCB=(RECFM=FB,LRECL=121,BLKSIZE=12100)
+ //SYSTERM  DD  SYSOUT=*
+ //SYSUDUMP DD  SYSOUT=*
+ //SYSIN    DD  DUMMY
+ //*
+ //         PEND
+ //*
+ //S1 EXEC RECV1
+ //SYSTSIN  DD  *
+ PROFILE PREFIX(GCC)
+ RECEIVE INDSNAME('GCC.GCC.SEQ.XMIT')
+ 
+ LISTC
+ /*
+ //*
+ //
Index: gcc/gcc/xmit5.jcl
diff -c nul gcc/gcc/xmit5.jcl:1.4
*** nul	Tue Oct 01 16:28:49 2019
--- gcc/gcc/xmit5.jcl	Fri May 01 06:41:11 2009
***************
*** 0 ****
--- 1,23 ----
+ //GCCGEN   JOB CLASS=C,REGION=0K
+ //*
+ //* Submit the job that receive the various XMITs
+ //* Also the job that submits the example.
+ //* And the cleanup job.
+ //*
+ //SUBMIT   PROC GCCPREF='GCC',MEMBER=''
+ //*
+ //SUBJOB   EXEC PGM=IEBGENER
+ //SYSUT1   DD  DSN=&GCCPREF..GCC.PDS.XMIT(&MEMBER),DISP=SHR
+ //SYSUT2   DD  SYSOUT=(A,INTRDR)
+ //SYSPRINT DD  SYSOUT=*
+ //SYSIN    DD  DUMMY
+ //*
+ //         PEND
+ //*
+ //S1 EXEC SUBMIT,MEMBER='XMIT6'
+ //*
+ //S2 EXEC SUBMIT,MEMBER='XMIT7'
+ //*
+ //S3 EXEC SUBMIT,MEMBER='XMIT8'
+ //*
+ //
Index: gcc/gcc/xmit6.jcl
diff -c nul gcc/gcc/xmit6.jcl:1.15
*** nul	Tue Oct 01 16:28:49 2019
--- gcc/gcc/xmit6.jcl	Mon Sep 30 12:56:17 2019
***************
*** 0 ****
--- 1,175 ----
+ //GCCGEN   JOB CLASS=C,REGION=0K
+ //*
+ //* Preallocate all target PDSes.
+ //* Then receive all the XMITs in the XMIT PDS.
+ //* Adjust the HLQs appropriately.
+ //*
+ //CREATE   PROC PDPPREF='PDPCLIB',GCCPREF='GCC'
+ //DELETE   EXEC PGM=IEFBR14
+ //DD1      DD DSN=&PDPPREF..INCLUDE,DISP=(MOD,DELETE),
+ //       UNIT=SYSALLDA,SPACE=(TRK,(0))
+ //DD2      DD DSN=&PDPPREF..SOURCE,DISP=(MOD,DELETE),
+ //       UNIT=SYSALLDA,SPACE=(TRK,(0))
+ //DD3      DD DSN=&PDPPREF..DOC,DISP=(MOD,DELETE),
+ //       UNIT=SYSALLDA,SPACE=(TRK,(0))
+ //DD4      DD DSN=&GCCPREF..PROCLIB,DISP=(MOD,DELETE),
+ //       UNIT=SYSALLDA,SPACE=(TRK,(0))
+ //DD5      DD DSN=&GCCPREF..SOURCE,DISP=(MOD,DELETE),
+ //       UNIT=SYSALLDA,SPACE=(TRK,(0))
+ //DD6      DD DSN=&GCCPREF..INCLUDE,DISP=(MOD,DELETE),
+ //       UNIT=SYSALLDA,SPACE=(TRK,(0))
+ //DD7      DD DSN=&GCCPREF..DOC,DISP=(MOD,DELETE),
+ //       UNIT=SYSALLDA,SPACE=(TRK,(0))
+ //DD8      DD DSN=&GCCPREF..JCL,DISP=(MOD,DELETE),
+ //       UNIT=SYSALLDA,SPACE=(TRK,(0))
+ //DD10     DD DSN=&GCCPREF..LINKLIB,DISP=(MOD,DELETE),
+ //       UNIT=SYSALLDA,SPACE=(TRK,(0))
+ //DD12     DD DSN=&PDPPREF..NCALIB,DISP=(MOD,DELETE),
+ //       UNIT=SYSALLDA,SPACE=(TRK,(0))
+ //DD13     DD DSN=&PDPPREF..MACLIB,DISP=(MOD,DELETE),
+ //       UNIT=SYSALLDA,SPACE=(TRK,(0))
+ //DD14     DD DSN=&GCCPREF..S2,DISP=(MOD,DELETE),
+ //       UNIT=SYSALLDA,SPACE=(TRK,(0))
+ //DD16     DD DSN=&PDPPREF..LINKLIB,DISP=(MOD,DELETE),
+ //       UNIT=SYSALLDA,SPACE=(TRK,(0))
+ //*
+ //ALLOC    EXEC PGM=IEFBR14
+ //DD1      DD DSN=&PDPPREF..INCLUDE,DISP=(,CATLG),
+ // DCB=(RECFM=FB,LRECL=80,BLKSIZE=6160),
+ // SPACE=(6160,(32,32,44)),UNIT=SYSALLDA
+ //DD2      DD DSN=&PDPPREF..SOURCE,DISP=(,CATLG),
+ // DCB=(RECFM=FB,LRECL=80,BLKSIZE=6160),
+ // SPACE=(6160,(400,400,44)),UNIT=SYSALLDA
+ //DD3      DD DSN=&PDPPREF..DOC,DISP=(,CATLG),
+ // DCB=(RECFM=FB,LRECL=80,BLKSIZE=6160),
+ // SPACE=(6160,(23,23,44)),UNIT=SYSALLDA
+ //DD4      DD DSN=&GCCPREF..PROCLIB,DISP=(,CATLG),
+ // DCB=(RECFM=FB,LRECL=80,BLKSIZE=6160),
+ // SPACE=(6160,(15,15,44)),UNIT=SYSALLDA
+ //DD5      DD DSN=&GCCPREF..SOURCE,DISP=(,CATLG),
+ // DCB=(RECFM=VB,LRECL=255,BLKSIZE=6233),
+ // SPACE=(6233,(2600,2600,44)),UNIT=SYSALLDA
+ //DD6      DD DSN=&GCCPREF..INCLUDE,DISP=(,CATLG),
+ // DCB=(RECFM=VB,LRECL=255,BLKSIZE=6233),
+ // SPACE=(6233,(346,346,44)),UNIT=SYSALLDA
+ //DD7      DD DSN=&GCCPREF..DOC,DISP=(,CATLG),
+ // DCB=(RECFM=VB,LRECL=255,BLKSIZE=6233),
+ // SPACE=(6233,(100,100,44)),UNIT=SYSALLDA
+ //DD8      DD DSN=&GCCPREF..JCL,DISP=(,CATLG),
+ // DCB=(RECFM=FB,LRECL=80,BLKSIZE=6160),
+ // SPACE=(6160,(69,69,44)),UNIT=SYSALLDA
+ //DD10     DD DSN=&GCCPREF..LINKLIB,DISP=(,CATLG),
+ // DCB=(RECFM=U,LRECL=0,BLKSIZE=6144),
+ // SPACE=(6144,(1548,1548,44),,,ROUND),UNIT=SYSALLDA
+ //DD12     DD DSN=&PDPPREF..NCALIB,DISP=(,CATLG),
+ // DCB=(RECFM=U,LRECL=0,BLKSIZE=6144),
+ // SPACE=(6144,(61,61,44)),UNIT=SYSALLDA
+ //DD13     DD DSN=&PDPPREF..MACLIB,DISP=(,CATLG),
+ // DCB=(RECFM=FB,LRECL=80,BLKSIZE=6160),
+ // SPACE=(6160,(10,10,44)),UNIT=SYSALLDA
+ //DD14     DD DSN=&GCCPREF..S2,DISP=(,CATLG),
+ // DCB=(RECFM=FB,LRECL=80,BLKSIZE=6160),
+ // SPACE=(6160,(10500,10500,44)),UNIT=SYSALLDA
+ //DD16     DD DSN=&PDPPREF..LINKLIB,DISP=(,CATLG),
+ // DCB=(RECFM=U,LRECL=0,BLKSIZE=6144),
+ // SPACE=(6144,(77,77,44),,,ROUND),UNIT=SYSALLDA
+ //         PEND
+ //*
+ //RECV2    PROC
+ //*
+ //RECV     EXEC PGM=IKJEFT01,DYNAMNBR=60
+ //SYSTSPRT DD  SYSOUT=*
+ //SYSPROC  DD  DSN=SYS1.CMDPROC,DISP=SHR
+ //SYSPRINT DD  SYSOUT=*,DCB=(RECFM=FB,LRECL=121,BLKSIZE=12100)
+ //SYSTERM  DD  SYSOUT=*
+ //SYSUDUMP DD  SYSOUT=*
+ //SYSIN    DD  DUMMY
+ //*
+ //         PEND
+ //*
+ //* Preallocate all datasets
+ //S1 EXEC CREATE
+ //*
+ //* Now "receive" into those preallocated datasets, using
+ //* the dataset substitutions below.
+ //S2 EXEC RECV2
+ //* Note that if you are trying to install this under your
+ //* own userid, or otherwise need multiple levels of dataset
+ //* name prefixes, you will need more than the profile prefix
+ //* to get to the right names. You will need to manually
+ //* specify the target dataset name. So on each of those
+ //* blank lines you will need something like:
+ //* DA('ABC.DEF.GCC.DOC').
+ //* For your convenience, a second send of RECEIVE commands
+ //* is included below in a DD statement that is not used.
+ //* If you change that DD to SYSTSIN and rename the existing
+ //* SYSTSIN to "UNUSED", it should work (on a z/OS system,
+ //* anyway).
+ //SYSTSIN  DD  *
+ PROFILE PREFIX(GCC)
+ RECEIVE INDSNAME('GCC.GCC.PDS.XMIT(GCCDOC)')
+ 
+ RECEIVE INDSNAME('GCC.GCC.PDS.XMIT(GCCJCL)')
+ 
+ RECEIVE INDSNAME('GCC.GCC.PDS.XMIT(GCCLINK)')
+ 
+ RECEIVE INDSNAME('GCC.GCC.PDS.XMIT(GCCPROC)')
+ 
+ RECEIVE INDSNAME('GCC.GCC.PDS.XMIT(GCCS2)')
+ 
+ RECEIVE INDSNAME('GCC.GCC.PDS.XMIT(GCCSRC)')
+ 
+ RECEIVE INDSNAME('GCC.GCC.PDS.XMIT(GCCINC)')
+ 
+ PROFILE PREFIX(PDPCLIB)
+ RECEIVE INDSNAME('GCC.GCC.PDS.XMIT(PDPDOC)')
+ 
+ RECEIVE INDSNAME('GCC.GCC.PDS.XMIT(PDPINC)')
+ 
+ RECEIVE INDSNAME('GCC.GCC.PDS.XMIT(PDPMAC)')
+ 
+ RECEIVE INDSNAME('GCC.GCC.PDS.XMIT(PDPNCAL)')
+ 
+ RECEIVE INDSNAME('GCC.GCC.PDS.XMIT(PDPLINK)')
+ 
+ RECEIVE INDSNAME('GCC.GCC.PDS.XMIT(PDPSRC)')
+ 
+ LISTC LEVEL(GCC)
+ LISTC LEVEL(PDPCLIB)
+ /*
+ //*
+ //* Rename this from UNUSED to SYSTSIN if this is more
+ //* suitable for your use. Make sure you rename the other
+ //* one from SYSTSIN to UNUSED if you do so though!
+ //UNUSED   DD  *
+ RECEIVE INDSNAME('ABC.DEF.GCC.GCC.PDS.XMIT(GCCDOC)')
+ DA('ABC.DEF.GCC.DOC')
+ RECEIVE INDSNAME('ABC.DEF.GCC.GCC.PDS.XMIT(GCCJCL)')
+ DA('ABC.DEF.GCC.JCL')
+ RECEIVE INDSNAME('ABC.DEF.GCC.GCC.PDS.XMIT(GCCLINK)')
+ DA('ABC.DEF.GCC.LINKLIB')
+ RECEIVE INDSNAME('ABC.DEF.GCC.GCC.PDS.XMIT(GCCPROC)')
+ DA('ABC.DEF.GCC.PROCLIB')
+ RECEIVE INDSNAME('ABC.DEF.GCC.GCC.PDS.XMIT(GCCS2)')
+ DA('ABC.DEF.GCC.S2')
+ RECEIVE INDSNAME('ABC.DEF.GCC.GCC.PDS.XMIT(GCCSRC)')
+ DA('ABC.DEF.GCC.SOURCE')
+ RECEIVE INDSNAME('ABC.DEF.GCC.GCC.PDS.XMIT(GCCINC)')
+ DA('ABC.DEF.GCC.INCLUDE')
+ RECEIVE INDSNAME('ABC.DEF.GCC.GCC.PDS.XMIT(PDPDOC)')
+ DA('ABC.DEF.PDPCLIB.DOC')
+ RECEIVE INDSNAME('ABC.DEF.GCC.GCC.PDS.XMIT(PDPINC)')
+ DA('ABC.DEF.PDPCLIB.INCLUDE')
+ RECEIVE INDSNAME('ABC.DEF.GCC.GCC.PDS.XMIT(PDPMAC)')
+ DA('ABC.DEF.PDPCLIB.MACLIB')
+ RECEIVE INDSNAME('ABC.DEF.GCC.GCC.PDS.XMIT(PDPNCAL)')
+ DA('ABC.DEF.PDPCLIB.NCALIB')
+ RECEIVE INDSNAME('ABC.DEF.GCC.GCC.PDS.XMIT(PDPLINK)')
+ DA('ABC.DEF.PDPCLIB.LINKLIB')
+ RECEIVE INDSNAME('ABC.DEF.GCC.GCC.PDS.XMIT(PDPSRC)')
+ DA('ABC.DEF.PDPCLIB.SOURCE')
+ LISTC LEVEL(ABC.DEF.GCC)
+ LISTC LEVEL(ABC.DEF.PDPCLIB)
+ /*
+ //*
+ //
Index: gcc/gcc/xmit7.jcl
diff -c nul gcc/gcc/xmit7.jcl:1.1
*** nul	Tue Oct 01 16:28:49 2019
--- gcc/gcc/xmit7.jcl	Thu Jun 04 19:54:19 2009
***************
*** 0 ****
--- 1,17 ----
+ //GCCGEN   JOB CLASS=C,REGION=0K
+ //*
+ //* Submit the example job
+ //*
+ //SUBEXAMP PROC GCCPREF='GCC'
+ //*
+ //SUBJOB   EXEC PGM=IEBGENER
+ //SYSUT1   DD  DSN=&GCCPREF..JCL(EXAMPLE),DISP=SHR
+ //SYSUT2   DD  SYSOUT=(A,INTRDR)
+ //SYSPRINT DD  SYSOUT=*
+ //SYSIN    DD  DUMMY
+ //*
+ //         PEND
+ //*
+ //S1 EXEC SUBEXAMP
+ //*
+ //
Index: gcc/gcc/xmit8.jcl
diff -c nul gcc/gcc/xmit8.jcl:1.2
*** nul	Tue Oct 01 16:28:49 2019
--- gcc/gcc/xmit8.jcl	Sat May 02 15:38:24 2009
***************
*** 0 ****
--- 1,16 ----
+ //GCCGEN   JOB CLASS=C,REGION=0K
+ //*
+ //* Delete temporary datasets
+ //*
+ //CLEAN    PROC GCCPREF='GCC'
+ //DELETE   EXEC PGM=IEFBR14
+ //DD1      DD DSN=&GCCPREF..GCC.SEQ.XMIT,DISP=(MOD,DELETE),
+ //       UNIT=SYSALLDA,SPACE=(TRK,(0))
+ //DD2      DD DSN=&GCCPREF..GCC.PDS.XMIT,DISP=(MOD,DELETE),
+ //       UNIT=SYSALLDA,SPACE=(TRK,(0))
+ //*
+ //         PEND
+ //*
+ //S1 EXEC CLEAN
+ //*
+ //
Index: gcc/gcc/xmitdoc.txt
diff -c nul gcc/gcc/xmitdoc.txt:1.9
*** nul	Tue Oct 01 16:28:49 2019
--- gcc/gcc/xmitdoc.txt	Sat May 02 17:41:02 2009
***************
*** 0 ****
--- 1,33 ----
+ This PDS contains a stack of XMITed PDSes. They all
+ need to be restored via the RECEIVE command, by
+ running the job XMIT6 (after reading the comments
+ in it) or similar. You probably want to create two 
+ aliases - one for GCC (the compiler proper), and one 
+ for PDPCLIB (the C runtime library) before doing so. 
+ XMIT1 provides an example of that.
+ 
+ After restoration, you may wish to run GCC.JCL(EXAMPLE)
+ to compile an example C program, after the usual site 
+ customizations.
+ 
+ For further information, please see GCC.DOC(GCCMVS)
+ after the restoration.
+ 
+ Note that XMIT2-5 and 7 do not need to be run, and are
+ only for reference purposes, for people who received
+ the XMIT as a zip file on the PC.
+ 
+ You may wish to delete the one or two XMIT files
+ that were created during this process, as they
+ are only useful when trying to transport GCCMVS.
+ XMIT8 is provided for that purpose.
+ 
+ Note that the "GCC" module is a 31-bit version of the 
+ compiler, so if you are running MVS/370 it won't work,
+ and you should instead use "GCC370" which is a 24-bit
+ module. The 31-bit version should work fine as-is on
+ z/OS, OS/390, MVS/XA and MVS/380. Also note that 
+ although the compiler is 31-bit, by default it produces
+ 24-bit modules. If you wish to change this to 31-bit,
+ then after installation read GCC.DOC(GCCMVS) where
+ there are instructions for running STAGE4.
Index: gcc/gcc/xmitgcc.jcl
diff -c nul gcc/gcc/xmitgcc.jcl:1.18
*** nul	Tue Oct 01 16:28:49 2019
--- gcc/gcc/xmitgcc.jcl	Fri Oct 30 00:11:39 2009
***************
*** 0 ****
--- 1,125 ----
+ //GCCGEN   JOB CLASS=C,REGION=0K
+ //*
+ //* GCC libraries are by default named GCC.* and PDPCLIB.*
+ //*
+ //* These are all bundled (via TRANSMIT) up into PDS, which
+ //* has the same (GCC) HLQ, since it's part of the GCC
+ //* product (although not a normal installation library).
+ //* it gets the HLQ repeated in case people wish to organize
+ //* XMITs of different products under their own userid, and 
+ //* still have the original product easily identifiable.
+ //* (Consider a non-sysprog doing the installation).
+ //*
+ //* That PDS is then in turn bundled up into a final XMIT
+ //* sequential file, called GCC.GCC.SEQ.XMIT
+ //*
+ //* Although both of these files are nominally temporary in 
+ //* nature, we give them permanent and semi-meaningful names 
+ //* so that when they are read (via RECEIVE on z/OS), the 
+ //* default name is something sensible and predictable.
+ //*
+ //DOIT     PROC 
+ //*
+ //* STUFF EACH GCC DSN INTO A MEMBER OF A PDS.
+ //*
+ //XMIT370A EXEC PGM=XMIT370
+ //XMITLOG   DD SYSOUT=*
+ //SYSPRINT  DD SYSOUT=*
+ //SYSUT1    DD DSN=&DSNAME,DISP=SHR
+ //SYSUT2    DD DSN=&&SYSUT2,
+ //             UNIT=SYSALLDA,                          
+ //             SPACE=(3120,(30000,30000)),
+ //             DISP=(,DELETE,DELETE)
+ //XMITOUT   DD DSN=GCC.GCC.PDS.XMIT(&MBR),
+ //             DISP=SHR
+ //SYSIN     DD DUMMY
+ //SYSUDUMP  DD SYSOUT=*
+ //         PEND
+ //*
+ //*
+ //*
+ //DELETE   EXEC PGM=IEFBR14
+ //XMITOUT   DD DSN=GCC.GCC.PDS.XMIT,
+ //             DISP=(MOD,DELETE,DELETE),
+ //             SPACE=(TRK,(0)),
+ //             UNIT=SYSALLDA
+ //*
+ //ALLOC    EXEC PGM=IEFBR14
+ //XMITOUT   DD DSN=GCC.GCC.PDS.XMIT,
+ //             DISP=(NEW,CATLG,DELETE),
+ //             DCB=(LRECL=80,BLKSIZE=3120,RECFM=FB,DSORG=PO),
+ //             SPACE=(3120,(30000,30000,44)),
+ //             UNIT=SYSALLDA
+ //*
+ //S1 EXEC PROC=DOIT,MBR=GCCDOC,DSNAME='GCC.DOC'
+ //S2 EXEC PROC=DOIT,MBR=GCCJCL,DSNAME='GCC.JCL'
+ //S3 EXEC PROC=DOIT,MBR=GCCLINK,DSNAME='GCC.LINKLIB'
+ //S4 EXEC PROC=DOIT,MBR=GCCPROC,DSNAME='GCC.PROCLIB'
+ //S5 EXEC PROC=DOIT,MBR=GCCS2,DSNAME='GCC.S2'
+ //S6 EXEC PROC=DOIT,MBR=GCCSRC,DSNAME='GCC.SOURCE'
+ //S7 EXEC PROC=DOIT,MBR=GCCINC,DSNAME='GCC.INCLUDE'
+ //*
+ //S1 EXEC PROC=DOIT,MBR=PDPDOC,DSNAME='PDPCLIB.DOC'
+ //S2 EXEC PROC=DOIT,MBR=PDPINC,DSNAME='PDPCLIB.INCLUDE'
+ //S3 EXEC PROC=DOIT,MBR=PDPMAC,DSNAME='PDPCLIB.MACLIB'
+ //S4 EXEC PROC=DOIT,MBR=PDPNCAL,DSNAME='PDPCLIB.NCALIB'
+ //S5 EXEC PROC=DOIT,MBR=PDPLINK,DSNAME='PDPCLIB.LINKLIB'
+ //S6 EXEC PROC=DOIT,MBR=PDPSRC,DSNAME='PDPCLIB.SOURCE'
+ //*
+ //*
+ //* Now provide some documentation
+ //*
+ //CPYFIL    EXEC PGM=COPYFILE,PARM='dd:in dd:out'
+ //STEPLIB   DD DSN=PDPCLIB.LINKLIB,DISP=SHR
+ //IN        DD DSN=GCC.DOC(XMITDOC),DISP=SHR
+ //OUT       DD DSN=GCC.GCC.PDS.XMIT($$DOC),DISP=SHR
+ //SYSIN     DD DUMMY
+ //SYSPRINT  DD SYSOUT=*
+ //SYSTERM   DD SYSOUT=*
+ //*
+ //*
+ //* And some JCL they will need
+ //*
+ //COPY      EXEC PGM=IEBCOPY
+ //SYSUT1    DD DSN=GCC.JCL,DISP=SHR
+ //SYSUT2    DD DSN=GCC.GCC.PDS.XMIT,DISP=SHR
+ //SYSPRINT  DD SYSOUT=*
+ //SYSIN     DD *
+  COPY OUTDD=SYSUT2
+       INDD=SYSUT1
+  SELECT MEMBER=((XMIT1,,R))
+  SELECT MEMBER=((XMIT2,,R))
+  SELECT MEMBER=((XMIT3,,R))
+  SELECT MEMBER=((XMIT4,,R))
+  SELECT MEMBER=((XMIT5,,R))
+  SELECT MEMBER=((XMIT6,,R))
+  SELECT MEMBER=((XMIT7,,R))
+  SELECT MEMBER=((XMIT8,,R))
+ /*
+ //*
+ //*
+ //* Now create a sequential XMIT of the XMIT PDS.
+ //*
+ //DELETE   EXEC PGM=IEFBR14
+ //XMITOUT   DD DSN=GCC.GCC.SEQ.XMIT,
+ //             DISP=(MOD,DELETE,DELETE),
+ //             SPACE=(TRK,(0)),
+ //             UNIT=SYSALLDA
+ //*
+ //XMIT370B EXEC PGM=XMIT370
+ //XMITLOG   DD SYSOUT=*
+ //SYSPRINT  DD SYSOUT=*
+ //SYSUT1    DD DSN=GCC.GCC.PDS.XMIT,DISP=(SHR,DELETE,DELETE)
+ //SYSUT2    DD DSN=&&SYSUT2,
+ //             UNIT=SYSALLDA,                          
+ //             SPACE=(3120,(30000,30000)),
+ //             DISP=(,DELETE,DELETE)
+ //XMITOUT   DD DSN=GCC.GCC.SEQ.XMIT,
+ //             DISP=(NEW,CATLG,DELETE),
+ //             DCB=(LRECL=80,BLKSIZE=3120,RECFM=FB),
+ //             SPACE=(3120,(30000,30000),RLSE),
+ //             UNIT=SYSALLDA
+ //SYSIN     DD DUMMY
+ //SYSUDUMP  DD SYSOUT=*
+ //*
+ //
Index: gcc/gcc/xmitread.txt
diff -c nul gcc/gcc/xmitread.txt:1.7
*** nul	Tue Oct 01 16:28:49 2019
--- gcc/gcc/xmitread.txt	Mon Sep 30 11:08:45 2019
***************
*** 0 ****
--- 1,56 ----
+ This archive contains GCCMVS in XMIT format.
+ --------------------------------------------
+ 
+ Note that the "GCC" module is a 31-bit version of the
+ compiler which should work fine on z/OS and OS/390,
+ while also working fine as AM24 on MVS/370, and as
+ AM32 on MVS/380. MVS/XA users will need to mark the
+ modules as RM24 because they can only run above the
+ line on late MVS/ESA and above. The output of the
+ compiler is also AM31/RMANY modules which have the
+ same operating characteristics.
+ 
+ More options for obtaining and installing GCCMVS
+ on different platforms can be found at 
+ http://gccmvs.sourceforge.net
+ 
+ 
+ To use this XMIT, you first need to transfer the .xmi 
+ file in binary mode to a FB80 dataset and then run 
+ "receive" in TSO. Transferring data to MVS is beyond 
+ the scope of this document. Some sites use ftp. Some 
+ use ind$file. Some use emulated tape.
+ 
+ Sample jobs have been provided for the "emulated tape"
+ scenario, although some of the jobs are also applicable
+ for other methods.
+ 
+ 
+ 1. You probably want to define aliases for GCC and
+ PDPCLIB, at least if you are a systems programmer.
+ xmit1.jcl has sample JCL to do that. An applications
+ programmer installing datasets under his own userid
+ does not require this.
+ 
+ 2. You need to allocate a dataset to contain the XMIT
+ file. xmit2.jcl will do that.
+ 
+ 3. Now you need to transfer the data from the PC to
+ the mainframe. xmit3.jcl will do that for those
+ using emulated tapes *via the runmvs script* or
+ equivalent (e.g. manually creating TDF tape) on MVS/380.
+ 
+ 4. Now "receive" the dataset, using a job similar
+ to xmit4.jcl.
+ 
+ 
+ Then follow the instructions in $$DOC of the
+ dataset created. This involves submitting another
+ job within the extracted PDS itself, something
+ remotely initiated for MVS/380 users, by using the
+ sample xmit5.jcl.
+ 
+ 
+ A "xmitrecv" Windows batch file is provided that does
+ all these steps for an MVS/380 user with a similar
+ setup. It is provided purely as an example.
Index: gcc/gcc/xmitrecv.bat
diff -c nul gcc/gcc/xmitrecv.bat:1.2
*** nul	Tue Oct 01 16:28:49 2019
--- gcc/gcc/xmitrecv.bat	Mon May 25 19:22:19 2009
***************
*** 0 ****
--- 1,7 ----
+ del alljcl.jcl
+ type xmit1.jcl >>alljcl.jcl
+ type xmit2.jcl >>alljcl.jcl
+ type xmit3.jcl >>alljcl.jcl
+ type xmit4.jcl >>alljcl.jcl
+ type xmit5.jcl >>alljcl.jcl
+ call runmvs alljcl.jcl output.txt gccmvs.xmi
Index: gcc/gcc/xmittape.jcl
diff -c nul gcc/gcc/xmittape.jcl:1.1
*** nul	Tue Oct 01 16:28:49 2019
--- gcc/gcc/xmittape.jcl	Thu Apr 23 22:52:05 2009
***************
*** 0 ****
--- 1,14 ----
+ //GCCGEN   JOB CLASS=C,REGION=0K
+ //*
+ //* Dump the sequential XMIT file to tape
+ //*
+ //TOTAPE   EXEC PGM=IEBGENER
+ //SYSIN    DD DUMMY
+ //SYSPRINT DD SYSOUT=*
+ //SYSUT1   DD DSN=GCC.GCC.SEQ.XMIT,DISP=(OLD,DELETE,DELETE)
+ //SYSUT2   DD DSN=GCC.GCC.SEQ.XMIT,
+ //            DISP=(NEW,KEEP,KEEP),
+ //            DCB=(LRECL=80,BLKSIZE=3120,RECFM=FB),
+ //            UNIT=TAPE,VOL=SER=MFTOPC,LABEL=(1,SL)
+ //*
+ //
Index: gcc/gcc/zipmvs
diff -c nul gcc/gcc/zipmvs:1.3
*** nul	Tue Oct 01 16:28:49 2019
--- gcc/gcc/zipmvs	Sat May 22 19:32:10 2010
***************
*** 0 ****
--- 1,81 ----
+ rm -f gccs.zip
+ rm -f pdpi.zip
+ rm -f gcci.zip
+ rm -f gccsrc.zip
+ rm -f pdpsrc.zip
+ rm -f gccjcl.zip
+ rm -f gccdoc.zip
+ rm -f pdpdoc.zip
+ rm -f gccprc.zip
+ rm -f gccexec.zip
+ rm -f pdpmac.zip
+ rm -f stage0d.jcl
+ rm -f alljcl.jcl
+ rm -f alljcl.txt
+ rm -f mvsendec.s
+ rm -f hexdump.s
+ rm -f dssrenam.s
+ rm -f mvsunzip.s
+ rm -f copyfile.s
+ zip -0 -X gccs.zip *.s
+ mkdir ../temp
+ rm -f ../temp/*.s
+ rm -f ../temp/*.h
+ rm -f ../temp/*.c
+ rm -f ../temp/*.def
+ cd ../../pdos/pdpclib
+ zip -0 -X ../../gcc/gcc/pdpi.zip *.h
+ zip -0 -X ../../gcc/gcc/pdpsrc.zip *.c *.asm
+ zip -0 -X ../../gcc/gcc/pdpdoc.zip *.txt
+ zip -0 -X ../../gcc/gcc/pdpmac.zip *.mac
+ cd ../../gcc/temp
+ cp ../include/*.h .
+ cp ../gcc/*.h .
+ cp ../gcc/config/i370/*.h .
+ cp ../gcc/*.def .
+ mv builtin-attrs.def builtina.h
+ mv builtin-types.def builtint.h
+ mv builtins.def builtind.h
+ mv c-common.def ccommond.h
+ mv diagnostic.def diagndef.h
+ mv machmode.def machmodd.h
+ mv params.def paramsd.h
+ mv predict.def predictd.h
+ mv rtl.def rtld.h
+ mv stab.def stabd.h
+ mv timevar.def timevard.h
+ mv tree.def treed.h
+ mv insn-constants.h i-constants.h
+ mv langhooks-def.h langhdef.h
+ zip -0 -X ../gcc/gcci.zip *.h
+ cp ../libiberty/*.c .
+ cp ../gcc/*.c .
+ cp ../gcc/config/i370/*.c .
+ zip -0 -X ../gcc/gccsrc.zip *.c
+ cd ../gcc
+ zip -0 -X gccjcl.zip *.jcl
+ zip -0 -X gccdoc.zip gccmvs.txt COPYING
+ zip -0 -X -j gccdoc.zip config/i370/i370.md
+ zip -0 -X gccdoc.zip c-parse.in
+ zip -0 -X gccprc.zip *.prc
+ zip -0 -X gccexec.zip *.exec *.parm
+ 
+ # for integrity, on a 31-bit system you should really
+ # delete these source files and allow them to be regenerated instead
+ #zip -d gccsrc.zip genrtl.c
+ #zip -d gccsrc.zip insn-attrtab.c
+ #zip -d gccsrc.zip insn-emit.c
+ #zip -d gccsrc.zip insn-extract.c
+ #zip -d gccsrc.zip insn-opinit.c
+ #zip -d gccsrc.zip insn-output.c
+ #zip -d gccsrc.zip insn-peep.c
+ #zip -d gccsrc.zip insn-recog.c
+ #zip -d gccsrc.zip c-parse.c
+ #zip -d gcci.zip genrtl.h
+ #zip -d gcci.zip insn-attr.h
+ #zip -d gcci.zip insn-codes.h
+ #zip -d gcci.zip insn-config.h
+ #zip -d gcci.zip i-constants.h
+ #zip -d gcci.zip insn-flags.h
+ #zip -d gcci.zip tm-preds.h
+ #zip -d gcci.zip tree-check.h
Index: gcc/gcc/zipmvs.bat
diff -c nul gcc/gcc/zipmvs.bat:1.5
*** nul	Tue Oct 01 16:28:49 2019
--- gcc/gcc/zipmvs.bat	Mon Jan 11 15:23:10 2016
***************
*** 0 ****
--- 1,86 ----
+ del all.zip
+ del autos.zip
+ del gccs.zip
+ del pdpi.zip
+ del gcci.zip
+ del gccsrc.zip
+ del pdpsrc.zip
+ del gccjcl.zip
+ del gccdoc.zip
+ del pdpdoc.zip
+ del gccprc.zip
+ del gccexec.zip
+ del pdpmac.zip
+ del gccmvs-xmit.zip
+ del makeutil.jcl
+ del alljcl.jcl
+ del output.txt
+ del mvsendec.s
+ del hexdump.s
+ del dssrenam.s
+ del mvsunzip.s
+ del copyfile.s
+ del cpyfil.s
+ del vseproc.s
+ del vsemanip.s
+ zip -9 -X -ll gccs.zip *.s
+ mkdir ..\temp
+ del /q ..\temp\*.*
+ cd ..\..\pdos\pdpclib
+ zip -9 -X -ll ..\..\gcc\gcc\pdpi.zip *.h
+ zip -9 -X -ll ..\..\gcc\gcc\pdpsrc.zip *.c *.asm
+ zip -9 -X -ll ..\..\gcc\gcc\pdpdoc.zip *.txt
+ zip -9 -X -ll ..\..\gcc\gcc\pdpmac.zip *.mac
+ cd ..\..\gcc\temp
+ copy ..\include\*.h
+ copy ..\gcc\*.h
+ copy ..\gcc\config\i370\*.h
+ copy ..\gcc\*.def
+ ren builtin-attrs.def builtina.h
+ ren builtin-types.def builtint.h
+ ren builtins.def builtind.h
+ ren c-common.def ccommond.h
+ ren diagnostic.def diagndef.h
+ ren machmode.def machmodd.h
+ ren params.def paramsd.h
+ ren predict.def predictd.h
+ ren rtl.def rtld.h
+ ren stab.def stabd.h
+ ren timevar.def timevard.h
+ ren tree.def treed.h
+ ren insn-constants.h i-constants.h
+ ren langhooks-def.h langhdef.h
+ zip -9 -X -ll ..\gcc\gcci.zip *.h
+ copy ..\libiberty\*.c
+ copy ..\gcc\*.c
+ copy ..\gcc\config\i370\*.c
+ zip -9 -X -ll ..\gcc\gccsrc.zip *.c
+ cd ..\gcc
+ zip -9 -X -ll gccjcl.zip *.jcl
+ zip -9 -X -ll gccdoc.zip gccmvs.txt COPYING gcccms.txt xmitdoc.txt
+ zip -9 -X -ll -j gccdoc.zip config\i370\i370.md
+ zip -9 -X -ll gccdoc.zip c-parse.in
+ zip -9 -X -ll gccprc.zip *.prc
+ zip -9 -X -ll gccexec.zip *.exec *.parm
+ 
+ rem for integrity, on a 31-bit system you should really
+ rem delete these source files and allow them to be regenerated instead
+ rem zip -d gccsrc.zip genrtl.c
+ rem zip -d gccsrc.zip insn-attrtab.c
+ rem zip -d gccsrc.zip insn-emit.c
+ rem zip -d gccsrc.zip insn-extract.c
+ rem zip -d gccsrc.zip insn-opinit.c
+ rem zip -d gccsrc.zip insn-output.c
+ rem zip -d gccsrc.zip insn-peep.c
+ rem zip -d gccsrc.zip insn-recog.c
+ rem zip -d gccsrc.zip c-parse.c
+ rem zip -d gcci.zip genrtl.h
+ rem zip -d gcci.zip insn-attr.h
+ rem zip -d gcci.zip insn-codes.h
+ rem zip -d gcci.zip insn-config.h
+ rem zip -d gcci.zip i-constants.h
+ rem zip -d gcci.zip insn-flags.h
+ rem zip -d gcci.zip tm-preds.h
+ rem zip -d gcci.zip tree-check.h
+ 
+ zip -9 -X all *.zip
Index: gcc/gcc/zippdos.bat
diff -c nul gcc/gcc/zippdos.bat:1.9
*** nul	Tue Oct 01 16:28:49 2019
--- gcc/gcc/zippdos.bat	Mon Jan 11 16:37:41 2016
***************
*** 0 ****
--- 1,74 ----
+ del all.zip
+ del autos.zip
+ del gccs.zip
+ del pdpi.zip
+ del gcci.zip
+ del gccsrc.zip
+ del pdpsrc.zip
+ del gccjcl.zip
+ del gccdoc.zip
+ del pdpdoc.zip
+ del gccprc.zip
+ del gccexec.zip
+ del pdpmac.zip
+ del gccmvs-xmit.zip
+ del makeutil.jcl
+ del alljcl.jcl
+ del output.txt
+ del mvsendec.s
+ del hexdump.s
+ del dssrenam.s
+ del mvsunzip.s
+ del copyfile.s
+ del cpyfil.s
+ del vseproc.s
+ del vsemanip.s
+ zip -9 -X -ll gccs.zip *.s
+ cd ..\..\pdos\pdpclib
+ zip -9 -X -ll ..\..\gcc\gcc\pdpi.zip *.h
+ zip -9 -X -ll ..\..\gcc\gcc\pdpsrc.zip *.c *.asm
+ zip -9 -X -ll ..\..\gcc\gcc\pdpdoc.zip *.txt
+ zip -9 -X -ll ..\..\gcc\gcc\pdpmac.zip *.mac
+ cd ..\..\gcc\gcc
+ zip -9 -X -ll -j gcci.zip *.h ..\include\*.h config\i370\*.h *.def
+ zip -9 -X -ll -j gccsrc.zip *.c ..\libiberty\*.c config\i370\*.c
+ zip -9 -X -ll gccjcl.zip *.jcl
+ zip -9 -X -ll gccdoc.zip gccmvs.txt COPYING gcccms.txt xmitdoc.txt
+ zip -9 -X -ll -j gccdoc.zip config\i370\i370.md
+ zip -9 -X -ll gccdoc.zip c-parse.in
+ zip -9 -X -ll gccprc.zip *.prc
+ zip -9 -X -ll gccexec.zip *.exec *.parm comppdos.bat
+ 
+ rem for integrity, on a 31-bit system you should really
+ rem delete these source files and allow them to be regenerated instead
+ rem zip -d gccsrc.zip genrtl.c
+ rem zip -d gccsrc.zip insn-attrtab.c
+ rem zip -d gccsrc.zip insn-emit.c
+ rem zip -d gccsrc.zip insn-extract.c
+ rem zip -d gccsrc.zip insn-opinit.c
+ rem zip -d gccsrc.zip insn-output.c
+ rem zip -d gccsrc.zip insn-peep.c
+ rem zip -d gccsrc.zip insn-recog.c
+ rem zip -d gccsrc.zip c-parse.c
+ rem zip -d gcci.zip genrtl.h
+ rem zip -d gcci.zip insn-attr.h
+ rem zip -d gcci.zip insn-codes.h
+ rem zip -d gcci.zip insn-config.h
+ rem zip -d gcci.zip i-constants.h
+ rem zip -d gcci.zip insn-flags.h
+ rem zip -d gcci.zip tm-preds.h
+ rem zip -d gcci.zip tree-check.h
+ 
+ zip -9 -X all *.zip
+ 
+ rem for now, we need to use mvsunzip
+ mkdir ..\temp
+ del /q ..\temp\*.*
+ cd ..\temp
+ unzip ..\gcc\all
+ unzip *.zip
+ del *.zip
+ ren *.s *.s1
+ del ..\gcc\all.zip
+ zip -0mX ..\gcc\all *
+ cd ..\gcc
Index: gcc/gcc/zipvse.bat
diff -c nul gcc/gcc/zipvse.bat:1.4
*** nul	Tue Oct 01 16:28:49 2019
--- gcc/gcc/zipvse.bat	Mon Dec 20 09:25:48 2010
***************
*** 0 ****
--- 1,16 ----
+ del all.zip
+ 
+ del pdpi.zip
+ del pdpsrc.zip
+ del pdpdoc.zip
+ del pdpmac.zip
+ cd ..\..\pdos\pdpclib
+ rem don't compress these libraries, because VSE doesn't
+ rem have a port of minizip yet
+ zip -0 -X -ll ..\..\gcc\gcc\pdpi.zip *.h
+ zip -0 -X -ll ..\..\gcc\gcc\pdpsrc.zip *.c *.asm
+ zip -0 -X -ll ..\..\gcc\gcc\pdpdoc.zip *.txt
+ zip -0 -X -ll ..\..\gcc\gcc\pdpmac.zip *.mac
+ cd ..\..\gcc\gcc
+ 
+ zip -0 -X all pdp*.zip
Index: gcc/gcc/config/i370/cms.h
diff -c nul gcc/gcc/config/i370/cms.h:1.4
*** nul	Tue Oct 01 16:28:49 2019
--- gcc/gcc/config/i370/cms.h	Sat Oct 15 17:41:46 2016
***************
*** 0 ****
--- 1,51 ----
+ /* Definitions of target machine for GNU compiler.  System/370 version.
+    Copyright (C) 1989, 1993, 1995, 1996, 1997 Free Software Foundation, Inc.
+    Contributed by Jan Stein (jan@cd.chalmers.se).
+    Modified for CMS by Paul Edwards.
+ 
+ This file is part of GNU CC.
+ 
+ GNU CC is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2, or (at your option)
+ any later version.
+ 
+ GNU CC is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+ 
+ You should have received a copy of the GNU General Public License
+ along with GNU CC; see the file COPYING.  If not, write to
+ the Free Software Foundation, 59 Temple Place - Suite 330,
+ Boston, MA 02111-1307, USA.  */
+ 
+ #define TARGET_VERSION fprintf (stderr, " (370/CMS)");
+ 
+ /* Specify that we're generating code for MVS.  */
+ 
+ #define TARGET_MVS 1
+ #define TARGET_HLASM 1
+ #define TARGET_EBCDIC 1
+ 
+ /* Specify that we're using the GCC macros */
+ 
+ #define TARGET_PDPMAC 1
+ #define STARTFILE_SPEC ""
+ 
+ /* Specify that we're using macro prolog/epilog.  */
+ 
+ #define TARGET_MACROS 1
+ 
+ /* Options for the preprocessor for this target machine.  */
+ 
+ #define CPP_SPEC "-trigraphs"
+ 
+ /* Names to predefine in the preprocessor for this target machine.  */
+ 
+ #define CPP_PREDEFINES "-D__GCC__ -D__CMS__ -Asystem=mvs -Acpu=i370 -Amachine=i370"
+ 
+ 
+ #ifdef PUREISO
+ #include "pureiso.h"
+ #endif
Index: gcc/gcc/config/i370/doconly.bat
diff -c nul gcc/gcc/config/i370/doconly.bat:1.1
*** nul	Tue Oct 01 16:28:49 2019
--- gcc/gcc/config/i370/doconly.bat	Sat Apr 01 02:30:50 2017
***************
*** 0 ****
--- 1,455 ----
+ del resconly.txt
+ 
+ call oneconly 20000105-1.c
+ call oneconly 20000105-2.c
+ call oneconly 20000120-1.c
+ call oneconly 20000120-2.c
+ call oneconly 20000127-1.c
+ call oneconly 20000211-1.c
+ call oneconly 20000211-3.c
+ call oneconly 20000224-1.c
+ call oneconly 20000314-1.c
+ call oneconly 20000314-2.c
+ call oneconly 20000319-1.c
+ call oneconly 20000326-1.c
+ call oneconly 20000326-2.c
+ call oneconly 20000329-1.c
+ call oneconly 20000403-1.c
+ call oneconly 20000403-2.c
+ call oneconly 20000405-1.c
+ call oneconly 20000405-2.c
+ call oneconly 20000405-3.c
+ call oneconly 20000412-1.c
+ call oneconly 20000412-2.c
+ call oneconly 20000420-1.c
+ call oneconly 20000420-2.c
+ call oneconly 20000427-1.c
+ call oneconly 20000502-1.c
+ call oneconly 20000504-1.c
+ call oneconly 20000511-1.c
+ call oneconly 20000517-1.c
+ call oneconly 20000518-1.c
+ call oneconly 20000523-1.c
+ call oneconly 20000605-1.c
+ call oneconly 20000606-1.c
+ call oneconly 20000609-1.c
+ call oneconly 20000629-1.c
+ call oneconly 20000701-1.c
+ call oneconly 20000717-1.c
+ call oneconly 20000718.c
+ call oneconly 20000728-1.c
+ call oneconly 20000802-1.c
+ call oneconly 20000803-1.c
+ call oneconly 20000804-1.c
+ call oneconly 20000818-1.c
+ call oneconly 20000825-1.c
+ call oneconly 20000827-1.c
+ call oneconly 20000922-1.c
+ call oneconly 20000923-1.c
+ call oneconly 20001018-1.c
+ call oneconly 20001024-1.c
+ call oneconly 20001109-1.c
+ call oneconly 20001109-2.c
+ call oneconly 20001116-1.c
+ call oneconly 20001121-1.c
+ call oneconly 20001123-1.c
+ call oneconly 20001123-2.c
+ call oneconly 20001205-1.c
+ call oneconly 20001212-1.c
+ call oneconly 20001221-1.c
+ call oneconly 20001222-1.c
+ call oneconly 20001226-1.c
+ call oneconly 20010102-1.c
+ call oneconly 20010107-1.c
+ call oneconly 20010112-1.c
+ call oneconly 20010113-1.c
+ call oneconly 20010114-1.c
+ call oneconly 20010114-2.c
+ call oneconly 20010117-1.c
+ call oneconly 20010117-2.c
+ call oneconly 20010118-1.c
+ call oneconly 20010124-1.c
+ call oneconly 20010202-1.c
+ call oneconly 20010209-1.c
+ call oneconly 20010226-1.c
+ call oneconly 20010227-1.c
+ call oneconly 20010313-1.c
+ call oneconly 20010320-1.c
+ call oneconly 20010326-1.c
+ call oneconly 20010327-1.c
+ call oneconly 20010328-1.c
+ call oneconly 20010329-1.c
+ call oneconly 20010404-1.c
+ call oneconly 20010408-1.c
+ call oneconly 20010421-1.c
+ call oneconly 20010423-1.c
+ call oneconly 20010426-1.c
+ call oneconly 20010503-1.c
+ call oneconly 20010510-1.c
+ call oneconly 20010516-1.c
+ call oneconly 20010518-1.c
+ call oneconly 20010518-2.c
+ call oneconly 20010525-1.c
+ call oneconly 20010605-1.c
+ call oneconly 20010605-2.c
+ call oneconly 20010605-3.c
+ call oneconly 20010610-1.c
+ call oneconly 20010611-1.c
+ call oneconly 20010701-1.c
+ call oneconly 20010706-1.c
+ call oneconly 20010711-1.c
+ call oneconly 20010711-2.c
+ call oneconly 20010714-1.c
+ call oneconly 20010824-1.c
+ call oneconly 20010903-1.c
+ call oneconly 20010903-2.c
+ call oneconly 20010911-1.c
+ call oneconly 20011010-1.c
+ call oneconly 20011023-1.c
+ call oneconly 20011029-1.c
+ call oneconly 20011106-1.c
+ call oneconly 20011106-2.c
+ call oneconly 20011109-1.c
+ call oneconly 20011114-1.c
+ call oneconly 20011114-2.c
+ call oneconly 20011114-3.c
+ call oneconly 20011114-4.c
+ call oneconly 20011119-1.c
+ call oneconly 20011119-2.c
+ call oneconly 20011130-1.c
+ call oneconly 20011130-2.c
+ call oneconly 20011205-1.c
+ call oneconly 20011217-1.c
+ call oneconly 20011217-2.c
+ call oneconly 20011218-1.c
+ call oneconly 20011219-1.c
+ call oneconly 20011219-2.c
+ call oneconly 20011229-1.c
+ call oneconly 20011229-2.c
+ call oneconly 20020103-1.c
+ call oneconly 20020106-1.c
+ call oneconly 20020109-1.c
+ call oneconly 20020109-2.c
+ call oneconly 20020110.c
+ call oneconly 20020116-1.c
+ call oneconly 20020120-1.c
+ call oneconly 20020121-1.c
+ call oneconly 20020206-1.c
+ call oneconly 20020210-1.c
+ call oneconly 20020304-1.c
+ call oneconly 20020304-2.c
+ call oneconly 20020309-1.c
+ call oneconly 20020309-2.c
+ call oneconly 20020312-1.c
+ call oneconly 20020315-1.c
+ call oneconly 20020318-1.c
+ call oneconly 20020320-1.c
+ call oneconly 20020323-1.c
+ call oneconly 20020330-1.c
+ call oneconly 20020409-1.c
+ call oneconly 20020418-1.c
+ call oneconly 20020530-1.c
+ call oneconly 20020605-1.c
+ call oneconly 20020701-1.c
+ call oneconly 20020710-1.c
+ call oneconly 20020715-1.c
+ call oneconly 20020926-1.c
+ call oneconly 20020927-1.c
+ call oneconly 20021007-1.c
+ call oneconly 20021015-1.c
+ call oneconly 20021015-2.c
+ call oneconly 20021123-1.c
+ call oneconly 20021123-2.c
+ call oneconly 20021123-3.c
+ call oneconly 20021123-4.c
+ call oneconly 20021124-1.c
+ call oneconly 20021204-1.c
+ call oneconly 20021205-1.c
+ call oneconly 20021212-1.c
+ call oneconly 20030110-1.c
+ call oneconly 20030206-1.c
+ call oneconly 20030220-1.c
+ call oneconly 20030305-1.c
+ call oneconly 20030314-1.c
+ call oneconly 900116-1.c
+ call oneconly 900216-1.c
+ call oneconly 900313-1.c
+ call oneconly 900407-1.c
+ call oneconly 900516-1.c
+ call oneconly 920301-1.c
+ call oneconly 920409-1.c
+ call oneconly 920409-2.c
+ call oneconly 920410-1.c
+ call oneconly 920410-2.c
+ call oneconly 920411-2.c
+ call oneconly 920413-1.c
+ call oneconly 920415-1.c
+ call oneconly 920428-1.c
+ call oneconly 920428-2.c
+ call oneconly 920428-3.c
+ call oneconly 920428-4.c
+ call oneconly 920428-5.c
+ call oneconly 920428-6.c
+ call oneconly 920428-7.c
+ call oneconly 920501-1.c
+ call oneconly 920501-10.c
+ call oneconly 920501-11.c
+ call oneconly 920501-12.c
+ call oneconly 920501-13.c
+ call oneconly 920501-15.c
+ call oneconly 920501-16.c
+ call oneconly 920501-17.c
+ call oneconly 920501-18.c
+ call oneconly 920501-19.c
+ call oneconly 920501-2.c
+ call oneconly 920501-20.c
+ call oneconly 920501-21.c
+ call oneconly 920501-22.c
+ call oneconly 920501-23.c
+ call oneconly 920501-3.c
+ call oneconly 920501-4.c
+ call oneconly 920501-6.c
+ call oneconly 920501-7.c
+ call oneconly 920501-8.c
+ call oneconly 920501-9.c
+ call oneconly 920502-1.c
+ call oneconly 920502-2.c
+ call oneconly 920520-1.c
+ call oneconly 920521-1.c
+ call oneconly 920529-1.c
+ call oneconly 920608-1.c
+ call oneconly 920611-2.c
+ call oneconly 920615-1.c
+ call oneconly 920617-1.c
+ call oneconly 920617-2.c
+ call oneconly 920623-1.c
+ call oneconly 920624-1.c
+ call oneconly 920625-1.c
+ call oneconly 920625-2.c
+ call oneconly 920626-1.c
+ call oneconly 920701-1.c
+ call oneconly 920702-1.c
+ call oneconly 920706-1.c
+ call oneconly 920710-2.c
+ call oneconly 920711-1.c
+ call oneconly 920721-1.c
+ call oneconly 920723-1.c
+ call oneconly 920729-1.c
+ call oneconly 920806-1.c
+ call oneconly 920808-1.c
+ call oneconly 920809-1.c
+ call oneconly 920817-1.c
+ call oneconly 920820-1.c
+ call oneconly 920821-1.c
+ call oneconly 920821-2.c
+ call oneconly 920825-1.c
+ call oneconly 920825-2.c
+ call oneconly 920826-1.c
+ call oneconly 920828-1.c
+ call oneconly 920829-1.c
+ call oneconly 920831-1.c
+ call oneconly 920902-1.c
+ call oneconly 920909-1.c
+ call oneconly 920917-1.c
+ call oneconly 920928-1.c
+ call oneconly 920928-2.c
+ call oneconly 920928-3.c
+ call oneconly 920928-4.c
+ call oneconly 920928-5.c
+ call oneconly 920928-6.c
+ call oneconly 921004-1.c
+ call oneconly 921011-1.c
+ call oneconly 921011-2.c
+ call oneconly 921012-1.c
+ call oneconly 921012-2.c
+ call oneconly 921013-1.c
+ call oneconly 921019-1.c
+ call oneconly 921021-1.c
+ call oneconly 921024-1.c
+ call oneconly 921026-1.c
+ call oneconly 921103-1.c
+ call oneconly 921109-1.c
+ call oneconly 921111-1.c
+ call oneconly 921116-2.c
+ call oneconly 921118-1.c
+ call oneconly 921126-1.c
+ call oneconly 921202-1.c
+ call oneconly 921202-2.c
+ call oneconly 921203-1.c
+ call oneconly 921203-2.c
+ call oneconly 921206-1.c
+ call oneconly 921227-1.c
+ call oneconly 930109-1.c
+ call oneconly 930109-2.c
+ call oneconly 930111-1.c
+ call oneconly 930117-1.c
+ call oneconly 930118-1.c
+ call oneconly 930120-1.c
+ call oneconly 930126-1.c
+ call oneconly 930210-1.c
+ call oneconly 930217-1.c
+ call oneconly 930222-1.c
+ call oneconly 930325-1.c
+ call oneconly 930326-1.c
+ call oneconly 930411-1.c
+ call oneconly 930421-1.c
+ call oneconly 930427-2.c
+ call oneconly 930503-1.c
+ call oneconly 930503-2.c
+ call oneconly 930506-1.c
+ call oneconly 930506-2.c
+ call oneconly 930510-1.c
+ call oneconly 930513-1.c
+ call oneconly 930513-2.c
+ call oneconly 930513-3.c
+ call oneconly 930523-1.c
+ call oneconly 930525-1.c
+ call oneconly 930527-1.c
+ call oneconly 930529-1.c
+ call oneconly 930530-1.c
+ call oneconly 930602-1.c
+ call oneconly 930603-1.c
+ call oneconly 930607-1.c
+ call oneconly 930611-1.c
+ call oneconly 930618-1.c
+ call oneconly 930621-1.c
+ call oneconly 930623-1.c
+ call oneconly 930702-1.c
+ call oneconly 930926-1.c
+ call oneconly 930927-1.c
+ call oneconly 931003-1.c
+ call oneconly 931004-1.c
+ call oneconly 931013-1.c
+ call oneconly 931013-2.c
+ call oneconly 931013-3.c
+ call oneconly 931018-1.c
+ call oneconly 931031-1.c
+ call oneconly 931102-1.c
+ call oneconly 931102-2.c
+ call oneconly 931203-1.c
+ call oneconly 940611-1.c
+ call oneconly 940712-1.c
+ call oneconly 940718-1.c
+ call oneconly 941014-1.c
+ call oneconly 941014-2.c
+ call oneconly 941014-3.c
+ call oneconly 941014-4.c
+ call oneconly 941019-1.c
+ call oneconly 941111-1.c
+ call oneconly 941113-1.c
+ call oneconly 950122-1.c
+ call oneconly 950124-1.c
+ call oneconly 950221-1.c
+ call oneconly 950329-1.c
+ call oneconly 950512-1.c
+ call oneconly 950530-1.c
+ call oneconly 950607-1.c
+ call oneconly 950610-1.c
+ call oneconly 950612-1.c
+ call oneconly 950613-1.c
+ call oneconly 950618-1.c
+ call oneconly 950719-1.c
+ call oneconly 950729-1.c
+ call oneconly 950816-1.c
+ call oneconly 950816-2.c
+ call oneconly 950816-3.c
+ call oneconly 950910-1.c
+ call oneconly 950919-1.c
+ call oneconly 950921-1.c
+ call oneconly 950922-1.c
+ call oneconly 951004-1.c
+ call oneconly 951106-1.c
+ call oneconly 951116-1.c
+ call oneconly 951128-1.c
+ call oneconly 951220-1.c
+ call oneconly 951222-1.c
+ call oneconly 960106-1.c
+ call oneconly 960130-1.c
+ call oneconly 960201-1.c
+ call oneconly 960218-1.c
+ call oneconly 960220-1.c
+ call oneconly 960221-1.c
+ call oneconly 960319-1.c
+ call oneconly 960514-1.c
+ call oneconly 960704-1.c
+ call oneconly 960829-1.c
+ call oneconly 961004-1.c
+ call oneconly 961010-1.c
+ call oneconly 961019-1.c
+ call oneconly 961031-1.c
+ call oneconly 961126-1.c
+ call oneconly 961203-1.c
+ call oneconly 970206-1.c
+ call oneconly 970214-1.c
+ call oneconly 980329-1.c
+ call oneconly 980408-1.c
+ call oneconly 980504-1.c
+ call oneconly 980506-1.c
+ call oneconly 980506-2.c
+ call oneconly 980511-1.c
+ call oneconly 980701-1.c
+ call oneconly 980706-1.c
+ call oneconly 980726-1.c
+ call oneconly 980729-1.c
+ call oneconly 980816-1.c
+ call oneconly 980821-1.c
+ call oneconly 980825-1.c
+ call oneconly 981001-1.c
+ call oneconly 981001-2.c
+ call oneconly 981001-3.c
+ call oneconly 981001-4.c
+ call oneconly 981006-1.c
+ call oneconly 981007-1.c
+ call oneconly 981022-1.c
+ call oneconly 981107-1.c
+ call oneconly 981223-1.c
+ call oneconly 990107-1.c
+ call oneconly 990117-1.c
+ call oneconly 990203-1.c
+ call oneconly 990517-1.c
+ call oneconly 990519-1.c
+ call oneconly 990523-1.c
+ call oneconly 990527-1.c
+ call oneconly 990617-1.c
+ call oneconly 990625-1.c
+ call oneconly 990625-2.c
+ call oneconly 990801-1.c
+ call oneconly 990801-2.c
+ call oneconly 990829-1.c
+ call oneconly 990913-1.c
+ call oneconly 990928-1.c
+ call oneconly 991008-1.c
+ call oneconly 991026-1.c
+ call oneconly 991026-2.c
+ call oneconly 991127-1.c
+ call oneconly 991202-1.c
+ call oneconly 991208-1.c
+ call oneconly 991213-1.c
+ call oneconly 991213-2.c
+ call oneconly 991213-3.c
+ call oneconly 991214-1.c
+ call oneconly 991214-2.c
+ call oneconly 991229-1.c
+ call oneconly 991229-2.c
+ call oneconly 991229-3.c
+ call oneconly calls.c
+ call oneconly cmpdi-1.c
+ call oneconly combine-hang.c
+ call oneconly cpp-1.c
+ call oneconly cpp-2.c
+ call oneconly dll.c
+ call oneconly funcptr-1.c
+ call oneconly goto-1.c
+ call oneconly iftrap-1.c
+ call oneconly iftrap-2.c
+ call oneconly init-1.c
+ call oneconly init-2.c
+ call oneconly init-3.c
+ call oneconly labels-1.c
+ call oneconly labels-2.c
+ call oneconly labels-3.c
+ call oneconly packed-1.c
+ call oneconly structs.c
+ call oneconly trunctfdf.c
+ call oneconly widechar-1.c
+ call oneconly zero-strct-1.c
Index: gcc/gcc/config/i370/dotests.bat
diff -c nul gcc/gcc/config/i370/dotests.bat:1.1
*** nul	Tue Oct 01 16:28:49 2019
--- gcc/gcc/config/i370/dotests.bat	Fri Mar 31 19:51:35 2017
***************
*** 0 ****
--- 1,635 ----
+ del results.txt
+ 
+ call onecomp 20000112-1.c
+ call onecomp 20000113-1.c
+ call onecomp 20000121-1.c
+ call onecomp 20000205-1.c
+ call onecomp 20000217-1.c
+ call onecomp 20000223-1.c
+ call onecomp 20000224-1.c
+ call onecomp 20000225-1.c
+ call onecomp 20000227-1.c
+ call onecomp 20000313-1.c
+ call onecomp 20000314-1.c
+ call onecomp 20000314-2.c
+ call onecomp 20000314-3.c
+ call onecomp 20000402-1.c
+ call onecomp 20000403-1.c
+ call onecomp 20000412-1.c
+ call onecomp 20000412-2.c
+ call onecomp 20000412-3.c
+ call onecomp 20000412-4.c
+ call onecomp 20000412-5.c
+ call onecomp 20000412-6.c
+ call onecomp 20000419-1.c
+ call onecomp 20000422-1.c
+ call onecomp 20000503-1.c
+ call onecomp 20000511-1.c
+ call onecomp 20000519-1.c
+ call onecomp 20000519-2.c
+ call onecomp 20000523-1.c
+ call onecomp 20000528-1.c
+ call onecomp 20000603-1.c
+ call onecomp 20000605-1.c
+ call onecomp 20000605-2.c
+ call onecomp 20000605-3.c
+ call onecomp 20000622-1.c
+ call onecomp 20000703-1.c
+ call onecomp 20000706-1.c
+ call onecomp 20000706-2.c
+ call onecomp 20000706-3.c
+ call onecomp 20000706-4.c
+ call onecomp 20000706-5.c
+ call onecomp 20000707-1.c
+ call onecomp 20000715-1.c
+ call onecomp 20000715-2.c
+ call onecomp 20000717-1.c
+ call onecomp 20000717-2.c
+ call onecomp 20000717-3.c
+ call onecomp 20000717-4.c
+ call onecomp 20000717-5.c
+ call onecomp 20000722-1.c
+ call onecomp 20000726-1.c
+ call onecomp 20000731-1.c
+ call onecomp 20000731-2.c
+ call onecomp 20000801-1.c
+ call onecomp 20000801-2.c
+ call onecomp 20000801-3.c
+ call onecomp 20000801-4.c
+ call onecomp 20000808-1.c
+ call onecomp 20000815-1.c
+ call onecomp 20000818-1.c
+ call onecomp 20000819-1.c
+ call onecomp 20000822-1.c
+ call onecomp 20000910-1.c
+ call onecomp 20000910-2.c
+ call onecomp 20000914-1.c
+ call onecomp 20000917-1.c
+ call onecomp 20001009-1.c
+ call onecomp 20001009-2.c
+ call onecomp 20001011-1.c
+ call onecomp 20001013-1.c
+ call onecomp 20001017-1.c
+ call onecomp 20001017-2.c
+ call onecomp 20001024-1.c
+ call onecomp 20001026-1.c
+ call onecomp 20001027-1.c
+ call onecomp 20001031-1.c
+ call onecomp 20001101.c
+ call onecomp 20001108-1.c
+ call onecomp 20001111-1.c
+ call onecomp 20001112-1.c
+ call onecomp 20001121-1.c
+ call onecomp 20001124-1.c
+ call onecomp 20001130-1.c
+ call onecomp 20001130-2.c
+ call onecomp 20001203-1.c
+ call onecomp 20001203-2.c
+ call onecomp 20001221-1.c
+ call onecomp 20001228-1.c
+ call onecomp 20001229-1.c
+ call onecomp 20010106-1.c
+ call onecomp 20010114-1.c
+ call onecomp 20010116-1.c
+ call onecomp 20010118-1.c
+ call onecomp 20010119-1.c
+ call onecomp 20010122-1.c
+ call onecomp 20010123-1.c
+ call onecomp 20010124-1.c
+ call onecomp 20010129-1.c
+ call onecomp 20010206-1.c
+ call onecomp 20010209-1.c
+ call onecomp 20010221-1.c
+ call onecomp 20010222-1.c
+ call onecomp 20010224-1.c
+ call onecomp 20010325-1.c
+ call onecomp 20010329-1.c
+ call onecomp 20010403-1.c
+ call onecomp 20010409-1.c
+ call onecomp 20010422-1.c
+ call onecomp 20010518-1.c
+ call onecomp 20010518-2.c
+ call onecomp 20010520-1.c
+ call onecomp 20010604-1.c
+ call onecomp 20010605-1.c
+ call onecomp 20010605-2.c
+ call onecomp 20010711-1.c
+ call onecomp 20010717-1.c
+ call onecomp 20010723-1.c
+ call onecomp 20010724-1.c
+ call onecomp 20010904-1.c
+ call onecomp 20010904-2.c
+ call onecomp 20010910-1.c
+ call onecomp 20010915-1.c
+ call onecomp 20010924-1.c
+ call onecomp 20010925-1.c
+ call onecomp 20011008-3.c
+ call onecomp 20011019-1.c
+ call onecomp 20011024-1.c
+ call onecomp 20011109-1.c
+ call onecomp 20011109-2.c
+ call onecomp 20011113-1.c
+ call onecomp 20011114-1.c
+ call onecomp 20011115-1.c
+ call onecomp 20011121-1.c
+ call onecomp 20011126-1.c
+ call onecomp 20011126-2.c
+ call onecomp 20011128-1.c
+ call onecomp 20011217-1.c
+ call onecomp 20011219-1.c
+ call onecomp 20011223-1.c
+ call onecomp 20020103-1.c
+ call onecomp 20020107-1.c
+ call onecomp 20020108-1.c
+ call onecomp 20020118-1.c
+ call onecomp 20020127-1.c
+ call onecomp 20020129-1.c
+ call onecomp 20020201-1.c
+ call onecomp 20020206-1.c
+ call onecomp 20020206-2.c
+ call onecomp 20020213-1.c
+ call onecomp 20020215-1.c
+ call onecomp 20020216-1.c
+ call onecomp 20020219-1.c
+ call onecomp 20020225-1.c
+ call onecomp 20020227-1.c
+ call onecomp 20020307-1.c
+ call onecomp 20020307-2.c
+ call onecomp 20020314-1.c
+ call onecomp 20020320-1.c
+ call onecomp 20020321-1.c
+ call onecomp 20020402-1.c
+ call onecomp 20020402-2.c
+ call onecomp 20020402-3.c
+ call onecomp 20020404-1.c
+ call onecomp 20020406-1.c
+ call onecomp 20020411-1.c
+ call onecomp 20020413-1.c
+ call onecomp 20020418-1.c
+ call onecomp 20020423-1.c
+ call onecomp 20020503-1.c
+ call onecomp 20020529-1.c
+ call onecomp 20020611-1.c
+ call onecomp 20020614-1.c
+ call onecomp 20020615-1.c
+ call onecomp 20020619-1.c
+ call onecomp 20020716-1.c
+ call onecomp 20020805-1.c
+ call onecomp 20020904-1.c
+ call onecomp 20021015-1.c
+ call onecomp 20021024-1.c
+ call onecomp 20021111-1.c
+ call onecomp 20021118-3.c
+ call onecomp 20021219-1.c
+ call onecomp 20030109-1.c
+ call onecomp 20030221-1.c
+ call onecomp 20030224-2.c
+ call onecomp 20030307-1.c
+ call onecomp 20030313-1.c
+ call onecomp 20030316-1.c
+ call onecomp 900409-1.c
+ call onecomp 920202-1.c
+ call onecomp 920302-1.c
+ call onecomp 920409-1.c
+ call onecomp 920410-1.c
+ call onecomp 920411-1.c
+ call onecomp 920415-1.c
+ call onecomp 920428-1.c
+ call onecomp 920428-2.c
+ call onecomp 920429-1.c
+ call onecomp 920501-1.c
+ call onecomp 920501-2.c
+ call onecomp 920501-3.c
+ call onecomp 920501-4.c
+ call onecomp 920501-5.c
+ call onecomp 920501-6.c
+ call onecomp 920501-7.c
+ call onecomp 920501-8.c
+ call onecomp 920501-9.c
+ call onecomp 920506-1.c
+ call onecomp 920520-1.c
+ call onecomp 920603-1.c
+ call onecomp 920604-1.c
+ call onecomp 920612-1.c
+ call onecomp 920612-2.c
+ call onecomp 920618-1.c
+ call onecomp 920625-1.c
+ call onecomp 920710-1.c
+ call onecomp 920711-1.c
+ call onecomp 920721-1.c
+ call onecomp 920721-2.c
+ call onecomp 920721-3.c
+ call onecomp 920721-4.c
+ call onecomp 920726-1.c
+ call onecomp 920728-1.c
+ call onecomp 920730-1.c
+ call onecomp 920730-1t.c
+ call onecomp 920731-1.c
+ call onecomp 920810-1.c
+ call onecomp 920812-1.c
+ call onecomp 920829-1.c
+ call onecomp 920908-1.c
+ call onecomp 920908-2.c
+ call onecomp 920909-1.c
+ call onecomp 920922-1.c
+ call onecomp 920929-1.c
+ call onecomp 921006-1.c
+ call onecomp 921007-1.c
+ call onecomp 921013-1.c
+ call onecomp 921016-1.c
+ call onecomp 921017-1.c
+ call onecomp 921019-1.c
+ call onecomp 921019-2.c
+ call onecomp 921029-1.c
+ call onecomp 921104-1.c
+ call onecomp 921110-1.c
+ call onecomp 921112-1.c
+ call onecomp 921113-1.c
+ call onecomp 921117-1.c
+ call onecomp 921123-1.c
+ call onecomp 921123-2.c
+ call onecomp 921124-1.c
+ call onecomp 921202-1.c
+ call onecomp 921202-2.c
+ call onecomp 921204-1.c
+ call onecomp 921207-1.c
+ call onecomp 921208-1.c
+ call onecomp 921208-2.c
+ call onecomp 921215-1.c
+ call onecomp 921218-1.c
+ call onecomp 921218-2.c
+ call onecomp 930106-1.c
+ call onecomp 930111-1.c
+ call onecomp 930123-1.c
+ call onecomp 930126-1.c
+ call onecomp 930208-1.c
+ call onecomp 930406-1.c
+ call onecomp 930408-1.c
+ call onecomp 930429-1.c
+ call onecomp 930429-2.c
+ call onecomp 930513-1.c
+ call onecomp 930513-2.c
+ call onecomp 930518-1.c
+ call onecomp 930526-1.c
+ call onecomp 930527-1.c
+ call onecomp 930529-1.c
+ call onecomp 930603-1.c
+ call onecomp 930603-2.c
+ call onecomp 930603-3.c
+ call onecomp 930608-1.c
+ call onecomp 930614-1.c
+ call onecomp 930614-2.c
+ call onecomp 930621-1.c
+ call onecomp 930622-1.c
+ call onecomp 930622-2.c
+ call onecomp 930628-1.c
+ call onecomp 930630-1.c
+ call onecomp 930702-1.c
+ call onecomp 930713-1.c
+ call onecomp 930718-1.c
+ call onecomp 930719-1.c
+ call onecomp 930725-1.c
+ call onecomp 930818-1.c
+ call onecomp 930916-1.c
+ call onecomp 930921-1.c
+ call onecomp 930929-1.c
+ call onecomp 930930-1.c
+ call onecomp 930930-2.c
+ call onecomp 931002-1.c
+ call onecomp 931004-1.c
+ call onecomp 931004-10.c
+ call onecomp 931004-11.c
+ call onecomp 931004-12.c
+ call onecomp 931004-13.c
+ call onecomp 931004-14.c
+ call onecomp 931004-2.c
+ call onecomp 931004-3.c
+ call onecomp 931004-4.c
+ call onecomp 931004-5.c
+ call onecomp 931004-6.c
+ call onecomp 931004-7.c
+ call onecomp 931004-8.c
+ call onecomp 931004-9.c
+ call onecomp 931005-1.c
+ call onecomp 931009-1.c
+ call onecomp 931012-1.c
+ call onecomp 931017-1.c
+ call onecomp 931018-1.c
+ call onecomp 931031-1.c
+ call onecomp 931102-1.c
+ call onecomp 931102-2.c
+ call onecomp 931110-1.c
+ call onecomp 931110-2.c
+ call onecomp 931208-1.c
+ call onecomp 931228-1.c
+ call onecomp 940115-1.c
+ call onecomp 940122-1.c
+ call onecomp 941014-1.c
+ call onecomp 941014-2.c
+ call onecomp 941015-1.c
+ call onecomp 941021-1.c
+ call onecomp 941025-1.c
+ call onecomp 941031-1.c
+ call onecomp 941101-1.c
+ call onecomp 941110-1.c
+ call onecomp 941202-1.c
+ call onecomp 950221-1.c
+ call onecomp 950322-1.c
+ call onecomp 950426-1.c
+ call onecomp 950426-2.c
+ call onecomp 950503-1.c
+ call onecomp 950511-1.c
+ call onecomp 950512-1.c
+ call onecomp 950605-1.c
+ call onecomp 950607-1.c
+ call onecomp 950607-2.c
+ call onecomp 950612-1.c
+ call onecomp 950621-1.c
+ call onecomp 950628-1.c
+ call onecomp 950704-1.c
+ call onecomp 950706-1.c
+ call onecomp 950710-1.c
+ call onecomp 950714-1.c
+ call onecomp 950809-1.c
+ call onecomp 950906-1.c
+ call onecomp 950915-1.c
+ call onecomp 950929-1.c
+ call onecomp 951003-1.c
+ call onecomp 951115-1.c
+ call onecomp 951204-1.c
+ call onecomp 960116-1.c
+ call onecomp 960117-1.c
+ call onecomp 960209-1.c
+ call onecomp 960215-1.c
+ call onecomp 960218-1.c
+ call onecomp 960219-1.c
+ call onecomp 960301-1.c
+ call onecomp 960302-1.c
+ call onecomp 960311-1.c
+ call onecomp 960311-2.c
+ call onecomp 960311-3.c
+ call onecomp 960312-1.c
+ call onecomp 960317-1.c
+ call onecomp 960321-1.c
+ call onecomp 960326-1.c
+ call onecomp 960327-1.c
+ call onecomp 960402-1.c
+ call onecomp 960405-1.c
+ call onecomp 960416-1.c
+ call onecomp 960419-1.c
+ call onecomp 960419-2.c
+ call onecomp 960512-1.c
+ call onecomp 960513-1.c
+ call onecomp 960521-1.c
+ call onecomp 960608-1.c
+ call onecomp 960801-1.c
+ call onecomp 960802-1.c
+ call onecomp 960830-1.c
+ call onecomp 960909-1.c
+ call onecomp 961004-1.c
+ call onecomp 961017-1.c
+ call onecomp 961017-2.c
+ call onecomp 961026-1.c
+ call onecomp 961112-1.c
+ call onecomp 961122-1.c
+ call onecomp 961122-2.c
+ call onecomp 961125-1.c
+ call onecomp 961206-1.c
+ call onecomp 961213-1.c
+ call onecomp 961223-1.c
+ call onecomp 970214-1.c
+ call onecomp 970214-2.c
+ call onecomp 970217-1.c
+ call onecomp 970923-1.c
+ call onecomp 980205.c
+ call onecomp 980223.c
+ call onecomp 980424-1.c
+ call onecomp 980505-1.c
+ call onecomp 980505-2.c
+ call onecomp 980506-1.c
+ call onecomp 980506-2.c
+ call onecomp 980506-3.c
+ call onecomp 980526-1.c
+ call onecomp 980526-2.c
+ call onecomp 980526-3.c
+ call onecomp 980602-1.c
+ call onecomp 980602-2.c
+ call onecomp 980604-1.c
+ call onecomp 980605-1.c
+ call onecomp 980608-1.c
+ call onecomp 980612-1.c
+ call onecomp 980617-1.c
+ call onecomp 980618-1.c
+ call onecomp 980701-1.c
+ call onecomp 980707-1.c
+ call onecomp 980709-1.c
+ call onecomp 980716-1.c
+ call onecomp 980929-1.c
+ call onecomp 981001-1.c
+ call onecomp 981019-1.c
+ call onecomp 981130-1.c
+ call onecomp 981206-1.c
+ call onecomp 990106-1.c
+ call onecomp 990106-2.c
+ call onecomp 990117-1.c
+ call onecomp 990127-1.c
+ call onecomp 990127-2.c
+ call onecomp 990128-1.c
+ call onecomp 990130-1.c
+ call onecomp 990208-1.c
+ call onecomp 990211-1.c
+ call onecomp 990222-1.c
+ call onecomp 990324-1.c
+ call onecomp 990326-1.c
+ call onecomp 990404-1.c
+ call onecomp 990413-2.c
+ call onecomp 990513-1.c
+ call onecomp 990524-1.c
+ call onecomp 990525-1.c
+ call onecomp 990525-2.c
+ call onecomp 990527-1.c
+ call onecomp 990531-1.c
+ call onecomp 990604-1.c
+ call onecomp 990628-1.c
+ call onecomp 990804-1.c
+ call onecomp 990811-1.c
+ call onecomp 990826-0.c
+ call onecomp 990827-1.c
+ call onecomp 990829-1.c
+ call onecomp 990923-1.c
+ call onecomp 991014-1.c
+ call onecomp 991016-1.c
+ call onecomp 991019-1.c
+ call onecomp 991023-1.c
+ call onecomp 991030-1.c
+ call onecomp 991112-1.c
+ call onecomp 991118-1.c
+ call onecomp 991201-1.c
+ call onecomp 991202-1.c
+ call onecomp 991202-2.c
+ call onecomp 991202-3.c
+ call onecomp 991216-1.c
+ call onecomp 991216-2.c
+ call onecomp 991216-3.c
+ call onecomp 991216-4.c
+ call onecomp 991221-1.c
+ call onecomp 991227-1.c
+ call onecomp 991228-1.c
+ call onecomp align-1.c
+ call onecomp align-2.c
+ call onecomp alloca-1.c
+ call onecomp anon-1.c
+ call onecomp arith-1.c
+ call onecomp arith-rand.c
+ call onecomp ashldi-1.c
+ call onecomp ashrdi-1.c
+ call onecomp bcp-1.c
+ call onecomp bf-layout-1.c
+ call onecomp bf-pack-1.c
+ call onecomp bf-sign-1.c
+ call onecomp bf-sign-2.c
+ call onecomp bf64-1.c
+ call onecomp bitfld-1.c
+ call onecomp bitfld-2.c
+ call onecomp built-in-setjmp.c
+ call onecomp builtin-abs-1.c
+ call onecomp builtin-abs-2.c
+ call onecomp builtin-complex-1.c
+ call onecomp builtin-noret-1.c
+ call onecomp builtin-prefetch-1.c
+ call onecomp builtin-prefetch-2.c
+ call onecomp builtin-prefetch-3.c
+ call onecomp builtin-prefetch-4.c
+ call onecomp builtin-prefetch-5.c
+ call onecomp builtin-prefetch-6.c
+ call onecomp builtin-types-compatible-p.c
+ call onecomp cbrt.c
+ call onecomp cmpdi-1.c
+ call onecomp cmpsi-1.c
+ call onecomp comp-goto-1.c
+ call onecomp comp-goto-2.c
+ call onecomp complex-1.c
+ call onecomp complex-2.c
+ call onecomp complex-3.c
+ call onecomp complex-4.c
+ call onecomp complex-5.c
+ call onecomp complex-6.c
+ call onecomp compndlit-1.c
+ call onecomp conversion.c
+ call onecomp cvt-1.c
+ call onecomp dbra-1.c
+ call onecomp divconst-1.c
+ call onecomp divconst-2.c
+ call onecomp divconst-3.c
+ call onecomp divmod-1.c
+ call onecomp eeprof-1.c
+ call onecomp enum-1.c
+ call onecomp enum-2.c
+ call onecomp extzvsi.c
+ call onecomp func-ptr-1.c
+ call onecomp gofast.c
+ call onecomp index-1.c
+ call onecomp inst-check.c
+ call onecomp int-compare.c
+ call onecomp longlong.c
+ call onecomp loop-1.c
+ call onecomp loop-10.c
+ call onecomp loop-11.c
+ call onecomp loop-12.c
+ call onecomp loop-14.c
+ call onecomp loop-15.c
+ call onecomp loop-2.c
+ call onecomp loop-2b.c
+ call onecomp loop-2c.c
+ call onecomp loop-2d.c
+ call onecomp loop-2e.c
+ call onecomp loop-2f.c
+ call onecomp loop-2g.c
+ call onecomp loop-3.c
+ call onecomp loop-3b.c
+ call onecomp loop-3c.c
+ call onecomp loop-4.c
+ call onecomp loop-4b.c
+ call onecomp loop-5.c
+ call onecomp loop-6.c
+ call onecomp loop-7.c
+ call onecomp loop-8.c
+ call onecomp loop-9.c
+ call onecomp lshrdi-1.c
+ call onecomp memcpy-1.c
+ call onecomp memcpy-bi.c
+ call onecomp memset-3.c
+ call onecomp mod-1.c
+ call onecomp nest-stdar-1.c
+ call onecomp nestfunc-1.c
+ call onecomp nestfunc-2.c
+ call onecomp nestfunc-3.c
+ call onecomp nestfunc-4.c
+ call onecomp packed-1.c
+ call onecomp packed-2.c
+ call onecomp pending-4.c
+ call onecomp ptr-arith-1.c
+ call onecomp regstack-1.c
+ call onecomp scope-1.c
+ call onecomp scope-2.c
+ call onecomp shiftdi.c
+ call onecomp stdio-opt-1.c
+ call onecomp stdio-opt-2.c
+ call onecomp stdio-opt-3.c
+ call onecomp strct-pack-1.c
+ call onecomp strct-pack-2.c
+ call onecomp strct-pack-3.c
+ call onecomp strct-pack-4.c
+ call onecomp strct-stdarg-1.c
+ call onecomp strct-varg-1.c
+ call onecomp string-opt-1.c
+ call onecomp string-opt-10.c
+ call onecomp string-opt-11.c
+ call onecomp string-opt-12.c
+ call onecomp string-opt-13.c
+ call onecomp string-opt-14.c
+ call onecomp string-opt-15.c
+ call onecomp string-opt-16.c
+ call onecomp string-opt-2.c
+ call onecomp string-opt-3.c
+ call onecomp string-opt-4.c
+ call onecomp string-opt-5.c
+ call onecomp string-opt-6.c
+ call onecomp string-opt-7.c
+ call onecomp string-opt-8.c
+ call onecomp string-opt-9.c
+ call onecomp struct-ini-1.c
+ call onecomp struct-ini-2.c
+ call onecomp struct-ini-3.c
+ call onecomp struct-ini-4.c
+ call onecomp struct-ret-1.c
+ call onecomp struct-ret-2.c
+ call onecomp tstdi-1.c
+ call onecomp unroll-1.c
+ call onecomp va-arg-1.c
+ call onecomp va-arg-10.c
+ call onecomp va-arg-11.c
+ call onecomp va-arg-12.c
+ call onecomp va-arg-13.c
+ call onecomp va-arg-14.c
+ call onecomp va-arg-15.c
+ call onecomp va-arg-16.c
+ call onecomp va-arg-17.c
+ call onecomp va-arg-18.c
+ call onecomp va-arg-19.c
+ call onecomp va-arg-2.c
+ call onecomp va-arg-20.c
+ call onecomp va-arg-21.c
+ call onecomp va-arg-22.c
+ call onecomp va-arg-3.c
+ call onecomp va-arg-4.c
+ call onecomp va-arg-5.c
+ call onecomp va-arg-6.c
+ call onecomp va-arg-7.c
+ call onecomp va-arg-8.c
+ call onecomp va-arg-9.c
+ call onecomp wchar_t-1.c
+ call onecomp widechar-1.c
+ call onecomp widechar-2.c
+ call onecomp zerolen-1.c
+ call onecomp zerolen-2.c
Index: gcc/gcc/config/i370/i370-c.c
diff -c gcc/gcc/config/i370/i370-c.c:1.1.1.1 gcc/gcc/config/i370/i370-c.c:1.3
*** gcc/gcc/config/i370/i370-c.c:1.1.1.1	Wed Feb 15 21:22:45 2006
--- gcc/gcc/config/i370/i370-c.c	Sun Oct 28 23:19:48 2007
***************
*** 47,63 ****
    if (c_lex (&x)        == CPP_OPEN_PAREN
        && c_lex (&name)  == CPP_NAME
        && c_lex (&x)     == CPP_COMMA
!       && c_lex (&alias) == CPP_NAME
        && c_lex (&x)     == CPP_CLOSE_PAREN)
      {
        if (c_lex (&x) != CPP_EOF)
  	warning ("junk at end of #pragma map");
  
!       mvs_add_alias (IDENTIFIER_POINTER (name), IDENTIFIER_POINTER (alias), 1);
        return;
      }
  
    warning ("malformed #pragma map, ignored");
  }
  
  #endif
--- 47,128 ----
    if (c_lex (&x)        == CPP_OPEN_PAREN
        && c_lex (&name)  == CPP_NAME
        && c_lex (&x)     == CPP_COMMA
!       && c_lex (&alias) == CPP_STRING
        && c_lex (&x)     == CPP_CLOSE_PAREN)
      {
+       const char *cp = TREE_STRING_POINTER(alias);
+ 
        if (c_lex (&x) != CPP_EOF)
  	warning ("junk at end of #pragma map");
  
!       mvs_add_alias (IDENTIFIER_POINTER (name), cp, 1);
        return;
      }
  
    warning ("malformed #pragma map, ignored");
  }
  
+ /* #pragma linkage (name, mode) -
+    In this implementation both name and alias are required to be
+    identifiers.  The older code seemed to be more permissive.  Can
+    anyone clarify?  */
+ 
+ void
+ i370_pr_linkage (pfile)
+      cpp_reader *pfile ATTRIBUTE_UNUSED;
+ {
+   tree name, mode, x;
+ 
+   if (c_lex (&x)        == CPP_OPEN_PAREN
+       && c_lex (&name)  == CPP_NAME
+       && c_lex (&x)     == CPP_COMMA
+       && c_lex (&mode)  == CPP_NAME
+       && c_lex (&x)     == CPP_CLOSE_PAREN)
+     {
+       if (c_lex (&x) != CPP_EOF)
+ 	warning ("junk at end of #pragma linkage");
+ 
+       return;
+     }
+ 
+   warning ("malformed #pragma linkage, ignored");
+ }
+ 
+ /* #pragma checkout (mode) -
+    In this implementation both name and alias are required to be
+    identifiers.  The older code seemed to be more permissive.  Can
+    anyone clarify?  */
+ 
+ void
+ i370_pr_checkout (pfile)
+      cpp_reader *pfile ATTRIBUTE_UNUSED;
+ {
+   tree mode, x;
+ 
+   if (c_lex (&x)        == CPP_OPEN_PAREN
+       && c_lex (&mode)  == CPP_NAME
+       && c_lex (&x)     == CPP_CLOSE_PAREN)
+     {
+       if (c_lex (&x) != CPP_EOF)
+ 	warning ("junk at end of #pragma checkout");
+ 
+       return;
+     }
+ 
+   warning ("malformed #pragma checkout, ignored");
+ }
+ 
+ /* #pragma nomargins
+    #pragma nosequence
+    We just ignore. */
+ 
+ void
+ i370_pr_skipit (pfile)
+      cpp_reader *pfile ATTRIBUTE_UNUSED;
+ {
+ 
+   return;
+ 
+ }
+ 
  #endif
Index: gcc/gcc/config/i370/i370-protos.h
diff -c gcc/gcc/config/i370/i370-protos.h:1.1.1.1 gcc/gcc/config/i370/i370-protos.h:1.2
*** gcc/gcc/config/i370/i370-protos.h:1.1.1.1	Wed Feb 15 21:22:45 2006
--- gcc/gcc/config/i370/i370-protos.h	Wed Feb 15 21:24:30 2006
***************
*** 37,43 ****
  extern int handle_pragma PARAMS ((int (*)(void), void (*)(int), const char *));
  #endif /* TREE_CODE */
  
- extern char mvs_map_char PARAMS ((int));
  extern void mvs_add_label PARAMS ((int));
  extern int mvs_check_label PARAMS ((int));
  extern int mvs_check_page PARAMS ((FILE *, int, int));
--- 37,42 ----
***************
*** 48,56 ****
  extern int mvs_check_alias PARAMS ((const char *, char *));
  extern void check_label_emit PARAMS ((void));
  extern void mvs_free_label_list PARAMS ((void));
  
  #ifdef GCC_C_PRAGMA_H
! extern void i370_pr_map PARAMS ((cpp_reader *));
  #endif
  
  #endif /* ! GCC_I370_PROTOS_H */
--- 47,59 ----
  extern int mvs_check_alias PARAMS ((const char *, char *));
  extern void check_label_emit PARAMS ((void));
  extern void mvs_free_label_list PARAMS ((void));
+ extern char *mvs_make_float PARAMS ((REAL_VALUE_TYPE));
  
  #ifdef GCC_C_PRAGMA_H
! extern void i370_pr_map       PARAMS ((cpp_reader *));
! extern void i370_pr_skipit    PARAMS ((cpp_reader *));
! extern void i370_pr_linkage   PARAMS ((cpp_reader *));
! extern void i370_pr_checkout  PARAMS ((cpp_reader *));
  #endif
  
  #endif /* ! GCC_I370_PROTOS_H */
Index: gcc/gcc/config/i370/i370.c
diff -c gcc/gcc/config/i370/i370.c:1.1.1.1 gcc/gcc/config/i370/i370.c:1.43
*** gcc/gcc/config/i370/i370.c:1.1.1.1	Wed Feb 15 21:22:45 2006
--- gcc/gcc/config/i370/i370.c	Mon Aug 18 00:15:38 2014
***************
*** 3,9 ****
     Free Software Foundation, Inc.
     Contributed by Jan Stein (jan@cd.chalmers.se).
     Modified for OS/390 LanguageEnvironment C by Dave Pitts (dpitts@cozx.com)
!    Hacked for Linux-ELF/390 by Linas Vepstas (linas@linas.org) 
  
  This file is part of GNU CC.
  
--- 3,9 ----
     Free Software Foundation, Inc.
     Contributed by Jan Stein (jan@cd.chalmers.se).
     Modified for OS/390 LanguageEnvironment C by Dave Pitts (dpitts@cozx.com)
!    Modified for Linux-ELF/390 by Linas Vepstas (linas@linas.org) 
  
  This file is part of GNU CC.
  
***************
*** 43,48 ****
--- 43,53 ----
  #include "target.h"
  #include "target-def.h"
  
+ 
+ /* maximum length output line */
+ /* need to allow for people dumping specs */
+ #define MAX_LEN_OUT 2000
+ 
  extern FILE *asm_out_file;
  
  /* Label node.  This structure is used to keep track of labels 
***************
*** 67,75 ****
--- 72,92 ----
    }
  label_node_t;
  
+ /* if we just inspected a label on another page, we want to
+    record that */
+ static int just_referenced_page = -1;
+ 
  /* Is 1 when a label has been generated and the base register must be reloaded.  */
  int mvs_need_base_reload = 0;
  
+ /* Is 1 when an entry point is to be generated.  */
+ int mvs_need_entry = 0;
+ 
+ /* Is 1 if we have seen main() */
+ int mvs_gotmain = 0;
+ 
+ int mvs_need_to_globalize = 1;
+ 
  /* Current function starting base page.  */
  int function_base_page;
  
***************
*** 79,93 ****
--- 96,122 ----
  /* Length of the current page literals.  */
  int mvs_page_lit;
  
+ /* Length of case statement entries */
+ int mvs_case_code = 0;
+ 
+ /* The desired CSECT name */
+ char *mvs_csect_name = 0;
+ 
  /* Current function name.  */
  char *mvs_function_name = 0;
  
+ /* Current source module.  */
+ char *mvs_module = 0;
+ 
  /* Current function name length.  */
  int mvs_function_name_length = 0;
  
  /* Page number for multi-page functions.  */
  int mvs_page_num = 0;
  
+ /* First entry point.  */
+ static int mvs_first_entry = 1;
+ 
  /* Label node list anchor.  */
  static label_node_t *label_anchor = 0;
  
***************
*** 97,102 ****
--- 126,134 ----
  /* Assembler source file descriptor.  */
  static FILE *assembler_source = 0;
  
+ /* Flag that enables position independent code */
+ int i370_enable_pic = 1;
+ 
  static label_node_t * mvs_get_label PARAMS ((int));
  static void i370_label_scan PARAMS ((void));
  #ifdef TARGET_HLASM
***************
*** 104,110 ****
  #endif
  static void i370_output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));
  static void i370_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));
! #ifdef LONGEXTERNAL
  static int mvs_hash_alias PARAMS ((const char *));
  #endif
  
--- 136,142 ----
  #endif
  static void i370_output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));
  static void i370_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));
! #ifdef TARGET_ALIASES
  static int mvs_hash_alias PARAMS ((const char *));
  #endif
  
***************
*** 113,119 ****
  #ifdef TARGET_HLASM
  
  #define MVS_HASH_PRIME 999983
! #if defined(HOST_EBCDIC)
  #define MVS_SET_SIZE 256
  #else
  #define MVS_SET_SIZE 128
--- 145,151 ----
  #ifdef TARGET_HLASM
  
  #define MVS_HASH_PRIME 999983
! #if 1 /*defined(HOST_EBCDIC)*/
  #define MVS_SET_SIZE 256
  #else
  #define MVS_SET_SIZE 128
***************
*** 133,138 ****
--- 165,171 ----
    {
      struct alias_node *alias_next;
      int  alias_emitted;
+     int  alias_used;
      char alias_name [MAX_MVS_LABEL_SIZE + 1];
      char real_name [MAX_LONG_LABEL_SIZE + 1];
    }
***************
*** 141,146 ****
--- 174,180 ----
  /* Alias node list anchor.  */
  static alias_node_t *alias_anchor = 0;
  
+ #ifdef TARGET_LE
  /* Define the length of the internal MVS function table.  */
  #define MVS_FUNCTION_TABLE_LENGTH 32
  
***************
*** 164,294 ****
     "y1",       "yn"
  #endif
  };
  
  #endif /* TARGET_HLASM */
- /* ===================================================== */
- 
- /* ASCII to EBCDIC conversion table.  */
- static const unsigned char ascebc[256] =
- {
-  /*00  NL    SH    SX    EX    ET    NQ    AK    BL */
-      0x00, 0x01, 0x02, 0x03, 0x37, 0x2D, 0x2E, 0x2F,
-  /*08  BS    HT    LF    VT    FF    CR    SO    SI */
-      0x16, 0x05, 0x15, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
-  /*10  DL    D1    D2    D3    D4    NK    SN    EB */
-      0x10, 0x11, 0x12, 0x13, 0x3C, 0x3D, 0x32, 0x26,
-  /*18  CN    EM    SB    EC    FS    GS    RS    US */
-      0x18, 0x19, 0x3F, 0x27, 0x1C, 0x1D, 0x1E, 0x1F,
-  /*20  SP     !     "     #     $     %     &     ' */
-      0x40, 0x5A, 0x7F, 0x7B, 0x5B, 0x6C, 0x50, 0x7D,
-  /*28   (     )     *     +     ,     -    .      / */
-      0x4D, 0x5D, 0x5C, 0x4E, 0x6B, 0x60, 0x4B, 0x61,
-  /*30   0     1     2     3     4     5     6     7 */
-      0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,
-  /*38   8     9     :     ;     <     =     >     ? */
-      0xF8, 0xF9, 0x7A, 0x5E, 0x4C, 0x7E, 0x6E, 0x6F,
-  /*40   @     A     B     C     D     E     F     G */
-      0x7C, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7,
-  /*48   H     I     J     K     L     M     N     O */
-      0xC8, 0xC9, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6,
-  /*50   P     Q     R     S     T     U     V     W */
-      0xD7, 0xD8, 0xD9, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6,
-  /*58   X     Y     Z     [     \     ]     ^     _ */
-      0xE7, 0xE8, 0xE9, 0xAD, 0xE0, 0xBD, 0x5F, 0x6D,
-  /*60   `     a     b     c     d     e     f     g */
-      0x79, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
-  /*68   h     i     j     k     l     m     n     o */
-      0x88, 0x89, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96,
-  /*70   p     q     r     s     t     u     v     w */
-      0x97, 0x98, 0x99, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6,
-  /*78   x     y     z     {     |     }     ~    DL */
-      0xA7, 0xA8, 0xA9, 0xC0, 0x4F, 0xD0, 0xA1, 0x07,
-      0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,
-      0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,
-      0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,
-      0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,
-      0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,
-      0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,
-      0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,
-      0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,
-      0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,
-      0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,
-      0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,
-      0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,
-      0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,
-      0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,
-      0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,
-      0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0xFF
- };
- 
- /* EBCDIC to ASCII conversion table.  */
- static const unsigned char ebcasc[256] =
- {
-  /*00  NU    SH    SX    EX    PF    HT    LC    DL */
-      0x00, 0x01, 0x02, 0x03, 0x00, 0x09, 0x00, 0x7F,
-  /*08              SM    VT    FF    CR    SO    SI */
-      0x00, 0x00, 0x00, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
-  /*10  DE    D1    D2    TM    RS    NL    BS    IL */
-      0x10, 0x11, 0x12, 0x13, 0x14, 0x0A, 0x08, 0x00,
-  /*18  CN    EM    CC    C1    FS    GS    RS    US */
-      0x18, 0x19, 0x00, 0x00, 0x1C, 0x1D, 0x1E, 0x1F,
-  /*20  DS    SS    FS          BP    LF    EB    EC */
-      0x00, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x17, 0x1B,
-  /*28              SM    C2    EQ    AK    BL       */
-      0x00, 0x00, 0x00, 0x00, 0x05, 0x06, 0x07, 0x00,
-  /*30              SY          PN    RS    UC    ET */
-      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04,
-  /*38                    C3    D4    NK          SU */
-      0x00, 0x00, 0x00, 0x00, 0x14, 0x15, 0x00, 0x1A,
-  /*40  SP                                           */
-      0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  /*48                     .     <     (     +     | */
-      0x00, 0x00, 0x00, 0x2E, 0x3C, 0x28, 0x2B, 0x7C,
-  /*50   &                                           */
-      0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  /*58               !     $     *     )     ;     ^ */
-      0x00, 0x00, 0x21, 0x24, 0x2A, 0x29, 0x3B, 0x5E,
-  /*60   -     /                                     */
-      0x2D, 0x2F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  /*68                     ,     %     _     >     ? */
-      0x00, 0x00, 0x00, 0x2C, 0x25, 0x5F, 0x3E, 0x3F,
-  /*70                                               */
-      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  /*78         `     :     #     @     '     =     " */
-      0x00, 0x60, 0x3A, 0x23, 0x40, 0x27, 0x3D, 0x22,
-  /*80         a     b     c     d     e     f     g */
-      0x00, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
-  /*88   h     i           {                         */
-      0x68, 0x69, 0x00, 0x7B, 0x00, 0x00, 0x00, 0x00,
-  /*90         j     k     l     m     n     o     p */
-      0x00, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70,
-  /*98   q     r           }                         */
-      0x71, 0x72, 0x00, 0x7D, 0x00, 0x00, 0x00, 0x00,
-  /*A0         ~     s     t     u     v     w     x */
-      0x00, 0x7E, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78,
-  /*A8   y     z                       [             */
-      0x79, 0x7A, 0x00, 0x00, 0x00, 0x5B, 0x00, 0x00,
-  /*B0                                               */
-      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  /*B8                                 ]             */
-      0x00, 0x00, 0x00, 0x00, 0x00, 0x5D, 0x00, 0x00,
-  /*C0   {     A     B     C     D     E     F     G */
-      0x7B, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
-  /*C8   H     I                                     */
-      0x48, 0x49, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  /*D0   }     J     K     L     M     N     O     P */
-      0x7D, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50,
-  /*D8   Q     R                                     */
-      0x51, 0x52, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  /*E0   \           S     T     U     V     W     X */
-      0x5C, 0x00, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,
-  /*E8   Y     Z                                     */
-      0x59, 0x5A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  /*F0   0     1     2     3     4     5     6     7 */
-      0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
-  /*F8   8     9                                     */
-      0x38, 0x39, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF
- };
  
  /* Initialize the GCC target structure.  */
  #ifdef TARGET_HLASM
--- 198,206 ----
     "y1",       "yn"
  #endif
  };
+ #endif /* TARGET_LE */
  
  #endif /* TARGET_HLASM */
  
  /* Initialize the GCC target structure.  */
  #ifdef TARGET_HLASM
***************
*** 309,333 ****
  
  struct gcc_target targetm = TARGET_INITIALIZER;
  
- /* Map characters from one character set to another.
-    C is the character to be translated.  */
  
! char
! mvs_map_char (c)
!      int c;
! {
! #if defined(TARGET_EBCDIC) && !defined(HOST_EBCDIC)
!   fprintf (stderr, "mvs_map_char: TE & !HE: c = %02x\n", c);
!   return ascebc[c];
! #else
! #if defined(HOST_EBCDIC) && !defined(TARGET_EBCDIC)
!   fprintf (stderr, "mvs_map_char: !TE & HE: c = %02x\n", c);
!   return ebcasc[c];
! #else
!   fprintf (stderr, "mvs_map_char: !TE & !HE: c = %02x\n", c);
!   return c;
! #endif
! #endif
  }
  
  /* ===================================================== */
--- 221,266 ----
  
  struct gcc_target targetm = TARGET_INITIALIZER;
  
  
! #define CURRFUNC (IDENTIFIER_POINTER (DECL_NAME (current_function_decl)))
! 
! 
! /* ===================================================== */
! /* This is our last chance to clean up before starting to compile.
!    We do this to fix up some initializations.   */
! 
! void
! i370_override_options (void)
! {
!   i370_enable_pic = flag_pic;
! 
!   if (mvs_csect_name)
!   {
!       static char buf[9];
!       char *p;
!       
!       strncpy(buf, mvs_csect_name, 8);
!       p = buf;
!       while (*p != '\0')
!       {
!           *p = toupper((unsigned char)*p);
!           p++;
!       }
!       mvs_csect_name = buf;
!   }
! #ifdef TARGET_LINUX
!   /* Override CALL_USED_REGISTERS & FIXED_REGISTERS 
!      PIC requires r12, otherwise its free */
!   if (i370_enable_pic) 
!     {
!       fix_register ("r12", 1, 1);
!     }
!   else
!     {
!       fix_register ("r12", 0, 0);
!     }
! #endif /* TARGET_LINUX */
! 
  }
  
  /* ===================================================== */
***************
*** 367,372 ****
--- 300,306 ----
  
       lp = mvs_get_label (labelno);
       if (-1 == lp -> first_ref_page) lp->first_ref_page = mvs_page_num;
+      just_referenced_page = lp->label_page;
    }
    return dest_addr;
  }
***************
*** 389,394 ****
--- 323,339 ----
    int base_offset;
  
    base_offset = i370_branch_length(insn);
+   /* If we just referenced something off-page, then you can
+      forget about doing a short branch to it! So for backward
+      references, we'll have a page number and can see that it is
+      different. For forward references, the page number isn't
+      available yet (ie it's still set to -1), so don't use
+      this logic on them. */
+   if ((just_referenced_page != mvs_page_num)
+       && (just_referenced_page != -1))
+     {
+       return 0;
+     }
    if (0 > base_offset) 
      {
        base_offset += mvs_page_code;
***************
*** 401,407 ****
      }
    
    /* make a conservative estimate of room left on page */
!   if ((4060 >base_offset) && ( 0 < base_offset)) return 1;
    return 0;
  }
  
--- 346,352 ----
      }
    
    /* make a conservative estimate of room left on page */
!   if ((MVS_PAGE_CONSERVATIVE >base_offset) && ( 0 < base_offset)) return 1;
    return 0;
  }
  
***************
*** 529,535 ****
     off than yesterday.  */
  
                      /* print_rtl_single (stdout, insn); */
!                     debug_rtx (insn);
                      /* abort(); */
                      continue;
                   }
--- 474,480 ----
     off than yesterday.  */
  
                      /* print_rtl_single (stdout, insn); */
!                     /* debug_rtx (insn); */
                      /* abort(); */
                      continue;
                   }
***************
*** 572,603 ****
     reloads when several labels are generated pointing to the same place
     in the code.  
  
!    The page table is written at the end of the function. 
!    The entries in the page table look like
       .LPGT0:          // PGT0 EQU *
       .long .LPG0      // DC A(PG0)
       .long .LPG1      // DC A(PG1)
!   while the prologue generates
!       L       r4,=A(.LPGT0)
  
!   Note that this paging scheme breaks down if a single subroutine 
!   has more than about 10MB of code in it ... as long as humans write
!   code, this shouldn't be a problem ...
   */
  
  void
  check_label_emit ()
  {
    if (mvs_need_base_reload)
      {
        mvs_need_base_reload = 0;
- 
        mvs_page_code += 4;
        fprintf (assembler_source, "\tL\t%d,%d(,%d)\n",
! 	  BASE_REGISTER, (mvs_page_num - function_base_page) * 4,
! 	  PAGE_REGISTER);
      }
  }
  
  /* Add the label to the current page label list.  If a free element is available
     it will be used for the new label.  Otherwise, a label element will be
--- 517,598 ----
     reloads when several labels are generated pointing to the same place
     in the code.  
  
!    The table of base register values is created at the end of the function.
!    The MVS/OE/USS/HLASM version keeps this table in the text section, and
!    it looks like the following:
!       PGT0 EQU *
!       DC A(PG0)
!       DC A(PG1)
!    
!    The ELF version keeps the base register table in either the text or the 
!    data section, depending on the setting of the i370_enable_pic flag.
!    Disabling this flag frees r12 for general purpose use, but makes the 
!    code non-relocatable.  The non-pic table resemble the mvs-style table.
!    The pic table stores values for both r3 (the register used for branching)
!    and r12 (the register to index the literal pool, also in the data section).
!    Thus, the ELF pic version has twice as many entries, and double the offset.
! 
       .LPGT0:          // PGT0 EQU *
       .long .LPG0      // DC A(PG0)
+      .long .LPOOL0     
       .long .LPG1      // DC A(PG1)
!      .long .LPOOL1     
  
!   Note that the functin prologue loads the page addressing register:
!       L       PAGE_REGISTER,=A(.LPGT0)
! 
!   The ELF version then stores this value at 0(r13), so that its always
!   accessible. This frees up r4 for general register allocation; whereas
!   the MVS version is stuck with r4.
! 
!   Note that this addressing scheme breaks down when a single subroutine
!   has more than twelve MBytes of code or so for non-pic, and 6MB for pic.
!   Its hard to imagine under what circumstances a single subroutine would 
!   ever get that big ...
   */
  
+ #ifdef TARGET_HLASM
  void
  check_label_emit ()
  {
    if (mvs_need_base_reload)
      {
        mvs_need_base_reload = 0;
        mvs_page_code += 4;
        fprintf (assembler_source, "\tL\t%d,%d(,%d)\n",
!           BASE_REGISTER, (mvs_page_num - function_base_page) * 4,
!           PAGE_REGISTER);
!     }
! }
! #endif /* TARGET_HLASM */
! 
! #ifdef TARGET_LINUX
! void
! check_label_emit ()
! {
!   if (mvs_need_base_reload)
!     {
!       mvs_need_base_reload = 0;
! 
!       if (i370_enable_pic) 
!         {
!           mvs_page_code += 12;
!           fprintf (assembler_source, "\tL\tr3,0(,r13)\n");
!           fprintf (assembler_source, "\tL\tr%d,%d(,r3)\n",
!               PIC_BASE_REGISTER, ((mvs_page_num - function_base_page) * 8 +4));
!           fprintf (assembler_source, "\tL\tr3,%d(,r3)\n",
!               (mvs_page_num - function_base_page) * 8);
!         }
!       else
!         {
!           mvs_page_code += 8;
!           fprintf (assembler_source, "\tL\tr3,0(,r13)\n");
!           fprintf (assembler_source, "\tL\tr3,%d(,r3)\n",
!               ((mvs_page_num - function_base_page) * 4));
!         }
      }
  }
+ #endif /* TARGET_LINUX */
  
  /* Add the label to the current page label list.  If a free element is available
     it will be used for the new label.  Otherwise, a label element will be
***************
*** 650,655 ****
--- 645,661 ----
    lp = mvs_get_label (id);
    lp->label_page = mvs_page_num;
  
+ /* Note that without this, some case statements are
+      not generating correct code, e.g. case '{' in
+      do_spec_1 in gcc.c */
+ #if 1
+   if (mvs_page_num != function_base_page)
+   {
+       mvs_need_base_reload ++;
+       return;
+   }
+ #endif
+ 
    /* OK, we just saw the label.  Determine if this label
     * needs a reload of the base register */
    if ((-1 != lp->first_ref_page) && 
***************
*** 677,683 ****
  
    fwd_distance = lp->label_last_ref - lp->label_addr;
  
!   if (mvs_page_code + 2 * fwd_distance + mvs_page_lit < 4060) return;
  
    mvs_need_base_reload ++;
  }
--- 683,690 ----
  
    fwd_distance = lp->label_last_ref - lp->label_addr;
  
!   if (mvs_page_code + 2 * fwd_distance + mvs_page_lit < MVS_PAGE_CONSERVATIVE)
!       return;
  
    mvs_need_base_reload ++;
  }
***************
*** 748,753 ****
--- 755,781 ----
    label_anchor = 0;
  }
  
+ /* Convert a float to a printable form.  */
+ 
+ char *
+ mvs_make_float (REAL_VALUE_TYPE r)
+ {
+    char *p;
+    static char buf[50];
+ 
+    REAL_VALUE_TO_DECIMAL (r, "%.9G", buf);
+    for (p = buf; *p; p++)
+       if (ISLOWER(*p)) *p = TOUPPER(*p);
+    if ((p = strrchr (buf, 'E')) != NULL)
+    {
+       char *t = p;
+       for (p--; *p == '0'; p--) ;
+       if (*p == '.') p++;
+       strcpy (++p, t);
+    }
+    return (buf);
+ }
+ 
  /* ====================================================================== */
  /* If the page size limit is reached a new code page is started, and the base
     register is set to it.  This page break point is counted conservatively,
***************
*** 768,785 ****
  
    if (mvs_page_code + code + mvs_page_lit + lit > MAX_MVS_PAGE_LENGTH)
      {
!       fprintf (assembler_source, "\tB\tPGE%d\n", mvs_page_num);
!       fprintf (assembler_source, "\tDS\t0F\n");
!       fprintf (assembler_source, "\tLTORG\n");
        fprintf (assembler_source, "\tDS\t0F\n");
!       fprintf (assembler_source, "PGE%d\tEQU\t*\n", mvs_page_num);
        fprintf (assembler_source, "\tDROP\t%d\n", BASE_REGISTER);
        mvs_page_num++;
!       /* Safe to use BASR not BALR, since we are
!        * not switching addressing mode here ...  */
!       fprintf (assembler_source, "\tBASR\t%d,0\n", BASE_REGISTER);
!       fprintf (assembler_source, "PG%d\tEQU\t*\n", mvs_page_num);
        fprintf (assembler_source, "\tUSING\t*,%d\n", BASE_REGISTER);
        mvs_page_code = code;
        mvs_page_lit = lit;
        return 1;
--- 796,817 ----
  
    if (mvs_page_code + code + mvs_page_lit + lit > MAX_MVS_PAGE_LENGTH)
      {
!       /* no need to dump literals if we're at the end of
!          a case statement - they will already have been 
! 	 dumped prior to the jump table generation. */
!       if (mvs_case_code == 0)
!         {
! 	  fprintf (assembler_source, "\tB\t@@PGE%d\n", mvs_page_num);
! 	  fprintf (assembler_source, "\tDS\t0F\n");
! 	  fprintf (assembler_source, "\tLTORG\n");
! 	}
        fprintf (assembler_source, "\tDS\t0F\n");
!       fprintf (assembler_source, "@@PGE%d\tEQU\t*\n", mvs_page_num);
        fprintf (assembler_source, "\tDROP\t%d\n", BASE_REGISTER);
        mvs_page_num++;
!       fprintf (assembler_source, "\tBALR\t%d,0\n", BASE_REGISTER);
        fprintf (assembler_source, "\tUSING\t*,%d\n", BASE_REGISTER);
+       fprintf (assembler_source, "@@PG%d\tEQU\t*\n", mvs_page_num);
        mvs_page_code = code;
        mvs_page_lit = lit;
        return 1;
***************
*** 791,797 ****
  #endif /* TARGET_HLASM */
  
  
! #ifdef TARGET_ELF_ABI
  int
  mvs_check_page (file, code, lit)
       FILE *file;
--- 823,829 ----
  #endif /* TARGET_HLASM */
  
  
! #ifdef TARGET_LINUX
  int
  mvs_check_page (file, code, lit)
       FILE *file;
***************
*** 802,827 ****
  
    if (mvs_page_code + code + mvs_page_lit + lit > MAX_MVS_PAGE_LENGTH)
      {
!       /* hop past the literal pool */
!       fprintf (assembler_source, "\tB\t.LPGE%d\n", mvs_page_num);
! 
!       /* dump the literal pool. The .baligns are optional, since 
!        * ltorg will align to the size of the largest literal 
!        * (which is possibly 8 bytes) */
!       fprintf (assembler_source, "\t.balign\t4\n");
!       fprintf (assembler_source, "\t.LTORG\n");
!       fprintf (assembler_source, "\t.balign\t4\n");
! 
!       /* we continue execution here ...  */
!       fprintf (assembler_source, ".LPGE%d:\n", mvs_page_num);
!       fprintf (assembler_source, "\t.DROP\t%d\n", BASE_REGISTER);
!       mvs_page_num++;
! 
!       /* BASR puts the contents of the PSW into r3
!        * that is, r3 will be loaded with the address of "." */
!       fprintf (assembler_source, "\tBASR\tr%d,0\n", BASE_REGISTER);
!       fprintf (assembler_source, ".LPG%d:\n", mvs_page_num);
!       fprintf (assembler_source, "\t.USING\t.,r%d\n", BASE_REGISTER);
        mvs_page_code = code;
        mvs_page_lit = lit;
        return 1;
--- 834,894 ----
  
    if (mvs_page_code + code + mvs_page_lit + lit > MAX_MVS_PAGE_LENGTH)
      {
!       if (i370_enable_pic) 
!         {
!           /* Dump the literal pool. The .baligns are optional, since 
!              ltorg will align to the size of the largest literal 
!              (which is possibly 8 bytes) */
!           fprintf (assembler_source, ".data\n"
!                                      "\t.balign\t4\n"
!                                      ".LPOOL%d:\n"
!                                      "\t.ltorg\n"
!                                      "\t.drop\tr%d\n"
!                                      "\t.using\t.LPOOL%d,r%d\n"
!                                      ".previous\n", 
!                    mvs_page_num, PIC_BASE_REGISTER, 
!                    mvs_page_num+1, PIC_BASE_REGISTER);
!     
!     
!           /* we continue execution here ...  */
!           fprintf (assembler_source, ".LPGE%d:\n", mvs_page_num);
!           fprintf (assembler_source, "\t.drop\tr%d\n",
!                                       BASE_REGISTER);
!           mvs_page_num++;
!     
!           /* BASR puts the contents of the PSW into r3
!              that is, r3 will be loaded with the address of "." 
!              We also put location of new literal pool into r12 */
!           fprintf (assembler_source, "\tBASR\tr%d,0\n", BASE_REGISTER);
!           fprintf (assembler_source, ".LPG%d:\n", mvs_page_num);
!           fprintf (assembler_source, "\t.using\t.,r%d\n", BASE_REGISTER);
!           fprintf (assembler_source, "\tL\tr%d,%d(,r%d)\n", PIC_BASE_REGISTER,
!                (mvs_page_num - function_base_page) * 8 + 4, PAGE_REGISTER);
!     
!         }
!       else
!         {
!           /* hop past the literal pool */
!           fprintf (assembler_source, "\tB\t.LPGE%d\n", mvs_page_num);
!     
!           /* dump the literal pool. The .baligns are optional, since
!            * ltorg will align to the size of the largest literal
!            * (which is possibly 8 bytes) */
!           fprintf (assembler_source, "\t.balign\t4\n");
!           fprintf (assembler_source, "\t.LTORG\n");
!           fprintf (assembler_source, "\t.balign\t4\n");
!     
!           /* we continue execution here ...  */
!           fprintf (assembler_source, ".LPGE%d:\n", mvs_page_num);
!           fprintf (assembler_source, "\t.drop\t%d\n", BASE_REGISTER);
!           mvs_page_num++;
!     
!           /* BASR puts the contents of the PSW into r3
!            * that is, r3 will be loaded with the address of "." */
!           fprintf (assembler_source, "\tBASR\tr%d,0\n", BASE_REGISTER);
!           fprintf (assembler_source, ".LPG%d:\n", mvs_page_num);
!           fprintf (assembler_source, "\t.using\t.,r%d\n", BASE_REGISTER);
!         }
        mvs_page_code = code;
        mvs_page_lit = lit;
        return 1;
***************
*** 830,836 ****
    mvs_page_lit += lit;
    return 0;
  }
! #endif /* TARGET_ELF_ABI */
  
  /* ===================================================== */
  /* defines and functions specific to the HLASM assembler */
--- 897,903 ----
    mvs_page_lit += lit;
    return 0;
  }
! #endif /* TARGET_LINUX */
  
  /* ===================================================== */
  /* defines and functions specific to the HLASM assembler */
***************
*** 844,849 ****
--- 911,917 ----
  mvs_function_check (name)
       const char *name;
  {
+ #ifdef TARGET_LE
    int lower, middle, upper;
    int i;
  
***************
*** 860,871 ****
        else
  	lower = middle + 1;
      }
    return 0;
  }
  
  /* Generate a hash for a given key.  */
  
! #ifdef LONGEXTERNAL
  static int
  mvs_hash_alias (key)
       const char *key;
--- 928,940 ----
        else
  	lower = middle + 1;
      }
+ #endif
    return 0;
  }
  
  /* Generate a hash for a given key.  */
  
! #ifdef TARGET_ALIASES
  static int
  mvs_hash_alias (key)
       const char *key;
***************
*** 874,882 ****
    int i;
    int l = strlen (key);
  
!   h = key[0];
    for (i = 1; i < l; i++)
!     h = ((h * MVS_SET_SIZE) + key[i]) % MVS_HASH_PRIME;
    return (h);
  }
  #endif
--- 943,951 ----
    int i;
    int l = strlen (key);
  
!   h = (unsigned char) MAP_OUTCHAR(key[0]);
    for (i = 1; i < l; i++)
!     h = ((h * MVS_SET_SIZE) + (unsigned char) MAP_OUTCHAR(key[i])) % MVS_HASH_PRIME;
    return (h);
  }
  #endif
***************
*** 891,896 ****
--- 960,971 ----
  {
    alias_node_t *ap;
  
+ #ifdef DEBUG
+   printf("mvs_add_alias: realname(%d) = '%s'\n", strlen(realname), realname);
+   printf("   aliasname(%d) = '%s'\n", strlen(aliasname), aliasname);
+   printf("   emitted = %d\n", emitted);
+ #endif
+ 
    ap = (alias_node_t *) xmalloc (sizeof (alias_node_t));
    if (strlen (realname) > MAX_LONG_LABEL_SIZE)
      {
***************
*** 906,911 ****
--- 981,987 ----
    strcpy (ap->real_name, realname);
    strcpy (ap->alias_name, aliasname);
    ap->alias_emitted = emitted;
+   ap->alias_used = 0 /* FALSE */;
    ap->alias_next = alias_anchor;
    alias_anchor = ap;
  }
***************
*** 921,926 ****
--- 997,1009 ----
  {
     int i, j = strlen (realname);
  
+ #ifdef DEBUG
+   printf("mvs_need_alias: realname(%d) = '%s'\n", strlen(realname), realname);
+ #endif
+ 
+ #if defined(TARGET_DIGNUS) || defined(TARGET_PDPMAC)
+    return 1;
+ #else
     if (mvs_function_check (realname))
       return 0;
  #if 0
***************
*** 951,956 ****
--- 1034,1086 ----
       }
  
     return 0;
+ #endif
+ }
+ 
+ /* Mark an alias as used as an external.  */
+ 
+ int
+ mvs_mark_alias (realname)
+    const char *realname;
+ {
+   alias_node_t *ap;
+ 
+ #ifdef DEBUG
+   printf("mvs_mark_alias: realname(%d) = '%s'\n", strlen(realname), realname);
+ #endif
+ 
+   for (ap = alias_anchor; ap; ap = ap->alias_next)
+     {
+       if (!strcmp (ap->real_name, realname))
+ 	{
+ 	  ap->alias_used = 1;
+ 	  return 0;
+ 	}
+     }
+   return 1;
+ }
+ 
+ /* Dump any used aliases that have been emitted.  */
+ 
+ int
+ mvs_dump_alias(FILE *f)
+ {
+   alias_node_t *ap;
+ 
+ #ifdef DEBUG
+   printf("mvs_dump_alias: \n");
+ #endif
+ 
+   for (ap = alias_anchor; ap; ap = ap->alias_next)
+     {
+       if (ap->alias_used && !ap->alias_emitted)
+ 	{
+ 	  fprintf (f, "%s\tALIAS\tC'%s'\n",
+ 	     ap->alias_name,
+ 	     ap->real_name);
+ 	}
+     }
+   return 0;
  }
  
  /* Get the alias from the list. 
***************
*** 961,969 ****
       const char *realname;
       char *aliasname;
  {
- #ifdef LONGEXTERNAL
    alias_node_t *ap;
  
    for (ap = alias_anchor; ap; ap = ap->alias_next)
      {
        if (!strcmp (ap->real_name, realname))
--- 1091,1104 ----
       const char *realname;
       char *aliasname;
  {
    alias_node_t *ap;
  
+ #ifdef DEBUG
+   printf("mvs_get_alias: realname(%d) = '%s'\n", strlen(realname), realname);
+ #endif
+ 
+ #ifdef TARGET_ALIASES
+ 
    for (ap = alias_anchor; ap; ap = ap->alias_next)
      {
        if (!strcmp (ap->real_name, realname))
***************
*** 1006,1014 ****
       const char *realname;
       char *aliasname;
  {
- #ifdef LONGEXTERNAL
    alias_node_t *ap;
  
    for (ap = alias_anchor; ap; ap = ap->alias_next)
      {
        if (!strcmp (ap->real_name, realname))
--- 1141,1154 ----
       const char *realname;
       char *aliasname;
  {
    alias_node_t *ap;
  
+ #ifdef DEBUG
+   printf("mvs_check_alias: realname(%d) = '%s'\n", strlen(realname), realname);
+ #endif
+ 
+ #ifdef TARGET_ALIASES
+ 
    for (ap = alias_anchor; ap; ap = ap->alias_next)
      {
        if (!strcmp (ap->real_name, realname))
***************
*** 1046,1057 ****
    return 0;
  }
  
- /* defines and functions specific to the HLASM assembler */
  #endif /* TARGET_HLASM */
  /* ===================================================== */
  /* ===================================================== */
  /* defines and functions specific to the gas assembler */
! #ifdef TARGET_ELF_ABI
  
  /* Check for C/370 runtime function, they don't use standard calling
     conventions.  True is returned if the function is in the table.
--- 1186,1197 ----
    return 0;
  }
  
  #endif /* TARGET_HLASM */
+ 
  /* ===================================================== */
  /* ===================================================== */
  /* defines and functions specific to the gas assembler */
! #ifdef TARGET_LINUX
  
  /* Check for C/370 runtime function, they don't use standard calling
     conventions.  True is returned if the function is in the table.
***************
*** 1065,1071 ****
     return 0;
  }
  
! #endif /* TARGET_ELF_ABI */
  /* ===================================================== */
  
  
--- 1205,1211 ----
     return 0;
  }
  
! #endif /* TARGET_LINUX */
  /* ===================================================== */
  
  
***************
*** 1157,1180 ****
     arithmetic insn's set the condition code as well.
  
     The unsigned_jump_follows_p() routine  returns a 1 if the next jump 
!    is unsigned.  INSN is the current instruction.  */
  
  int
  unsigned_jump_follows_p (insn)
       register rtx insn;
  {
    rtx orig_insn = insn;
    while (1) 
      {
        register rtx tmp_insn;
        enum rtx_code coda;
    
        insn = NEXT_INSN (insn);
!       if (!insn) fatal_insn ("internal error--no jump follows compare:", orig_insn);
    
        if (GET_CODE (insn) != JUMP_INSN) continue;
      
!       tmp_insn = XEXP (insn, 3);
        if (GET_CODE (tmp_insn) != SET) continue;
      
        if (GET_CODE (XEXP (tmp_insn, 0)) != PC) continue;
--- 1297,1323 ----
     arithmetic insn's set the condition code as well.
  
     The unsigned_jump_follows_p() routine  returns a 1 if the next jump 
!    is unsigned.  INSN is the current instruction. We err on the side
!    of assuming unsigned, so there are a lot of return 1. */
  
  int
  unsigned_jump_follows_p (insn)
       register rtx insn;
  {
    rtx orig_insn = insn;
+ 
    while (1) 
      {
        register rtx tmp_insn;
        enum rtx_code coda;
    
        insn = NEXT_INSN (insn);
!       if (!insn) return (1);
    
        if (GET_CODE (insn) != JUMP_INSN) continue;
      
!       tmp_insn = PATTERN (insn);
!       if (!tmp_insn) continue;
        if (GET_CODE (tmp_insn) != SET) continue;
      
        if (GET_CODE (XEXP (tmp_insn, 0)) != PC) continue;
***************
*** 1186,1191 ****
--- 1329,1374 ----
        tmp_insn = XEXP (tmp_insn, 0);
        coda = GET_CODE (tmp_insn);
    
+       /* if we get an equal or not equal, either comparison
+          will work. What we're really interested in what happens
+          after that. So check one more instruction to see if
+          anything comes up. */
+          
+       if ((coda == EQ) || (coda == NE))
+         {
+           insn = NEXT_INSN (insn);
+           if (!insn) return (1);
+   
+           if (GET_CODE (insn) != JUMP_INSN)
+           {
+               /* skip any labels or notes or non-branching
+                  instructions, looking to see if there's a
+                  branch ahead */
+               while (GET_CODE (insn) != JUMP_INSN)
+               {
+                   if ((GET_CODE (insn) != CODE_LABEL)
+                       && (GET_CODE (insn) != NOTE)
+                       && (GET_CODE (insn) != INSN)
+                       && (GET_CODE (insn) != JUMP_INSN)) return (1);
+                   insn = NEXT_INSN (insn);
+                   if (!insn) return (1);
+               }
+           }
+     
+           tmp_insn = PATTERN (insn);
+           if (!tmp_insn) continue;
+           if (GET_CODE (tmp_insn) != SET) return (1);
+     
+           if (GET_CODE (XEXP (tmp_insn, 0)) != PC) return (1);
+     
+           tmp_insn = XEXP (tmp_insn, 1);
+           if (GET_CODE (tmp_insn) != IF_THEN_ELSE) return (1);
+     
+           tmp_insn = XEXP (tmp_insn, 0);
+           coda = GET_CODE (tmp_insn);
+         }
+ 
+       /* if we got to here, this instruction is a jump.  Is it signed? */
        return coda != GE && coda != GT && coda != LE && coda != LT;
      }
  }
***************
*** 1202,1217 ****
--- 1385,1403 ----
       int aligned_p;
  {
    const char *int_format = NULL;
+   int intmask;
  
    if (aligned_p)
      switch (size)
        {
        case 1:
  	int_format = "\tDC\tX'%02X'\n";
+ 	intmask = 0xFF;
  	break;
  
        case 2:
  	int_format = "\tDC\tX'%04X'\n";
+ 	intmask = 0xFFFF;
  	break;
  
        case 4:
***************
*** 1223,1229 ****
  	  }
  	else
  	  {
! 	    fputs ("\tDC\tA(", asm_out_file);
  	    output_addr_const (asm_out_file, x);
  	    fputs (")\n", asm_out_file);
  	  }
--- 1409,1453 ----
  	  }
  	else
  	  {
!             if (GET_CODE (x) == CONST			
!   	      && GET_CODE (XEXP (XEXP (x, 0), 0)) == SYMBOL_REF	
! 	      && SYMBOL_REF_FLAG (XEXP (XEXP (x, 0), 0)))
!               {
!                 const char *fname;
!                 typedef struct _entnod { 
!                     char *data; 
!                     struct _entnod *next; 
!                     } entnod;
!                 static entnod *enstart = NULL;
!                 entnod **en;
!                 
!                 fname = XSTR((XEXP (XEXP (x, 0), 0)), 0);
!                 en = &enstart;
!                 while (*en != NULL)
!                 {
!                     if (strcmp((*en)->data, fname) == 0) break;
!                     en = &((*en)->next);
!                 }
!                 if (*en == NULL)
!                 {
!                     *en = xmalloc(sizeof(entnod));
!                     (*en)->data = xmalloc(strlen(fname) + 1);
!                     strcpy((*en)->data, fname);
!                     (*en)->next = NULL;
!                     fputs ("\tEXTRN\t", asm_out_file);
!                     assemble_name(asm_out_file, 
!                                   XSTR((XEXP (XEXP (x, 0), 0)), 0));
!                     fputs ("\n", asm_out_file);
!                 }                
!               }
!             if (SYMBOL_REF_FLAG(x))
!               {
!                 fputs ("\tDC\tV(", asm_out_file);
!               }
!             else
!               {
!     	        fputs ("\tDC\tA(", asm_out_file);
!               }
  	    output_addr_const (asm_out_file, x);
  	    fputs (")\n", asm_out_file);
  	  }
***************
*** 1232,1238 ****
  
    if (int_format && GET_CODE (x) == CONST_INT)
      {
!       fprintf (asm_out_file, int_format, INTVAL (x));
        return true;
      }
    return default_assemble_integer (x, size, aligned_p);
--- 1456,1462 ----
  
    if (int_format && GET_CODE (x) == CONST_INT)
      {
!       fprintf (asm_out_file, int_format, INTVAL (x) & intmask);
        return true;
      }
    return default_assemble_integer (x, size, aligned_p);
***************
*** 1252,1268 ****
       FILE *f;
       HOST_WIDE_INT l;
  {
! #if MACROPROLOGUE == 1
!   fprintf (f, "* Function %s prologue\n", mvs_function_name);
    fprintf (f, "\tEDCPRLG USRDSAL=%d,BASEREG=%d\n",
! 	   STACK_POINTER_OFFSET + l - 120 +
! 	   current_function_outgoing_args_size, BASE_REGISTER);
! #else /* MACROPROLOGUE != 1 */
    static int function_label_index = 1;
    static int function_first = 0;
    static int function_year, function_month, function_day;
    static int function_hour, function_minute, function_second;
- #if defined(LE370)
    if (!function_first)
      {
        struct tm *function_time;
--- 1476,1550 ----
       FILE *f;
       HOST_WIDE_INT l;
  {
! /* Don't print stack and args in PDPMAC as it makes the
!    comment too long */
! #ifdef TARGET_PDPMAC
!   fprintf (f, "* %c-func %s prologue\n",
!            mvs_need_entry ? 'X' : 'S',
!            CURRFUNC);
! #else
!   fprintf (f, "* Function %s prologue: stack = %d, args = %d\n",
!            mvs_function_name,
! 	   l,
! 	   current_function_outgoing_args_size);
! #endif
! 
!   if (mvs_first_entry)
!     {
! #ifdef TARGET_ALIASES
!       fprintf (f, "@CODE\tALIAS\tC'@%s'\n", mvs_module);
!       fputs ("@CODE\tAMODE\tANY\n", f);
!       fputs ("@CODE\tRMODE\tANY\n", f);
!       fputs ("@CODE\tCSECT\n", f);
! #elif !defined(TARGET_PDPMAC)
!       fprintf (f, "@%s\tCSECT\n", mvs_module);
! #endif
!       mvs_first_entry = 0;
!     }
! #ifdef TARGET_MACROS
! 
! #if defined(TARGET_DIGNUS) || defined(TARGET_PDPMAC)
!   assemble_name (f, mvs_function_name);
! #ifdef TARGET_DIGNUS
!   fprintf (f, "\tDCCPRLG CINDEX=%d,FRAME=%d,BASER=%d,ENTRY=%s\n",
! #endif
! #ifdef TARGET_PDPMAC
!   fprintf (f, "\tPDPPRLG CINDEX=%d,FRAME=%d,BASER=%d,ENTRY=%s\n",
! #endif
! 	   mvs_page_num,
! 	   STACK_FRAME_BASE + l + current_function_outgoing_args_size,
! 	   BASE_REGISTER,
! 	   mvs_need_entry ? "YES" : "NO");
!   fprintf (f, "\tB\t@@FEN%d\n", mvs_page_num);
! #ifdef TARGET_DIGNUS
!   fprintf (f, "@FRAMESIZE_%d DC F'%d'\n", 
! 	   mvs_page_num,
! 	   STACK_FRAME_BASE + l + current_function_outgoing_args_size);
! #endif
! #ifdef TARGET_PDPMAC
!   fprintf (f, "\tLTORG\n");
! #endif
!   fprintf (f, "@@FEN%d\tEQU\t*\n", mvs_page_num);
!   fprintf (f, "\tDROP\t%d\n", BASE_REGISTER);
!   fprintf (f, "\tBALR\t%d,0\n", BASE_REGISTER);
!   fprintf (f, "\tUSING\t*,%d\n", BASE_REGISTER);
! #endif
! 
! #ifdef TARGET_LE
!   assemble_name (f, mvs_function_name);
    fprintf (f, "\tEDCPRLG USRDSAL=%d,BASEREG=%d\n",
! 	   STACK_FRAME_BASE + l + current_function_outgoing_args_size,
! 	   BASE_REGISTER);
! #endif
! 
! #else /* TARGET_MACROS != 1 */
! 
! #if defined(TARGET_LE)
! {
    static int function_label_index = 1;
    static int function_first = 0;
    static int function_year, function_month, function_day;
    static int function_hour, function_minute, function_second;
    if (!function_first)
      {
        struct tm *function_time;
***************
*** 1276,1282 ****
        function_minute = function_time->tm_min;
        function_second = function_time->tm_sec;
      }
-   fprintf (f, "* Function %s prologue\n", mvs_function_name);
    fprintf (f, "FDSE%03d\tDSECT\n", function_label_index);
    fprintf (f, "\tDS\tD\n");
    fprintf (f, "\tDS\tCL(%d)\n", STACK_POINTER_OFFSET + l
--- 1558,1563 ----
***************
*** 1288,1297 ****
    fprintf (f, "FDSL%03d\tEQU\t*-FDSE%03d-8\n", function_label_index,
  	   function_label_index);
    fprintf (f, "\tDS\t0H\n");
!   assemble_name (f, mvs_function_name);
!   fprintf (f, "\tCSECT\n");
    fprintf (f, "\tUSING\t*,15\n");
!   fprintf (f, "\tB\tFENT%03d\n", function_label_index);
    fprintf (f, "\tDC\tAL1(FNAM%03d+4-*)\n", function_label_index);
    fprintf (f, "\tDC\tX'CE',X'A0',AL1(16)\n");
    fprintf (f, "\tDC\tAL4(FPPA%03d)\n", function_label_index);
--- 1569,1582 ----
    fprintf (f, "FDSL%03d\tEQU\t*-FDSE%03d-8\n", function_label_index,
  	   function_label_index);
    fprintf (f, "\tDS\t0H\n");
! #ifdef TARGET_ALIASES
!   fprintf (f, "@CODE\tCSECT\n");
! #else
!   fprintf (f, "@%s\tCSECT\n", mvs_module);
! #endif
    fprintf (f, "\tUSING\t*,15\n");
!   assemble_name (f, mvs_function_name);
!   fprintf (f, "\tB\t@@FENT%03d\n", function_label_index);
    fprintf (f, "\tDC\tAL1(FNAM%03d+4-*)\n", function_label_index);
    fprintf (f, "\tDC\tX'CE',X'A0',AL1(16)\n");
    fprintf (f, "\tDC\tAL4(FPPA%03d)\n", function_label_index);
***************
*** 1310,1316 ****
    		 function_year, function_month, function_day,
      		 function_hour, function_minute);
    fprintf (f, "\tDC\tCL2'01',CL4'0100'\n");
!   fprintf (f, "FENT%03d\tDS\t0H\n", function_label_index);
    fprintf (f, "\tSTM\t14,12,12(13)\n");
    fprintf (f, "\tL\t2,76(,13)\n");
    fprintf (f, "\tL\t0,16(,15)\n");
--- 1595,1601 ----
    		 function_year, function_month, function_day,
      		 function_hour, function_minute);
    fprintf (f, "\tDC\tCL2'01',CL4'0100'\n");
!   fprintf (f, "@@FENT%03d\tDS\t0H\n", function_label_index);
    fprintf (f, "\tSTM\t14,12,12(13)\n");
    fprintf (f, "\tL\t2,76(,13)\n");
    fprintf (f, "\tL\t0,16(,15)\n");
***************
*** 1330,1408 ****
    fprintf (f, "\tUSING\t*,%d\n", BASE_REGISTER);
    function_first = 1;
    function_label_index ++;
! #else /* !LE370 */
!   if (!function_first)
!     {
!       struct tm *function_time;
!       time_t lcltime;
!       time (&lcltime);
!       function_time = localtime (&lcltime);
!       function_year = function_time->tm_year + 1900;
!       function_month = function_time->tm_mon + 1;
!       function_day = function_time->tm_mday;
!       function_hour = function_time->tm_hour;
!       function_minute = function_time->tm_min;
!       function_second = function_time->tm_sec;
!       fprintf (f, "PPA2\tDS\t0F\n");
!       fprintf (f, "\tDC\tX'03',X'00',X'33',X'00'\n");
!       fprintf (f, "\tDC\tV(CEESTART),A(0)\n");
!       fprintf (f, "\tDC\tA(CEETIMES)\n");
!       fprintf (f, "CEETIMES\tDS\t0F\n");
!       fprintf (f, "\tDC\tCL4'%d',CL4'%02d%02d',CL6'%02d%02d00'\n",
!     		 function_year, function_month, function_day,
!     		 function_hour, function_minute, function_second);
!       fprintf (f, "\tDC\tCL2'01',CL4'0100'\n");
!     }
!   fprintf (f, "* Function %s prologue\n", mvs_function_name);
!   fprintf (f, "FDSD%03d\tDSECT\n", function_label_index);
!   fprintf (f, "\tDS\tD\n");
!   fprintf (f, "\tDS\tCL(%d)\n", STACK_POINTER_OFFSET + l
! 			+ current_function_outgoing_args_size);
!   fprintf (f, "\tORG\tFDSD%03d\n", function_label_index);
!   fprintf (f, "\tDS\tCL(120+8)\n");
!   fprintf (f, "\tORG\n");
!   fprintf (f, "\tDS\t0D\n");
!   fprintf (f, "FDSL%03d\tEQU\t*-FDSD%03d-8\n", function_label_index,
! 	   function_label_index);
!   fprintf (f, "\tDS\t0H\n");
!   assemble_name (f, mvs_function_name);
!   fprintf (f, "\tCSECT\n");
!   fprintf (f, "\tUSING\t*,15\n");
!   fprintf (f, "\tB\tFPL%03d\n", function_label_index);
!   fprintf (f, "\tDC\tAL1(FPL%03d+4-*)\n", function_label_index + 1);
!   fprintf (f, "\tDC\tX'CE',X'A0',AL1(16)\n");
!   fprintf (f, "\tDC\tAL4(PPA2)\n");
!   fprintf (f, "\tDC\tAL4(0)\n");
!   fprintf (f, "\tDC\tAL4(FDSL%03d)\n", function_label_index);
!   fprintf (f, "FPL%03d\tEQU\t*\n", function_label_index + 1);
!   fprintf (f, "\tDC\tAL2(%d),C'%s'\n", strlen (mvs_function_name),
! 	mvs_function_name);
!   fprintf (f, "FPL%03d\tDS\t0H\n", function_label_index);
!   fprintf (f, "\tSTM\t14,12,12(13)\n");
!   fprintf (f, "\tL\t2,76(,13)\n");
!   fprintf (f, "\tL\t0,16(,15)\n");
!   fprintf (f, "\tALR\t0,2\n");
!   fprintf (f, "\tCL\t0,12(,12)\n");
!   fprintf (f, "\tBNH\t*+10\n");
!   fprintf (f, "\tL\t15,116(,12)\n");
!   fprintf (f, "\tBALR\t14,15\n");
!   fprintf (f, "\tL\t15,72(,13)\n");
!   fprintf (f, "\tSTM\t15,0,72(2)\n");
!   fprintf (f, "\tMVI\t0(2),X'10'\n");
!   fprintf (f, "\tST\t2,8(,13)\n ");
!   fprintf (f, "\tST\t13,4(,2)\n ");
!   fprintf (f, "\tLR\t13,2\n");
!   fprintf (f, "\tDROP\t15\n");
!   fprintf (f, "\tBALR\t%d,0\n", BASE_REGISTER);
!   fprintf (f, "\tUSING\t*,%d\n", BASE_REGISTER);
!   function_first = 1;
!   function_label_index += 2;
! #endif /* !LE370 */
! #endif /* MACROPROLOGUE */
!   fprintf (f, "PG%d\tEQU\t*\n", mvs_page_num );
    fprintf (f, "\tLR\t11,1\n"); 
!   fprintf (f, "\tL\t%d,=A(PGT%d)\n", PAGE_REGISTER, mvs_page_num);
!   fprintf (f, "* Function %s code\n", mvs_function_name);
  
    mvs_free_label_list ();
    mvs_page_code = 6;
--- 1615,1629 ----
    fprintf (f, "\tUSING\t*,%d\n", BASE_REGISTER);
    function_first = 1;
    function_label_index ++;
! }
! #endif /* TARGET_LE */
! 
! #endif /* TARGET_MACROS */
! 
!   fprintf (f, "@@PG%d\tEQU\t*\n", mvs_page_num );
    fprintf (f, "\tLR\t11,1\n"); 
!   fprintf (f, "\tL\t%d,=A(@@PGT%d)\n", PAGE_REGISTER, mvs_page_num);
!   fprintf (f, "* Function %s code\n", CURRFUNC);
  
    mvs_free_label_list ();
    mvs_page_code = 6;
***************
*** 1416,1440 ****
  #endif /* TARGET_HLASM */
  
  
! #ifdef TARGET_ELF_ABI
  /*
     The 370_function_prolog() routine generates the current ELF ABI ES/390 prolog.
!    It implements a stack that grows downward. 
!    It performs the following steps:
!    -- saves the callers non-volatile registers on the callers stack.
!    -- subtracts stackframe size from the stack pointer.
     -- stores backpointer to old caller stack.
!   
!    XXX hack alert -- if the global var int leaf_function is non-zero, 
!    then this is a leaf, and it might be possible to optimize the prologue
!    into doing even less, e.g. not grabbing a new stackframe or maybe just a
!    partial stack frame.
!   
!    XXX hack alert -- the current stack frame is bloated into twice the 
!    needed size by unused entries. These entries make it marginally 
!    compatible with MVS/OE/USS C environment, but really they're not used
!    and could probably chopped out. Modifications to i370.md would be needed
!    also, to quite using addresses 136, 140, etc.
   */
  
  static void
--- 1637,1668 ----
  #endif /* TARGET_HLASM */
  
  
! #ifdef TARGET_LINUX
  /*
     The 370_function_prolog() routine generates the current ELF ABI ES/390 prolog.
!    There are some provisions for stacks that grow both up and down.  Both
!    were implemented for experimental purposes.  The two differ in subtle ways:
! 
!    The downward growing stack requires the following steps:
!    -- saves the caller's non-volatile registers on the callers stack.
!    -- places callee's arguments in callers stack
!    -- adds the stackframe size to the stack/frame pointer.
!    -- optionally sets up a frame pointer
     -- stores backpointer to old caller stack.
! 
!    The upward growing stack performs the following:
!    -- saves the caller's non-volatile registers on the callee's stack.
!    -- places callee's arguments in callee's stack
!    -- adds the stackframe size to the stack pointer.
!    -- callers stack pointer becomes calee's frame pointer.
!    -- stores backpointer to old caller stack.
! 
!    Note that with the upwards growing stack, we pass args on the callee's
!    stack.  As a result, we don't know a-priori how many arguments there 
!    will be.  We make a worse case assumption and hard-code room for 128 
!    args (== I370_VARARGS_AREA_SIZE/4).  This hard-coded limit seems to 
!    be a reasonable tradeoff for the otherwise much simplified and speedier
!    design.
   */
  
  static void
***************
*** 1446,1503 ****
    static int function_first = 0;
    int stackframe_size, aligned_size;
  
!   fprintf (f, "# Function prologue\n");
!   /* define the stack, put it into its own data segment
!      FDSE == Function Stack Entry
!      FDSL == Function Stack Length */
    stackframe_size = 
       STACK_POINTER_OFFSET + current_function_outgoing_args_size + frame_size;
    aligned_size = (stackframe_size + 7) >> 3;
    aligned_size <<= 3;
    
    fprintf (f, "# arg_size=0x%x frame_size=0x%x aligned size=0x%x\n", 
!      current_function_outgoing_args_size, frame_size, aligned_size);
! 
!   fprintf (f, "\t.using\t.,r15\n");
! 
!   /* Branch to exectuable part of prologue.  */
!   fprintf (f, "\tB\t.LFENT%03d\n", function_label_index);
  
!   /* write the length of the stackframe */
!   fprintf (f, "\t.long\t%d\n", aligned_size);
! 
!   /* FENT == function prologue entry */
!   fprintf (f, "\t.balign 2\n.LFENT%03d:\n",
!               function_label_index);
! 
!   /* store multiple registers 14,15,0,...12 at 12 bytes from sp */
!   fprintf (f, "\tSTM\tr14,r12,12(sp)\n");
  
!   /* r3 == saved callee stack pointer */
!   fprintf (f, "\tLR\tr3,sp\n");
  
!   /* 4(r15) == stackframe size */
!   fprintf (f, "\tSL\tsp,4(,r15)\n");
  
!   /* r11 points to arg list in callers stackframe; was passed in r2 */
!   fprintf (f, "\tLR\tr11,r2\n");
  
!   /* store callee stack pointer at 8(sp) */
!   /* fprintf (f, "\tST\tsp,8(,r3)\n ");  wasted cycles, no one uses this ...  */
  
!   /* backchain -- store caller sp at 4(callee_sp)  */
!   fprintf (f, "\tST\tr3,4(,sp)\n ");
  
!   fprintf (f, "\t.drop\tr15\n");
!   /* Place contents of the PSW into r3
!      that is, place the address of "." into r3 */
!   fprintf (f, "\tBASR\tr%d,0\n", BASE_REGISTER);
!   fprintf (f, "\t.using\t.,r%d\n", BASE_REGISTER);
    function_first = 1;
    function_label_index ++;
  
!   fprintf (f, ".LPG%d:\n", mvs_page_num  );
!   fprintf (f, "\tL\tr%d,=A(.LPGT%d)\n", PAGE_REGISTER, mvs_page_num);
    fprintf (f, "# Function code\n");
  
    mvs_free_label_list ();
--- 1674,1785 ----
    static int function_first = 0;
    int stackframe_size, aligned_size;
  
!   /* store stack size where we can get to it */
! #ifdef STACK_GROWS_DOWNWARDS 
    stackframe_size = 
       STACK_POINTER_OFFSET + current_function_outgoing_args_size + frame_size;
+ #else /* STACK_GROWS_DOWNWARDS */
+   stackframe_size = 
+      STACK_POINTER_OFFSET + current_function_args_size + frame_size;
+   if (current_function_varargs || current_function_stdarg) 
+     {
+       stackframe_size += I370_VARARGS_AREA_SIZE;
+     }
+ #endif /* STACK_GROWS_DOWNWARDS */
    aligned_size = (stackframe_size + 7) >> 3;
    aligned_size <<= 3;
    
    fprintf (f, "# arg_size=0x%x frame_size=0x%x aligned size=0x%x\n", 
!      current_function_args_size, frame_size, aligned_size);
!   fprintf (f, "# varargs=%d stdarg=%d rserved area size=0x%x\n", 
!      current_function_varargs, current_function_stdarg, I370_VARARGS_AREA_SIZE);
! 
! #ifdef STACK_GROWS_DOWNWARDS 
!   /* If you want your stack to grow down, you will need to create this piece. */
! #else /* STACK_GROWS_DOWNWARDS */
!   if (i370_enable_pic)
!     {
!       /* Use register 12 as base register for addressing into the data section. */
!       fprintf (f, "# Function %s data segment PIC glue \n"
!                   ".data\n"
!                   "\t.balign 4\n"
!                   "%s:\n"
!                   "\tST\tr12,68(,r11)\n"
!                   "\tL\tr12,12(,r15)\n"
!                   "\tBR\tr12\n"
!                   "\t.short\t0\n"
!                   "\t.long\t%s.textentry\n"
!                   "\t.long\t.LPOOL%d\n"
!                   "\t.long\t%d\n"
!                   "\t.long\t.LPGT%d\n"
!                   "\t.using\t.LPOOL%d,r12\n"
!                   ".previous\n"
!                   "# Function %s prologue \n"
!                   "%s.textentry:\n",
!                mvs_function_name,
!                mvs_function_name, mvs_function_name,
!                mvs_page_num, aligned_size, mvs_page_num, mvs_page_num,
!                mvs_function_name, mvs_function_name);
  
!       /* store multiple registers 13,15,0,...11 at 8 bytes from sp */
!       fprintf (f, "\tSTM\tr13,r11,8(r11)\n");
!     
!       /* load frame, arg pointer from callers top-of-stack */
!       fprintf (f, "\tLR\tr13,r11\n");
!    
!       /* bump stack pointer by 20(r15) == stackframe size */
!       fprintf (f, "\tA\tr11,20(,r15)\n");
  
!       /* 16(r15) == PIC pool pointer (pointer to literals in data section */
!       fprintf (f, "\tL\tr12,16(,r15)\n");
  
!       /* r4 will be the pointer to the code page pool for this function */
!       fprintf (f, "\tL\tr4,24(,r15)\n");
!     }
!   else 
!     {
!       fprintf (f, "%s:\n"
!                   "# Function prologue\n"
!                   "\t.using\t.,r15\n", mvs_function_name);
!     
!       /* Branch to exectuable part of prologue.  */
!       fprintf (f, "\tB\t.LFENT%06d\n", function_label_index);
!     
!       /* write the length of the stackframe */
!       fprintf (f, "\t.long\t%d\n", aligned_size);
!     
!       /* write the code page table pointer */
!       fprintf (f, "\t.long\t.LPGT%d\n", mvs_page_num);
  
!       fprintf (f, "\t.drop\tr15\n");
  
!       /* FENT == function prologue entry */
!       fprintf (f, "\t.balign 2\n.LFENT%06d:\n", function_label_index);
!     
!       /* store multiple registers 13,14,...12 at 8 bytes from sp */
!       fprintf (f, "\tSTM\tr13,r12,8(r11)\n");
!     
!       /* r13 == callee frame ptr == callee arg ptr == caller stack ptr */
!       fprintf (f, "\tLR\tr13,r11\n");
!     
!       /* r11 == callee top-of-stack pointer = caller sp + stackframe size */
!       fprintf (f, "\tA\tr11,4(,r15)\n");
  
!       /* r4 will be the pointer to the code page pool for this function */
!       fprintf (f, "\tL\tr4,8(,r15)\n");
!     }
! #endif /* STACK_GROWS_DOWNWARDS */
  
!   /* r3 will be the base register for this code page.
!      That is, place the address of "." into r3 */
!   fprintf (f, "\tBASR\tr3,0\n");
!   fprintf (f, "\t.using\t.,r3\n");
!   fprintf (f, ".LPG%d:\n", mvs_page_num  );
    function_first = 1;
    function_label_index ++;
  
!   /* Store the code page pool off of the frame pointer for easy access. */
!   fprintf (f, "\tST\tr4,0(r13)\n");
    fprintf (f, "# Function code\n");
  
    mvs_free_label_list ();
***************
*** 1509,1515 ****
    /* find all labels in this routine */
    i370_label_scan ();
  }
! #endif /* TARGET_ELF_ABI */
  
  /* This function generates the assembly code for function exit.
     Args are as for output_function_prologue ().
--- 1791,1797 ----
    /* find all labels in this routine */
    i370_label_scan ();
  }
! #endif /* TARGET_LINUX */
  
  /* This function generates the assembly code for function exit.
     Args are as for output_function_prologue ().
***************
*** 1528,1556 ****
  
    check_label_emit ();
    mvs_check_page (file, 14, 0);
!   fprintf (file, "* Function %s epilogue\n", mvs_function_name);
    mvs_page_num++;
  
! #if MACROEPILOGUE == 1
    fprintf (file, "\tEDCEPIL\n");
! #else /* MACROEPILOGUE != 1 */
    fprintf (file, "\tL\t13,4(,13)\n");
    fprintf (file, "\tL\t14,12(,13)\n");
    fprintf (file, "\tLM\t2,12,28(13)\n");
    fprintf (file, "\tBALR\t1,14\n");
    fprintf (file, "\tDC\tA(");
    assemble_name (file, mvs_function_name);
    fprintf (file, ")\n" );
! #endif /* MACROEPILOGUE */
  
!   fprintf (file, "* Function %s literal pool\n", mvs_function_name);
    fprintf (file, "\tDS\t0F\n" );
    fprintf (file, "\tLTORG\n");
!   fprintf (file, "* Function %s page table\n", mvs_function_name);
    fprintf (file, "\tDS\t0F\n");
!   fprintf (file, "PGT%d\tEQU\t*\n", function_base_page);
  
    mvs_free_label_list();
    for (i = function_base_page; i < mvs_page_num; i++)
!     fprintf (file, "\tDC\tA(PG%d)\n", i);
  }
--- 1810,1983 ----
  
    check_label_emit ();
    mvs_check_page (file, 14, 0);
!   fprintf (file, "* Function %s epilogue\n", CURRFUNC);
    mvs_page_num++;
  
! #ifdef TARGET_MACROS
! 
! #ifdef TARGET_DIGNUS
!   fprintf (file, "\tDCCEPIL\n");
! #endif
! #ifdef TARGET_PDPMAC
!   fprintf (file, "\tPDPEPIL\n");
! #endif
! #ifdef TARGET_LE
    fprintf (file, "\tEDCEPIL\n");
!   fprintf (file, "\tDROP\t%d\n", BASE_REGISTER);
! #endif
! 
! #else /* !TARGET_MACROS */
! 
! #ifdef TARGET_LE
    fprintf (file, "\tL\t13,4(,13)\n");
    fprintf (file, "\tL\t14,12(,13)\n");
    fprintf (file, "\tLM\t2,12,28(13)\n");
    fprintf (file, "\tBALR\t1,14\n");
+   fprintf (file, "\tDROP\t%d\n", BASE_REGISTER);
    fprintf (file, "\tDC\tA(");
    assemble_name (file, mvs_function_name);
    fprintf (file, ")\n" );
! #endif
! 
! #endif /* TARGET_MACROS */
  
!   fprintf (file, "* Function %s literal pool\n", CURRFUNC);
    fprintf (file, "\tDS\t0F\n" );
    fprintf (file, "\tLTORG\n");
!   fprintf (file, "* Function %s page table\n", CURRFUNC);
    fprintf (file, "\tDS\t0F\n");
!   fprintf (file, "@@PGT%d\tEQU\t*\n", function_base_page);
  
    mvs_free_label_list();
    for (i = function_base_page; i < mvs_page_num; i++)
!     fprintf (file, "\tDC\tA(@@PG%d)\n", i);
!   mvs_need_entry = 0;
! }
! 
! 
! #if defined(PUREISO) && !defined(NO_DETAB)
! 
! #undef fputs
! #undef fprintf
! #undef vfprintf
! #undef fwrite
! #undef fputc
! 
! int
! t_fputs (const char *str, FILE *file)
! {
!     t_fprintf(file, "%s", str);
!     if (ferror(file)) return (EOF);
!     else return (0);
! }
! 
! size_t
! t_fwrite (const void *ptr, size_t size, size_t nmemb, FILE *file)
! {
!     size_t tot;
!     
!     tot = size * nmemb;
!     t_fprintf(file, "%.*s", tot, ptr);
!     return (nmemb);
! }
! 
! int
! t_fprintf (FILE *file, const char *format, ...)
! {
!     va_list arg;
!     int ret;
! 
!     va_start(arg, format);
!     ret = t_vfprintf(file, format, arg);
!     va_end(arg);
!     return (ret);
! }
! 
! static int ocnt = 0;
! static char obuf[MAX_LEN_OUT];
! 
! int
! t_fputc (int c, FILE *file)
! {
!     if (c == '\t')
!     {
!         if (ocnt < 9)
!         {
!             for (; ocnt < 9; ocnt++)
!             {
!                 obuf[ocnt] = ' ';
!             }
!         }
!         else if (ocnt < 15)
!         {
!             for (; ocnt < 15; ocnt++)
!             {
!                 obuf[ocnt] = ' ';
!             }
!         }
!         else
!         {
!             obuf[ocnt] = ' ';
!             ocnt++;
!         }
!     }
!     else if (c == '\n')
!     {
!         t_fprintf(file, "%c", c);
!     }
!     else
!     {
!         obuf[ocnt] = c;
!         ocnt++;
!     }
!     return (c);
! }
! 
! int
! t_vfprintf (FILE *file, const char *format, va_list arg)
! {
!     char buf[MAX_LEN_OUT];
!     int icnt;
! 
!     vsprintf(buf, format, arg);
!     icnt = 0;
!     while (buf[icnt] != '\0')
!     {
!         if (buf[icnt] == '\t')
!         {
!             if (ocnt < 9)
!             {
!                 for (; ocnt < 9; ocnt++)
!                 {
!                     obuf[ocnt] = ' ';
!                 }
!             }
!             else if (ocnt < 15)
!             {
!                 for (; ocnt < 15; ocnt++)
!                 {
!                     obuf[ocnt] = ' ';
!                 }
!             }
!             else
!             {
!                 obuf[ocnt] = ' ';
!                 ocnt++;
!             }
!         }
!         else
!         {
!             obuf[ocnt] = buf[icnt];
!             ocnt++;
!             if (buf[icnt] == '\n')
!             {
!                 fwrite(obuf, ocnt, 1, file);
!                 ocnt = 0;
!             }
!         }
!         icnt++;
!     }
!     return (icnt);
  }
+ 
+ #endif
Index: gcc/gcc/config/i370/i370.h
diff -c gcc/gcc/config/i370/i370.h:1.1.1.1 gcc/gcc/config/i370/i370.h:1.49
*** gcc/gcc/config/i370/i370.h:1.1.1.1	Wed Feb 15 21:22:45 2006
--- gcc/gcc/config/i370/i370.h	Mon Apr 03 00:22:34 2017
***************
*** 3,9 ****
     Free Software Foundation, Inc.
     Contributed by Jan Stein (jan@cd.chalmers.se).
     Modified for OS/390 LanguageEnvironment C by Dave Pitts (dpitts@cozx.com)
!    Hacked for Linux-ELF/390 by Linas Vepstas (linas@linas.org)
  
  This file is part of GNU CC.
  
--- 3,9 ----
     Free Software Foundation, Inc.
     Contributed by Jan Stein (jan@cd.chalmers.se).
     Modified for OS/390 LanguageEnvironment C by Dave Pitts (dpitts@cozx.com)
!    Modified for Linux-ELF/390 by Linas Vepstas (linas@linas.org)
  
  This file is part of GNU CC.
  
***************
*** 32,37 ****
--- 32,47 ----
  
  extern int mvs_page_code, mvs_page_lit;
  
+ /* The length of code used by case labels */
+ 
+ extern int mvs_case_code;
+ 
+ /* Specify that we need to be an entry point.  */
+ 
+ extern int mvs_need_entry;
+ extern int mvs_gotmain;  
+ extern int mvs_need_to_globalize;
+ 
  /* The current page number and the base page number for the function.  */
  
  extern int mvs_page_num, function_base_page;
***************
*** 44,56 ****
--- 54,80 ----
  
  extern int mvs_function_name_length;
  
+ /* The desired CSECT name */
+ 
+ extern char *mvs_csect_name;
+ 
+ /* The source file module.  */
+ 
+ extern char *mvs_module;
+ 
  /* Compile using char instructions (mvc, nc, oc, xc).  On 4341 use this since
     these are more than twice as fast as load-op-store.
     On 3090 don't use this since load-op-store is much faster.  */
  
  #define TARGET_CHAR_INSTRUCTIONS (target_flags & 1)
  
+ /* Compile experimental position independent code */
+ #define TARGET_PIC (target_flags & 2)
+ extern int i370_enable_pic;
+ 
  /* Default target switches */
+ /* This appears to be what switches
+    target char instructions on by default */
  
  #define TARGET_DEFAULT 1
  
***************
*** 62,69 ****
--- 86,109 ----
  #define TARGET_SWITCHES							\
  { { "char-instructions", 1, N_("Generate char instructions")},            \
    { "no-char-instructions", -1, N_("Do not generate char instructions")}, \
+   { "pickax", 2, "Experimental i370 PIC"}, \
+   { "no-pickax", -2, "Disable experimental i370 PIC"}, \
    { "", TARGET_DEFAULT, 0} }
  
+ #define TARGET_OPTIONS \
+ { { "csect=", (const char **)&mvs_csect_name, \
+     N_("Set CSECT name")},     \
+   SUBTARGET_OPTIONS    \
+ }
+ 
+ #define SUBTARGET_OPTIONS
+ 
+ 
+ #define REAL_ARITHMETIC
+ 
+ extern void i370_override_options (void);
+ #define OVERRIDE_OPTIONS i370_override_options()
+ 
  /* To use IBM supplied macro function prologue and epilogue, define the
     following to 1.  Should only be needed if IBM changes the definition
     of their prologue and epilogue.  */
***************
*** 112,118 ****
  
  /* Boundary (in *bits*) on which stack pointer should be aligned.  */
  
! #define STACK_BOUNDARY 32
  
  /* Allocation boundary (in *bits*) for the code of a function.  */
  
--- 152,158 ----
  
  /* Boundary (in *bits*) on which stack pointer should be aligned.  */
  
! #define STACK_BOUNDARY 64
  
  /* Allocation boundary (in *bits*) for the code of a function.  */
  
***************
*** 124,130 ****
  
  /* Alignment of field after `int : 0' in a structure.  */
  
! #define EMPTY_FIELD_BOUNDARY 32
  
  /* Define this if move instructions will actually fail to work when given
     unaligned data.  */
--- 164,170 ----
  
  /* Alignment of field after `int : 0' in a structure.  */
  
! #define EMPTY_FIELD_BOUNDARY 8
  
  /* Define this if move instructions will actually fail to work when given
     unaligned data.  */
***************
*** 140,171 ****
  
  #ifdef TARGET_EBCDIC
  #ifdef HOST_EBCDIC
! #define MAP_CHARACTER(c) ((char)(c))
  #else
! #define MAP_CHARACTER(c) ((char)mvs_map_char (c))
  #endif
  #endif
  
  #ifdef TARGET_HLASM
  /* HLASM requires #pragma map.  */
  #define REGISTER_TARGET_PRAGMAS(PFILE) \
!   cpp_register_pragma (PFILE, 0, "map", i370_pr_map)
  #endif /* TARGET_HLASM */
  
  /* Define maximum length of page minus page escape overhead.  */
  
! #define MAX_MVS_PAGE_LENGTH 4080
  
! /* Define special register allocation order desired.  
!    Don't fiddle with this.  I did, and I got all sorts of register 
!    spill errors when compiling even relatively simple programs...
!    I have no clue why ...
!    E.g. this one is bad:
!    { 0, 1, 2, 9, 8, 7, 6, 5, 10, 15, 14, 12, 3, 4, 16, 17, 18, 19, 11, 13 }
!  */
  
! #define REG_ALLOC_ORDER							\
! { 0, 1, 2, 3, 14, 15, 12, 10, 9, 8, 7, 6, 5, 4, 16, 17, 18, 19, 11, 13 }
  
  /* Standard register usage.  */
  
--- 180,226 ----
  
  #ifdef TARGET_EBCDIC
  #ifdef HOST_EBCDIC
! #define MAP_OUTCHAR(c) (c)
! #define MAP_INCHAR(c) (c)
  #else
! #define MAP_OUTCHAR(c) (ASCTOEBC (c))
! #define MAP_INCHAR(c) (EBCTOASC (c))
! #endif
! #else
! #ifdef HOST_EBCDIC
! #define MAP_OUTCHAR(c) ((char)EBCTOASC (c))
! #define MAP_INCHAR(c) (ASCTOEBC (c))
  #endif
  #endif
  
  #ifdef TARGET_HLASM
  /* HLASM requires #pragma map.  */
  #define REGISTER_TARGET_PRAGMAS(PFILE) \
!   do { \
!   cpp_register_pragma (PFILE, 0, "map", i370_pr_map); \
!   cpp_register_pragma (PFILE, 0, "nomargins", i370_pr_skipit); \
!   cpp_register_pragma (PFILE, 0, "nosequence", i370_pr_skipit); \
!   cpp_register_pragma (PFILE, 0, "checkout", i370_pr_checkout); \
!   cpp_register_pragma (PFILE, 0, "linkage", i370_pr_linkage); \
!   } while(0)
  #endif /* TARGET_HLASM */
  
  /* Define maximum length of page minus page escape overhead.  */
  
! #define MAX_MVS_PAGE_LENGTH 4068
  
! #define PREDICATE_CODES \
!   {"r_or_s_operand", { REG, SUBREG, MEM }}, \
!   {"s_operand", { MEM }},
! 
! /* Conservative page size when considering literals and overhead. */
! 
! #define MVS_PAGE_CONSERVATIVE 4060
  
! /* Define special register allocation order desired. */
! 
! #define REG_ALLOC_ORDER \
!    { 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 10, 15, 14, 12, 16, 17, 18, 19, 11, 13 }
  
  /* Standard register usage.  */
  
***************
*** 183,188 ****
--- 238,244 ----
  
  #define BASE_REGISTER 3
  #define PAGE_REGISTER 4
+ #define PIC_BASE_REGISTER 12
  
  #ifdef TARGET_HLASM
  /* 1 for registers that have pervasive standard uses and are not available
***************
*** 192,204 ****
     they must never be clobbered, and, if clobbered, the register allocator 
     will never restore them back.
     
!    We use five registers in this special way:
     -- R3 which is used as the base register
     -- R4 the page origin table pointer used to load R3,
     -- R11 the arg pointer.  
     -- R12 the TCA pointer
     -- R13 the stack (DSA) pointer
  
     A fifth register is also exceptional: R14 is used in many branch
     instructions to hold the target of the branch.  Technically, this
     does not qualify R14 as a register with a long-term meaning; it should
--- 248,266 ----
     they must never be clobbered, and, if clobbered, the register allocator 
     will never restore them back.
     
!    For the LE/370 mode, we use five registers in this special way:
     -- R3 which is used as the base register
     -- R4 the page origin table pointer used to load R3,
     -- R11 the arg pointer.  
     -- R12 the TCA pointer
     -- R13 the stack (DSA) pointer
  
+    For TARGET_DIGNUS or TARGET_PDPMAC mode:
+    -- R10 the page origin table pointer used to load R3,
+    -- R11 the arg pointer.  
+    -- R12 the base register.
+    -- R13 the stack pointer
+ 
     A fifth register is also exceptional: R14 is used in many branch
     instructions to hold the target of the branch.  Technically, this
     does not qualify R14 as a register with a long-term meaning; it should
***************
*** 225,230 ****
--- 287,331 ----
     I think this is a bug, but I can't track it down...
   */
  
+ #if defined(TARGET_DIGNUS) || defined(TARGET_PDPMAC)
+ #undef PAGE_REGISTER
+ #undef BASE_REGISTER
+ #define PAGE_REGISTER 10
+ #define BASE_REGISTER 12
+ 
+ #ifdef TARGET_DIGNUS
+ #define FIXED_REGISTERS 						\
+ { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0 }
+ /*0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19*/
+ #endif
+ 
+ #ifdef TARGET_PDPMAC
+ /* made register 1 fixed because it is used
+    for parameter passing, otherwise we DO
+    have a problem! */
+ /* also made register 0 fixed, because I am using that
+    for the struct, instead of 1.  Why would anyone
+    choose 1 for the struct when it is being used
+    already for the parameters? */
+ #define FIXED_REGISTERS 						\
+ { 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0 }
+ /*0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19*/
+ #endif
+ 
+ /* 1 for registers not available across function calls.  These must include
+    the FIXED_REGISTERS and also any registers that can be used without being
+    saved.
+    The latter must include the registers where values are returned
+    and the register where structure-value addresses are passed.
+    NOTE: all floating registers are undefined across calls.  
+ */
+ 
+ #define CALL_USED_REGISTERS 						\
+ { 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 }
+ /*0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19*/
+ #endif
+ 
+ #ifdef TARGET_LE
  #define FIXED_REGISTERS 						\
  { 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0 }
  /*0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19*/
***************
*** 240,273 ****
  #define CALL_USED_REGISTERS 						\
  { 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1 }
  /*0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19*/
  
- /* Return number of consecutive hard regs needed starting at reg REGNO
-    to hold something of mode MODE.
-    This is ordinarily the length in words of a value of mode MODE
-    but can be less for certain modes in special long registers.  
-    Note that DCmode (complex double) needs two regs.
- */
  #endif /* TARGET_HLASM */
  
  /* ================= */
! #ifdef TARGET_ELF_ABI 
  /* The Linux/ELF ABI uses the same register layout as the 
!  * the MVS/OE version, with the following exceptions:
!  * -- r12 (rtca) is not used.
   */
  
  #define FIXED_REGISTERS 						\
! { 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0 }
  /*0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19*/
  
  #define CALL_USED_REGISTERS 						\
! { 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1 }
  /*0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19*/
  
! #endif /* TARGET_ELF_ABI */
  /* ================= */
  
  
  #define HARD_REGNO_NREGS(REGNO, MODE) 					\
    ((REGNO) > 15 ? 							\
     ((GET_MODE_SIZE (MODE) + 2*UNITS_PER_WORD - 1) / (2*UNITS_PER_WORD)) :	\
--- 341,390 ----
  #define CALL_USED_REGISTERS 						\
  { 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1 }
  /*0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19*/
+ #endif /* TARGET_LE */
  
  #endif /* TARGET_HLASM */
  
  /* ================= */
! #ifdef TARGET_LINUX 
  /* The Linux/ELF ABI uses the same register layout as the 
!    the MVS/OE version, with the following exceptions:
!    -- r4 is not used; its role is taken by 0(r13)
!    -- r13 is used as a combined argument & frame pointer
!    -- r11 is used to point to the top of the stack.
!    -- r12 is used as a base pointer into the data section
!       but only if i370_enable_pic is true; otherwise we can
!       free up this register.
! 
!    Note that the ELF calling convention is radically different 
!    than the MVS/OE convention.  In particular, r11 always points
!    to the top of the stack, and r13 always points to the bottom 
!    of the stack.  Thus, r13 can be used as a dual arg & frame 
!    pointer for all occasions, whereas r11 can be used for alloca
!    and other stack-dynamic allocations.  
! 
!    XXX Future enhancment possible: When a function doesn't have
!    any args, and doesn't use alloca(), then r11 is not really needed.
   */
  
  #define FIXED_REGISTERS 						\
! { 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0 }
  /*0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19*/
  
  #define CALL_USED_REGISTERS 						\
! { 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1 }
  /*0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19*/
  
! #endif /* TARGET_LINUX */
  /* ================= */
  
  
+ /* Return number of consecutive hard regs needed starting at reg REGNO
+    to hold something of mode MODE.
+    This is ordinarily the length in words of a value of mode MODE
+    but can be less for certain modes in special long registers.  
+    Note that DCmode (complex double) needs two regs.  */
+ 
  #define HARD_REGNO_NREGS(REGNO, MODE) 					\
    ((REGNO) > 15 ? 							\
     ((GET_MODE_SIZE (MODE) + 2*UNITS_PER_WORD - 1) / (2*UNITS_PER_WORD)) :	\
***************
*** 306,311 ****
--- 423,432 ----
  
  /* #define PC_REGNUM */
  
+ /* ------------------------------------------------------------------- */
+ /* ================= */
+ #ifdef TARGET_HLASM
+ 
  /* Register to use for pushing function arguments.  */
  
  #define STACK_POINTER_REGNUM 13
***************
*** 325,330 ****
--- 446,485 ----
  
  #define ARG_POINTER_REGNUM 11
  
+ #endif /* TARGET_HLASM */
+ 
+ /* ================= */
+ #ifdef TARGET_LINUX 
+ 
+ /* Register to use for pushing function arguments.  */
+ 
+ #define STACK_POINTER_REGNUM 11
+ 
+ /* Base register for access to local variables of the function.
+    A separate stack and frame pointer is required for any function 
+    that calls alloca() or does other pushing onto the stack. */
+ 
+ #define FRAME_POINTER_REGNUM 13
+ 
+ /* Value should be nonzero if functions must have frame pointers.
+    Zero means the frame pointer need not be set up (and parms may be
+    accessed via the stack pointer) in functions that seem suitable.
+    This is computed in `reload', in reload1.c.  */
+ 
+ #define FRAME_POINTER_REQUIRED 1
+ 
+ /* Function epilogue uses the frame pointer to restore the context */
+ #define EXIT_IGNORE_STACK 1
+ 
+ /* Base register for access to arguments of the function.  
+    We will use the frame pointer as the arg pointer. */
+ 
+ #define ARG_POINTER_REGNUM 13
+ 
+ #endif /* TARGET_LINUX */
+ /* ================= */
+ /* ------------------------------------------------------------------- */
+ 
  /* R10 is register in which static-chain is passed to a function.  
     Static-chaining is done when a nested function references as a global
     a stack variable of its parent: e.g.
***************
*** 349,355 ****
--- 504,514 ----
     the R1 points at that mem location.
   */
  
+ #ifdef TARGET_PDPMAC
+ #define STRUCT_VALUE_REGNUM 0
+ #else
  #define STRUCT_VALUE_REGNUM 1
+ #endif
  
  /* Define the classes of registers for register constraints in the
     machine description.  Also define ranges of constants.
***************
*** 462,471 ****
  
  /* Define this if pushing a word on the stack makes the stack pointer a
     smaller address.  */
- /* ------------------------------------------------------------------- */
  
- /* ================= */
- #ifdef TARGET_HLASM
  /* #define STACK_GROWS_DOWNWARD */
  
  /* Define this if the nominal address of the stack frame is at the
--- 621,627 ----
***************
*** 474,479 ****
--- 630,661 ----
  
  /* #define FRAME_GROWS_DOWNWARD */
  
+ 
+ /* ------------------------------------------------------------------- */
+ /* ================= */
+ #ifdef TARGET_HLASM
+ 
+ /* Define offset from stack pointer, to location where a parm can be
+    pushed.  */
+ 
+ #if defined(TARGET_DIGNUS) || defined(TARGET_PDPMAC)
+ #define STACK_POINTER_OFFSET 88
+ #else
+ #define STACK_POINTER_OFFSET 148
+ #endif
+ 
+ #define STACK_FRAME_BASE 88
+ 
+ 
+ /* used in i370.md for temp scratch area */
+ #if defined(TARGET_DIGNUS) || defined(TARGET_PDPMAC)
+ #define CONVLO "80"
+ #define CONVHI "84"
+ #else
+ #define CONVLO "140"
+ #define CONVHI "144"
+ #endif
+ 
  /* Offset within stack frame to start allocating local variables at.
     If FRAME_GROWS_DOWNWARD, this is the offset to the END of the
     first local allocated.  Otherwise, it is the offset to the BEGINNING
***************
*** 484,526 ****
  
  #define INITIAL_FRAME_POINTER_OFFSET(DEPTH) (DEPTH) = STARTING_FRAME_OFFSET
  
! /* If we generate an insn to push BYTES bytes, this says how many the stack
!    pointer really advances by.  On the 370, we have no push instruction.  */
  
  #endif /* TARGET_HLASM */
  
  /* ================= */
! #ifdef TARGET_ELF_ABI 
  
! /* With ELF/Linux, stack is placed at large virtual addrs and grows down.
!    But we want the compiler to generate posistive displacements from the 
!    stack pointer, and so we make the frame lie above the stack.  */
  
! #define STACK_GROWS_DOWNWARD 
! /* #define FRAME_GROWS_DOWNWARD */
  
! /* Offset within stack frame to start allocating local variables at.
!    This is the offset to the BEGINNING of the first local allocated.  */
  
  #define STARTING_FRAME_OFFSET  						\
!      (STACK_POINTER_OFFSET + current_function_outgoing_args_size)
  
  #define INITIAL_FRAME_POINTER_OFFSET(DEPTH) (DEPTH) = STARTING_FRAME_OFFSET
  
! #endif /* TARGET_ELF_ABI */
! /* ================= */
  
! /* #define PUSH_ROUNDING(BYTES) */
  
! /* Accumulate the outgoing argument count so we can request the right
!    DSA size and determine stack offset.  */
  
! #define ACCUMULATE_OUTGOING_ARGS 1
  
! /* Define offset from stack pointer, to location where a parm can be
!    pushed.  */
  
  #define STACK_POINTER_OFFSET 148
  
  /* Offset of first parameter from the argument pointer register value.  */
  
--- 666,772 ----
  
  #define INITIAL_FRAME_POINTER_OFFSET(DEPTH) (DEPTH) = STARTING_FRAME_OFFSET
  
! /* Offset of first parameter from the argument pointer register value.  */
! 
! #define FIRST_PARM_OFFSET(FNDECL) 0
! 
! /* Accumulate the outgoing argument count so we can request the right
!    DSA size and determine stack offset.  */
! 
! #define ACCUMULATE_OUTGOING_ARGS 1
  
  #endif /* TARGET_HLASM */
  
  /* ================= */
! #ifdef TARGET_LINUX 
! /* Here's the stack layout as currently designed:
  
!    r11 -- top of stack aka stack pointer
!    -4(r11) -- last local (stack) variable)
!    ...          ...
!    88+4*nargs(r13) -- first local (stack) variable.
!    ...          ...
!    92(r13) -- second incoming (callee) argument
!    88(r13) -- first incoming (callee) argument
!    84(r13) -- volatile scratch area
!    80(r13) -- volatile scratch area
!    76(r13) -- not used (frame size)
!    72(r13) -- not used
!    68(r13) -- saved callers r12
!    64(r13) -- saved callers r11
!    ...          ...
!    28(r13) -- saved callers r2
!    24(r13) -- saved callers r1
!    20(r13) -- saved callers r0
!    16(r13) -- saved callers r15
!    12(r13) -- saved callers r14
!    8(r13)  -- saved callers r13
!    4(r13)  -- not used
!    0(r13)  -- code page table pointer
!    r13 -- bottom of stack aka frame pointer aka arg pointer
! 
!    Note that this bears superficial similarity to the MVS/OE stack layout,
!    but in fact it is very very different.  In particular, under MVS/OE
!    the roles of r11 and r13 are quite different.   
! 
!    Note that the use of varargs/stdarg is limited to 512 bytes of
!    of arguments.  This is the price that is paid for freeing up a 
!    register and having a more efficient function return.
! */
  
! /* Define size of the calling convention register save area.
!    This includes room for the 16 GPR's, a saved frame size, and 
!    a (floating point math) scratch area */
! #define I370_SAVE_AREA_SIZE 88
! 
! /* Define the size of the amount of room reserved for varargs */
! #define I370_VARARGS_AREA_SIZE 512
! 
! /* Used in i370.md for temp scratch area. Must be that last two words
!    of the I370_SAVE_AREA. */
! #define CONVLO "80"
! #define CONVHI "84"
  
! /* Define offset from stack pointer, to location where a parm can be
!    pushed.  */
! 
! #define STACK_POINTER_OFFSET I370_SAVE_AREA_SIZE
! 
! #define STACK_DYNAMIC_OFFSET(FNDECL) 0
! 
! /* Offset within frame to start allocating local variables at.
!    It is the offset to the BEGINNING of the first local allocated.  */
  
  #define STARTING_FRAME_OFFSET  						\
!      ((current_function_varargs || current_function_stdarg) ?		\
!      (I370_SAVE_AREA_SIZE + I370_VARARGS_AREA_SIZE):			\
!      (I370_SAVE_AREA_SIZE + current_function_args_size))
  
  #define INITIAL_FRAME_POINTER_OFFSET(DEPTH) (DEPTH) = STARTING_FRAME_OFFSET
  
! /* Offset of first incoming parameter from the arg ptr register value.  */
! #define FIRST_PARM_OFFSET(FNDECL) I370_SAVE_AREA_SIZE
  
! /* The ACCUMULATE_OUTGOING_ARGS flag seems to have some funny side effects
!    that we need.  Specifically, if it is set, then the stack pointer is
!    not bumped when args are placed on the stack, which is just how we want
!    it. */
! #define ACCUMULATE_OUTGOING_ARGS 1
  
! #endif /* TARGET_LINUX */
  
! /* ================= */
! /* ------------------------------------------------------------------- */
  
! /* If we generate an insn to push BYTES bytes, this says how many the stack
!    pointer really advances by.  On the 370, we have no push instruction.  */
  
+ /* #define PUSH_ROUNDING(BYTES) */
+ 
+ #ifdef TARGET_LE
  #define STACK_POINTER_OFFSET 148
+ #define STACK_FRAME_BASE 28
+ #endif
  
  /* Offset of first parameter from the argument pointer register value.  */
  
***************
*** 1041,1046 ****
--- 1287,1293 ----
  /* ======================================================== */
  
  #ifdef TARGET_HLASM
+ 
  #define TEXT_SECTION_ASM_OP "* Program text area"
  #define DATA_SECTION_ASM_OP "* Program data area"
  #define INIT_SECTION_ASM_OP "* Program initialization area"
***************
*** 1058,1068 ****
    "0",  "2",  "4",  "6"							\
  }
  
  #define ASM_FILE_START(FILE)						\
! { fputs ("\tRMODE\tANY\n", FILE);					\
!   fputs ("\tCSECT\n", FILE); }
  
- #define ASM_FILE_END(FILE) fputs ("\tEND\n", FILE);
  #define ASM_COMMENT_START "*"
  #define ASM_APP_OFF ""
  #define ASM_APP_ON ""
--- 1305,1419 ----
    "0",  "2",  "4",  "6"							\
  }
  
+ #ifdef TARGET_ALIASES
+ 
  #define ASM_FILE_START(FILE)						\
! { extern const char *main_input_filename;				\
!   extern char *asm_file_name;						\
!   char temp[256];							\
!   const char *cbp, *cfp;						\
!   char *bp;								\
!   if (asm_file_name)							\
!     {									\
!       if (strncmp (asm_file_name, "/tmp", 4) == 0)			\
!         cfp = main_input_filename;					\
!       else								\
!         cfp = asm_file_name;						\
!     }									\
!   else cfp = main_input_filename;					\
!   if ((cbp = strrchr (cfp, '/')) == NULL)				\
!     cbp = cfp;								\
!   else cbp++;								\
!   while (*cbp == '_') cbp++;						\
!   strcpy (temp, cbp);							\
!   if ((bp = strchr (temp, '.')) != NULL) *bp = '\0';			\
!   for (bp = temp; *bp; bp++)						\
!     *bp = ISLOWER(*bp) ? TOUPPER(*bp) : *bp;				\
!   mvs_module = (char *) xmalloc (strlen(temp)+2);			\
!   strcpy (mvs_module, temp);						\
!   for (bp = temp; *bp; bp++)						\
!     *bp = ISUPPER(*bp) ? TOLOWER(*bp) : *bp;				\
!   fprintf (FILE, "@DATA\tALIAS\tC'@%s'\n", temp);			\
!   fputs ("@DATA\tAMODE\tANY\n", FILE);					\
!   fputs ("@DATA\tRMODE\tANY\n", FILE);					\
!   fputs ("@DATA\tCSECT\n", FILE); }
! 
! #define ASM_FILE_END(FILE) 						\
! { mvs_dump_alias (FILE);						\
!   fputs ("\tEND\n", FILE);						\
! }
! 
! #else
! 
! #ifdef TARGET_PDPMAC
! #define ASM_FILE_START(FILE)						\
! { extern const char *main_input_filename;				\
!   extern char *asm_file_name;						\
!   char temp[256];							\
!   const char *cbp, *cfp;						\
!   char *bp;								\
!   if (asm_file_name)							\
!     {									\
!       if (strncmp (asm_file_name, "/tmp", 4) == 0)			\
!         cfp = main_input_filename;					\
!       else								\
!         cfp = asm_file_name;						\
!     }									\
!   else cfp = main_input_filename;					\
!   if ((cbp = strrchr (cfp, '/')) == NULL)				\
!     cbp = cfp;								\
!   else cbp++;								\
!   while (*cbp == '_') cbp++;						\
!   strcpy (temp, cbp);							\
!   if ((bp = strchr (temp, '.')) != NULL) *bp = '\0';			\
!   if (strlen (temp) > MAX_MVS_LABEL_SIZE - 1)				\
!     temp[MAX_MVS_LABEL_SIZE-1] = '\0';					\
!   for (bp = temp; *bp; bp++)						\
!     *bp = ISLOWER(*bp) ? TOUPPER(*bp) : *bp;				\
!   mvs_module = (char *) xmalloc (strlen(temp)+2);			\
!   strcpy (mvs_module, temp);						\
!   fprintf(FILE, "\tCOPY\tPDPTOP\n"); \
!   fprintf (FILE, "%s\tCSECT\n", mvs_csect_name ? mvs_csect_name : "");\
! }
! #else
! #define ASM_FILE_START(FILE)						\
! { extern const char *main_input_filename;				\
!   extern char *asm_file_name;						\
!   char temp[256];							\
!   const char *cbp, *cfp;						\
!   char *bp;								\
!   if (asm_file_name)							\
!     {									\
!       if (strncmp (asm_file_name, "/tmp", 4) == 0)			\
!         cfp = main_input_filename;					\
!       else								\
!         cfp = asm_file_name;						\
!     }									\
!   else cfp = main_input_filename;					\
!   if ((cbp = strrchr (cfp, '/')) == NULL)					\
!     cbp = cfp;								\
!   else cbp++;								\
!   while (*cbp == '_') cbp++;						\
!   strcpy (temp, cbp);							\
!   if ((bp = strchr (temp, '.')) != NULL) *bp = '\0';			\
!   if (strlen (temp) > MAX_MVS_LABEL_SIZE - 1)				\
!     temp[MAX_MVS_LABEL_SIZE-1] = '\0';					\
!   for (bp = temp; *bp; bp++)						\
!     *bp = ISLOWER(*bp) ? TOUPPER(*bp) : *bp;				\
!   mvs_module = (char *) xmalloc (strlen(temp)+2);			\
!   strcpy (mvs_module, temp);						\
!   fprintf (FILE, "$%s\tCSECT\n", mvs_module);				\
! }
! #endif
! 
! #define ASM_FILE_END(FILE) 						\
! { if (mvs_gotmain) fputs ("\tEND\t@@MAIN\n", FILE);			\
!   else fputs ("\tEND\n", FILE);						\
! }
! 
! #endif /* TARGET_ALIASES */
! 
  
  #define ASM_COMMENT_START "*"
  #define ASM_APP_OFF ""
  #define ASM_APP_ON ""
***************
*** 1070,1075 ****
--- 1421,1434 ----
  #define ASM_OUTPUT_LABEL(FILE, NAME) 					\
  { assemble_name (FILE, NAME); fputs ("\tEQU\t*\n", FILE); }
  
+ #define ASM_OUTPUT_FUNCTION_PREFIX(FILE, NAME)				\
+   mvs_need_to_globalize = 0; \
+   mvs_need_entry = 0
+ 
+ #if defined(TARGET_DIGNUS) || defined(TARGET_PDPMAC)
+ #define ASM_OUTPUT_EXTERNAL(FILE, DECL, NAME)
+ #endif
+ #ifdef TARGET_LE
  #define ASM_OUTPUT_EXTERNAL(FILE, DECL, NAME)				\
  {									\
    char temp[MAX_MVS_LABEL_SIZE + 1];					\
***************
*** 1078,1084 ****
--- 1437,1491 ----
        fprintf (FILE, "%s\tALIAS\tC'%s'\n", temp, NAME);			\
      }									\
  }
+ #endif
  
+ #ifdef TARGET_ALIASES
+ #ifdef TARGET_DIGNUS
+ #define ASM_GLOBALIZE_LABEL(FILE, NAME)					\
+ { 									\
+   char temp[MAX_MVS_LABEL_SIZE + 1];					\
+   if (!strcmp (NAME, "main"))						\
+     {									\
+       fputs ("@CRT0\tALIAS\tC'@crt0'\n", FILE);				\
+       fputs ("\tEXTRN\t@CRT0\n", FILE);					\
+     }									\
+   if (mvs_check_alias (NAME, temp) == 2)				\
+     {									\
+       fprintf (FILE, "%s\tALIAS\tC'%s'\n", temp, NAME);			\
+     }									\
+   if (mvs_need_to_globalize)						\
+     {									\
+       fputs ("\tENTRY\t", FILE);					\
+       assemble_name (FILE, NAME);					\
+       fputs ("\n", FILE);						\
+     }									\
+   mvs_need_entry = 1;							\
+ }
+ #endif
+ #ifdef TARGET_PDPMAC
+ #define ASM_GLOBALIZE_LABEL(FILE, NAME)					\
+ { 									\
+   char temp[MAX_MVS_LABEL_SIZE + 1];					\
+   if (!strcmp (NAME, "main"))						\
+     {									\
+       fputs ("@@CRT0\tALIAS\tC'@@crt0'\n", FILE);			\
+       fputs ("\tEXTRN\t@@CRT0\n", FILE);				\
+     }									\
+   if (mvs_check_alias (NAME, temp) == 2)				\
+     {									\
+       fprintf (FILE, "%s\tALIAS\tC'%s'\n", temp, NAME);			\
+     }									\
+   if (mvs_need_to_globalize)						\
+     {									\
+       fprintf(FILE, "* X-var %s\n", NAME); \
+       fputs ("\tENTRY\t", FILE);					\
+       assemble_name (FILE, NAME);					\
+       fputs ("\n", FILE);						\
+     }									\
+   mvs_need_entry = 1;							\
+ }
+ #endif
+ #ifdef TARGET_LE
  #define ASM_GLOBALIZE_LABEL(FILE, NAME)					\
  { 									\
    char temp[MAX_MVS_LABEL_SIZE + 1];					\
***************
*** 1090,1100 ****
--- 1497,1599 ----
    assemble_name (FILE, NAME);						\
    fputs ("\n", FILE);							\
  }
+ #endif
+ #else /* !TARGET_ALIASES */
+ #ifdef TARGET_DIGNUS
+ #define ASM_GLOBALIZE_LABEL(FILE, NAME)					\
+ { 									\
+   char temp[MAX_MVS_LABEL_SIZE + 1];					\
+   if (!strcmp (NAME, "main"))						\
+     {									\
+       fputs ("\tEXTRN\t@CRT0\n", FILE);					\
+     }									\
+   if (mvs_check_alias (NAME, temp) == 2)				\
+     {									\
+       fprintf (FILE, "%s\tALIAS\tC'%s'\n", temp, NAME);			\
+     }									\
+   if (mvs_need_to_globalize)						\
+     {									\
+       fputs ("\tENTRY\t", FILE);					\
+       assemble_name (FILE, NAME);					\
+       fputs ("\n", FILE);						\
+     }									\
+   mvs_need_entry = 1;							\
+ }
+ #endif
+ #ifdef TARGET_PDPMAC
+ #ifdef TARGET_VSE
+ #define ASM_GLOBALIZE_LABEL(FILE, NAME)					\
+ { 									\
+   char temp[MAX_MVS_LABEL_SIZE + 1];					\
+   if (!strcmp (NAME, "main"))						\
+     {									\
+       fputs ("\tDC\tC'GCCMVS!!'\n", FILE);				\
+       fputs ("\tEXTRN\t@@CRT0\n", FILE);				\
+       fputs ("\tENTRY\t@@MAIN\n", FILE);				\
+       fputs ("@@MAIN\tDS\t0H\n", FILE);				\
+       fputs ("\tBALR\t10,0\n", FILE);				\
+       fputs ("\tUSING\t*,10\n", FILE);				\
+       fputs ("\tL\t10,=V(@@CRT0)\n", FILE);				\
+       fputs ("\tBR\t10\n", FILE);				\
+       fputs ("\tDROP\t10\n", FILE);				\
+       fputs ("\tLTORG\n", FILE);				\
+       mvs_gotmain = 1; /* was 1 */         				\
+     }									\
+   if (mvs_check_alias (NAME, temp) == 2)				\
+     {									\
+       fprintf (FILE, "%s\tALIAS\tC'%s'\n", temp, NAME);			\
+     }									\
+   if (mvs_need_to_globalize)						\
+     {									\
+       fprintf(FILE, "* X-var %s\n", NAME); \
+       fputs ("\tENTRY\t", FILE);					\
+       assemble_name (FILE, NAME);					\
+       fputs ("\n", FILE);						\
+     }									\
+   mvs_need_entry = 1;							\
+ }
+ #else
+ #define ASM_GLOBALIZE_LABEL(FILE, NAME)					\
+ { 									\
+   char temp[MAX_MVS_LABEL_SIZE + 1];					\
+   if (!strcmp (NAME, "main"))						\
+     {									\
+       fputs ("\tCOPY\tPDPMAIN\n", FILE);				\
+       mvs_gotmain = 1; /* was 1 */         				\
+     }									\
+   if (mvs_check_alias (NAME, temp) == 2)				\
+     {									\
+       fprintf (FILE, "%s\tALIAS\tC'%s'\n", temp, NAME);			\
+     }									\
+   if (mvs_need_to_globalize)						\
+     {									\
+       fprintf(FILE, "* X-var %s\n", NAME); \
+       fputs ("\tENTRY\t", FILE);					\
+       assemble_name (FILE, NAME);					\
+       fputs ("\n", FILE);						\
+     }									\
+   mvs_need_entry = 1;							\
+ }
+ #endif /* TARGET_VSE */
+ #endif /* TARGET_PDPMAC */
+ #endif /* TARGET_ALIASES */
+ 
  
  /* MVS externals are limited to 8 characters, upper case only.
     The '_' is mapped to '@', except for MVS functions, then '#'.  */
  
  
+ #ifdef TARGET_ALIASES
+ #if defined(TARGET_DIGNUS) || defined(TARGET_PDPMAC)
+ #define ASM_OUTPUT_LABELREF(FILE, NAME)					\
+ {									\
+   char *bp, ch, temp[MAX_MVS_LABEL_SIZE + 1];				\
+   if (!mvs_get_alias (NAME, temp))					\
+     strcpy (temp, NAME);						\
+   fprintf (FILE, "%s", temp);						\
+ }
+ #endif
+ #ifdef TARGET_LE
  #define ASM_OUTPUT_LABELREF(FILE, NAME)					\
  {									\
    char *bp, ch, temp[MAX_MVS_LABEL_SIZE + 1];				\
***************
*** 1110,1118 ****
      *bp = (*bp == '_' ? ch : TOUPPER (*bp));				\
    fprintf (FILE, "%s", temp);						\
  }
  
  #define ASM_GENERATE_INTERNAL_LABEL(LABEL, PREFIX, NUM)			\
!   sprintf (LABEL, "*%s%d", PREFIX, NUM)
  
  /* Generate internal label.  Since we can branch here from off page, we
     must reload the base register.  */
--- 1609,1649 ----
      *bp = (*bp == '_' ? ch : TOUPPER (*bp));				\
    fprintf (FILE, "%s", temp);						\
  }
+ #endif
+ #else /* !TARGET_ALIASES */
+ #if defined(TARGET_DIGNUS) || defined(TARGET_PDPMAC)
+ #define ASM_OUTPUT_LABELREF(FILE, NAME)					\
+ {									\
+   char *bp, ch, temp[MAX_MVS_LABEL_SIZE + 1];				\
+   if (!mvs_get_alias (NAME, temp))					\
+     strcpy (temp, NAME);						\
+   ch = '@';								\
+   for (bp = temp; *bp; bp++)						\
+     *bp = (*bp == '_' ? ch : TOUPPER (*bp));				\
+   fprintf (FILE, "%s", temp);						\
+ }
+ #endif
+ #ifdef TARGET_LE
+ #define ASM_OUTPUT_LABELREF(FILE, NAME)					\
+ {									\
+   char *bp, ch, temp[MAX_MVS_LABEL_SIZE + 1];				\
+   if (!mvs_get_alias (NAME, temp))					\
+     strcpy (temp, NAME);						\
+   if (!strcmp (temp,"main"))						\
+     strcpy (temp,"gccmain");						\
+   if (mvs_function_check (temp))					\
+     ch = '#';								\
+   else									\
+     ch = '@';								\
+   for (bp = temp; *bp; bp++)						\
+     *bp = (*bp == '_' ? ch : TOUPPER (*bp));				\
+   fprintf (FILE, "%s", temp);						\
+ }
+ #endif
+ #endif /* TARGET_ALIASES */
  
  #define ASM_GENERATE_INTERNAL_LABEL(LABEL, PREFIX, NUM)			\
!   sprintf (LABEL, "*@@%s%d", PREFIX, NUM)
  
  /* Generate internal label.  Since we can branch here from off page, we
     must reload the base register.  */
***************
*** 1123,1155 ****
      {									\
        mvs_add_label(NUM);						\
      }									\
!   fprintf (FILE, "%s%d\tEQU\t*\n", PREFIX, NUM);			\
  }
  
  /* Generate case label.  For HLASM we can change to the data CSECT
     and put the vectors out of the code body. The assembler just
     concatenates CSECTs with the same name.  */
  
  #define ASM_OUTPUT_CASE_LABEL(FILE, PREFIX, NUM, TABLE)			\
    fprintf (FILE, "\tDS\t0F\n");                                         \
!   fprintf (FILE,"\tCSECT\n");                                           \
    fprintf (FILE, "%s%d\tEQU\t*\n", PREFIX, NUM)
  
  /* Put the CSECT back to the code body */
  
  #define ASM_OUTPUT_CASE_END(FILE, NUM, TABLE)                           \
!   assemble_name (FILE, mvs_function_name);                              \
!   fputs ("\tCSECT\n", FILE);
  
  /* This is how to output an element of a case-vector that is absolute.  */
  
  #define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  				\
!   fprintf (FILE, "\tDC\tA(L%d)\n", VALUE)
  
  /* This is how to output an element of a case-vector that is relative.  */
  
  #define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) 		\
!   fprintf (FILE, "\tDC\tA(L%d-L%d)\n", VALUE, REL)
  
  /* This is how to output an insn to push a register on the stack.
      It need not be very fast code.  
--- 1654,1713 ----
      {									\
        mvs_add_label(NUM);						\
      }									\
!   fprintf (FILE, "@@%s%d\tEQU\t*\n", PREFIX, NUM);			\
  }
  
  /* Generate case label.  For HLASM we can change to the data CSECT
     and put the vectors out of the code body. The assembler just
     concatenates CSECTs with the same name.  */
  
+ #ifdef TARGET_ALIASES
  #define ASM_OUTPUT_CASE_LABEL(FILE, PREFIX, NUM, TABLE)			\
    fprintf (FILE, "\tDS\t0F\n");                                         \
!   fprintf (FILE,"@DATA\tCSECT\n");                                      \
    fprintf (FILE, "%s%d\tEQU\t*\n", PREFIX, NUM)
+ #else /* !TARGET_ALIASES */
+ #ifdef TARGET_PDPMAC
+ #define ASM_OUTPUT_CASE_LABEL(FILE, PREFIX, NUM, TABLE)			\
+   fprintf (FILE, "\tLTORG\n");                                          \
+   fprintf (FILE, "\tDS\t0F\n");                                         \
+   mvs_case_code = 0;							\
+   fprintf (FILE, "@@%s%d\tEQU\t*\n", PREFIX, NUM)
+ #else
+ #define ASM_OUTPUT_CASE_LABEL(FILE, PREFIX, NUM, TABLE)			\
+   fprintf (FILE, "\tDS\t0F\n");                                         \
+   fprintf (FILE,"$%s\tCSECT\n", mvs_module);                            \
+   fprintf (FILE, "%s%d\tEQU\t*\n", PREFIX, NUM)
+ #endif
+ #endif /* TARGET_ALIASES */
  
  /* Put the CSECT back to the code body */
  
+ #ifdef TARGET_ALIASES
  #define ASM_OUTPUT_CASE_END(FILE, NUM, TABLE)                           \
!   fputs ("@CODE\tCSECT\n", FILE);
! #else /* !TARGET_ALIASES */
! #ifdef TARGET_PDPMAC
! #define ASM_OUTPUT_CASE_END(FILE, NUM, TABLE)                           \
!   mvs_page_code += mvs_case_code;					\
!   mvs_check_page (FILE, 0, 0);						\
!   mvs_case_code = 0;
! #else
! #define ASM_OUTPUT_CASE_END(FILE, NUM, TABLE)                           \
!   fprintf (FILE, "@%s\tCSECT\n", mvs_module);
! #endif
! #endif /* TARGET_ALIASES */
  
  /* This is how to output an element of a case-vector that is absolute.  */
  
  #define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  				\
!   mvs_case_code += 4;							\
!   fprintf (FILE, "\tDC\tA(@@L%d)\n", VALUE)
  
  /* This is how to output an element of a case-vector that is relative.  */
  
  #define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) 		\
!   fprintf (FILE, "\tDC\tA(@@L%d-@@L%d)\n", VALUE, REL)
  
  /* This is how to output an insn to push a register on the stack.
      It need not be very fast code.  
***************
*** 1184,1195 ****
    for (j = 0, i = 0; i < limit; j++, i++)				\
      {									\
        int c = (PTR)[i];							\
!       if (ISCNTRL (c) || c == '&')					\
  	{								\
  	  if (j % MVS_ASCII_TEXT_LENGTH != 0 )				\
  	    fprintf (FILE, "'\n");					\
  	  j = -1;							\
! 	  if (c == '&') c = MAP_CHARACTER (c);				\
  	  fprintf (FILE, "\tDC\tX'%X'\n", c );				\
  	}								\
        else								\
--- 1742,1753 ----
    for (j = 0, i = 0; i < limit; j++, i++)				\
      {									\
        int c = (PTR)[i];							\
!       if (!IS_ISOBASIC (c) || ISCNTRL(c) || c == '&')			\
  	{								\
  	  if (j % MVS_ASCII_TEXT_LENGTH != 0 )				\
  	    fprintf (FILE, "'\n");					\
  	  j = -1;							\
! 	  c = MAP_OUTCHAR (c);						\
  	  fprintf (FILE, "\tDC\tX'%X'\n", c );				\
  	}								\
        else								\
***************
*** 1197,1203 ****
  	  if (j % MVS_ASCII_TEXT_LENGTH == 0)				\
              fprintf (FILE, "\tDC\tC'");					\
            if ( c == '\'' )                                       	\
! 	    fprintf (FILE, "%c%c", c, c);                        	\
  	  else                                                   	\
  	    fprintf (FILE, "%c", c);                             	\
  	  if (j % MVS_ASCII_TEXT_LENGTH == MVS_ASCII_TEXT_LENGTH - 1)	\
--- 1755,1766 ----
  	  if (j % MVS_ASCII_TEXT_LENGTH == 0)				\
              fprintf (FILE, "\tDC\tC'");					\
            if ( c == '\'' )                                       	\
! 	    {	/* we are going to print 2 chars - is there space */	\
! 	  if( j % MVS_ASCII_TEXT_LENGTH == MVS_ASCII_TEXT_LENGTH - 1)   \
!           { /* not enough space */					\
! 	    fprintf (FILE, "'\n" );					\
!             fprintf (FILE, "\tDC\tC'");	++j;}				\
!                fprintf (FILE, "%c%c", c, c);++j;}                   	\
  	  else                                                   	\
  	    fprintf (FILE, "%c", c);                             	\
  	  if (j % MVS_ASCII_TEXT_LENGTH == MVS_ASCII_TEXT_LENGTH - 1)	\
***************
*** 1229,1234 ****
--- 1792,1811 ----
     instruction to advance the location counter by SIZE bytes. Those
     bytes should be zero when loaded.  */
  
+ #ifdef TARGET_PDPMAC
+ #define ASM_OUTPUT_SKIP(FILE, SIZE)  					\
+ {									\
+   int s, k;								\
+   for (s = (SIZE); s > 0; s -= MAX_CHUNK)				\
+     {									\
+       if (s > MAX_CHUNK)						\
+ 	k = MAX_CHUNK;							\
+       else								\
+ 	k = s;								\
+       fprintf (FILE, "\tDC\t%dX'00'\n", k);				\
+     }									\
+ }
+ #else
  #define ASM_OUTPUT_SKIP(FILE, SIZE)  					\
  {									\
    int s, k;								\
***************
*** 1241,1246 ****
--- 1818,1824 ----
        fprintf (FILE, "\tDS\tXL%d\n", k);				\
      }									\
  }
+ #endif
  
  /* A C statement (sans semicolon) to output to the stdio stream
     FILE the assembler definition of a common-label named NAME whose
***************
*** 1254,1259 ****
--- 1832,1838 ----
      {									\
        fprintf (FILE, "%s\tALIAS\tC'%s'\n", temp, NAME);			\
      }									\
+   fprintf(FILE, "* X-var %s\n", NAME); \
    fputs ("\tENTRY\t", FILE);						\
    assemble_name (FILE, NAME);						\
    fputs ("\n", FILE);							\
***************
*** 1278,1288 ****
--- 1857,1875 ----
     assembler-name for a local static variable named NAME.
     LABELNO is an integer which is different for each call.  */
  
+ #ifdef TARGET_PDPMAC
+ #define ASM_FORMAT_PRIVATE_NAME(OUTPUT, NAME, LABELNO)  		\
+ {									\
+   (OUTPUT) = (char *) alloca (strlen ((NAME)) + 10);			\
+   sprintf ((OUTPUT), "__%d", (LABELNO));				\
+ }
+ #else
  #define ASM_FORMAT_PRIVATE_NAME(OUTPUT, NAME, LABELNO)  		\
  {									\
    (OUTPUT) = (char *) alloca (strlen ((NAME)) + 10);			\
    sprintf ((OUTPUT), "%s%d", (NAME), (LABELNO));			\
  }
+ #endif
  
  /* Print operand XV (an rtx) in assembler syntax to file FILE.
     CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.
***************
*** 1324,1333 ****
        case SYMBOL_REF:							\
        case LABEL_REF:							\
  	mvs_page_lit += 4;						\
! 	if (SYMBOL_REF_FLAG (XV)) fprintf (FILE, "=V(");		\
! 	else                      fprintf (FILE, "=A(");		\
! 	output_addr_const (FILE, XV);					\
! 	fprintf (FILE, ")");						\
  	break;								\
        case CONST_INT:					        	\
  	if (CODE == 'B')						\
--- 1911,1929 ----
        case SYMBOL_REF:							\
        case LABEL_REF:							\
  	mvs_page_lit += 4;						\
! 	if (SYMBOL_REF_FLAG (XV))					\
! 	  {								\
! 	    fprintf (FILE, "=V(");					\
! 	    output_addr_const (FILE, XV);				\
! 	    fprintf (FILE, ")");					\
! 	    mvs_mark_alias (XSTR(XV,0));				\
! 	  }								\
! 	else								\
! 	  {								\
! 	    fprintf (FILE, "=A(");					\
! 	    output_addr_const (FILE, XV);				\
! 	    fprintf (FILE, ")");					\
! 	  }								\
  	break;								\
        case CONST_INT:					        	\
  	if (CODE == 'B')						\
***************
*** 1386,1406 ****
  	  }								\
  	else								\
  	  { 								\
-             /* hack alert -- this prints wildly incorrect values */	\
-             /* when run in cross-compiler mode. See ELF section  */	\
-             /* for suggested fix */					\
- 	    union { double d; int i[2]; } u;				\
- 	    u.i[0] = CONST_DOUBLE_LOW (XV);				\
- 	    u.i[1] = CONST_DOUBLE_HIGH (XV);				\
  	    if (GET_MODE (XV) == SFmode)				\
  	      {								\
  		mvs_page_lit += 4;					\
! 		fprintf (FILE, "=E'%.9G'", u.d);			\
  	      }								\
  	    else							\
  	      {								\
  		mvs_page_lit += 8;					\
! 		fprintf (FILE, "=D'%.18G'", u.d);			\
  	      }								\
  	  }								\
  	break;								\
--- 1982,2007 ----
  	  }								\
  	else								\
  	  { 								\
  	    if (GET_MODE (XV) == SFmode)				\
  	      {								\
+ 	        REAL_VALUE_TYPE rval;					\
+ 	        REAL_VALUE_FROM_CONST_DOUBLE(rval, XV);			\
  		mvs_page_lit += 4;					\
! 		fprintf (FILE, "=E'%s'", mvs_make_float(rval));		\
  	      }								\
  	    else							\
+ 	    if (GET_MODE (XV) == DFmode)				\
+ 	      {								\
+ 	        REAL_VALUE_TYPE rval;					\
+ 	        REAL_VALUE_FROM_CONST_DOUBLE(rval, XV);			\
+ 		mvs_page_lit += 8;					\
+ 		fprintf (FILE, "=D'%s'", mvs_make_float(rval));		\
+ 	      }								\
+ 	    else 							\
  	      {								\
  		mvs_page_lit += 8;					\
! 		fprintf (FILE, "=XL8'%08X%08X'", 			\
! 			CONST_DOUBLE_HIGH (XV), CONST_DOUBLE_LOW (XV));	\
  	      }								\
  	  }								\
  	break;								\
***************
*** 1411,1421 ****
  	    mvs_page_lit += 4;						\
  	    if (SYMBOL_REF_FLAG (XEXP (XEXP (XV, 0), 0)))		\
  	      {								\
  		fprintf (FILE, "=V(");					\
  		ASM_OUTPUT_LABELREF (FILE,				\
  				  XSTR (XEXP (XEXP (XV, 0), 0), 0));	\
! 		fprintf (FILE, ")\n\tA\t%s,=F'%d'", curreg,		\
! 				  INTVAL (XEXP (XEXP (XV, 0), 1)));	\
  	      }								\
  	    else							\
  	      {								\
--- 2012,2029 ----
  	    mvs_page_lit += 4;						\
  	    if (SYMBOL_REF_FLAG (XEXP (XEXP (XV, 0), 0)))		\
  	      {								\
+ 		int xx = INTVAL (XEXP (XEXP (XV, 0), 1));		\
  		fprintf (FILE, "=V(");					\
  		ASM_OUTPUT_LABELREF (FILE,				\
  				  XSTR (XEXP (XEXP (XV, 0), 0), 0));	\
! 		if ((unsigned)xx < 4096)				\
! 		  fprintf (FILE, ")\n\tLA\t%s,%d(0,%s)", curreg,	\
! 				  xx,					\
! 				  curreg);				\
! 		else							\
! 		  fprintf (FILE, ")\n\tA\t%s,=F'%d'", curreg,		\
! 				  xx);					\
! 		mvs_mark_alias (XSTR (XEXP (XEXP (XV, 0), 0), 0));	\
  	      }								\
  	    else							\
  	      {								\
***************
*** 1505,1511 ****
  	if (offset)							\
  	  {								\
  	    if (GET_CODE (offset) == LABEL_REF)				\
! 	      fprintf (FILE, "L%d",					\
  			CODE_LABEL_NUMBER (XEXP (offset, 0)));		\
  	    else							\
  	      output_addr_const (FILE, offset);				\
--- 2113,2119 ----
  	if (offset)							\
  	  {								\
  	    if (GET_CODE (offset) == LABEL_REF)				\
! 	      fprintf (FILE, "@@L%d",					\
  			CODE_LABEL_NUMBER (XEXP (offset, 0)));		\
  	    else							\
  	      output_addr_const (FILE, offset);				\
***************
*** 1520,1535 ****
  	break;								\
        default:								\
  	mvs_page_lit += 4;						\
! 	if (SYMBOL_REF_FLAG (ADDR)) fprintf (FILE, "=V(");		\
! 	else                        fprintf (FILE, "=A(");		\
! 	output_addr_const (FILE, ADDR);					\
! 	fprintf (FILE, ")");						\
  	break;								\
      }									\
  }
  
  #define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL)			\
  {									\
    if (strlen (NAME) + 1 > mvs_function_name_length)			\
      {									\
        if (mvs_function_name)						\
--- 2128,2154 ----
  	break;								\
        default:								\
  	mvs_page_lit += 4;						\
! 	if (SYMBOL_REF_FLAG (ADDR))					\
! 	  {								\
! 	    fprintf (FILE, "=V(");					\
! 	    output_addr_const (FILE, ADDR);				\
! 	    fprintf (FILE, ")");					\
! 	    mvs_mark_alias (XSTR (ADDR, 0));				\
! 	  }								\
! 	else								\
! 	  {								\
! 	    fprintf (FILE, "=A(");					\
! 	    output_addr_const (FILE, ADDR);				\
! 	    fprintf (FILE, ")");					\
! 	  }								\
  	break;								\
      }									\
  }
  
+ #ifdef TARGET_LE
  #define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL)			\
  {									\
+   /* Save a copy of the function name. We need it later */		\
    if (strlen (NAME) + 1 > mvs_function_name_length)			\
      {									\
        if (mvs_function_name)						\
***************
*** 1545,1556 ****
      strcpy (mvs_function_name, "gccmain");				\
    else									\
      strcpy (mvs_function_name, NAME);					\
-   fprintf (FILE, "\tDS\t0F\n");						\
-   assemble_name (FILE, mvs_function_name);				\
-   fputs ("\tRMODE\tANY\n", FILE);					\
-   assemble_name (FILE, mvs_function_name);				\
-   fputs ("\tCSECT\n", FILE);						\
  }
  
  /* Output assembler code to FILE to increment profiler label # LABELNO
     for profiling a function entry.  */
--- 2164,2190 ----
      strcpy (mvs_function_name, "gccmain");				\
    else									\
      strcpy (mvs_function_name, NAME);					\
  }
+ #endif
+ 
+ #if defined(TARGET_DIGNUS) || defined(TARGET_PDPMAC)
+ #define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL)			\
+ {									\
+   if (strlen (NAME) + 1 > mvs_function_name_length)			\
+     {									\
+       if (mvs_function_name)						\
+ 	free (mvs_function_name);					\
+       mvs_function_name = 0;						\
+     }									\
+   if (!mvs_function_name)						\
+     {									\
+       mvs_function_name_length = strlen (NAME) * 2 + 1;			\
+       mvs_function_name = (char *) xmalloc (mvs_function_name_length);	\
+     }									\
+   strcpy (mvs_function_name, NAME);					\
+   mvs_need_to_globalize = 1;						\
+ }
+ #endif
  
  /* Output assembler code to FILE to increment profiler label # LABELNO
     for profiling a function entry.  */
***************
*** 1562,1568 ****
  
  /* ======================================================== */
  
! #ifdef TARGET_ELF_ABI 
  
  /* How to refer to registers in assembler output.  This sequence is
     indexed by compiler's hard-register-number (see above).  */
--- 2196,2202 ----
  
  /* ======================================================== */
  
! #ifdef TARGET_LINUX 
  
  /* How to refer to registers in assembler output.  This sequence is
     indexed by compiler's hard-register-number (see above).  */
***************
*** 1675,1694 ****
  	  }								\
  	else								\
  	  { 								\
-             char buf[50];						\
-             REAL_VALUE_TYPE rval;					\
-             REAL_VALUE_FROM_CONST_DOUBLE(rval, XV);			\
-             REAL_VALUE_TO_DECIMAL (rval, HOST_WIDE_INT_PRINT_DEC, buf);	\
  	    if (GET_MODE (XV) == SFmode)				\
  	      {								\
  		mvs_page_lit += 4;					\
! 		fprintf (FILE, "=E'%s'", buf);				\
  	      }								\
  	    else							\
  	    if (GET_MODE (XV) == DFmode)				\
  	      {								\
  		mvs_page_lit += 8;					\
! 		fprintf (FILE, "=D'%s'", buf);				\
  	      }								\
  	    else /* VOIDmode !?!? strange but true ...  */		\
  	      {								\
--- 2309,2328 ----
  	  }								\
  	else								\
  	  { 								\
  	    if (GET_MODE (XV) == SFmode)				\
  	      {								\
+ 	        REAL_VALUE_TYPE rval;					\
+ 	        REAL_VALUE_FROM_CONST_DOUBLE(rval, XV);			\
  		mvs_page_lit += 4;					\
! 		fprintf (FILE, "=E'%s'", mvs_make_float(rval));		\
  	      }								\
  	    else							\
  	    if (GET_MODE (XV) == DFmode)				\
  	      {								\
+ 	        REAL_VALUE_TYPE rval;					\
+ 	        REAL_VALUE_FROM_CONST_DOUBLE(rval, XV);			\
  		mvs_page_lit += 8;					\
! 		fprintf (FILE, "=D'%s'", mvs_make_float(rval));		\
  	      }								\
  	    else /* VOIDmode !?!? strange but true ...  */		\
  	      {								\
***************
*** 1803,1809 ****
  	if (offset)							\
  	  {								\
  	    if (GET_CODE (offset) == LABEL_REF)				\
! 	      fprintf (FILE, "L%d",					\
  			CODE_LABEL_NUMBER (XEXP (offset, 0)));		\
  	    else							\
  	      output_addr_const (FILE, offset);				\
--- 2437,2443 ----
  	if (offset)							\
  	  {								\
  	    if (GET_CODE (offset) == LABEL_REF)				\
! 	      fprintf (FILE, "@@L%d",					\
  			CODE_LABEL_NUMBER (XEXP (offset, 0)));		\
  	    else							\
  	      output_addr_const (FILE, offset);				\
***************
*** 1826,1831 ****
--- 2460,2543 ----
      }									\
  }
  
+ #ifdef ASM_DECLARE_FUNCTION_NAME
+ #undef ASM_DECLARE_FUNCTION_NAME
+ #endif
+ #define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL)			\
+ {									\
+   /* Save a copy of the function name. We need it later */		\
+   if (strlen (NAME) +1 > mvs_function_name_length)			\
+     {									\
+       if (mvs_function_name)						\
+ 	free (mvs_function_name);					\
+       mvs_function_name = 0;						\
+     }									\
+   if (!mvs_function_name)						\
+     {									\
+       mvs_function_name_length = strlen (NAME) * 2 + 1;			\
+       mvs_function_name = (char *) xmalloc (mvs_function_name_length);	\
+     }									\
+   strcpy (mvs_function_name, NAME);					\
+ 									\
+   ASM_DECLARE_RESULT (FILE, DECL_RESULT (DECL));			\
+ }
+ 
+ /* This macro generates the assembly code for function exit, on machines
+    that need it.  If FUNCTION_EPILOGUE is not defined then individual
+    return instructions are generated for each return statement.  Args are
+    same as for FUNCTION_PROLOGUE.
+ 
+    The function epilogue should not depend on the current stack pointer!
+    It should use the frame pointer only.  This is mandatory because
+    of alloca; we also take advantage of it to omit stack adjustments
+    before returning.  */
+ 
+ #define FUNCTION_EPILOGUE(FILE, LSIZE)					\
+ {									\
+   int i;								\
+   check_label_emit();							\
+   mvs_check_page (FILE,14,0);						\
+   fprintf (FILE, "# Function epilogue\n");				\
+   fprintf (FILE, "\tL\tr14,12(,r13)\n");				\
+   fprintf (FILE, "\tLM\t2,12,28(r13)\n");				\
+   fprintf (FILE, "\tL\tr13,8(,r13)\n");					\
+   fprintf (FILE, "\tBASR\tr1,r14\n");					\
+   fprintf (FILE, "# Function literal pool\n");				\
+   if (i370_enable_pic)							\
+     {									\
+       fprintf (FILE, ".data\n");					\
+       fprintf (FILE, "\t.balign\t4\n");					\
+       fprintf (FILE, ".LPOOL%d:\n",mvs_page_num);			\
+       fprintf (FILE, "\t.ltorg\n");					\
+       fprintf (FILE, "# Function page table\n");			\
+       fprintf (FILE, "\t.balign\t4\n");					\
+       fprintf (FILE, ".LPGT%d:\n", function_base_page);			\
+       mvs_page_num++;							\
+       for ( i = function_base_page; i < mvs_page_num; i++ )		\
+         {								\
+           fprintf (FILE, "\t.long\t.LPG%d\n", i);			\
+           fprintf (FILE, "\t.long\t.LPOOL%d\n", i);			\
+         }								\
+       /* fprintf (FILE, ".previous\n");	 */				\
+     }									\
+   else									\
+     {									\
+       fprintf (FILE, "\t.balign\t4\n");					\
+       fprintf (FILE, "\t.ltorg\n");					\
+       fprintf (FILE, "# Function page table\n");			\
+       fprintf (FILE, "\t.balign\t4\n");					\
+       fprintf (FILE, ".LPGT%d:\n", function_base_page);			\
+       mvs_page_num++;							\
+       for ( i = function_base_page; i < mvs_page_num; i++ )		\
+         {								\
+           fprintf (FILE, "\t.long\t.LPG%d\n", i);			\
+         }								\
+     }									\
+   mvs_free_label_list();						\
+ }
+ 
+ #define FUNCTION_PROLOGUE(FILE, LSIZE) i370_function_prolog ((FILE), (LSIZE));
+ 
  /* Output assembler code to FILE to increment profiler label # LABELNO
     for profiling a function entry.  */
  /* Make it a no-op for now, so we can at least compile glibc */
***************
*** 1955,1959 ****
    assemble_name ((FILE), (NAME)),               \
    fprintf ((FILE), ",%u\n", (ROUNDED)))
  
! #endif /* TARGET_ELF_ABI */
  #endif /* ! GCC_I370_H */
--- 2667,2671 ----
    assemble_name ((FILE), (NAME)),               \
    fprintf ((FILE), ",%u\n", (ROUNDED)))
  
! #endif /* TARGET_LINUX */
  #endif /* ! GCC_I370_H */
Index: gcc/gcc/config/i370/i370.md
diff -c gcc/gcc/config/i370/i370.md:1.1.1.1 gcc/gcc/config/i370/i370.md:1.114
*** gcc/gcc/config/i370/i370.md:1.1.1.1	Wed Feb 15 21:22:45 2006
--- gcc/gcc/config/i370/i370.md	Sun Nov 05 23:53:33 2017
***************
*** 1,9 ****
--- 1,18 ----
  ;;- Machine description for GNU compiler -- System/370 version.
+ 
+ ;; =======================================================================
+ ;; Note that this file is not nearly as complicated as it looks
+ ;; at first glance. See below the copyright notice for an explanation
+ ;; (you will get nowhere without an explanation).
+ ;; =======================================================================
+ 
+ 
  ;;  Copyright (C) 1989, 1993, 1994, 1995, 1997, 1998, 1999, 2000, 2002
  ;;  Free Software Foundation, Inc.
  ;;  Contributed by Jan Stein (jan@cd.chalmers.se).
  ;;  Modified for OS/390 LanguageEnvironment C by Dave Pitts (dpitts@cozx.com)
  ;;  Lots of Bug Fixes & Enhancements by Linas Vepstas (linas@linas.org)
+ ;;  More bug fixes by Paul Edwards (fight.subjugation@gmail.com)
  
  ;; This file is part of GNU CC.
  
***************
*** 22,27 ****
--- 31,197 ----
  ;; the Free Software Foundation, 59 Temple Place - Suite 330,
  ;; Boston, MA 02111-1307, USA.
  
+ 
+ ;; =======================================================================
+ ;; At the heart of the GCC backend (the backend is what generates the
+ ;; code for a particular CPU, the frontend deals with some high-level
+ ;; language - you can basically feed an arbitrary language into the
+ ;; front and get code for an arbitrary CPU out the back) is this 
+ ;; "machine description" file. This is where you put the S/370 
+ ;; instructions, e.g. "MH", multiply halfword, into a form that the 
+ ;; rest of the GCC compiler understands.
+ 
+ ;; At some point in GCC's deliberations, it will have a requirement
+ ;; to say multiply x (an integer) by say "5". This can be done by the
+ ;; MH instruction. The thing is that "x" could actually already be in
+ ;; a register, or it could be in memory. If in memory, it could be
+ ;; conveniently referenced by an RX instruction (ie base + index). It
+ ;; may not be accessible via an S address (base only), for whatever
+ ;; reason (typically, a variable is on the stack, and offset on the
+ ;; stack is more than 4096, so base + offset can't get to it).
+ 
+ ;; So basically GCC needs to be made aware of whether the MH instruction
+ ;; can operate on an S address, an RX, or only a register. The "ST"
+ ;; instruction is RX so can operate on RX or S. In this case, MH, the
+ ;; destination needs to be a register. It's an RX instruction though,
+ ;; so the source can be be an RX address. However, there's an
+ ;; additional constraint - the source must be a halfword, so this is
+ ;; only suitable for values between -32768 and 32767 inclusive.
+ ;; All this information needs to be communicated to the compiler.
+ 
+ ;; Let's take a look at this instruction:
+ ;;
+ ;; (define_insn ""
+ ;;   [(set (match_operand:SI 0 "register_operand" "=d")
+ ;;   (mult:SI (match_operand:SI 1 "register_operand" "0")
+ ;;    (match_operand:SI 2 "immediate_operand" "K")))]
+ ;;   ""
+ ;;   "*
+ ;; {
+ ;;   check_label_emit ();
+ ;;   mvs_check_page (0, 4, 0);
+ ;;   return \"MH	%0,%H2\";
+ ;; }"
+ ;;    [(set_attr "length" "4")]
+ ;; )
+ ;;
+ ;; The important things here are:
+ ;;
+ ;; the "mult:SI" tells it that this will do a multiply of fullword integers.
+ ;; If it had been "DI" it would be doublewords, ie either register pairs
+ ;; or 8 bytes of memory aligned on an 8-byte boundary. "SI" is a standard
+ ;; integer. "DI" is double-sized integer. "HI" is a halfword integer,
+ ;; and finally we have "QI" for a quarter, or byte operation.
+ ;;
+ ;; "mult" is a standard keyword that GCC knows and it will go looking for
+ ;; a pattern of this name when it needs to do a multiply.
+ 
+ ;; Next look at the "match_operand:SI". That tells it that the operand
+ ;; for this instruction needs to be an integer. If e.g. this said
+ ;; instead "DI", it would let GCC know that if it needs to multiply an
+ ;; integer, it first needs to move it into a register pair before doing
+ ;; this instruction. This bit is extremely important. The loading into
+ ;; the right registers needs to be done *BEFORE* the instruction is
+ ;; executed. It's too late at this stage of the game to start defining
+ ;; some temporary registers you would like to use to complete this
+ ;; operation.
+ 
+ ;; Next we see a "0". That means operand number 0, the destination.
+ ;;
+ ;; Then we have "register_operand". That means that the destination
+ ;; is a register. You can't use this to write an answer directly to
+ ;; memory. Note that you can find this keyword, and other keywords,
+ ;; in the "GCC internals" manual:
+ ;; https://gcc.gnu.org/onlinedocs/gcc-3.2.3/gccint/index.html
+ ;; under "Machine Descriptions", "RTL template", and
+ ;; are called the "predicate" (look for manual
+ ;; sections called "predicates" too). Some of these
+ ;; predicates are not documented there, they are specific to S/370.
+ ;; e.g. "s_operand" which says that it must be an S-type (ie no
+ ;; index) memory reference. So long as the compiler knows this in
+ ;; advance, it will take care of moving any variable into an S-type
+ ;; memory reference. Be careful. The predicate "r_or_s_operand"
+ ;; doesn't mean RX or S memory address. It means that the following
+ ;; pattern will deal with both a REGISTER and an S-type address.
+ 
+ ;; Next we have a constraint. That's the "=d". The "=" says that
+ ;; this operand will be an output (destination). A "+" would mean
+ ;; that it is both input and output. And nothing would mean
+ ;; input-only. These are documented in "constraint modifier
+ ;; characters" under "operand constraints" under "machine descriptions".
+ ;; The "d" bit would have been documented under "simple constraints",
+ ;; except it is not standard with GCC. It is an S/370 extension which
+ ;; means that it is a general register, ie even R0, rather than "a"
+ ;; which would be an address register (ie R0 isn't allowed). This
+ ;; lets GCC know that if it happens to have the value in R0, then
+ ;; that's fine. It doesn't need to go to the effort of moving it
+ ;; into say R1 in order to do the "MH" instruction.
+ 
+ ;; That completes the first operand. The second operand is a bit
+ ;; complicated. As you know, the MH instruction only takes 2
+ ;; operands. But in the general case (logically, for any machine),
+ ;; a multiply involves 3 separate things. There are two numbers
+ ;; that are multiplied together to produce a third. In the case
+ ;; of the MH instruction, it can only operate on itself. ie
+ ;; instead of a = b * c we have a = a * b. We need to inform GCC
+ ;; of that fact. We do this by saying that the second logical
+ ;; operand is actually the exact same thing as the first. We
+ ;; do this by setting the constraint to "0", meaning that the
+ ;; first operand is not just constrained to being a register -
+ ;; it's constrained to be the exact same register in operand 0!!!
+ 
+ ;; Finally on the last parameter, we need to tell it that the
+ ;; integer, e.g. "5", must be known at compile time. It can't
+ ;; be a variable. If it is a variable, it might exceed the limits
+ ;; of a halfword. So we tell it that it must be an "immediate
+ ;; operand". But that's not all. If the number is "50000", it will
+ ;; exceed the limit of a halfword. So we have another S/370-specific
+ ;; constraint. This time "K". "K" means that the value must lie
+ ;; between -32768 and 32767 so that this instruction can actually
+ ;; be used.
+ 
+ ;; That's the basics. You will need to refer to the manual for more
+ ;; details. However, there's more things to be aware of. There
+ ;; can actually be multiple constraints in the one instruction.
+ ;; e.g. if you want to move some data from R3 to R4, you can use
+ ;; the "LR" instruction. And to move from an RX memory address
+ ;; you can use "L". Both of these things are just "movsi" to GCC,
+ ;; and it expects to be able to move from a variety of data types.
+ ;; moving a constant or an arbitrary fullword in memory, are both
+ ;; done by the "L" instruction. But LR is only for registers.
+ ;; So we might see a constraint of "d" for operand 1, but "di"
+ ;; for operand 2. "g" would mean that we can take any data type.
+ 
+ ;; If operand 1 is "=d,dm" and operand 2 is "di,F", then what
+ ;; this means is that the "di" matches the "d", ignore the stuff
+ ;; after the comma, and the following pattern will deal with
+ ;; that combination. Which means that either a constant or a
+ ;; register can be the source, and the destination will be a
+ ;; register. If we now look after the comma, then we match
+ ;; "dm" with "F". What that means is that an immediate floating
+ ;; point value, such as "5.7" can be moved into either a
+ ;; data register (d) or any memory address (m). If it could only
+ ;; be moved into an S address, it would have an "S" there instead
+ ;; of a "m". So if you look at any pattern which involves "MVC",
+ ;; you will see that it is never exposed to an "m", it will
+ ;; always have an "S" there (or something even more stringent).
+ 
+ ;; Another thing to be aware of is that the patterns sometimes
+ ;; have standard names (like "movdi"). You can see these names
+ ;; documented in "Standard Pattern Names For Generation" or
+ ;; "Standard Names" under "Machine Descriptions". You
+ ;; can have multiple patterns
+ ;; to accomplish the same basic thing in different circumstances.
+ ;; The way it is organized is to put your preferred instructions
+ ;; first, and then the official name on the last one. A lot of
+ ;; the S/370 instructions have a first pattern that is only enabled
+ ;; if you activate "TARGET_CHAR_INSTRUCTIONS", which indeed, is on
+ ;; by default.
+ 
+ ;; Below here you will find documentation from my predecessors who
+ ;; seem to assume you've found, read, and understood the official
+ ;; documentation. :-)
+ 
  ;; =======================================================================
  ;; Condition codes for some of the instructions (in particular, for 
  ;; add, sub, shift, abs, etc. are handled with the cpp macro NOTICE_UPDATE_CC 
***************
*** 30,35 ****
--- 200,206 ----
  ;;
  ;;    a -- Any address register from 1 to 15.
  ;;    d -- Any register from 0 to 15.
+ ;;    f -- Floating point register
  ;;    I -- An 8-bit constant (0..255).
  ;;    J -- A 12-bit constant (0..4095).
  ;;    K -- A 16-bit constant (-32768..32767).
***************
*** 77,83 ****
  ;;   136 - internal function result buffer
  ;;   140 - numeric conversion buffer
  ;;   144 - pointer to internal function result buffer
! ;;   148 - start of automatic variables and function arguments
  ;;
  ;; To support programs larger than a page, 4096 bytes, PAGE_REGISTER points
  ;; to a page origin table, all internal labels are generated to reload the
--- 248,260 ----
  ;;   136 - internal function result buffer
  ;;   140 - numeric conversion buffer
  ;;   144 - pointer to internal function result buffer
! ;;   148 - start of function arguments and automatic variables 
! ;;
! ;; For TARGET_DIGNUS or TARGET_PDPMAC we use the stack locations for:
! ;;
! ;;   80 - numeric conversion buffer
! ;;   84 - pointer to internal function result buffer
! ;;   88 - start of function arguments and automatic variables
  ;;
  ;; To support programs larger than a page, 4096 bytes, PAGE_REGISTER points
  ;; to a page origin table, all internal labels are generated to reload the
***************
*** 159,201 ****
  ; tstqi instruction pattern(s).
  ;
  
! (define_insn ""
!   [(set (cc0)
! 	(match_operand:QI 0 "r_or_s_operand" "dm"))]
!   "unsigned_jump_follows_p (insn)"
!   "*
! {
!   check_label_emit ();
!   if (REG_P (operands[0]))
!     {
!       /* an unsigned compare to zero is always zero/not-zero...  */
!       mvs_check_page (0, 4, 4);
!       return \"N	%0,=XL4'000000FF'\";
!     }
!   mvs_check_page (0, 4, 0);
!   return \"CLI	%0,0\";
! }"
!    [(set_attr "length" "4")]
! )
  
! (define_insn "tstqi"
!   [(set (cc0)
!      (match_operand:QI 0 "register_operand" "d"))]
!   ""
!   "*
! {
!   check_label_emit ();
!   if (unsigned_jump_follows_p (insn))
!     {
!       /* an unsigned compare to zero is always zero/not-zero...  */
!       mvs_check_page (0, 4, 4);
!       return \"N	%0,=XL4'000000FF'\";
!     }
!   mvs_check_page (0, 8, 0);
!   return \"SLL	%0,24\;SRA	%0,24\";
! }"
!    [(set_attr "length" "8")]
! )
  
  ;
  ; tstdf instruction pattern(s).
--- 336,378 ----
  ; tstqi instruction pattern(s).
  ;
  
! ;(define_insn ""
! ;  [(set (cc0)
! ;	(match_operand:QI 0 "s_operand" "S"))]
! ;  "unsigned_jump_follows_p (insn)"
! ;  "*
! ;{
! ;  check_label_emit ();
! ;  if (REG_P (operands[0]))
! ;    {
! ;      /* an unsigned compare to zero is always zero/not-zero...  */
! ;      mvs_check_page (0, 4, 4);
! ;      return \"N	%0,=XL4'000000FF'\";
! ;    }
! ;  mvs_check_page (0, 4, 0);
! ;  return \"CLI	%0,0\";
! ;}"
! ;   [(set_attr "length" "4")]
! ;)
  
! ;(define_insn "tstqi"
! ;  [(set (cc0)
! ;     (match_operand:QI 0 "register_operand" "d"))]
! ;  ""
! ;  "*
! ;{
! ;  check_label_emit ();
! ;  if (unsigned_jump_follows_p (insn))
! ;    {
! ;      /* an unsigned compare to zero is always zero/not-zero...  */
! ;      mvs_check_page (0, 4, 4);
! ;      return \"N	%0,=XL4'000000FF'\";
! ;    }
! ;  mvs_check_page (0, 8, 0);
! ;  return \"SLL	%0,24\;SRA	%0,24\";
! ;}"
! ;   [(set_attr "length" "8")]
! ;)
  
  ;
  ; tstdf instruction pattern(s).
***************
*** 299,309 ****
  ;
  
  ; deprecate constraint d because it takes multiple instructions
! ; and a memeory access ...
  (define_insn "cmphi"
    [(set (cc0)
  	(compare (match_operand:HI 0 "register_operand" "d")
! 		 (match_operand:HI 1 "general_operand" "???dim")))]
    ""
    "*
  {
--- 476,486 ----
  ;
  
  ; deprecate constraint d because it takes multiple instructions
! ; and a memory access ...
  (define_insn "cmphi"
    [(set (cc0)
  	(compare (match_operand:HI 0 "register_operand" "d")
! 		 (match_operand:HI 1 "general_operand" "???diS")))]
    ""
    "*
  {
***************
*** 312,325 ****
      {
        mvs_check_page (0, 8, 0);
        if (unsigned_jump_follows_p (insn))
! 	return \"STH	%1,140(,13)\;CLM	%0,3,140(13)\";
!       return \"STH	%1,140(,13)\;CH	%0,140(,13)\";
      }
    if (GET_CODE (operands[1]) == CONST_INT)
      {
!       mvs_check_page (0, 4, 0);
        return \"CH	%0,%H1\";
      }
    mvs_check_page (0, 4, 0);
    return \"CH	%0,%1\";
  }"
--- 489,514 ----
      {
        mvs_check_page (0, 8, 0);
        if (unsigned_jump_follows_p (insn))
! 	return \"STH	%1,\" CONVLO \"(,13)\;CLM	%0,3,\" CONVLO \"(13)\";
!       return \"STH	%1,\" CONVLO \"(,13)\;CH	%0,\" CONVLO \"(,13)\";
      }
    if (GET_CODE (operands[1]) == CONST_INT)
      {
!       if (unsigned_jump_follows_p (insn))
!         {
!       mvs_check_page (0, 4, 2);
!       return \"CLM	%0,3,%H1\";
!         }
!       mvs_check_page (0, 4, 2);
        return \"CH	%0,%H1\";
      }
+   if (unsigned_jump_follows_p (insn))
+     {
+       mvs_check_page (0, 10, 0);
+       if (REG_P (operands[1]))
+ 	return \"STH	%1,\" CONVLO \"(,13)\;CLM	%0,3,\" CONVLO \"(13)\";
+       return \"MVC	\" CONVLO \"(2,13),%1\;CLM	%0,3,\" CONVLO \"(13)\";
+     }
    mvs_check_page (0, 4, 0);
    return \"CH	%0,%1\";
  }"
***************
*** 333,339 ****
  (define_insn ""
    [(set (cc0)
  	(compare (match_operand:QI 0 "r_or_s_operand" "dS")
! 		 (match_operand:QI 1 "r_or_s_operand" "diS")))]
    "unsigned_jump_follows_p (insn)"
    "*
  {
--- 522,528 ----
  (define_insn ""
    [(set (cc0)
  	(compare (match_operand:QI 0 "r_or_s_operand" "dS")
! 		 (match_operand:QI 1 "general_operand" "diS")))]
    "unsigned_jump_follows_p (insn)"
    "*
  {
***************
*** 343,349 ****
        if (REG_P (operands[1]))
  	{
  	  mvs_check_page (0, 8, 0);
!           return \"STC	%1,140(,13)\;CLM	%0,1,140(13)\";
          }
        if (GET_CODE (operands[1]) == CONST_INT)
  	{
--- 532,538 ----
        if (REG_P (operands[1]))
  	{
  	  mvs_check_page (0, 8, 0);
!           return \"STC	%1,\" CONVLO \"(,13)\;CLM	%0,1,\" CONVLO \"(13)\";
          }
        if (GET_CODE (operands[1]) == CONST_INT)
  	{
***************
*** 402,408 ****
            return \"CLM	%0,1,%1\";
          }
        mvs_check_page (0, 8, 0);
!       return \"STC	%1,140(,13)\;CLM	%0,1,140(13)\";
      }
    if (REG_P (operands[1]))
      {
--- 591,597 ----
            return \"CLM	%0,1,%1\";
          }
        mvs_check_page (0, 8, 0);
!       return \"STC	%1,\" CONVLO \"(,13)\;CLM	%0,1,\" CONVLO \"(13)\";
      }
    if (REG_P (operands[1]))
      {
***************
*** 475,480 ****
--- 664,670 ----
  
  ;
  ; cmpstrsi instruction pattern(s).
+ ; block must be less than 16M (24 bits) in length
  ;
  
  (define_expand "cmpstrsi"
***************
*** 514,524 ****
        op2 = gen_rtx_MEM (BLKmode, copy_to_mode_reg (SImode, op2));
      }
        
!   if (GET_CODE (operands[3]) == CONST_INT && INTVAL (operands[3]) < 256)
      {
        emit_insn (gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2,
  		gen_rtx_SET (VOIDmode, operands[0], 
! 			gen_rtx_COMPARE (VOIDmode, op1, op2)),
  		gen_rtx_USE (VOIDmode, operands[3]))));
      }
    else
--- 704,715 ----
        op2 = gen_rtx_MEM (BLKmode, copy_to_mode_reg (SImode, op2));
      }
        
!   if (GET_CODE (operands[3]) == CONST_INT 
!       && (unsigned)INTVAL (operands[3]) <= 256)
      {
        emit_insn (gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2,
  		gen_rtx_SET (VOIDmode, operands[0], 
! 			gen_rtx_COMPARE (SImode, op1, op2)), /* was VOIDmode */
  		gen_rtx_USE (VOIDmode, operands[3]))));
      }
    else
***************
*** 550,579 ****
    DONE;
  }")
  
! ; Compare a block that is less than 256 bytes in length.
  
  (define_insn ""
    [(set (match_operand:SI 0 "register_operand" "=d")
! 	(compare (match_operand:BLK 1 "s_operand" "m")
! 		 (match_operand:BLK 2 "s_operand" "m")))
!    (use (match_operand:QI 3 "immediate_operand" "I"))]
!   "((unsigned) INTVAL (operands[3]) < 256)"
    "*
  {
    check_label_emit ();
    mvs_check_page (0, 22, 0);
!   return \"LA	%0,%1\;CLC	%O1(%c3,%R1),%2\;BH	*+12\;BL	*+6\;SLR	%0,%0\;LNR	%0,%0\";
  }"
     [(set_attr "length" "22")]
  )
  
! ; Compare a block that is larger than 255 bytes in length.
  
  (define_insn "cmpstrsi_1"
    [(set (match_operand:SI 0 "register_operand" "+d")
!         (compare
!         (mem:BLK (subreg:SI (match_operand:DI 1 "register_operand" "+d") 0))
!         (mem:BLK (subreg:SI (match_operand:DI 2 "register_operand" "+d") 0))))
     (use (match_dup 1))
     (use (match_dup 2))
     (clobber (match_dup 1))
--- 741,772 ----
    DONE;
  }")
  
! ; Compare a block that is less than or equal to 256 bytes in length.
  
  (define_insn ""
    [(set (match_operand:SI 0 "register_operand" "=d")
! 	(compare:SI (match_operand:BLK 1 "s_operand" "S")
! 		 (match_operand:BLK 2 "s_operand" "S")))
!    (use (match_operand:SI 3 "immediate_operand" "i"))]
!   "((unsigned) INTVAL (operands[3]) <= 256)"
    "*
  {
    check_label_emit ();
    mvs_check_page (0, 22, 0);
!   return \"CLC	%O1(%c3,%R1),%2\;LA	%0,1(0,0)\;BH	*+12\;BL	*+6\;SLR	%0,%0\;LNR	%0,%0\";
  }"
     [(set_attr "length" "22")]
  )
  
! ; Compare a block that is larger than 256 bytes in length.
! ;        (mem:BLK (subreg:SI (match_operand:DI 1 "register_operand" "+d") 0))
! ;        (mem:BLK (subreg:SI (match_operand:DI 2 "register_operand" "+d") 0))))
  
  (define_insn "cmpstrsi_1"
    [(set (match_operand:SI 0 "register_operand" "+d")
!         (compare:SI
!         (mem:BLK (match_operand:DI 1 "register_operand" "+d") )
!         (mem:BLK (match_operand:DI 2 "register_operand" "+d") )))
     (use (match_dup 1))
     (use (match_dup 2))
     (clobber (match_dup 1))
***************
*** 597,607 ****
  ;
  
  (define_insn ""
! ;;  [(set (match_operand:DI 0 "r_or_s_operand" "=dm")
! ;;        (match_operand:DI 1 "r_or_s_operand" "dim*fF"))]
!   [(set (match_operand:DI 0 "r_or_s_operand" "=dS,m")
!         (match_operand:DI 1 "r_or_s_operand" "diS*fF,d*fF"))]
! 
    "TARGET_CHAR_INSTRUCTIONS"
    "*
  {
--- 790,799 ----
  ;
  
  (define_insn ""
!   [(set (match_operand:DI 0 "nonimmediate_operand" "=d,m,S")
!         (match_operand:DI 1 "general_operand" "g,d,SF"))]
! ;;  [(set (match_operand:DI 0 "r_or_s_operand" "=dS,m")
! ;;        (match_operand:DI 1 "r_or_s_operand" "diS*fF,d*fF"))]
    "TARGET_CHAR_INSTRUCTIONS"
    "*
  {
***************
*** 611,617 ****
        if (FP_REG_P (operands[1]))
  	{
  	  mvs_check_page (0, 8, 0);
! 	  return \"STD	%1,140(,13)\;LM	%0,%N0,140(13)\";
  	}
        if (REG_P (operands[1]))
  	{
--- 803,809 ----
        if (FP_REG_P (operands[1]))
  	{
  	  mvs_check_page (0, 8, 0);
! 	  return \"STD	%1,\" CONVLO \"(,13)\;LM	%0,%N0,\" CONVLO \"(13)\";
  	}
        if (REG_P (operands[1]))
  	{
***************
*** 637,644 ****
  	  mvs_check_page (0, 8, 0);
  	  return \"L	%0,%1\;SRDA	%0,32\";
  	}
        mvs_check_page (0, 4, 0);
!       return \"LM	%0,%N0,%1\";
      }
    else if (FP_REG_P (operands[1]))
      {
--- 829,842 ----
  	  mvs_check_page (0, 8, 0);
  	  return \"L	%0,%1\;SRDA	%0,32\";
  	}
+       if (GET_CODE (operands[1]) == CONST_DOUBLE)
+ 	{
+ 	  mvs_check_page (0, 6, 8);
+ 	  return \"LM	%0,%N0,%1\";
+ 	}
        mvs_check_page (0, 4, 0);
!       /*return \"LM	%0,%N0,%1\";*/
!       return \"L	%0,%1\;L	%N0,4+%1\";
      }
    else if (FP_REG_P (operands[1]))
      {
***************
*** 648,666 ****
    else if (REG_P (operands[1]))
      {
        mvs_check_page (0, 4, 0);
!       return \"STM	%1,%N1,%0\"; 
      }
!   mvs_check_page (0, 6, 0);
!   return \"MVC	%O0(8,%R0),%W1\";
  }"
     [(set_attr "length" "8")]
  )
  
  (define_insn "movdi"
  ;;  [(set (match_operand:DI 0 "general_operand" "=d,dm")
! ;;	(match_operand:DI 1 "general_operand" "dimF,*fd"))]
!   [(set (match_operand:DI 0 "general_operand" "=d,dm")
! 	(match_operand:DI 1 "r_or_s_operand" "diSF,*fd"))]
    ""
    "*
  {
--- 846,865 ----
    else if (REG_P (operands[1]))
      {
        mvs_check_page (0, 4, 0);
!       /*return \"STM	%1,%N1,%0\"; */
!       return \"ST	%1,%0\;ST	%N1,4+%0\"; 
      }
!   mvs_check_page (0, 6, 8);
!   return \"MVC	%O0(8,%R0),%1\";
  }"
     [(set_attr "length" "8")]
  )
  
  (define_insn "movdi"
+   [(set (match_operand:DI 0 "nonimmediate_operand" "=d,dm")
+ 	(match_operand:DI 1 "general_operand" "dimF,*fd"))]
  ;;  [(set (match_operand:DI 0 "general_operand" "=d,dm")
! ;;	(match_operand:DI 1 "r_or_s_operand" "diSF,*fd"))]
    ""
    "*
  {
***************
*** 670,676 ****
        if (FP_REG_P (operands[1]))
  	{
  	  mvs_check_page (0, 8, 0);
! 	  return \"STD	%1,140(,13)\;LM	%0,%N0,140(13)\";
  	}
        if (REG_P (operands[1]))
  	{
--- 869,875 ----
        if (FP_REG_P (operands[1]))
  	{
  	  mvs_check_page (0, 8, 0);
! 	  return \"STD	%1,\" CONVLO \"(,13)\;LM	%0,%N0,\" CONVLO \"(13)\";
  	}
        if (REG_P (operands[1]))
  	{
***************
*** 697,703 ****
  	  return \"L	%0,%1\;SRDA	%0,32\";
  	}
        mvs_check_page (0, 4, 0);
!       return \"LM	%0,%N0,%1\";
      }
    else if (FP_REG_P (operands[1]))
      {
--- 896,903 ----
  	  return \"L	%0,%1\;SRDA	%0,32\";
  	}
        mvs_check_page (0, 4, 0);
!       /*return \"LM	%0,%N0,%1\";*/
!       return \"L	%0,%1\;L	%N0,4+%1\";
      }
    else if (FP_REG_P (operands[1]))
      {
***************
*** 705,711 ****
        return \"STD	%1,%0\";
      }
    mvs_check_page (0, 4, 0);
!   return \"STM	%1,%N1,%0\";
  }"
     [(set_attr "length" "8")]
  )
--- 905,912 ----
        return \"STD	%1,%0\";
      }
    mvs_check_page (0, 4, 0);
!   /*return \"STM	%1,%N1,%0\"; */
!   return \"ST	%1,%0\;ST	%N1,4+%0\"; 
  }"
     [(set_attr "length" "8")]
  )
***************
*** 715,807 ****
  ;; discourage its use by listing this alternative last.
  ;; The problem is that the instructions above only provide 
  ;; S-form style (base + displacement) mem access, while the
! ;; below provvides the full (base+index+displacement) RX-form.
  ;; These are rarely needed, but when needed they're needed.
  
! (define_insn ""
!   [(set (match_operand:DI 0 "general_operand" "=d,???m")
!         (match_operand:DI 1 "general_operand" "???m,d"))]
! 
!   ""
!   "*
! {
!   check_label_emit ();
!   if (REG_P (operands[0]))
!     {
!       mvs_check_page (0, 8, 0);
!       return \"LM	%0,%N0,%1\";
!     }
!   else if (REG_P (operands[1]))
!     {
!       mvs_check_page (0, 8, 0);
!       return \"STM	%1,%N1,%0\";
!     }
!   mvs_check_page (0, 6, 0);
!   return \"MVC	%O0(8,%R0),%1\";
! }"
!    [(set_attr "length" "8")]
! )
  
  ;
  ; movsi instruction pattern(s).
  ;
  
! (define_insn ""
! ;;  [(set (match_operand:SI 0 "r_or_s_operand" "=dm,d,dm")
! ;;        (match_operand:SI 1 "r_or_s_operand" "diR,dim,*fF"))]
!   [(set (match_operand:SI 0 "r_or_s_operand" "=d,dS,dm")
!         (match_operand:SI 1 "general_operand" "dim,diS,di*fF"))]
! 
!   "TARGET_CHAR_INSTRUCTIONS"
!   "*
! {
!   check_label_emit ();
!   if (REG_P (operands[0]))
!     {
!       if (FP_REG_P (operands[1]))
! 	{
! 	  mvs_check_page (0, 8, 0);
! 	  return \"STE	%1,140(,13)\;L	%0,140(,13)\";
! 	}
!       if (REG_P (operands[1]))
! 	{
! 	  mvs_check_page (0, 2, 0);
! 	  return \"LR	%0,%1\";
! 	}
!       if (operands[1] == const0_rtx)
! 	{
! 	  CC_STATUS_INIT;
! 	  mvs_check_page (0, 2, 0);
! 	  return \"SLR	%0,%0\";
! 	}
!       if (GET_CODE (operands[1]) == CONST_INT
!  	  && (unsigned) INTVAL (operands[1]) < 4096)
! 	{
! 	  mvs_check_page (0, 4, 0);
! 	  return \"LA	%0,%c1(0,0)\";
! 	}
!       mvs_check_page (0, 4, 0);
!       return \"L	%0,%1\";
!     }
!   else if (FP_REG_P (operands[1]))
!     {
!       mvs_check_page (0, 4, 0);
!       return \"STE	%1,%0\";
!     }
!   else if (REG_P (operands[1]))
!     {
!       mvs_check_page (0, 4, 0);
!       return \"ST	%1,%0\";
!     }
!   mvs_check_page (0, 6, 0);
!   return \"MVC	%O0(4,%R0),%1\";
! }"
!    [(set_attr "length" "8")]
! )
  
  (define_insn "movsi"
!   [(set (match_operand:SI 0 "general_operand" "=d,dm")
! 	(match_operand:SI 1 "general_operand" "dimF,*fd"))]
    ""
    "*
  {
--- 916,961 ----
  ;; discourage its use by listing this alternative last.
  ;; The problem is that the instructions above only provide 
  ;; S-form style (base + displacement) mem access, while the
! ;; below provides the full (base+index+displacement) RX-form.
  ;; These are rarely needed, but when needed they're needed.
+ ;; Don't use LM/STM as they can't handle a full RX-form address.
  
! ;;(define_insn ""
! ;;  [(set (match_operand:DI 0 "general_operand" "=d,???m")
! ;;        (match_operand:DI 1 "general_operand" "???m,d"))]
! ;;
! ;;  ""
! ;;  "*
! ;;{
! ;;  check_label_emit ();
! ;;  if (REG_P (operands[0]))
! ;;    {
! ;;      mvs_check_page (0, 8, 0);
! ;;      return \"L	%0,%1\;L	%N0,4+%1\";
! ;;    }
! ;;  else if (REG_P (operands[1]))
! ;;    {
! ;;      mvs_check_page (0, 8, 0);
! ;;      return \"ST	%1,%0\;ST	%N1,4+%0\";
! ;;    }
! ;;  mvs_check_page (0, 6, 8);
! ;;  return \"MVC	%O0(8,%R0),%1\";
! ;;}"
! ;;   [(set_attr "length" "8")]
! ;;)
  
  ;
  ; movsi instruction pattern(s).
  ;
  
! ; For some reason, presumably a bug somewhere, we need to use
! ; "R" in the constraint rather than "S", otherwise it doesn't
! ; allow MVCs to be generated in circumstances where it should.
! ; Using "R" is harmless enough in this circumstance though.
  
  (define_insn "movsi"
!   [(set (match_operand:SI 0 "nonimmediate_operand" "=d,dm,R")
! 	(match_operand:SI 1 "general_operand" "dimF,*fd,R"))]
    ""
    "*
  {
***************
*** 811,817 ****
        if (FP_REG_P (operands[1]))
  	{
  	  mvs_check_page (0, 8, 0);
! 	  return \"STE	%1,140(,13)\;L	%0,140(,13)\";
  	}
        if (REG_P (operands[1]))
  	{
--- 965,971 ----
        if (FP_REG_P (operands[1]))
  	{
  	  mvs_check_page (0, 8, 0);
! 	  return \"STE	%1,\" CONVLO \"(,13)\;L	%0,\" CONVLO \"(,13)\";
  	}
        if (REG_P (operands[1]))
  	{
***************
*** 838,884 ****
        mvs_check_page (0, 4, 0);
        return \"STE	%1,%0\";
      }
    mvs_check_page (0, 4, 0);
    return \"ST	%1,%0\";
  }"
     [(set_attr "length" "8")]
  )
  
- ;(define_expand "movsi"
- ;  [(set (match_operand:SI 0 "general_operand" "=d,dm")
- ;	(match_operand:SI 1 "general_operand" "dimF,*fd"))]
- ;  ""
- ;  "
- ;{
- ;  rtx op0, op1;
- ;
- ;  op0 = operands[0];
- ;  if (GET_CODE (op0) == CONST
- ;      && GET_CODE (XEXP (XEXP (op0, 0), 0)) == SYMBOL_REF
- ;      && SYMBOL_REF_FLAG (XEXP (XEXP (op0, 0), 0)))
- ;    {
- ;      op0 = gen_rtx_MEM (SImode, copy_to_mode_reg (SImode, XEXP (op0, 0)));
- ;    }
- ;
- ;  op1 = operands[1];
- ;  if (GET_CODE (op1) == CONST
- ;      && GET_CODE (XEXP (XEXP (op1, 0), 0)) == SYMBOL_REF
- ;      && SYMBOL_REF_FLAG (XEXP (XEXP (op1, 0), 0)))
- ;    {
- ;      op1 = gen_rtx_MEM (SImode, copy_to_mode_reg (SImode, XEXP (op1, 0)));
- ;    }
- ;
- ;  emit_insn (gen_rtx_SET (VOIDmode, op0, op1));
- ;  DONE;
- ;}")
- 
  ;
  ; movhi instruction pattern(s).
  ;
  
  (define_insn ""
!   [(set (match_operand:HI 0 "r_or_s_operand" "=g")
!         (match_operand:HI 1 "r_or_s_operand" "g"))]
    "TARGET_CHAR_INSTRUCTIONS"
    "*
  {
--- 992,1015 ----
        mvs_check_page (0, 4, 0);
        return \"STE	%1,%0\";
      }
+   else if (!REG_P (operands[1]))
+     {
+       mvs_check_page (0, 6, 0);
+       return \"MVC	%O0(4,%R0),%1\";
+     }
    mvs_check_page (0, 4, 0);
    return \"ST	%1,%0\";
  }"
     [(set_attr "length" "8")]
  )
  
  ;
  ; movhi instruction pattern(s).
  ;
  
  (define_insn ""
!   [(set (match_operand:HI 0 "r_or_s_operand" "=R,d")
!         (match_operand:HI 1 "general_operand" "R,g"))]
    "TARGET_CHAR_INSTRUCTIONS"
    "*
  {
***************
*** 904,910 ****
  	}
        if (GET_CODE (operands[1]) == CONST_INT)
  	{
! 	  mvs_check_page (0, 4, 0);
  	  return \"LH	%0,%H1\";
  	}
        mvs_check_page (0, 4, 0);
--- 1035,1041 ----
  	}
        if (GET_CODE (operands[1]) == CONST_INT)
  	{
! 	  mvs_check_page (0, 4, 2);
  	  return \"LH	%0,%H1\";
  	}
        mvs_check_page (0, 4, 0);
***************
*** 917,923 ****
      }
    if (GET_CODE (operands[1]) == CONST_INT)
      {
!       mvs_check_page (0, 6, 0);
        return \"MVC	%O0(2,%R0),%H1\";
      }
    mvs_check_page (0, 6, 0);
--- 1048,1054 ----
      }
    if (GET_CODE (operands[1]) == CONST_INT)
      {
!       mvs_check_page (0, 6, 2);
        return \"MVC	%O0(2,%R0),%H1\";
      }
    mvs_check_page (0, 6, 0);
***************
*** 927,933 ****
  )
  
  (define_insn "movhi"
!   [(set (match_operand:HI 0 "general_operand" "=d,m")
  	(match_operand:HI 1 "general_operand" "g,d"))]
    ""
    "*
--- 1058,1064 ----
  )
  
  (define_insn "movhi"
!   [(set (match_operand:HI 0 "nonimmediate_operand" "=d,m")
  	(match_operand:HI 1 "general_operand" "g,d"))]
    ""
    "*
***************
*** 954,960 ****
  	}
        if (GET_CODE (operands[1]) == CONST_INT)
  	{
! 	  mvs_check_page (0, 4, 0);
  	  return \"LH	%0,%H1\";
  	}
        mvs_check_page (0, 4, 0);
--- 1085,1091 ----
  	}
        if (GET_CODE (operands[1]) == CONST_INT)
  	{
! 	  mvs_check_page (0, 4, 2);
  	  return \"LH	%0,%H1\";
  	}
        mvs_check_page (0, 4, 0);
***************
*** 971,978 ****
  ;
  
  (define_insn ""
!   [(set (match_operand:QI 0 "r_or_s_operand" "=g")
! 	(match_operand:QI 1 "r_or_s_operand" "g"))]
    "TARGET_CHAR_INSTRUCTIONS"
    "*
  {
--- 1102,1109 ----
  ;
  
  (define_insn ""
!   [(set (match_operand:QI 0 "r_or_s_operand" "=R,d")
! 	(match_operand:QI 1 "general_operand" "R,g"))]
    "TARGET_CHAR_INSTRUCTIONS"
    "*
  {
***************
*** 998,1004 ****
  	      mvs_check_page (0, 4, 0);
  	      return \"LA	%0,%c1(0,0)\";
  	    }
! 	  mvs_check_page (0, 4, 0);
  	  return \"L	%0,=F'%c1'\";
  	}
        mvs_check_page (0, 4, 0);
--- 1129,1135 ----
  	      mvs_check_page (0, 4, 0);
  	      return \"LA	%0,%c1(0,0)\";
  	    }
! 	  mvs_check_page (0, 4, 4);
  	  return \"L	%0,=F'%c1'\";
  	}
        mvs_check_page (0, 4, 0);
***************
*** 1021,1027 ****
  )
  
  (define_insn "movqi"
!   [(set (match_operand:QI 0 "general_operand" "=d,m")
  	(match_operand:QI 1 "general_operand" "g,d"))]
    ""
    "*
--- 1152,1158 ----
  )
  
  (define_insn "movqi"
!   [(set (match_operand:QI 0 "nonimmediate_operand" "=d,m")
  	(match_operand:QI 1 "general_operand" "g,d"))]
    ""
    "*
***************
*** 1048,1054 ****
  	      mvs_check_page (0, 4, 0);
  	      return \"LA	%0,%c1(0,0)\";
  	    }
! 	  mvs_check_page (0, 4, 0);
  	  return \"L	%0,=F'%c1'\";
  	}
        mvs_check_page (0, 4, 0);
--- 1179,1185 ----
  	      mvs_check_page (0, 4, 0);
  	      return \"LA	%0,%c1(0,0)\";
  	    }
! 	  mvs_check_page (0, 4, 4);
  	  return \"L	%0,=F'%c1'\";
  	}
        mvs_check_page (0, 4, 0);
***************
*** 1063,1116 ****
  ;
  ; movstrictqi instruction pattern(s).
  ;
! 
! (define_insn "movstrictqi"
!   [(set (strict_low_part (match_operand:QI 0 "general_operand" "+d"))
! 	(match_operand:QI 1 "general_operand" "g"))]
!   ""
!   "*
! {
!   check_label_emit ();
!   if (REG_P (operands[1]))
!     {
!       mvs_check_page (0, 8, 0);
!       return \"STC	%1,140(,13)\;IC	%0,140(,13)\";
!     }
!   mvs_check_page (0, 4, 0);
!   return \"IC	%0,%1\";
! }"
!    [(set_attr "length" "8")]
! )
  
  ;
  ; movstricthi instruction pattern(s).
  ;
  
! (define_insn ""
!   [(set (strict_low_part (match_operand:HI 0 "register_operand" "+d"))
! 	(match_operand:HI 1 "r_or_s_operand" "g"))]
!   ""
!   "*
! {
!   check_label_emit ();
!   if (REG_P (operands[1]))
!     {
!       mvs_check_page (0, 8, 0);
!       return \"STH	%1,140(,13)\;ICM	%0,3,140(13)\";
!     }
!   else if (GET_CODE (operands[1]) == CONST_INT)
!     {
!       mvs_check_page (0, 4, 0);
!       return \"ICM	%0,3,%H1\";
!     }
!   mvs_check_page (0, 4, 0);
!   return \"ICM	%0,3,%1\";
! }"
!    [(set_attr "length" "8")]
! )
  
  (define_insn "movstricthi"
!   [(set (strict_low_part (match_operand:HI 0 "general_operand" "+dm"))
  	(match_operand:HI 1 "general_operand" "d"))]
    ""
    "*
--- 1194,1267 ----
  ;
  ; movstrictqi instruction pattern(s).
  ;
! ; Need to comment this out in 3.4.6 because otherwise we are
! ; getting an IC generated followed by a branch, when there
! ; should have been an intervening compare.
! 
! ;(define_insn "movstrictqi"
! ;  [(set (strict_low_part (match_operand:QI 0 "register_operand" "+d"))
! ;   (match_operand:QI 1 "general_operand" "g"))]
! ;  ""
! ;  "*
! ;{
! ;  check_label_emit ();
! ;  if (REG_P (operands[1]))
! ;    {
! ;      mvs_check_page (0, 8, 0);
! ;      return \"STC	%1,\" CONVLO \"(,13)\;IC	%0,\" CONVLO \"(,13)\";
! ;    }
! ;  mvs_check_page (0, 4, 0);
! ;  return \"IC	%0,=XL1'%X1'\";
! ;}"
! ;   [(set_attr "length" "8")]
! ;)
  
  ;
  ; movstricthi instruction pattern(s).
  ;
+ ; Need to comment this out in 3.4.6 because otherwise we are
+ ; getting code like this (example from stdio):
  
! ; SLR   2,2
! ; IC    2,0(8)
! ; LA    5,92(0,0)
! ; CLR   2,5
! ; BE    L699
! ; BH    L702
! ; ICM   5,3,=H'64'
! ; BE    L696
! ; ICM   5,3,=H'78'
! ; BE    L694
! 
! ; ie using ICM instead of LA, and then failing to actually do
! ; the compare! Was causing a branch to not be done (for the "+")
! ; in stdio ; when doing printf("%+d")
! 
! ;(define_insn ""
! ;  [(set (strict_low_part (match_operand:HI 0 "register_operand" "+d"))
! ;	(match_operand:HI 1 "general_operand" "dSi"))]
! ;  ""
! ;  "*
! ;{
! ;  check_label_emit ();
! ;  if (REG_P (operands[1]))
! ;    {
! ;      mvs_check_page (0, 8, 0);
! ;      return \"STH	%1,\" CONVLO \"(,13)\;ICM	%0,3,\" CONVLO \"(13)\";
! ;    }
! ;  else if (GET_CODE (operands[1]) == CONST_INT)
! ;    {
! ;      mvs_check_page (0, 4, 2);
! ;      return \"ICM	%0,3,%H1\";
! ;    }
! ;  mvs_check_page (0, 4, 0);
! ;  return \"ICM	%0,3,%1\";
! ;}"
! ;   [(set_attr "length" "8")]
! ;)
  
  (define_insn "movstricthi"
!   [(set (strict_low_part (match_operand:HI 0 "nonimmediate_operand" "+dm"))
  	(match_operand:HI 1 "general_operand" "d"))]
    ""
    "*
***************
*** 1119,1125 ****
    if (REG_P (operands[0]))
      {
        mvs_check_page (0, 8, 0);
!       return \"STH	%1,140(,13)\;ICM	%0,3,140(13)\";
      }
    mvs_check_page (0, 4, 0);
    return \"STH	%1,%0\";
--- 1270,1276 ----
    if (REG_P (operands[0]))
      {
        mvs_check_page (0, 8, 0);
!       return \"STH	%1,\" CONVLO \"(,13)\;ICM	%0,3,\" CONVLO \"(13)\";
      }
    mvs_check_page (0, 4, 0);
    return \"STH	%1,%0\";
***************
*** 1134,1142 ****
  (define_insn ""
  ;;  [(set (match_operand:DF 0 "r_or_s_operand" "=fm,fm,*dm")
  ;;        (match_operand:DF 1 "r_or_s_operand" "fmF,*dm,fmF"))]
!   [(set (match_operand:DF 0 "general_operand" "=f,m,fS,*dS,???d")
!       (match_operand:DF 1 "general_operand" "fmF,fF,*dS,fSF,???d"))]
! 
    "TARGET_CHAR_INSTRUCTIONS"
    "*
  {
--- 1285,1292 ----
  (define_insn ""
  ;;  [(set (match_operand:DF 0 "r_or_s_operand" "=fm,fm,*dm")
  ;;        (match_operand:DF 1 "r_or_s_operand" "fmF,*dm,fmF"))]
!   [(set (match_operand:DF 0 "nonimmediate_operand" "=f,m,fS,*dS,???d")
!       (match_operand:DF 1 "general_operand" "fmF,f,*dS,fSF,???d"))]
    "TARGET_CHAR_INSTRUCTIONS"
    "*
  {
***************
*** 1151,1157 ****
        if (REG_P (operands[1]))
  	{
  	  mvs_check_page (0, 8, 0);
! 	  return \"STM	%1,%N1,140(13)\;LD	%0,140(,13)\";
  	}
        if (operands[1] == const0_rtx)
  	{
--- 1301,1307 ----
        if (REG_P (operands[1]))
  	{
  	  mvs_check_page (0, 8, 0);
! 	  return \"STM	%1,%N1,\" CONVLO \"(13)\;LD	%0,\" CONVLO \"(,13)\";
  	}
        if (operands[1] == const0_rtx)
  	{
***************
*** 1167,1173 ****
        if (FP_REG_P (operands[1]))
  	{
  	  mvs_check_page (0, 12, 0);
! 	  return \"STD	%1,140(,13)\;LM	%0,%N0,140(13)\";
  	}
        if (REG_P (operands[1]))
  	{
--- 1317,1323 ----
        if (FP_REG_P (operands[1]))
  	{
  	  mvs_check_page (0, 12, 0);
! 	  return \"STD	%1,\" CONVLO \"(,13)\;LM	%0,%N0,\" CONVLO \"(13)\";
  	}
        if (REG_P (operands[1]))
  	{
***************
*** 1176,1181 ****
--- 1326,1332 ----
  	}
        mvs_check_page (0, 4, 0);
        return \"LM	%0,%N0,%1\";
+       /*return \"L	%0,%1\;L	%N0,4+%1\";*/
      }
    else if (FP_REG_P (operands[1]))
      {
***************
*** 1185,1193 ****
    else if (REG_P (operands[1]))
      {
        mvs_check_page (0, 4, 0);
!       return \"STM	%1,%N1,%0\";
      }
!   mvs_check_page (0, 6, 0);
    return \"MVC	%O0(8,%R0),%1\";
  }"
     [(set_attr "length" "12")]
--- 1336,1345 ----
    else if (REG_P (operands[1]))
      {
        mvs_check_page (0, 4, 0);
!       /*return \"STM	%1,%N1,%0\"; */
!       return \"ST	%1,%0\;ST	%N1,4+%0\"; 
      }
!   mvs_check_page (0, 6, 8);
    return \"MVC	%O0(8,%R0),%1\";
  }"
     [(set_attr "length" "12")]
***************
*** 1196,1204 ****
  (define_insn "movdf"
  ;;  [(set (match_operand:DF 0 "general_operand" "=f,fm,m,*d")
  ;;	(match_operand:DF 1 "general_operand" "fmF,*d,f,fmF"))]
!   [(set (match_operand:DF 0 "general_operand" "=f,m,fS,*d,???d")
        (match_operand:DF 1 "general_operand" "fmF,f,*d,SfF,???d"))]
- 
    ""
    "*
  {
--- 1348,1355 ----
  (define_insn "movdf"
  ;;  [(set (match_operand:DF 0 "general_operand" "=f,fm,m,*d")
  ;;	(match_operand:DF 1 "general_operand" "fmF,*d,f,fmF"))]
!   [(set (match_operand:DF 0 "nonimmediate_operand" "=f,m,fS,*d,???d")
        (match_operand:DF 1 "general_operand" "fmF,f,*d,SfF,???d"))]
    ""
    "*
  {
***************
*** 1213,1219 ****
        if (REG_P (operands[1]))
  	{
  	  mvs_check_page (0, 8, 0);
! 	  return \"STM	%1,%N1,140(13)\;LD	%0,140(,13)\";
  	}
        if (operands[1] == const0_rtx)
  	{
--- 1364,1370 ----
        if (REG_P (operands[1]))
  	{
  	  mvs_check_page (0, 8, 0);
! 	  return \"STM	%1,%N1,\" CONVLO \"(13)\;LD	%0,\" CONVLO \"(,13)\";
  	}
        if (operands[1] == const0_rtx)
  	{
***************
*** 1229,1235 ****
        if (FP_REG_P (operands[1]))
  	{
  	  mvs_check_page (0, 12, 0);
! 	  return \"STD	%1,140(,13)\;LM	%0,%N0,140(13)\";
  	}
        if (REG_P (operands[1]))
  	{
--- 1380,1386 ----
        if (FP_REG_P (operands[1]))
  	{
  	  mvs_check_page (0, 12, 0);
! 	  return \"STD	%1,\" CONVLO \"(,13)\;LM	%0,%N0,\" CONVLO \"(13)\";
  	}
        if (REG_P (operands[1]))
  	{
***************
*** 1237,1243 ****
  	  return \"LR	%0,%1\;LR	%N0,%N1\";
  	}
        mvs_check_page (0, 4, 0);
!       return \"LM	%0,%N0,%1\";
      }
    else if (FP_REG_P (operands[1]))
      {
--- 1388,1395 ----
  	  return \"LR	%0,%1\;LR	%N0,%N1\";
  	}
        mvs_check_page (0, 4, 0);
!       /*return \"LM	%0,%N0,%1\";*/
!       return \"L	%0,%1\;L	%N0,4+%1\";
      }
    else if (FP_REG_P (operands[1]))
      {
***************
*** 1245,1251 ****
        return \"STD	%1,%0\";
      }
    mvs_check_page (0, 4, 0);
!   return \"STM	%1,%N1,%0\";
  }"
     [(set_attr "length" "12")]
  )
--- 1397,1404 ----
        return \"STD	%1,%0\";
      }
    mvs_check_page (0, 4, 0);
!   /*return \"STM	%1,%N1,%0\"; */
!   return \"ST	%1,%0\;ST	%N1,4+%0\"; 
  }"
     [(set_attr "length" "12")]
  )
***************
*** 1259,1267 ****
  ;;        (match_operand:SF 1 "r_or_s_operand" "fmF,*dm,fmF"))]
  ;;  [(set (match_operand:SF 0 "general_operand" "=f,m,fm,*d,S")
  ;;         (match_operand:SF 1 "general_operand" "fmF,fF,*d,fmF,S"))]
!   [(set (match_operand:SF 0 "general_operand" "=f*d,fm,S,???d")
          (match_operand:SF 1 "general_operand" "fmF,fF*d,S,???d"))]
- 
    "TARGET_CHAR_INSTRUCTIONS"
    "*
  {
--- 1412,1419 ----
  ;;        (match_operand:SF 1 "r_or_s_operand" "fmF,*dm,fmF"))]
  ;;  [(set (match_operand:SF 0 "general_operand" "=f,m,fm,*d,S")
  ;;         (match_operand:SF 1 "general_operand" "fmF,fF,*d,fmF,S"))]
!   [(set (match_operand:SF 0 "nonimmediate_operand" "=f*d,fm,S,???d")
          (match_operand:SF 1 "general_operand" "fmF,fF*d,S,???d"))]
    "TARGET_CHAR_INSTRUCTIONS"
    "*
  {
***************
*** 1276,1282 ****
        if (REG_P (operands[1]))
  	{
  	  mvs_check_page (0, 8, 0);
! 	  return \"ST	%1,140(,13)\;LE	%0,140(,13)\";
  	}
        if (operands[1] == const0_rtx)
  	{
--- 1428,1434 ----
        if (REG_P (operands[1]))
  	{
  	  mvs_check_page (0, 8, 0);
! 	  return \"ST	%1,\" CONVLO \"(,13)\;LE	%0,\" CONVLO \"(,13)\";
  	}
        if (operands[1] == const0_rtx)
  	{
***************
*** 1292,1298 ****
        if (FP_REG_P (operands[1]))
  	{
  	  mvs_check_page (0, 8, 0);
! 	  return \"STE	%1,140(,13)\;L	%0,140(,13)\";
  	}
        if (REG_P (operands[1]))
  	{
--- 1444,1450 ----
        if (FP_REG_P (operands[1]))
  	{
  	  mvs_check_page (0, 8, 0);
! 	  return \"STE	%1,\" CONVLO \"(,13)\;L	%0,\" CONVLO \"(,13)\";
  	}
        if (REG_P (operands[1]))
  	{
***************
*** 1319,1325 ****
  )
  
  (define_insn "movsf"
!   [(set (match_operand:SF 0 "general_operand" "=f,fm,m,*d")
  	(match_operand:SF 1 "general_operand" "fmF,*d,f,fmF"))]
    ""
    "*
--- 1471,1477 ----
  )
  
  (define_insn "movsf"
!   [(set (match_operand:SF 0 "nonimmediate_operand" "=f,fm,m,*d")
  	(match_operand:SF 1 "general_operand" "fmF,*d,f,fmF"))]
    ""
    "*
***************
*** 1335,1341 ****
        if (REG_P (operands[1]))
  	{
  	  mvs_check_page (0, 8, 0);
! 	  return \"ST	%1,140(,13)\;LE	%0,140(,13)\";
  	}
        if (operands[1] == const0_rtx)
  	{
--- 1487,1493 ----
        if (REG_P (operands[1]))
  	{
  	  mvs_check_page (0, 8, 0);
! 	  return \"ST	%1,\" CONVLO \"(,13)\;LE	%0,\" CONVLO \"(,13)\";
  	}
        if (operands[1] == const0_rtx)
  	{
***************
*** 1351,1357 ****
        if (FP_REG_P (operands[1]))
  	{
  	  mvs_check_page (0, 8, 0);
! 	  return \"STE	%1,140(,13)\;L	%0,140(,13)\";
  	}
        mvs_check_page (0, 4, 0);
        return \"L	%0,%1\";
--- 1503,1509 ----
        if (FP_REG_P (operands[1]))
  	{
  	  mvs_check_page (0, 8, 0);
! 	  return \"STE	%1,\" CONVLO \"(,13)\;L	%0,\" CONVLO \"(,13)\";
  	}
        mvs_check_page (0, 4, 0);
        return \"L	%0,%1\";
***************
*** 1438,1444 ****
    else
      op1 = replace_equiv_address (operands[1], copy_to_mode_reg (SImode, op1));
  
!   if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) < 256)
      emit_insn (gen_rtx_PARALLEL (VOIDmode,
  			gen_rtvec (2,
  				   gen_rtx_SET (VOIDmode, op0, op1),
--- 1590,1597 ----
    else
      op1 = replace_equiv_address (operands[1], copy_to_mode_reg (SImode, op1));
  
!   if (GET_CODE (operands[2]) == CONST_INT
!       && (unsigned) INTVAL (operands[2]) <= 256)
      emit_insn (gen_rtx_PARALLEL (VOIDmode,
  			gen_rtvec (2,
  				   gen_rtx_SET (VOIDmode, op0, op1),
***************
*** 1472,1484 ****
    DONE;
  }")
  
! ; Move a block that is less than 256 bytes in length.
  
  (define_insn ""
!   [(set (match_operand:BLK 0 "s_operand" "=m")
! 	(match_operand:BLK 1 "s_operand" "m"))
!    (use (match_operand 2 "immediate_operand" "I"))]
!   "((unsigned) INTVAL (operands[2]) < 256)"
    "*
  {
    check_label_emit ();
--- 1625,1637 ----
    DONE;
  }")
  
! ; Move a block that is less than or equal to 256 bytes in length.
  
  (define_insn ""
!   [(set (match_operand:BLK 0 "s_operand" "=S")
! 	(match_operand:BLK 1 "s_operand" "S"))
!    (use (match_operand 2 "immediate_operand" "i"))]
!   "((unsigned) INTVAL (operands[2]) <= 256)"
    "*
  {
    check_label_emit ();
***************
*** 1488,1498 ****
     [(set_attr "length" "6")]
  )
  
! ; Move a block that is larger than 255 bytes in length.
  
  (define_insn "movstrsi_1"
!   [(set (mem:BLK (subreg:SI (match_operand:DI 0 "register_operand" "+d") 0))
!         (mem:BLK (subreg:SI (match_operand:DI 1 "register_operand" "+d") 0)))
     (use (match_dup 0))
     (use (match_dup 1))
     (clobber (match_dup 0))
--- 1641,1653 ----
     [(set_attr "length" "6")]
  )
  
! ; Move a block that is larger than 256 bytes in length.
! ;  [(set (mem:BLK (subreg:SI (match_operand:DI 0 "register_operand" "+d") 0))
! ;        (mem:BLK (subreg:SI (match_operand:DI 1 "register_operand" "+d") 0)))
  
  (define_insn "movstrsi_1"
!   [(set (mem:BLK (match_operand:DI 0 "register_operand" "+d") )
!         (mem:BLK (match_operand:DI 1 "register_operand" "+d") ))
     (use (match_dup 0))
     (use (match_dup 1))
     (clobber (match_dup 0))
***************
*** 1554,1560 ****
  ;
  
  (define_insn "extendhisi2"
!   [(set (match_operand:SI 0 "general_operand" "=d,m")
  	(sign_extend:SI (match_operand:HI 1 "general_operand" "g,d")))]
    ""
    "*
--- 1709,1715 ----
  ;
  
  (define_insn "extendhisi2"
!   [(set (match_operand:SI 0 "nonimmediate_operand" "=d,m")
  	(sign_extend:SI (match_operand:HI 1 "general_operand" "g,d")))]
    ""
    "*
***************
*** 1586,1592 ****
  	}
        if (GET_CODE (operands[1]) == CONST_INT)
  	{
! 	  mvs_check_page (0, 4, 0);
  	  return \"LH	%0,%H1\";
  	}
        mvs_check_page (0, 4, 0);
--- 1741,1747 ----
  	}
        if (GET_CODE (operands[1]) == CONST_INT)
  	{
! 	  mvs_check_page (0, 4, 2);
  	  return \"LH	%0,%H1\";
  	}
        mvs_check_page (0, 4, 0);
***************
*** 1603,1609 ****
  ;
  
  (define_insn "extendqisi2"
!   [(set (match_operand:SI 0 "general_operand" "=d")
  	(sign_extend:SI (match_operand:QI 1 "general_operand" "0mi")))]
    ""
    "*
--- 1758,1764 ----
  ;
  
  (define_insn "extendqisi2"
!   [(set (match_operand:SI 0 "register_operand" "=d")
  	(sign_extend:SI (match_operand:QI 1 "general_operand" "0mi")))]
    ""
    "*
***************
*** 1631,1637 ****
  ;
  
  (define_insn "extendqihi2"
!   [(set (match_operand:HI 0 "general_operand" "=d")
  	(sign_extend:HI (match_operand:QI 1 "general_operand" "0m")))]
    ""
    "*
--- 1786,1792 ----
  ;
  
  (define_insn "extendqihi2"
!   [(set (match_operand:HI 0 "register_operand" "=d")
  	(sign_extend:HI (match_operand:QI 1 "general_operand" "0m")))]
    ""
    "*
***************
*** 1677,1683 ****
  ;
  
  (define_insn "zero_extendhisi2"
!   [(set (match_operand:SI 0 "general_operand" "=d")
  	(zero_extend:SI (match_operand:HI 1 "general_operand" "0")))]
    ""
    "*
--- 1832,1838 ----
  ;
  
  (define_insn "zero_extendhisi2"
!   [(set (match_operand:SI 0 "register_operand" "=d")
  	(zero_extend:SI (match_operand:HI 1 "general_operand" "0")))]
    ""
    "*
***************
*** 1696,1702 ****
  ;
  
  (define_insn "zero_extendqisi2"
!   [(set (match_operand:SI 0 "general_operand" "=d,&d")
  	(zero_extend:SI (match_operand:QI 1 "general_operand" "0i,m")))]
    ""
    "*
--- 1851,1857 ----
  ;
  
  (define_insn "zero_extendqisi2"
!   [(set (match_operand:SI 0 "register_operand" "=d,&d")
  	(zero_extend:SI (match_operand:QI 1 "general_operand" "0i,m")))]
    ""
    "*
***************
*** 1726,1732 ****
  ;
  
  (define_insn "zero_extendqihi2"
!   [(set (match_operand:HI 0 "general_operand" "=d,&d")
  	(zero_extend:HI (match_operand:QI 1 "general_operand" "0i,m")))]
    ""
    "*
--- 1881,1887 ----
  ;
  
  (define_insn "zero_extendqihi2"
!   [(set (match_operand:HI 0 "register_operand" "=d,&d")
  	(zero_extend:HI (match_operand:QI 1 "general_operand" "0i,m")))]
    ""
    "*
***************
*** 1756,1762 ****
  ;
  
  (define_insn "truncsihi2"
!   [(set (match_operand:HI 0 "general_operand" "=d,m")
  	(truncate:HI (match_operand:SI 1 "general_operand" "0,d")))]
    ""
    "*
--- 1911,1917 ----
  ;
  
  (define_insn "truncsihi2"
!   [(set (match_operand:HI 0 "nonimmediate_operand" "=d,m")
  	(truncate:HI (match_operand:SI 1 "general_operand" "0,d")))]
    ""
    "*
***************
*** 1779,1786 ****
  ;
  
  (define_insn "fix_truncdfsi2"
!   [(set (match_operand:SI 0 "general_operand" "=d")
!         (fix:SI (truncate:DF (match_operand:DF 1 "general_operand" "+f"))))
  	(clobber (reg:DF 16))]
    ""
    "*
--- 1934,1941 ----
  ;
  
  (define_insn "fix_truncdfsi2"
!   [(set (match_operand:SI 0 "register_operand" "=d")
!         (fix:SI (truncate:DF (match_operand:DF 1 "general_operand" "f"))))
  	(clobber (reg:DF 16))]
    ""
    "*
***************
*** 1790,1799 ****
    if (REGNO (operands[1]) == 16)
      {
        mvs_check_page (0, 12, 8);
!       return \"AD	0,=XL8'4F08000000000000'\;STD	0,140(,13)\;L	%0,144(,13)\";
      }
    mvs_check_page (0, 14, 8);
!   return \"LDR	0,%1\;AD	0,=XL8'4F08000000000000'\;STD	0,140(,13)\;L	%0,144(,13)\";
  }"
     [(set_attr "length" "14")]
  )
--- 1945,1954 ----
    if (REGNO (operands[1]) == 16)
      {
        mvs_check_page (0, 12, 8);
!       return \"AD	0,=XL8'4F08000000000000'\;STD	0,\" CONVLO \"(,13)\;L	%0,\" CONVHI \"(,13)\";
      }
    mvs_check_page (0, 14, 8);
!   return \"LDR	0,%1\;AD	0,=XL8'4F08000000000000'\;STD	0,\" CONVLO \"(,13)\;L	%0,\" CONVHI \"(,13)\";
  }"
     [(set_attr "length" "14")]
  )
***************
*** 1805,1820 ****
  ;
  
  (define_insn "floatsidf2"
!   [(set (match_operand:DF 0 "general_operand" "=f")
          (float:DF (match_operand:SI 1 "general_operand" "d")))]
    ""
    "*
  {
    check_label_emit ();
    CC_STATUS_INIT;
! #ifdef TARGET_ELF_ABI
    mvs_check_page (0, 22, 12);
!   return \"MVC  140(4,13),=XL4'4E000000'\;ST	%1,144(,13)\;XI	144(13),128\;LD	%0,140(,13)\;SD	%0,=XL8'4E00000080000000'\";
  #else
    mvs_check_page (0, 16, 8);
    return \"ST	%1,508(,12)\;XI	508(12),128\;LD	%0,504(,12)\;SD	%0,=XL8'4E00000080000000'\";
--- 1960,1978 ----
  ;
  
  (define_insn "floatsidf2"
!   [(set (match_operand:DF 0 "register_operand" "=f")
          (float:DF (match_operand:SI 1 "general_operand" "d")))]
    ""
    "*
  {
    check_label_emit ();
    CC_STATUS_INIT;
! #if defined(TARGET_LINUX)
!   mvs_check_page (0, 22, 12);
!   return \"MVC	\" CONVLO \"(4,13),=XL4'4E000000'\;ST	%1,\" CONVLO \"+4(,13)\;XI	\" CONVLO \"+4(13),128\;LD	%0,\" CONVLO \"(,13)\;SD	%0,=XL8'4E00000080000000'\";
! #elif defined(TARGET_DIGNUS) || defined(TARGET_PDPMAC)
    mvs_check_page (0, 22, 12);
!   return \"MVC	\" CONVLO \"(4,13),=XL8'4E00000080000000'\;ST	%1,\" CONVHI \"(,13)\;XI	\" CONVHI \"(13),128\;LD	%0,\" CONVLO \"(,13)\;SD	%0,=XL8'4E00000080000000'\";
  #else
    mvs_check_page (0, 16, 8);
    return \"ST	%1,508(,12)\;XI	508(12),128\;LD	%0,504(,12)\;SD	%0,=XL8'4E00000080000000'\";
***************
*** 1828,1834 ****
  ;
  
  (define_insn "truncdfsf2"
!   [(set (match_operand:SF 0 "general_operand" "=f")
          (float_truncate:SF (match_operand:DF 1 "general_operand" "f")))]
    ""
    "*
--- 1986,1992 ----
  ;
  
  (define_insn "truncdfsf2"
!   [(set (match_operand:SF 0 "register_operand" "=f")
          (float_truncate:SF (match_operand:DF 1 "general_operand" "f")))]
    ""
    "*
***************
*** 1845,1851 ****
  ; 
  
  (define_insn "extendsfdf2"
!   [(set (match_operand:DF 0 "general_operand" "=f")
          (float_extend:DF (match_operand:SF 1 "general_operand" "fmF")))]
    ""
    "*
--- 2003,2009 ----
  ; 
  
  (define_insn "extendsfdf2"
!   [(set (match_operand:DF 0 "register_operand" "=f")
          (float_extend:DF (match_operand:SF 1 "general_operand" "fmF")))]
    ""
    "*
***************
*** 1857,1863 ****
        if (REGNO (operands[0]) == REGNO (operands[1]))
  	{
  	  mvs_check_page (0, 10, 0);
! 	  return \"STE	%1,140(,13)\;SDR	%0,%0\;LE	%0,140(,13)\";
  	}
        mvs_check_page (0, 4, 0);
        return \"SDR	%0,%0\;LER	%0,%1\";
--- 2015,2021 ----
        if (REGNO (operands[0]) == REGNO (operands[1]))
  	{
  	  mvs_check_page (0, 10, 0);
! 	  return \"STE	%1,\" CONVLO \"(,13)\;SDR	%0,%0\;LE	%0,\" CONVLO \"(,13)\";
  	}
        mvs_check_page (0, 4, 0);
        return \"SDR	%0,%0\;LER	%0,%1\";
***************
*** 1876,1910 ****
  ; adddi3 instruction pattern(s).
  ;
  ;
! ;(define_expand "adddi3"
! ;  [(set (match_operand:DI 0 "general_operand" "")
! ;	(plus:DI (match_operand:DI 1 "general_operand" "")
! ;		 (match_operand:DI 2 "general_operand" "")))]
! ;  ""
! ;  "
! ;{
! ;  rtx label = gen_label_rtx ();
! ;  rtx op0_high = operand_subword (operands[0], 0, 1, DImode);
! ;  rtx op0_low = gen_lowpart (SImode, operands[0]);
! ;	
! ;  emit_insn (gen_rtx_SET (VOIDmode, op0_high,
! ;		    gen_rtx_PLUS (SImode,
! ;			    operand_subword (operands[1], 0, 1, DImode),
! ;			    operand_subword (operands[2], 0, 1, DImode))));
! ;  emit_jump_insn (gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2,
! ;	      gen_rtx_SET (VOIDmode, op0_low,
! ;		      gen_rtx_PLUS (SImode, gen_lowpart (SImode, operands[1]),
! ;			      gen_lowpart (SImode, operands[2]))),
! ;	      gen_rtx_USE (VOIDmode, gen_rtx_LABEL_REF (VOIDmode, label)))));
! ;  emit_insn (gen_rtx_SET (VOIDmode, op0_high,
! ;		    gen_rtx_PLUS (SImode, op0_high,
! ;			    gen_rtx_CONST_INT (SImode, 1))));
! ;  emit_label (label);
! ;  DONE;
! ;}")
  
  (define_insn ""
!   [(set (match_operand:SI 0 "general_operand" "=d")
  	(plus:SI (match_operand:SI 1 "general_operand" "%0")
  		 (match_operand:SI 2 "general_operand" "g")))
     (use (label_ref (match_operand 3 "" "")))
--- 2034,2068 ----
  ; adddi3 instruction pattern(s).
  ;
  ;
! (define_expand "adddi3"
!   [(set (match_operand:DI 0 "general_operand" "")
! 	(plus:DI (match_operand:DI 1 "general_operand" "")
! 		 (match_operand:DI 2 "general_operand" "")))]
!   ""
!   "
! {
!   rtx label = gen_label_rtx ();
!   rtx op0_high = operand_subword (operands[0], 0, 1, DImode);
!   rtx op0_low = gen_lowpart (SImode, operands[0]);
! 	
!   emit_insn (gen_rtx_SET (VOIDmode, op0_high,
! 		    gen_rtx_PLUS (SImode,
! 			    operand_subword (operands[1], 0, 1, DImode),
! 			    operand_subword (operands[2], 0, 1, DImode))));
!   emit_jump_insn (gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2,
! 	      gen_rtx_SET (VOIDmode, op0_low,
! 		      gen_rtx_PLUS (SImode, gen_lowpart (SImode, operands[1]),
! 			      gen_lowpart (SImode, operands[2]))),
! 	      gen_rtx_USE (VOIDmode, gen_rtx_LABEL_REF (VOIDmode, label)))));
!   emit_insn (gen_rtx_SET (VOIDmode, op0_high,
! 		    gen_rtx_PLUS (SImode, op0_high,
! 			    gen_rtx_CONST_INT (SImode, 1))));
!   emit_label (label);
!   DONE;
! }")
  
  (define_insn ""
!   [(set (match_operand:SI 0 "register_operand" "=d")
  	(plus:SI (match_operand:SI 1 "general_operand" "%0")
  		 (match_operand:SI 2 "general_operand" "g")))
     (use (label_ref (match_operand 3 "" "")))
***************
*** 2007,2013 ****
  ;; 
  
  (define_insn "addsi3"
!   [(set (match_operand:SI 0 "general_operand" "=d")
  	(plus:SI (match_operand:SI 1 "general_operand" "%0")
  		 (match_operand:SI 2 "general_operand" "g")))]
    ""
--- 2165,2171 ----
  ;; 
  
  (define_insn "addsi3"
!   [(set (match_operand:SI 0 "register_operand" "=d")
  	(plus:SI (match_operand:SI 1 "general_operand" "%0")
  		 (match_operand:SI 2 "general_operand" "g")))]
    ""
***************
*** 2039,2045 ****
  ;
  
  (define_insn "addhi3"
!   [(set (match_operand:HI 0 "general_operand" "=d")
  	(plus:HI (match_operand:HI 1 "general_operand" "%0")
  		 (match_operand:HI 2 "general_operand" "dmi")))]
    ""
--- 2197,2203 ----
  ;
  
  (define_insn "addhi3"
!   [(set (match_operand:HI 0 "register_operand" "=d")
  	(plus:HI (match_operand:HI 1 "general_operand" "%0")
  		 (match_operand:HI 2 "general_operand" "dmi")))]
    ""
***************
*** 2049,2055 ****
    if (REG_P (operands[2]))
      {
        mvs_check_page (0, 8, 0);
!       return \"STH	%2,140(,13)\;AH	%0,140(,13)\";
      }
    if (GET_CODE (operands[2]) == CONST_INT)
      {
--- 2207,2213 ----
    if (REG_P (operands[2]))
      {
        mvs_check_page (0, 8, 0);
!       return \"STH	%2,\" CONVLO \"(,13)\;AH	%0,\" CONVLO \"(,13)\";
      }
    if (GET_CODE (operands[2]) == CONST_INT)
      {
***************
*** 2059,2065 ****
  	  mvs_check_page (0, 2, 0);
  	  return \"BCTR	%0,0\";
  	}
!       mvs_check_page (0, 4, 0);
        return \"AH	%0,%H2\";
      }
    mvs_check_page (0, 4, 0);
--- 2217,2223 ----
  	  mvs_check_page (0, 2, 0);
  	  return \"BCTR	%0,0\";
  	}
!       mvs_check_page (0, 4, 2);
        return \"AH	%0,%H2\";
      }
    mvs_check_page (0, 4, 0);
***************
*** 2073,2079 ****
  ;
  
  (define_insn "addqi3"
!   [(set (match_operand:QI 0 "general_operand" "=d")
  	(plus:QI (match_operand:QI 1 "general_operand" "%a")
  		 (match_operand:QI 2 "general_operand" "ai")))]
    ""
--- 2231,2237 ----
  ;
  
  (define_insn "addqi3"
!   [(set (match_operand:QI 0 "register_operand" "=d")
  	(plus:QI (match_operand:QI 1 "general_operand" "%a")
  		 (match_operand:QI 2 "general_operand" "ai")))]
    ""
***************
*** 2094,2100 ****
  ;
  
  (define_insn "adddf3"
!   [(set (match_operand:DF 0 "general_operand" "=f")
  	(plus:DF (match_operand:DF 1 "general_operand" "%0")
  		 (match_operand:DF 2 "general_operand" "fmF")))]
    ""
--- 2252,2258 ----
  ;
  
  (define_insn "adddf3"
!   [(set (match_operand:DF 0 "register_operand" "=f")
  	(plus:DF (match_operand:DF 1 "general_operand" "%0")
  		 (match_operand:DF 2 "general_operand" "fmF")))]
    ""
***************
*** 2117,2123 ****
  ;
  
  (define_insn "addsf3"
!   [(set (match_operand:SF 0 "general_operand" "=f")
  	(plus:SF (match_operand:SF 1 "general_operand" "%0")
  		 (match_operand:SF 2 "general_operand" "fmF")))]
    ""
--- 2275,2281 ----
  ;
  
  (define_insn "addsf3"
!   [(set (match_operand:SF 0 "register_operand" "=f")
  	(plus:SF (match_operand:SF 1 "general_operand" "%0")
  		 (match_operand:SF 2 "general_operand" "fmF")))]
    ""
***************
*** 2173,2179 ****
  ;}")
  
  (define_insn ""
!   [(set (match_operand:SI 0 "general_operand" "=d")
  	(minus:SI (match_operand:SI 1 "general_operand" "0")
  		  (match_operand:SI 2 "general_operand" "g")))
     (use (label_ref (match_operand 3 "" "")))
--- 2331,2337 ----
  ;}")
  
  (define_insn ""
!   [(set (match_operand:SI 0 "register_operand" "=d")
  	(minus:SI (match_operand:SI 1 "general_operand" "0")
  		  (match_operand:SI 2 "general_operand" "g")))
     (use (label_ref (match_operand 3 "" "")))
***************
*** 2221,2227 ****
  ;
  
  (define_insn "subsi3"
!   [(set (match_operand:SI 0 "general_operand" "=d")
  	(minus:SI (match_operand:SI 1 "general_operand" "0")
  		  (match_operand:SI 2 "general_operand" "g")))]
    ""
--- 2379,2385 ----
  ;
  
  (define_insn "subsi3"
!   [(set (match_operand:SI 0 "register_operand" "=d")
  	(minus:SI (match_operand:SI 1 "general_operand" "0")
  		  (match_operand:SI 2 "general_operand" "g")))]
    ""
***************
*** 2250,2256 ****
  ;
  
  (define_insn "subhi3"
!   [(set (match_operand:HI 0 "general_operand" "=d")
  	(minus:HI (match_operand:HI 1 "general_operand" "0")
  		  (match_operand:HI 2 "general_operand" "g")))]
    ""
--- 2408,2414 ----
  ;
  
  (define_insn "subhi3"
!   [(set (match_operand:HI 0 "register_operand" "=d")
  	(minus:HI (match_operand:HI 1 "general_operand" "0")
  		  (match_operand:HI 2 "general_operand" "g")))]
    ""
***************
*** 2260,2266 ****
    if (REG_P (operands[2]))
      {
        mvs_check_page (0, 8, 0);
!       return \"STH	%2,140(,13)\;SH	%0,140(,13)\";
      }
    if (operands[2] == const1_rtx)
      {
--- 2418,2424 ----
    if (REG_P (operands[2]))
      {
        mvs_check_page (0, 8, 0);
!       return \"STH	%2,\" CONVLO \"(,13)\;SH	%0,\" CONVLO \"(,13)\";
      }
    if (operands[2] == const1_rtx)
      {
***************
*** 2270,2276 ****
      }
    if (GET_CODE (operands[2]) == CONST_INT)
      {
!       mvs_check_page (0, 4, 0);
        return \"SH	%0,%H2\";
      }
    mvs_check_page (0, 4, 0);
--- 2428,2434 ----
      }
    if (GET_CODE (operands[2]) == CONST_INT)
      {
!       mvs_check_page (0, 4, 2);
        return \"SH	%0,%H2\";
      }
    mvs_check_page (0, 4, 0);
***************
*** 2283,2310 ****
  ; subqi3 instruction pattern(s).
  ;
  
! (define_expand "subqi3"
!   [(set (match_operand:QI 0 "general_operand" "=d")
! 	(minus:QI (match_operand:QI 1 "general_operand" "0")
! 		  (match_operand:QI 2 "general_operand" "di")))]
!   ""
!   "
! {
!   if (REG_P (operands[2]))
!     {
!       emit_insn (gen_rtx_SET (VOIDmode, operands[0],
! 			gen_rtx_MINUS (QImode, operands[1], operands[2])));
!     }
!   else
!     {
!       emit_insn (gen_rtx_SET (VOIDmode, operands[0],
! 			gen_rtx_PLUS (QImode, operands[1],
! 				 negate_rtx (QImode, operands[2]))));
!     }
!   DONE;
! }")
  
! (define_insn ""
    [(set (match_operand:QI 0 "register_operand" "=d")
  	(minus:QI (match_operand:QI 1 "register_operand" "0")
  		 (match_operand:QI 2 "register_operand" "d")))]
--- 2441,2468 ----
  ; subqi3 instruction pattern(s).
  ;
  
! ;(define_expand "subqi3"
! ;  [(set (match_operand:QI 0 "register_operand" "=d")
! ;	(minus:QI (match_operand:QI 1 "general_operand" "0")
! ;		  (match_operand:QI 2 "general_operand" "di")))]
! ;  ""
! ;  "
! ;{
! ;  if (REG_P (operands[2]))
! ;    {
! ;      emit_insn (gen_rtx_SET (VOIDmode, operands[0],
! ;			gen_rtx_MINUS (QImode, operands[1], operands[2])));
! ;    }
! ;  else
! ;    {
! ;      emit_insn (gen_rtx_SET (VOIDmode, operands[0],
! ;			gen_rtx_PLUS (QImode, operands[1],
! ;				 negate_rtx (QImode, operands[2]))));
! ;    }
! ;  DONE;
! ;}")
  
! (define_insn "subqi3"
    [(set (match_operand:QI 0 "register_operand" "=d")
  	(minus:QI (match_operand:QI 1 "register_operand" "0")
  		 (match_operand:QI 2 "register_operand" "d")))]
***************
*** 2323,2329 ****
  ;
  
  (define_insn "subdf3"
!   [(set (match_operand:DF 0 "general_operand" "=f")
  	(minus:DF (match_operand:DF 1 "general_operand" "0")
  		  (match_operand:DF 2 "general_operand" "fmF")))]
    ""
--- 2481,2487 ----
  ;
  
  (define_insn "subdf3"
!   [(set (match_operand:DF 0 "register_operand" "=f")
  	(minus:DF (match_operand:DF 1 "general_operand" "0")
  		  (match_operand:DF 2 "general_operand" "fmF")))]
    ""
***************
*** 2346,2352 ****
  ;
  
  (define_insn "subsf3"
!   [(set (match_operand:SF 0 "general_operand" "=f")
  	(minus:SF (match_operand:SF 1 "general_operand" "0")
  		  (match_operand:SF 2 "general_operand" "fmF")))]
    ""
--- 2504,2510 ----
  ;
  
  (define_insn "subsf3"
!   [(set (match_operand:SF 0 "register_operand" "=f")
  	(minus:SF (match_operand:SF 1 "general_operand" "0")
  		  (match_operand:SF 2 "general_operand" "fmF")))]
    ""
***************
*** 2380,2391 ****
--- 2538,2551 ----
    "
  {
    if (GET_CODE (operands[1]) == CONST_INT
+       && REG_P (operands[0])
        && CONST_OK_FOR_LETTER_P (INTVAL (operands[1]), 'K'))
      {
        emit_insn (gen_rtx_SET (VOIDmode, operands[0],
  			  gen_rtx_MULT (SImode, operands[2], operands[1])));
      }
    else if (GET_CODE (operands[2]) == CONST_INT
+            && REG_P (operands[0])
  	   && CONST_OK_FOR_LETTER_P (INTVAL (operands[2]), 'K'))
      {
        emit_insn (gen_rtx_SET (VOIDmode, operands[0],
***************
*** 2398,2404 ****
        /* XXX trouble.  Below we generate some rtx's that model what
         * is really supposed to happen with multiply on the 370/390
         * hardware, and that is all well & good.  However, during optimization
!        * it can happen that the two operands are exchanged (after all, 
         * multiplication is commutitive), in which case the doubleword
         * ends up in memory and everything is hosed.  The gen_reg_rtx
         * should have kept it in a reg ...  We hack around this
--- 2558,2564 ----
        /* XXX trouble.  Below we generate some rtx's that model what
         * is really supposed to happen with multiply on the 370/390
         * hardware, and that is all well & good.  However, during optimization
!        * it can happen that the two operands are exchanged (after all,
         * multiplication is commutitive), in which case the doubleword
         * ends up in memory and everything is hosed.  The gen_reg_rtx
         * should have kept it in a reg ...  We hack around this
***************
*** 2406,2417 ****
--- 2566,2591 ----
         * \"di\" instead of \"g\".  But this still ends up with lots & lots of
         * movement between registers & memory and is an awful waste.
         * Dunno how to untwist it elegantly; but it seems to work for now.
+        
+        * Note, this comment doesn't seem to be relevant for 3.4.6
+        * at least, so it is being opened up.
         */
+       if (GET_CODE (operands[1]) == CONST_INT)
+       {
        emit_insn (gen_rtx_SET (VOIDmode,
  			  gen_rtx_SUBREG (SImode, r, GET_MODE_SIZE (SImode)),
  					  operands[1]));
        emit_insn (gen_rtx_SET (VOIDmode, r,
  			  gen_rtx_MULT (DImode, r, operands[2])));
+       }
+       else
+       {
+       emit_insn (gen_rtx_SET (VOIDmode,
+ 			  gen_rtx_SUBREG (SImode, r, GET_MODE_SIZE (SImode)),
+ 					  operands[2]));
+       emit_insn (gen_rtx_SET (VOIDmode, r,
+ 			  gen_rtx_MULT (DImode, r, operands[1])));
+       }
        emit_insn (gen_rtx_SET (VOIDmode, operands[0],
  			  gen_rtx_SUBREG (SImode, r, GET_MODE_SIZE (SImode))));
      }
***************
*** 2419,2428 ****
  }")
  
  (define_insn ""
!   [(set (match_operand:SI 0 "general_operand" "=d")
! 	(mult:SI (match_operand:SI 1 "general_operand" "%0")
! 		 (match_operand:SI 2 "immediate_operand" "K")))]
!   ""
    "*
  {
    check_label_emit ();
--- 2593,2602 ----
  }")
  
  (define_insn ""
!   [(set (match_operand:SI 0 "register_operand" "=d")
! 	(mult:SI (match_operand:SI 1 "register_operand" "0")
! 		 (match_operand:SI 2 "const_int_operand" "K")))]
!   "CONST_OK_FOR_LETTER_P (INTVAL (operands[2]), 'K')"
    "*
  {
    check_label_emit ();
***************
*** 2432,2441 ****
     [(set_attr "length" "4")]
  )
  
  (define_insn ""
    [(set (match_operand:DI 0 "register_operand" "=d")
! 	(mult:DI (match_operand:DI 1 "general_operand" "%0")
! 		 (match_operand:SI 2 "general_operand" "di")))]
    ""
    "*
  {
--- 2606,2617 ----
     [(set_attr "length" "4")]
  )
  
+ ; See mulsi3 comment above as to why this is constrained to
+ ; "di" rather than "g"
  (define_insn ""
    [(set (match_operand:DI 0 "register_operand" "=d")
! 	(mult:DI (match_operand:DI 1 "general_operand" "0")
! 		 (match_operand:SI 2 "general_operand" "g")))]
    ""
    "*
  {
***************
*** 2456,2462 ****
  ;
  
  (define_insn "muldf3"
!   [(set (match_operand:DF 0 "general_operand" "=f")
  	(mult:DF (match_operand:DF 1 "general_operand" "%0")
  		 (match_operand:DF 2 "general_operand" "fmF")))]
    ""
--- 2632,2638 ----
  ;
  
  (define_insn "muldf3"
!   [(set (match_operand:DF 0 "register_operand" "=f")
  	(mult:DF (match_operand:DF 1 "general_operand" "%0")
  		 (match_operand:DF 2 "general_operand" "fmF")))]
    ""
***************
*** 2479,2485 ****
  ;
  
  (define_insn "mulsf3"
!   [(set (match_operand:SF 0 "general_operand" "=f")
  	(mult:SF (match_operand:SF 1 "general_operand" "%0")
  		 (match_operand:SF 2 "general_operand" "fmF")))]
    ""
--- 2655,2661 ----
  ;
  
  (define_insn "mulsf3"
!   [(set (match_operand:SF 0 "register_operand" "=f")
  	(mult:SF (match_operand:SF 1 "general_operand" "%0")
  		 (match_operand:SF 2 "general_operand" "fmF")))]
    ""
***************
*** 2571,2577 ****
        emit_insn (gen_rtx_SET (VOIDmode, dr_1, const0_rtx));
        emit_insn (gen_cmpsi (sr, dr_0));
        emit_jump_insn (gen_bgtu (label3));
!       emit_insn (gen_cmpsi (sr, const1_rtx));
        emit_jump_insn (gen_blt (label2));
        emit_insn (gen_cmpsi (sr, const1_rtx));
        emit_jump_insn (gen_beq (label1));
--- 2747,2753 ----
        emit_insn (gen_rtx_SET (VOIDmode, dr_1, const0_rtx));
        emit_insn (gen_cmpsi (sr, dr_0));
        emit_jump_insn (gen_bgtu (label3));
!       emit_insn (gen_cmpsi (sr, const0_rtx));
        emit_jump_insn (gen_blt (label2));
        emit_insn (gen_cmpsi (sr, const1_rtx));
        emit_jump_insn (gen_beq (label1));
***************
*** 2619,2625 ****
  ;
  
  (define_insn "divdf3"
!   [(set (match_operand:DF 0 "general_operand" "=f")
          (div:DF (match_operand:DF 1 "general_operand" "0")
                  (match_operand:DF 2 "general_operand" "fmF")))]
    ""
--- 2795,2801 ----
  ;
  
  (define_insn "divdf3"
!   [(set (match_operand:DF 0 "register_operand" "=f")
          (div:DF (match_operand:DF 1 "general_operand" "0")
                  (match_operand:DF 2 "general_operand" "fmF")))]
    ""
***************
*** 2642,2648 ****
  ;
  
  (define_insn "divsf3"
!   [(set (match_operand:SF 0 "general_operand" "=f")
          (div:SF (match_operand:SF 1 "general_operand" "0")
                  (match_operand:SF 2 "general_operand" "fmF")))]
    ""
--- 2818,2824 ----
  ;
  
  (define_insn "divsf3"
!   [(set (match_operand:SF 0 "register_operand" "=f")
          (div:SF (match_operand:SF 1 "general_operand" "0")
                  (match_operand:SF 2 "general_operand" "fmF")))]
    ""
***************
*** 2736,2743 ****
        emit_insn (gen_rtx_SET (VOIDmode, sr, operands[2]));
        emit_insn (gen_cmpsi (sr, dr_0));
        emit_jump_insn (gen_bgtu (label3));
!       emit_insn (gen_cmpsi (sr, const1_rtx));
        emit_jump_insn (gen_blt (label2));
        emit_jump_insn (gen_beq (label1));
        emit_insn (gen_rtx_SET (VOIDmode, dr,
  			  gen_rtx_LSHIFTRT (DImode, dr,
--- 2912,2920 ----
        emit_insn (gen_rtx_SET (VOIDmode, sr, operands[2]));
        emit_insn (gen_cmpsi (sr, dr_0));
        emit_jump_insn (gen_bgtu (label3));
!       emit_insn (gen_cmpsi (sr, const0_rtx));
        emit_jump_insn (gen_blt (label2));
+       emit_insn (gen_cmpsi (sr, const1_rtx));
        emit_jump_insn (gen_beq (label1));
        emit_insn (gen_rtx_SET (VOIDmode, dr,
  			  gen_rtx_LSHIFTRT (DImode, dr,
***************
*** 2810,2823 ****
  ;
  
  (define_insn ""
!   [(set (match_operand:SI 0 "r_or_s_operand" "=d,m")
  	(and:SI (match_operand:SI 1 "r_or_s_operand" "%0,0")
! 		(match_operand:SI 2 "r_or_s_operand" "g,mi")))]
    "TARGET_CHAR_INSTRUCTIONS"
    "*
  {
    check_label_emit ();
!   CC_STATUS_INIT;  /* and sets CC but not how we want it */
    if (REG_P (operands[2]))
      {
        mvs_check_page (0, 2, 0);
--- 2987,3000 ----
  ;
  
  (define_insn ""
!   [(set (match_operand:SI 0 "r_or_s_operand" "=d,R")
  	(and:SI (match_operand:SI 1 "r_or_s_operand" "%0,0")
! 		(match_operand:SI 2 "general_operand" "g,Si")))]
    "TARGET_CHAR_INSTRUCTIONS"
    "*
  {
    check_label_emit ();
!   CC_STATUS_INIT;  /* AND sets CC but not how we want it */
    if (REG_P (operands[2]))
      {
        mvs_check_page (0, 2, 0);
***************
*** 2835,2848 ****
  )
  
  (define_insn "andsi3"
!   [(set (match_operand:SI 0 "general_operand" "=d")
  	(and:SI (match_operand:SI 1 "general_operand" "%0")
  		(match_operand:SI 2 "general_operand" "g")))]
    ""
    "*
  {
    check_label_emit ();
!   CC_STATUS_INIT;  /* and sets CC but not how we want it */
    if (REG_P (operands[2]))
      {
        mvs_check_page (0, 2, 0);
--- 3012,3025 ----
  )
  
  (define_insn "andsi3"
!   [(set (match_operand:SI 0 "register_operand" "=d")
  	(and:SI (match_operand:SI 1 "general_operand" "%0")
  		(match_operand:SI 2 "general_operand" "g")))]
    ""
    "*
  {
    check_label_emit ();
!   CC_STATUS_INIT;  /* AND sets CC but not how we want it */
    if (REG_P (operands[2]))
      {
        mvs_check_page (0, 2, 0);
***************
*** 2859,2872 ****
  ;
  
  (define_insn ""
!   [(set (match_operand:HI 0 "r_or_s_operand" "=d,m")
  	(and:HI (match_operand:HI 1 "r_or_s_operand" "%0,0")
! 		(match_operand:HI 2 "r_or_s_operand" "di,mi")))]
    "TARGET_CHAR_INSTRUCTIONS"
    "*
  {
    check_label_emit ();
!   CC_STATUS_INIT;  /* and sets CC but not how we want it */
    if (REG_P (operands[2]))
      {
        mvs_check_page (0, 2, 0);
--- 3036,3049 ----
  ;
  
  (define_insn ""
!   [(set (match_operand:HI 0 "r_or_s_operand" "=d,S")
  	(and:HI (match_operand:HI 1 "r_or_s_operand" "%0,0")
! 		(match_operand:HI 2 "general_operand" "di,Si")))]
    "TARGET_CHAR_INSTRUCTIONS"
    "*
  {
    check_label_emit ();
!   CC_STATUS_INIT;  /* AND sets CC but not how we want it */
    if (REG_P (operands[2]))
      {
        mvs_check_page (0, 2, 0);
***************
*** 2874,2888 ****
      }
    if (REG_P (operands[0]))
      {
!       /* %K2 == sign extend operand to 32 bits so that CH works */
!       mvs_check_page (0, 4, 0);
        if (GET_CODE (operands[2]) == CONST_INT)
!          return \"N	%0,%K2\";
        return \"N	%0,%2\";
      }
    if (GET_CODE (operands[2]) == CONST_INT)
      {
!       mvs_check_page (0, 6, 0);
        return \"NC	%O0(2,%R0),%H2\";
      }
    mvs_check_page (0, 6, 0);
--- 3051,3068 ----
      }
    if (REG_P (operands[0]))
      {
!       /* %K2 == sign extend operand to 32 bits so that CH works - huh??? */
        if (GET_CODE (operands[2]) == CONST_INT)
!         {
!           mvs_check_page (0, 4, 4);
!           return \"N	%0,%K2\";
!         }
!       mvs_check_page (0, 4, 0);
        return \"N	%0,%2\";
      }
    if (GET_CODE (operands[2]) == CONST_INT)
      {
!       mvs_check_page (0, 6, 2);
        return \"NC	%O0(2,%R0),%H2\";
      }
    mvs_check_page (0, 6, 0);
***************
*** 2892,2909 ****
  )
  
  (define_insn "andhi3"
!   [(set (match_operand:HI 0 "general_operand" "=d")
! 	(and:HI (match_operand:HI 1 "general_operand" "%0")
  		(match_operand:HI 2 "general_operand" "di")))]
    ""
    "*
  {
    check_label_emit ();
!   CC_STATUS_INIT;  /* and sets CC but not how we want it */
    if (GET_CODE (operands[2]) == CONST_INT)
      {
!       /* %K2 == sign extend operand to 32 bits so that CH works */
!       mvs_check_page (0, 4, 0);
        return \"N	%0,%K2\";
      }
    mvs_check_page (0, 2, 0);
--- 3072,3089 ----
  )
  
  (define_insn "andhi3"
!   [(set (match_operand:HI 0 "register_operand" "=d")
! 	(and:HI (match_operand:HI 1 "register_operand" "%0")
  		(match_operand:HI 2 "general_operand" "di")))]
    ""
    "*
  {
    check_label_emit ();
!   CC_STATUS_INIT;  /* AND sets CC but not how we want it */
    if (GET_CODE (operands[2]) == CONST_INT)
      {
!       /* %K2 == sign extend operand to 32 bits so that CH works - huh??? */
!       mvs_check_page (0, 4, 4);
        return \"N	%0,%K2\";
      }
    mvs_check_page (0, 2, 0);
***************
*** 2917,2930 ****
  ;
  
  (define_insn ""
!   [(set (match_operand:QI 0 "r_or_s_operand" "=d,m")
  	(and:QI (match_operand:QI 1 "r_or_s_operand" "%0,0")
! 		(match_operand:QI 2 "r_or_s_operand" "di,mi")))]
    "TARGET_CHAR_INSTRUCTIONS"
    "*
  {
    check_label_emit ();
!   CC_STATUS_INIT;  /* and sets CC but not how we want it */
    if (REG_P (operands[2]))
      {
        mvs_check_page (0, 2, 0);
--- 3097,3110 ----
  ;
  
  (define_insn ""
!   [(set (match_operand:QI 0 "r_or_s_operand" "=d,S")
  	(and:QI (match_operand:QI 1 "r_or_s_operand" "%0,0")
! 		(match_operand:QI 2 "general_operand" "di,Si")))]
    "TARGET_CHAR_INSTRUCTIONS"
    "*
  {
    check_label_emit ();
!   CC_STATUS_INIT;  /* AND sets CC but not how we want it */
    if (REG_P (operands[2]))
      {
        mvs_check_page (0, 2, 0);
***************
*** 2947,2964 ****
  )
  
  (define_insn "andqi3"
!   [(set (match_operand:QI 0 "general_operand" "=d")
  	(and:QI (match_operand:QI 1 "general_operand" "%0")
  		(match_operand:QI 2 "general_operand" "di")))]
    ""
    "*
  {
    check_label_emit ();
!   CC_STATUS_INIT;  /* and sets CC but not how we want it */
    if (GET_CODE (operands[2]) == CONST_INT)
      {
!       mvs_check_page (0, 4, 0);
!       return \"N	%0,%2\";
      }
    mvs_check_page (0, 2, 0);
    return \"NR	%0,%2\";
--- 3127,3144 ----
  )
  
  (define_insn "andqi3"
!   [(set (match_operand:QI 0 "register_operand" "=d")
  	(and:QI (match_operand:QI 1 "general_operand" "%0")
  		(match_operand:QI 2 "general_operand" "di")))]
    ""
    "*
  {
    check_label_emit ();
!   CC_STATUS_INIT;  /* AND sets CC but not how we want it */
    if (GET_CODE (operands[2]) == CONST_INT)
      {
!       mvs_check_page (0, 4, 4);
!       return \"N	%0,=XL4'%X2'\";
      }
    mvs_check_page (0, 2, 0);
    return \"NR	%0,%2\";
***************
*** 2997,3005 ****
  ;
  
  (define_insn ""
!   [(set (match_operand:SI 0 "r_or_s_operand" "=d,m")
  	(ior:SI (match_operand:SI 1 "r_or_s_operand" "%0,0")
! 		(match_operand:SI 2 "r_or_s_operand" "g,Si")))]
    "TARGET_CHAR_INSTRUCTIONS"
    "*
  {
--- 3177,3185 ----
  ;
  
  (define_insn ""
!   [(set (match_operand:SI 0 "r_or_s_operand" "=d,R")
  	(ior:SI (match_operand:SI 1 "r_or_s_operand" "%0,0")
! 		(match_operand:SI 2 "general_operand" "g,Si")))]
    "TARGET_CHAR_INSTRUCTIONS"
    "*
  {
***************
*** 3018,3028 ****
    mvs_check_page (0, 6, 0);
    return \"OC	%O0(4,%R0),%2\";
  }"
!   [(set_attr "length" "6")]
  )
  
  (define_insn "iorsi3"
!   [(set (match_operand:SI 0 "general_operand" "=d")
  	(ior:SI (match_operand:SI 1 "general_operand" "%0")
  		(match_operand:SI 2 "general_operand" "g")))]
    ""
--- 3198,3208 ----
    mvs_check_page (0, 6, 0);
    return \"OC	%O0(4,%R0),%2\";
  }"
!    [(set_attr "length" "6")]
  )
  
  (define_insn "iorsi3"
!   [(set (match_operand:SI 0 "register_operand" "=d")
  	(ior:SI (match_operand:SI 1 "general_operand" "%0")
  		(match_operand:SI 2 "general_operand" "g")))]
    ""
***************
*** 3046,3054 ****
  ;
  
  (define_insn ""
!   [(set (match_operand:HI 0 "r_or_s_operand" "=d,m")
  	(ior:HI (match_operand:HI 1 "r_or_s_operand" "%0,0")
! 		(match_operand:HI 2 "r_or_s_operand" "di,mi")))]
    "TARGET_CHAR_INSTRUCTIONS"
    "*
  {
--- 3226,3234 ----
  ;
  
  (define_insn ""
!   [(set (match_operand:HI 0 "r_or_s_operand" "=d,S")
  	(ior:HI (match_operand:HI 1 "r_or_s_operand" "%0,0")
! 		(match_operand:HI 2 "general_operand" "di,Si")))]
    "TARGET_CHAR_INSTRUCTIONS"
    "*
  {
***************
*** 3061,3066 ****
--- 3241,3252 ----
      }
    if (REG_P (operands[0]))
      {
+       /* %K2 == sign extend operand to 32 bits so that CH works - huh??? */
+       if (GET_CODE (operands[2]) == CONST_INT)
+         {
+           mvs_check_page (0, 4, 4);
+           return \"O	%0,%K2\";
+         }
        mvs_check_page (0, 4, 0);
        return \"O	%0,%2\";
      }
***************
*** 3076,3083 ****
  )
  
  (define_insn "iorhi3"
!   [(set (match_operand:HI 0 "general_operand" "=d")
! 	(ior:HI (match_operand:HI 1 "general_operand" "%0")
  		(match_operand:HI 2 "general_operand" "di")))]
    ""
    "*
--- 3262,3269 ----
  )
  
  (define_insn "iorhi3"
!   [(set (match_operand:HI 0 "register_operand" "=d")
! 	(ior:HI (match_operand:HI 1 "register_operand" "%0")
  		(match_operand:HI 2 "general_operand" "di")))]
    ""
    "*
***************
*** 3086,3093 ****
    CC_STATUS_INIT;  /* OR sets CC but not how we want it */
    if (GET_CODE (operands[2]) == CONST_INT)
      {
!       mvs_check_page (0, 4, 0);
!       return \"O	%0,%2\";
      }
    mvs_check_page (0, 2, 0);
    return \"OR	%0,%2\";
--- 3272,3280 ----
    CC_STATUS_INIT;  /* OR sets CC but not how we want it */
    if (GET_CODE (operands[2]) == CONST_INT)
      {
!       /* %K2 == sign extend operand to 32 bits so that CH works - huh??? */
!       mvs_check_page (0, 4, 4);
!       return \"O	%0,%K2\";
      }
    mvs_check_page (0, 2, 0);
    return \"OR	%0,%2\";
***************
*** 3100,3108 ****
  ;
  
  (define_insn ""
!   [(set (match_operand:QI 0 "r_or_s_operand" "=d,m")
  	(ior:QI (match_operand:QI 1 "r_or_s_operand" "%0,0")
! 		(match_operand:QI 2 "r_or_s_operand" "di,mi")))]
    "TARGET_CHAR_INSTRUCTIONS"
    "*
  {
--- 3287,3295 ----
  ;
  
  (define_insn ""
!   [(set (match_operand:QI 0 "r_or_s_operand" "=d,S")
  	(ior:QI (match_operand:QI 1 "r_or_s_operand" "%0,0")
! 		(match_operand:QI 2 "general_operand" "di,Si")))]
    "TARGET_CHAR_INSTRUCTIONS"
    "*
  {
***************
*** 3130,3136 ****
  )
  
  (define_insn "iorqi3"
!   [(set (match_operand:QI 0 "general_operand" "=d")
  	(ior:QI (match_operand:QI 1 "general_operand" "%0")
  		(match_operand:QI 2 "general_operand" "di")))]
    ""
--- 3317,3323 ----
  )
  
  (define_insn "iorqi3"
!   [(set (match_operand:QI 0 "register_operand" "=d")
  	(ior:QI (match_operand:QI 1 "general_operand" "%0")
  		(match_operand:QI 2 "general_operand" "di")))]
    ""
***************
*** 3140,3147 ****
    CC_STATUS_INIT;  /* OR sets CC but not how we want it */
    if (GET_CODE (operands[2]) == CONST_INT)
      {
!       mvs_check_page (0, 4, 0);
!       return \"O	%0,%2\";
      }
    mvs_check_page (0, 2, 0);
    return \"OR	%0,%2\";
--- 3327,3334 ----
    CC_STATUS_INIT;  /* OR sets CC but not how we want it */
    if (GET_CODE (operands[2]) == CONST_INT)
      {
!       mvs_check_page (0, 4, 4);
!       return \"O	%0,=XL4'%X2'\";
      }
    mvs_check_page (0, 2, 0);
    return \"OR	%0,%2\";
***************
*** 3180,3188 ****
  ;
  
  (define_insn ""
!   [(set (match_operand:SI 0 "r_or_s_operand" "=d,m")
  	(xor:SI (match_operand:SI 1 "r_or_s_operand" "%0,0")
! 		(match_operand:SI 2 "r_or_s_operand" "g,mi")))]
    "TARGET_CHAR_INSTRUCTIONS"
    "*
  {
--- 3367,3375 ----
  ;
  
  (define_insn ""
!   [(set (match_operand:SI 0 "r_or_s_operand" "=d,R")
  	(xor:SI (match_operand:SI 1 "r_or_s_operand" "%0,0")
! 		(match_operand:SI 2 "general_operand" "g,Si")))]
    "TARGET_CHAR_INSTRUCTIONS"
    "*
  {
***************
*** 3205,3211 ****
  )
  
  (define_insn "xorsi3"
!   [(set (match_operand:SI 0 "general_operand" "=d")
  	(xor:SI (match_operand:SI 1 "general_operand" "%0")
  		(match_operand:SI 2 "general_operand" "g")))]
    ""
--- 3392,3398 ----
  )
  
  (define_insn "xorsi3"
!   [(set (match_operand:SI 0 "register_operand" "=d")
  	(xor:SI (match_operand:SI 1 "general_operand" "%0")
  		(match_operand:SI 2 "general_operand" "g")))]
    ""
***************
*** 3221,3227 ****
    mvs_check_page (0, 4, 0);
    return \"X	%0,%2\";
  }"
!   [(set_attr "length" "4")]
  )
  
  ;
--- 3408,3414 ----
    mvs_check_page (0, 4, 0);
    return \"X	%0,%2\";
  }"
!    [(set_attr "length" "4")]
  )
  
  ;
***************
*** 3229,3237 ****
  ;
  
  (define_insn ""
!   [(set (match_operand:HI 0 "r_or_s_operand" "=d,m")
  	(xor:HI (match_operand:HI 1 "r_or_s_operand" "%0,0")
! 		(match_operand:HI 2 "r_or_s_operand" "di,mi")))]
    "TARGET_CHAR_INSTRUCTIONS"
    "*
  {
--- 3416,3424 ----
  ;
  
  (define_insn ""
!   [(set (match_operand:HI 0 "r_or_s_operand" "=d,S")
  	(xor:HI (match_operand:HI 1 "r_or_s_operand" "%0,0")
! 		(match_operand:HI 2 "general_operand" "di,Si")))]
    "TARGET_CHAR_INSTRUCTIONS"
    "*
  {
***************
*** 3244,3266 ****
      }
    if (REG_P (operands[0]))
      {
        mvs_check_page (0, 4, 0);
!       return \"X	%0,%H2\";
      }
    if (GET_CODE (operands[2]) == CONST_INT)
      {
!       mvs_check_page (0, 6, 0);
        return \"XC	%O0(2,%R0),%H2\";
      }
    mvs_check_page (0, 6, 0);
    return \"XC	%O0(2,%R0),%2\";
  }"
!   [(set_attr "length" "6")]
  )
  
  (define_insn "xorhi3"
!   [(set (match_operand:HI 0 "general_operand" "=d")
! 	(xor:HI (match_operand:HI 1 "general_operand" "%0")
  		(match_operand:HI 2 "general_operand" "di")))]
    ""
    "*
--- 3431,3459 ----
      }
    if (REG_P (operands[0]))
      {
+       /* %K2 == sign extend operand to 32 bits so that CH works - huh??? */
+       if (GET_CODE (operands[2]) == CONST_INT)
+         {
+           mvs_check_page (0, 4, 4);
+           return \"X	%0,%K2\";
+         }
        mvs_check_page (0, 4, 0);
!       return \"X	%0,%2\";
      }
    if (GET_CODE (operands[2]) == CONST_INT)
      {
!       mvs_check_page (0, 6, 2);
        return \"XC	%O0(2,%R0),%H2\";
      }
    mvs_check_page (0, 6, 0);
    return \"XC	%O0(2,%R0),%2\";
  }"
!    [(set_attr "length" "6")]
  )
  
  (define_insn "xorhi3"
!   [(set (match_operand:HI 0 "register_operand" "=d")
! 	(xor:HI (match_operand:HI 1 "register_operand" "%0")
  		(match_operand:HI 2 "general_operand" "di")))]
    ""
    "*
***************
*** 3269,3281 ****
    CC_STATUS_INIT;  /* XOR sets CC but not how we want it */
    if (GET_CODE (operands[2]) == CONST_INT)
      {
!       mvs_check_page (0, 4, 0);
!       return \"X	%0,%H2\";
      }
    mvs_check_page (0, 2, 0);
    return \"XR	%0,%2\";
  }"
!   [(set_attr "length" "4")]
  )
  
  ;
--- 3462,3475 ----
    CC_STATUS_INIT;  /* XOR sets CC but not how we want it */
    if (GET_CODE (operands[2]) == CONST_INT)
      {
!       /* %K2 == sign extend operand to 32 bits so that CH works - huh??? */
!       mvs_check_page (0, 4, 4);
!       return \"X	%0,%K2\";
      }
    mvs_check_page (0, 2, 0);
    return \"XR	%0,%2\";
  }"
!    [(set_attr "length" "4")]
  )
  
  ;
***************
*** 3283,3291 ****
  ;
  
  (define_insn ""
!   [(set (match_operand:QI 0 "r_or_s_operand" "=d,m")
  	(xor:QI (match_operand:QI 1 "r_or_s_operand" "%0,0")
! 		(match_operand:QI 2 "r_or_s_operand" "di,mi")))]
    "TARGET_CHAR_INSTRUCTIONS"
    "*
  {
--- 3477,3485 ----
  ;
  
  (define_insn ""
!   [(set (match_operand:QI 0 "r_or_s_operand" "=d,S")
  	(xor:QI (match_operand:QI 1 "r_or_s_operand" "%0,0")
! 		(match_operand:QI 2 "general_operand" "di,Si")))]
    "TARGET_CHAR_INSTRUCTIONS"
    "*
  {
***************
*** 3309,3319 ****
    mvs_check_page (0, 6, 0);
    return \"XC	%O0(1,%R0),%2\";
  }"
!   [(set_attr "length" "6")]
  )
  
  (define_insn "xorqi3"
!   [(set (match_operand:QI 0 "general_operand" "=d")
  	(xor:QI (match_operand:QI 1 "general_operand" "%0")
  		(match_operand:QI 2 "general_operand" "di")))]
    ""
--- 3503,3513 ----
    mvs_check_page (0, 6, 0);
    return \"XC	%O0(1,%R0),%2\";
  }"
!    [(set_attr "length" "6")]
  )
  
  (define_insn "xorqi3"
!   [(set (match_operand:QI 0 "register_operand" "=d")
  	(xor:QI (match_operand:QI 1 "general_operand" "%0")
  		(match_operand:QI 2 "general_operand" "di")))]
    ""
***************
*** 3324,3335 ****
    if (GET_CODE (operands[2]) == CONST_INT)
      {
        mvs_check_page (0, 4, 0);
!       return \"X	%0,%2\";
      }
    mvs_check_page (0, 2, 0);
    return \"XR	%0,%2\";
  }"
!   [(set_attr "length" "4")]
  )
  
  ;;
--- 3518,3529 ----
    if (GET_CODE (operands[2]) == CONST_INT)
      {
        mvs_check_page (0, 4, 0);
!       return \"X	%0,=XL4'%X2'\";
      }
    mvs_check_page (0, 2, 0);
    return \"XR	%0,%2\";
  }"
!    [(set_attr "length" "4")]
  )
  
  ;;
***************
*** 3341,3347 ****
  ;
  
  (define_insn "negsi2"
!   [(set (match_operand:SI 0 "general_operand" "=d")
  	(neg:SI (match_operand:SI 1 "general_operand" "d")))]
    ""
    "*
--- 3535,3541 ----
  ;
  
  (define_insn "negsi2"
!   [(set (match_operand:SI 0 "register_operand" "=d")
  	(neg:SI (match_operand:SI 1 "general_operand" "d")))]
    ""
    "*
***************
*** 3358,3364 ****
  ;
  
  (define_insn "neghi2"
!   [(set (match_operand:HI 0 "general_operand" "=d")
  	(neg:HI (match_operand:HI 1 "general_operand" "d")))]
    ""
    "*
--- 3552,3558 ----
  ;
  
  (define_insn "neghi2"
!   [(set (match_operand:HI 0 "register_operand" "=d")
  	(neg:HI (match_operand:HI 1 "general_operand" "d")))]
    ""
    "*
***************
*** 3375,3381 ****
  ;
  
  (define_insn "negdf2"
!   [(set (match_operand:DF 0 "general_operand" "=f")
  	(neg:DF (match_operand:DF 1 "general_operand" "f")))]
    ""
    "*
--- 3569,3575 ----
  ;
  
  (define_insn "negdf2"
!   [(set (match_operand:DF 0 "register_operand" "=f")
  	(neg:DF (match_operand:DF 1 "general_operand" "f")))]
    ""
    "*
***************
*** 3392,3398 ****
  ;
  
  (define_insn "negsf2"
!   [(set (match_operand:SF 0 "general_operand" "=f")
  	(neg:SF (match_operand:SF 1 "general_operand" "f")))]
    ""
    "*
--- 3586,3592 ----
  ;
  
  (define_insn "negsf2"
!   [(set (match_operand:SF 0 "register_operand" "=f")
  	(neg:SF (match_operand:SF 1 "general_operand" "f")))]
    ""
    "*
***************
*** 3413,3419 ****
  ;
  
  (define_insn "abssi2"
!   [(set (match_operand:SI 0 "general_operand" "=d")
  	(abs:SI (match_operand:SI 1 "general_operand" "d")))]
    ""
    "*
--- 3607,3613 ----
  ;
  
  (define_insn "abssi2"
!   [(set (match_operand:SI 0 "register_operand" "=d")
  	(abs:SI (match_operand:SI 1 "general_operand" "d")))]
    ""
    "*
***************
*** 3430,3436 ****
  ;
  
  (define_insn "abshi2"
!   [(set (match_operand:HI 0 "general_operand" "=d")
  	(abs:HI (match_operand:HI 1 "general_operand" "d")))]
    ""
    "*
--- 3624,3630 ----
  ;
  
  (define_insn "abshi2"
!   [(set (match_operand:HI 0 "register_operand" "=d")
  	(abs:HI (match_operand:HI 1 "general_operand" "d")))]
    ""
    "*
***************
*** 3447,3453 ****
  ;
  
  (define_insn "absdf2"
!   [(set (match_operand:DF 0 "general_operand" "=f")
  	(abs:DF (match_operand:DF 1 "general_operand" "f")))]
    ""
    "*
--- 3641,3647 ----
  ;
  
  (define_insn "absdf2"
!   [(set (match_operand:DF 0 "register_operand" "=f")
  	(abs:DF (match_operand:DF 1 "general_operand" "f")))]
    ""
    "*
***************
*** 3464,3470 ****
  ;
  
  (define_insn "abssf2"
!   [(set (match_operand:SF 0 "general_operand" "=f")
  	(abs:SF (match_operand:SF 1 "general_operand" "f")))]
    ""
    "*
--- 3658,3664 ----
  ;
  
  (define_insn "abssf2"
!   [(set (match_operand:SF 0 "register_operand" "=f")
  	(abs:SF (match_operand:SF 1 "general_operand" "f")))]
    ""
    "*
***************
*** 3524,3530 ****
  )
  
  (define_insn "one_cmplsi2"
!   [(set (match_operand:SI 0 "general_operand" "=d")
  	(not:SI (match_operand:SI 1 "general_operand" "0")))]
    ""
    "*
--- 3718,3724 ----
  )
  
  (define_insn "one_cmplsi2"
!   [(set (match_operand:SI 0 "register_operand" "=d")
  	(not:SI (match_operand:SI 1 "general_operand" "0")))]
    ""
    "*
***************
*** 3554,3567 ****
        mvs_check_page (0, 4, 4);
        return \"X	%0,=F'-1'\";
      }
!   mvs_check_page (0, 6, 4);
!   return \"XC	%O0(2,%R0),=XL4'FFFF'\";
  }"
    [(set_attr "length" "6")]
  )
  
  (define_insn "one_cmplhi2"
!   [(set (match_operand:HI 0 "general_operand" "=d")
  	(not:HI (match_operand:HI 1 "general_operand" "0")))]
    ""
    "*
--- 3748,3761 ----
        mvs_check_page (0, 4, 4);
        return \"X	%0,=F'-1'\";
      }
!   mvs_check_page (0, 6, 2);
!   return \"XC	%O0(2,%R0),=XL2'FFFF'\";
  }"
    [(set_attr "length" "6")]
  )
  
  (define_insn "one_cmplhi2"
!   [(set (match_operand:HI 0 "register_operand" "=d")
  	(not:HI (match_operand:HI 1 "general_operand" "0")))]
    ""
    "*
***************
*** 3598,3604 ****
  )
  
  (define_insn "one_cmplqi2"
!   [(set (match_operand:QI 0 "general_operand" "=d")
  	(not:QI (match_operand:QI 1 "general_operand" "0")))]
    ""
    "*
--- 3792,3798 ----
  )
  
  (define_insn "one_cmplqi2"
!   [(set (match_operand:QI 0 "register_operand" "=d")
  	(not:QI (match_operand:QI 1 "general_operand" "0")))]
    ""
    "*
***************
*** 3620,3626 ****
  ;
  
  (define_insn "ashldi3"
!   [(set (match_operand:DI 0 "general_operand" "=d")
  	(ashift:DI (match_operand:DI 1 "general_operand" "0")
  		   (match_operand:SI 2 "general_operand" "Ja")))]
    ""
--- 3814,3820 ----
  ;
  
  (define_insn "ashldi3"
!   [(set (match_operand:DI 0 "register_operand" "=d")
  	(ashift:DI (match_operand:DI 1 "general_operand" "0")
  		   (match_operand:SI 2 "general_operand" "Ja")))]
    ""
***************
*** 3666,3672 ****
  ;
  
  (define_insn "ashlsi3"
!   [(set (match_operand:SI 0 "general_operand" "=d")
  	(ashift:SI (match_operand:SI 1 "general_operand" "0")
  		   (match_operand:SI 2 "general_operand" "Ja")))]
    ""
--- 3860,3866 ----
  ;
  
  (define_insn "ashlsi3"
!   [(set (match_operand:SI 0 "register_operand" "=d")
  	(ashift:SI (match_operand:SI 1 "general_operand" "0")
  		   (match_operand:SI 2 "general_operand" "Ja")))]
    ""
***************
*** 3686,3692 ****
  ;
  
  (define_insn "ashrsi3"
!   [(set (match_operand:SI 0 "general_operand" "=d")
  	(ashiftrt:SI (match_operand:SI 1 "general_operand" "0")
  		     (match_operand:SI 2 "general_operand" "Ja")))]
    ""
--- 3880,3886 ----
  ;
  
  (define_insn "ashrsi3"
!   [(set (match_operand:SI 0 "register_operand" "=d")
  	(ashiftrt:SI (match_operand:SI 1 "general_operand" "0")
  		     (match_operand:SI 2 "general_operand" "Ja")))]
    ""
***************
*** 3707,3713 ****
  ;
  
  (define_insn "ashlhi3"
!   [(set (match_operand:HI 0 "general_operand" "=d")
  	(ashift:HI (match_operand:HI 1 "general_operand" "0")
  		   (match_operand:SI 2 "general_operand" "Ja")))]
    ""
--- 3901,3907 ----
  ;
  
  (define_insn "ashlhi3"
!   [(set (match_operand:HI 0 "register_operand" "=d")
  	(ashift:HI (match_operand:HI 1 "general_operand" "0")
  		   (match_operand:SI 2 "general_operand" "Ja")))]
    ""
***************
*** 3727,3733 ****
  ;
  
  (define_insn "ashrhi3"
!   [(set (match_operand:HI 0 "general_operand" "=d")
  	(ashiftrt:HI (match_operand:HI 1 "general_operand" "0")
  		     (match_operand:SI 2 "general_operand" "Ja")))]
    ""
--- 3921,3927 ----
  ;
  
  (define_insn "ashrhi3"
!   [(set (match_operand:HI 0 "register_operand" "=d")
  	(ashiftrt:HI (match_operand:HI 1 "general_operand" "0")
  		     (match_operand:SI 2 "general_operand" "Ja")))]
    ""
***************
*** 3747,3753 ****
  ;
  
  (define_insn "ashlqi3"
!   [(set (match_operand:QI 0 "general_operand" "=d")
  	(ashift:QI (match_operand:QI 1 "general_operand" "0")
  		   (match_operand:SI 2 "general_operand" "Ja")))]
    ""
--- 3941,3947 ----
  ;
  
  (define_insn "ashlqi3"
!   [(set (match_operand:QI 0 "register_operand" "=d")
  	(ashift:QI (match_operand:QI 1 "general_operand" "0")
  		   (match_operand:SI 2 "general_operand" "Ja")))]
    ""
***************
*** 3767,3773 ****
  ;
  
  (define_insn "ashrqi3"
!   [(set (match_operand:QI 0 "general_operand" "=d")
  	(ashiftrt:QI (match_operand:QI 1 "general_operand" "0")
  		     (match_operand:SI 2 "general_operand" "Ja")))]
    ""
--- 3961,3967 ----
  ;
  
  (define_insn "ashrqi3"
!   [(set (match_operand:QI 0 "register_operand" "=d")
  	(ashiftrt:QI (match_operand:QI 1 "general_operand" "0")
  		     (match_operand:SI 2 "general_operand" "Ja")))]
    ""
***************
*** 3791,3797 ****
  ;
  
  (define_insn "lshrdi3"
!   [(set (match_operand:DI 0 "general_operand" "=d")
  	(lshiftrt:DI (match_operand:DI 1 "general_operand" "0")
  		     (match_operand:SI 2 "general_operand" "Ja")))]
    ""
--- 3985,3991 ----
  ;
  
  (define_insn "lshrdi3"
!   [(set (match_operand:DI 0 "register_operand" "=d")
  	(lshiftrt:DI (match_operand:DI 1 "general_operand" "0")
  		     (match_operand:SI 2 "general_operand" "Ja")))]
    ""
***************
*** 3812,3818 ****
  ;
  
  (define_insn "lshrsi3"
!   [(set (match_operand:SI 0 "general_operand" "=d")
  	(lshiftrt:SI (match_operand:SI 1 "general_operand" "0")
  		     (match_operand:SI 2 "general_operand" "Ja")))]
    ""
--- 4006,4012 ----
  ;
  
  (define_insn "lshrsi3"
!   [(set (match_operand:SI 0 "register_operand" "=d")
  	(lshiftrt:SI (match_operand:SI 1 "general_operand" "0")
  		     (match_operand:SI 2 "general_operand" "Ja")))]
    ""
***************
*** 3832,3838 ****
  ;
  
  (define_insn "lshrhi3"
!   [(set (match_operand:HI 0 "general_operand" "=d")
  	(lshiftrt:HI (match_operand:HI 1 "general_operand" "0")
  		     (match_operand:SI 2 "general_operand" "Ja")))]
    ""
--- 4026,4032 ----
  ;
  
  (define_insn "lshrhi3"
!   [(set (match_operand:HI 0 "register_operand" "=d")
  	(lshiftrt:HI (match_operand:HI 1 "general_operand" "0")
  		     (match_operand:SI 2 "general_operand" "Ja")))]
    ""
***************
*** 3856,3862 ****
  ;
  
  (define_insn "lshrqi3"
!   [(set (match_operand:QI 0 "general_operand" "=d")
  	(lshiftrt:QI (match_operand:QI 1 "general_operand" "0")
  		     (match_operand:SI 2 "general_operand" "Ja")))]
    ""
--- 4050,4056 ----
  ;
  
  (define_insn "lshrqi3"
!   [(set (match_operand:QI 0 "register_operand" "=d")
  	(lshiftrt:QI (match_operand:QI 1 "general_operand" "0")
  		     (match_operand:SI 2 "general_operand" "Ja")))]
    ""
***************
*** 4539,4559 ****
  (define_insn "call"
    [(call (match_operand:QI 0 "memory_operand" "m")
  	 (match_operand:SI 1 "immediate_operand" "i"))
!    (clobber (reg:SI 2))
     ]
    ""
    "*
  {
    static char temp[128];
    int i = STACK_POINTER_OFFSET;
-   CC_STATUS_INIT;
  
    check_label_emit ();
- #ifdef TARGET_ELF_ABI
    mvs_check_page (0, 10, 4);
    sprintf ( temp, \"LA	r2,%d(,sp)\;LA	15,%%0\;BASR	14,15\", i );
    return temp;
  #else
    if (mvs_function_check (XSTR (operands[0], 0)))
      {
        mvs_check_page (0, 22, 4);
--- 4733,4767 ----
  (define_insn "call"
    [(call (match_operand:QI 0 "memory_operand" "m")
  	 (match_operand:SI 1 "immediate_operand" "i"))
! ;;    (clobber (reg:SI 2))
     ]
    ""
    "*
  {
+ #ifdef TARGET_LINUX
+ #ifdef STACK_GROWS_DOWNWARD
    static char temp[128];
    int i = STACK_POINTER_OFFSET;
  
+   CC_STATUS_INIT;
    check_label_emit ();
    mvs_check_page (0, 10, 4);
    sprintf ( temp, \"LA	r2,%d(,sp)\;LA	15,%%0\;BASR	14,15\", i );
    return temp;
+ #else /* STACK_GROWS_DOWNWARD */
+   CC_STATUS_INIT;
+   check_label_emit ();
+   mvs_check_page (0, 6, 4);
+   return \"LA	15,%0\;BASR	14,15\";
+ #endif /* STACK_GROWS_DOWNWARD */
+ 
  #else
+ 
+   static char temp[128];
+   int i = STACK_POINTER_OFFSET;
+ 
+   CC_STATUS_INIT;
+   check_label_emit ();
    if (mvs_function_check (XSTR (operands[0], 0)))
      {
        mvs_check_page (0, 22, 4);
***************
*** 4579,4599 ****
    [(set (match_operand 0 "" "=rf")
   	(call (match_operand:QI 1 "memory_operand" "m")
   	      (match_operand:SI 2 "general_operand" "i")))
!    (clobber (reg:SI 2))
     ]
    ""
    "*
  {
    static char temp[128];
    int i = STACK_POINTER_OFFSET;
    CC_STATUS_INIT;
- 
-   check_label_emit ();
- #ifdef TARGET_ELF_ABI
    mvs_check_page (0, 10, 4);
    sprintf ( temp, \"LA	r2,%d(,sp)\;LA	15,%%1\;BASR	14,15\", i );
!   return temp;
  #else
    if (mvs_function_check (XSTR (operands[1], 0)))
      {
        mvs_check_page (0, 22, 4);
--- 4787,4820 ----
    [(set (match_operand 0 "" "=rf")
   	(call (match_operand:QI 1 "memory_operand" "m")
   	      (match_operand:SI 2 "general_operand" "i")))
! ;;   (clobber (reg:SI 2)) 
     ]
    ""
    "*
  {
+ #ifdef TARGET_LINUX
+ #ifdef STACK_GROWS_DOWNWARD
    static char temp[128];
    int i = STACK_POINTER_OFFSET;
    CC_STATUS_INIT;
    mvs_check_page (0, 10, 4);
    sprintf ( temp, \"LA	r2,%d(,sp)\;LA	15,%%1\;BASR	14,15\", i );
!   return temp;     
! 
! #else /* STACK_GROWS_DOWNWARD */
!   CC_STATUS_INIT;
!   check_label_emit ();
!   mvs_check_page (0, 6, 4);
!   return \"LA	15,%1\;BASR	14,15\";
! #endif /* STACK_GROWS_DOWNWARD */
! 
  #else
+ 
+   static char temp[128];
+   int i = STACK_POINTER_OFFSET;
+   CC_STATUS_INIT;
+ 
+   check_label_emit ();
    if (mvs_function_check (XSTR (operands[1], 0)))
      {
        mvs_check_page (0, 22, 4);
***************
*** 4606,4611 ****
--- 4827,4833 ----
        sprintf ( temp, \"LA	1,%d(,13)\;LA	15,%%1\;BALR	14,15\", i );
      }
    return temp;
+ 
  #endif
  }"
    [(set_attr "length" "22")]
***************
*** 4614,4634 ****
  (define_insn ""
    [(call (mem:QI (match_operand:SI 0 "" "i"))
  	 (match_operand:SI 1 "general_operand" "g"))
!    (clobber (reg:SI 2))
     ]
    "GET_CODE (operands[0]) == SYMBOL_REF"
    "*
  {
    static char temp[128];
    int i = STACK_POINTER_OFFSET;
    CC_STATUS_INIT;
- 
-   check_label_emit ();
- #ifdef TARGET_ELF_ABI
    mvs_check_page (0, 10, 4);
    sprintf ( temp, \"LA	r2,%d(,sp)\;L	15,%%0\;BASR	14,15\", i );
    return temp;
  #else
    if (mvs_function_check (XSTR (operands[0], 0)))
      {
        mvs_check_page (0, 22, 4);
--- 4836,4869 ----
  (define_insn ""
    [(call (mem:QI (match_operand:SI 0 "" "i"))
  	 (match_operand:SI 1 "general_operand" "g"))
! ;;   (clobber (reg:SI 2)) 
     ]
    "GET_CODE (operands[0]) == SYMBOL_REF"
    "*
  {
+ #ifdef TARGET_LINUX
+ #ifdef STACK_GROWS_DOWNWARD
    static char temp[128];
    int i = STACK_POINTER_OFFSET;
    CC_STATUS_INIT;
    mvs_check_page (0, 10, 4);
    sprintf ( temp, \"LA	r2,%d(,sp)\;L	15,%%0\;BASR	14,15\", i );
    return temp;
+ 
+ #else /* STACK_GROWS_DOWNWARD */
+   CC_STATUS_INIT;
+   check_label_emit ();
+   mvs_check_page (0, 6, 4);
+   return \"L	15,%0\;BASR	14,15\";
+ #endif /* STACK_GROWS_DOWNWARD */
+ 
  #else
+ 
+   static char temp[128];
+   int i = STACK_POINTER_OFFSET;
+   CC_STATUS_INIT;
+ 
+   check_label_emit ();
    if (mvs_function_check (XSTR (operands[0], 0)))
      {
        mvs_check_page (0, 22, 4);
***************
*** 4650,4670 ****
    [(set (match_operand 0 "" "=rf")
  	(call (mem:QI (match_operand:SI 1 "" "i"))
  	      (match_operand:SI 2 "general_operand" "g")))
!    (clobber (reg:SI 2))
     ]
    "GET_CODE (operands[1]) == SYMBOL_REF"
    "*
  {
    static char temp[128];
    int i = STACK_POINTER_OFFSET;
    CC_STATUS_INIT;
  
    check_label_emit ();
- #ifdef TARGET_ELF_ABI
    mvs_check_page (0, 10, 4);
    sprintf ( temp, \"LA	r2,%d(,sp)\;L	15,%%1\;BASR	14,15\", i );
    return temp;
  #else
    if (mvs_function_check (XSTR (operands[1], 0)))
      {
        mvs_check_page (0, 22, 4);
--- 4885,4920 ----
    [(set (match_operand 0 "" "=rf")
  	(call (mem:QI (match_operand:SI 1 "" "i"))
  	      (match_operand:SI 2 "general_operand" "g")))
! ;;   (clobber (reg:SI 2)) 
     ]
    "GET_CODE (operands[1]) == SYMBOL_REF"
    "*
  {
+ #ifdef TARGET_LINUX
+ #ifdef STACK_GROWS_DOWNWARD
    static char temp[128];
    int i = STACK_POINTER_OFFSET;
    CC_STATUS_INIT;
  
    check_label_emit ();
    mvs_check_page (0, 10, 4);
    sprintf ( temp, \"LA	r2,%d(,sp)\;L	15,%%1\;BASR	14,15\", i );
    return temp;
+ 
+ #else /* STACK_GROWS_DOWNWARD */
+   CC_STATUS_INIT;
+   check_label_emit ();
+   mvs_check_page (0, 6, 4);
+   return \"L	15,%1\;BASR	14,15\";
+ #endif /* STACK_GROWS_DOWNWARD */
+ 
  #else
+ 
+   static char temp[128];
+   int i = STACK_POINTER_OFFSET;
+   CC_STATUS_INIT;
+ 
+   check_label_emit ();
    if (mvs_function_check (XSTR (operands[1], 0)))
      {
        mvs_check_page (0, 22, 4);
***************
*** 4733,4739 ****
  {
    check_label_emit ();
    mvs_check_page (0, 2, 0);
!   return \"LR	0,0\";
  }"
    [(set_attr "length" "2")]
  )
--- 4983,4989 ----
  {
    check_label_emit ();
    mvs_check_page (0, 2, 0);
!   return \"NOPR	0\";
  }"
    [(set_attr "length" "2")]
  )
Index: gcc/gcc/config/i370/linux.h
diff -c gcc/gcc/config/i370/linux.h:1.1.1.1 gcc/gcc/config/i370/linux.h:1.2
*** gcc/gcc/config/i370/linux.h:1.1.1.1	Wed Feb 15 21:22:45 2006
--- gcc/gcc/config/i370/linux.h	Wed Feb 15 21:24:30 2006
***************
*** 26,32 ****
  
  /* Specify that we're generating code for a Linux port to 370 */
  
! #define TARGET_ELF_ABI
  #define LINUX_DEFAULT_ELF
  
  
--- 26,32 ----
  
  /* Specify that we're generating code for a Linux port to 370 */
  
! #define TARGET_LINUX
  #define LINUX_DEFAULT_ELF
  
  
***************
*** 37,46 ****
   * cross-compiling ...  */
  #define REAL_ARITHMETIC
  
- /* Include system common definitions */
- /* TODO: convert include to ${tm_file} list in config.gcc.  */
- #include "i370/i370.h"
- 
  /* Names to predefine in the preprocessor for this target machine.  */
  
  #undef CPP_PREDEFINES
--- 37,42 ----
Index: gcc/gcc/config/i370/mshort.h
diff -c nul gcc/gcc/config/i370/mshort.h:1.13
*** nul	Tue Oct 01 16:28:50 2019
--- gcc/gcc/config/i370/mshort.h	Sun Oct 12 11:39:07 2008
***************
*** 0 ****
--- 1,1316 ----
+ /* External function redefines */
+ 
+ #define _cpp_do__Pragma _cpdprag
+ #define _cpp_do_file_change _cpdfcha
+ #define _cpp_free_buff _cfbuff
+ #define _cpp_free_definition _cfdefn
+ #define _cpp_init_directives _cpindir
+ #define _cpp_init_hashtable _cpihtab
+ #define _cpp_init_includes _cpiincl
+ #define _cpp_init_internal_pragmas _cpintprag
+ #define _cpp_init_tokenrun _cpitoken
+ #define _cpp_lex_direct _cplexd
+ #define _cpp_lex_token _cpletk
+ #define _cpp_pop_buffer _cppbuff
+ #define _cpp_pop_context _cpcontext
+ #define _cpp_pop_file_buffer _cpfbuff
+ #define _fatal_insn _fatins
+ #define _fatal_insn_not_found _fatnotf
+ #define _obstack_allocated_p _osallp
+ #define _obstack_begin _osbegin
+ #define _obstack_begin_1 _osbg1
+ #define _obstack_free _osfree
+ #define _obstack_memory_used _osmemu
+ #define _obstack_newchunk _osnchunk
+ #define add_insn addin
+ #define add_insn_after addina
+ #define add_insn_before addinbef
+ #define address_cost adrcost
+ #define address_operand adroper
+ #define adjust_address_1 adjadd
+ #define adjust_automodify_address_1 adjaad
+ #define alloc_aux_for_block aauxfb
+ #define alloc_aux_for_blocks aauxfs
+ #define alloc_aux_for_edge aafedg
+ #define alloc_aux_for_edges aafeds
+ #define allocate_bb_life_data allbbld
+ #define allocate_dynamic_stack_space aldynstks
+ #define allocate_initial_values alinval
+ #define allocate_reg_info allreginf
+ #define allocate_reg_life_data allrlifed
+ #define assemble_align assal
+ #define assemble_asm assasm
+ #define assemble_constant_align assca
+ #define assemble_end_function assef
+ #define assemble_external assext
+ #define assemble_external_libcall asselibc
+ #define assemble_global assglb
+ #define assemble_integer assint
+ #define assemble_integer_with_op asiwo
+ #define assemble_label asslab
+ #define assemble_name assname
+ #define assemble_real assreal
+ #define assemble_start_function asfunc
+ #define assemble_static_space asstsp
+ #define assemble_string assstr
+ #define assemble_trampoline_template astrtemp
+ #define assemble_variable assvar
+ #define assemble_vtable_entry assvtent
+ #define assemble_vtable_inherit assvinh
+ #define assemble_zeros asszero
+ #define assign_stack_local asstkloc
+ #define assign_stack_temp asstkt
+ #define assign_stack_temp_for_type astft
+ #define attribute_hash_list atthal
+ #define attribute_list_contained attlcont
+ #define bitmap_clear_bit bmclrbit
+ #define bitmap_copy bm_copy
+ #define bitmap_initialize bm_init
+ #define bitmap_ior_and_compl bm_ior
+ #define build_array_declarator bardecl
+ #define build_array_ref barref
+ #define build_array_type baratyp
+ #define build_common_tree_nodes bctnodes
+ #define build_common_tree_nodes_2 bctno2
+ #define build_complex bcomplex
+ #define build_complex_type bldctype
+ #define build_component_ref bldcmpref
+ #define build_compound_expr bldcexpr
+ #define build_compound_literal bcmplit
+ #define build_conditional_expr bldconexp
+ #define build_continue_stmt bcntstmt
+ #define build_decl bdecl
+ #define build_decl_attribute_variant bdeclav
+ #define build_expr_wfl bexwfl
+ #define build_external_ref bextref
+ #define build_function_call bfnccall
+ #define build_function_type bftype
+ #define build_index_2_type bi2type
+ #define build_index_type bindtyp
+ #define build_indirect_ref bindcref
+ #define build_insn_chain binsnchn
+ #define build_int_2_wide bint2wid
+ #define build_real breal
+ #define build_real_from_int_cst brfricst
+ #define build_reference_type breftype
+ #define build_stmt bldstmt
+ #define build_string bldstring
+ #define build_type_attribute_variant bypatv
+ #define build_type_copy btypecp
+ #define build_type_no_quals btypnoqual
+ #define c_alignof calof
+ #define c_alignof_expr calofex
+ #define c_begin_if_stmt cbegif
+ #define c_begin_while_stmt cbegws
+ #define c_common_finish ccomfin
+ #define c_common_get_alias_set ccomgas
+ #define c_common_init ccominit
+ #define c_common_init_options comnopt
+ #define c_common_nodes_and_builtins ccomnode
+ #define c_common_post_options ccompo
+ #define c_expand_asm_operands cexpasm
+ #define c_expand_decl_stmt cexpdecl
+ #define c_expand_deferred_function cexpdff
+ #define c_expand_end_cond ceecond
+ #define c_expand_expr ceexpr
+ #define c_expand_expr_stmt cexexst
+ #define c_expand_return cexpret
+ #define c_expand_start_cond cexstcond
+ #define c_expand_start_else cexstelse
+ #define c_finish_case cfincase
+ #define c_finish_else cfinelse
+ #define c_finish_then cfinthen
+ #define c_finish_while_stmt_cond cfinwhst
+ #define c_objc_common_finish_file cocff
+ #define c_objc_common_init cocinit
+ #define c_sizeof csizeof
+ #define c_sizeof_nowarn csiznowarn
+ #define can_throw_external cantext
+ #define can_throw_internal cantint
+ #define cfg_layout_finalize cfglfin
+ #define cfg_layout_initialize cfglinit
+ #define chain_member chmem
+ #define chain_member_purpose chmemp
+ #define chain_member_value chmemv
+ #define check_for_full_enumeration_handling chkffeh
+ #define check_for_loop_decls chkfldecls
+ #define check_function_format chkfformat
+ #define cleanup_barriers clnpbarr
+ #define cleanup_cfg clnpcfg
+ #define cleanup_subreg_operands clnpsoper
+ #define clear_aux_for_blocks cafblks
+ #define clear_aux_for_edges cafedge
+ #define combine_instructions combinst
+ #define combine_stack_adjustments cstkadj
+ #define combine_strings cmbstrngs
+ #define combine_temp_slots ctslots
+ #define compare_from_rtx cmpfrtx
+ #define compare_tree_int ctreent
+ #define comparison_dominates_p cmdominsp
+ #define comparison_operator cmpoprt
+ #define compute_alignments cmpalgn
+ #define compute_available cavail
+ #define compute_bb_for_insn cebforin
+ #define compute_dominance_frontiers cdfront
+ #define compute_record_mode cmprecmod
+ #define compute_use_by_pseudos cusebyps
+ #define concat_copy cncopy
+ #define concat_copy2 cncop2
+ #define condjump_in_parallel_p cjinpar
+ #define condjump_label cjlabel
+ #define condjump_p cjumpp
+ #define conflict_graph_add cgadd
+ #define conflict_graph_compute cgcomp
+ #define conflict_graph_conflict_p cgconf
+ #define conflict_graph_delete cgdel
+ #define conflict_graph_enum cgenum
+ #define conflict_graph_merge_regs cgmregs
+ #define conflict_graph_new cgnew
+ #define conflict_graph_print cgprint
+ #define constant_expression_warning conexpw
+ #define constrain_operands cstoper
+ #define constrain_operands_cached cstocach
+ #define convert_and_check candchk
+ #define convert_from_eh_region_ranges cferrange
+ #define convert_from_ssa cvtfrssa
+ #define convert_modes cnvmod
+ #define convert_move cnvmov
+ #define convert_to_complex cnvtcompl
+ #define convert_to_eh_region_ranges ctehrran
+ #define convert_to_integer cnvtint
+ #define convert_to_mode cttomode
+ #define convert_to_pointer cnvtptr
+ #define convert_to_real cnvtreal
+ #define convert_to_ssa cvttossa
+ #define convert_to_vector cnvtvec
+ #define copy_insn cpinsn
+ #define copy_insn_1 cpins1
+ #define copy_rtx cpyrtx
+ #define copy_rtx_and_substitute cprandsub
+ #define copy_rtx_if_shared cprtifshr
+ #define copy_to_mode_reg copytmr
+ #define copy_to_reg copytreg
+ #define copy_to_suggested_reg copytsreg
+ #define cpp_define cppdefin
+ #define cpp_defined cppdfnd
+ #define cpp_error cperr
+ #define cpp_error_from_errno cperrfe
+ #define cpp_error_with_line cperrwl
+ #define cpp_finish cppfin
+ #define cpp_finish_options cppfino
+ #define cpp_get_callbacks cg_calb
+ #define cpp_get_line_maps cg_linmaps
+ #define cpp_get_options cg_opts
+ #define cpp_get_token cg_token
+ #define cpp_handle_option cpphopt
+ #define cpp_handle_options cppopts
+ #define cpp_included cpincldd
+ #define cpp_notice_from_errno cpnot
+ #define cpp_output_line cpoline
+ #define cpp_output_token cpotok
+ #define cpp_pedwarn cppdwarn
+ #define cpp_pedwarn_with_line cppdwwl
+ #define cpp_token_as_text cptastext
+ #define cpp_token_len cptklen
+ #define cpp_warning cppwrn
+ #define cpp_warning_with_line cppwwl
+ #define create_basic_block cbasblk
+ #define create_basic_block_structure cbasbs
+ #define current_function_has_exception_handlers cfhasxchdl
+ #define current_nesting_level cnestlvl
+ #define current_scope_stmt_stack cs_ststk
+ #define current_stmt_tree cs_tree
+ #define dead_or_set_p dedset
+ #define dead_or_set_regno_p detsreg
+ #define debug_bb dbgbb
+ #define debug_bb_n dbgbbn
+ #define debug_bitmap dbgbtmap
+ #define debug_bitmap_file dbgbmf
+ #define debug_biv dbgbiv
+ #define debug_df_chain ddfch
+ #define debug_df_defno ddfdef
+ #define debug_df_insn ddfinsn
+ #define debug_df_ref ddfref
+ #define debug_df_reg ddfreg
+ #define debug_df_regno ddfren
+ #define debug_df_useno ddfuse
+ #define debug_iv_class divclas
+ #define debug_ivs divs
+ #define debug_loop dloop
+ #define debug_loops dloops
+ #define debug_nothing_charstar dnutcs
+ #define debug_nothing_int dnutint
+ #define debug_nothing_int_charstar dnuics
+ #define debug_nothing_int_int dnuiint
+ #define debug_nothing_rtx dnurtx
+ #define debug_nothing_tree dnutree
+ #define debug_nothing_void dnuvoid
+ #define debug_real dbreal
+ #define debug_regset dbregset
+ #define debug_reload dbgrel
+ #define debug_reload_to_stream dbgrtostr
+ #define debug_rtx drtx
+ #define debug_rtx_find dr_find
+ #define debug_rtx_list dr_list
+ #define debug_rtx_range dr_range
+ #define debug_true_tree dtrtree
+ #define declare_nonlocal_label dcnonll
+ #define declare_parm_level dcplevl
+ #define declare_weak dcweak
+ #define default_assemble_integer defai
+ #define default_coff_asm_named_section defcans
+ #define default_comp_type_attributes defcta
+ #define default_conversion defconvr
+ #define default_eh_frame_section dfehsect
+ #define default_elf_asm_named_section defeans
+ #define default_exception_section defesec
+ #define default_expand_builtin defexp
+ #define default_function_attribute_inlinable_p defatip
+ #define default_function_pro_epilogue dfprepil
+ #define default_init_builtins definitb
+ #define default_insert_attributes defiatt
+ #define default_ms_bitfield_layout_p defmsl
+ #define default_named_section_asm_out_constructor defnsaoc
+ #define default_named_section_asm_out_destructor defnsaod
+ #define default_no_named_section defnonsec
+ #define default_pe_asm_named_section defpeasm
+ #define default_print_error_function dpefunc
+ #define default_section_type_flags defsectyp
+ #define default_set_default_type_attributes defsdta
+ #define default_stabs_asm_out_constructor defsaocn
+ #define default_stabs_asm_out_destructor dstbaod
+ #define delete_insn delins
+ #define delete_insn_chain delinchain
+ #define delete_null_pointer_checks delnpchk
+ #define deps_add_default_target da_deft
+ #define deps_add_dep da_dep
+ #define deps_add_target da_target
+ #define df_bb_reg_live_end_p dfrlep
+ #define df_bb_reg_live_start_p dfrlstrt
+ #define df_bb_regs_lives_compare dfrlc
+ #define df_insn_debug dfideb
+ #define df_insn_debug_regno dfidreg
+ #define df_insn_delete dfidel
+ #define df_insn_dominates_all_uses_p dfidaup
+ #define df_insn_dominates_uses_p dfidup
+ #define df_insn_mem_replace dfimrep
+ #define df_insn_modify dfimod
+ #define df_insn_move_before dfimov
+ #define df_insn_regno_def_p dfirdef
+ #define df_pattern_emit_after dfpatea
+ #define df_pattern_emit_before dfpebef
+ #define df_ref_reg_replace dfrrr
+ #define df_ref_remove dfrrem
+ #define diagnostic_initialize diaginit
+ #define do_jump_by_parts_equality_rtx dojbpr
+ #define do_jump_by_parts_greater_rtx dojprrtx
+ #define dump_combine_stats dmpcstat
+ #define dump_combine_total_stats dmpctotstats
+ #define dump_flag dmpflg
+ #define dump_flag_name dmpflname
+ #define dump_sbitmap dsbitm
+ #define dump_sbitmap_vector dsbitv
+ #define dw2_asm_output_addr daoaddr
+ #define dw2_asm_output_addr_rtx daoadr
+ #define dw2_asm_output_data daod
+ #define dw2_asm_output_data_sleb128 daodsl
+ #define dw2_asm_output_data_uleb128 daodul
+ #define dw2_asm_output_delta daodel
+ #define dw2_asm_output_delta_sleb128 daodes
+ #define dw2_asm_output_delta_uleb128 daodeu
+ #define dw2_asm_output_encoded_addr_rtx daoear
+ #define dw2_asm_output_nstring daonstr
+ #define dw2_asm_output_offset daooff
+ #define dw2_asm_output_pcrel daopcr
+ #define eliminate_regs elregs
+ #define emit_barrier embar
+ #define emit_barrier_after embaf
+ #define emit_barrier_before embbef
+ #define emit_call_insn emcins
+ #define emit_call_insn_before emcibef
+ #define emit_cmp_and_jump_insns ecaji
+ #define emit_cmp_insn emcmpi
+ #define emit_group_load emgrld
+ #define emit_group_store emgrst
+ #define emit_insn emins
+ #define emit_insn_after emiaft
+ #define emit_insn_after_with_line_notes emiafwln
+ #define emit_insn_before emibef
+ #define emit_insns emisn
+ #define emit_insns_after emisaf
+ #define emit_insns_before emisbf
+ #define emit_jump emjmp
+ #define emit_jump_insn emji
+ #define emit_jump_insn_after emjia
+ #define emit_jump_insn_before emjib
+ #define emit_label emlab
+ #define emit_label_after emlaba
+ #define emit_label_before emlabb
+ #define emit_libcall_block el_block
+ #define emit_library_call el_call
+ #define emit_library_call_value el_val
+ #define emit_line_note emlnot
+ #define emit_line_note_after emlnaft
+ #define emit_line_note_force emlnfor
+ #define emit_move_insn emmov
+ #define emit_move_insn_1 emmov1
+ #define emit_note emnote
+ #define emit_note_after emnota
+ #define emit_note_before emnotb
+ #define emit_stack_restore emsrest
+ #define emit_stack_save emssave
+ #define emit_store_flag emsflag
+ #define emit_store_flag_force emsfforc
+ #define ereal_from_double erfdoub
+ #define ereal_from_float erffloat
+ #define ereal_from_int effint
+ #define ereal_from_uint effuint
+ #define ereal_to_decimal ertodec
+ #define ereal_to_int ertoint
+ #define ereal_unto_double eruntodb
+ #define ereal_unto_float eruntofl
+ #define error_with_decl errwdecl
+ #define error_with_file_and_line errwfal
+ #define expand_abs x_abs
+ #define expand_and x_and
+ #define expand_anon_union_decl eanonunion
+ #define expand_asm expasm
+ #define expand_asm_operands expasop
+ #define expand_assignment expassign
+ #define expand_binop expbinop
+ #define expand_builtin expbuilt
+ #define expand_builtin_eh_return expbehret
+ #define expand_builtin_eh_return_data_regno eberdr
+ #define expand_builtin_expect_jump expbej
+ #define expand_builtin_extract_return_addr expbera
+ #define expand_builtin_frob_return_addr expfra
+ #define expand_builtin_longjmp expblj
+ #define expand_builtin_return_addr exprad
+ #define expand_builtin_saveregs expsregs
+ #define expand_builtin_setjmp_receiver expsjr
+ #define expand_builtin_setjmp_setup expsjs
+ #define expand_builtin_trap exptrap
+ #define expand_builtin_unwind_init expunwind
+ #define expand_call x_call
+ #define expand_complex_abs ecabs
+ #define expand_computed_goto expcgoto
+ #define expand_cond x_cond
+ #define expand_continue_loop expcoloop
+ #define expand_dec expdec
+ #define expand_decl expdcl
+ #define expand_decl_cleanup xpdcleanup
+ #define expand_decl_cleanup_eh expdcleh
+ #define expand_decl_init expdinit
+ #define expand_divmod expdivm
+ #define expand_eh_region_end_allowed eereall
+ #define expand_eh_region_end_cleanup eereclean
+ #define expand_eh_region_end_fixup eerefix
+ #define expand_eh_region_end_throw eerethrow
+ #define expand_eh_region_start eerstart
+ #define expand_eh_return eehret
+ #define expand_elseif eeeeif
+ #define expand_end_all_catch eendallc
+ #define expand_end_bindings eebind
+ #define expand_end_case_dummy eecasdum
+ #define expand_end_case_type eecastype
+ #define expand_end_catch eendcatch
+ #define expand_end_cond eecond
+ #define expand_end_loop exeloop
+ #define expand_end_null_loop eenullloop
+ #define expand_end_stmt_expr eestexpr
+ #define expand_end_target_temps eetarg
+ #define expand_exit_loop eeloop
+ #define expand_exit_loop_if_false eelopif
+ #define expand_exit_loop_top_cond eeloptc
+ #define expand_exit_something eesome
+ #define expand_expr expexpr
+ #define expand_expr_stmt eestmt
+ #define expand_expr_stmt_value eesval
+ #define expand_fix expfx
+ #define expand_fixups expfxps
+ #define expand_float expfloat
+ #define expand_function_end expfend
+ #define expand_function_start expfst
+ #define expand_inc x_inc
+ #define expand_inline_function x_inline
+ #define expand_label explab
+ #define expand_loop_continue_here explconth
+ #define expand_mult expmult
+ #define expand_mult_add expmadd
+ #define expand_mult_highpart expmhigh
+ #define expand_mult_highpart_adjust expmhadj
+ #define expand_shift expshift
+ #define expand_simple_binop expsbin
+ #define expand_simple_unop expsunop
+ #define expand_start_all_catch expsallc
+ #define expand_start_bindings_and_block esbandb
+ #define expand_start_case escase
+ #define expand_start_case_dummy escsdum
+ #define expand_start_catch expscatch
+ #define expand_start_cond escond
+ #define expand_start_else eselse
+ #define expand_start_elseif eselif
+ #define expand_start_loop estloop
+ #define expand_start_loop_continue_elsewhere esloce
+ #define expand_start_null_loop esnuloop
+ #define expand_start_stmt_expr essexpr
+ #define expand_start_target_temps estgtps
+ #define expand_tree_builtin x_tree_blt
+ #define expand_twoval_binop x_twoval
+ #define expunge_block expblk
+ #define expunge_block_nocompact expblkno
+ #define extract_bit_field extbfield
+ #define extract_constrain_insn_cached ecstrica
+ #define extract_insn einsn
+ #define extract_insn_cached einsnc
+ #define fibheap_delete fdelete
+ #define fibheap_delete_node fdelnode
+ #define fibheap_empty fempty
+ #define fibheap_extract_min femin
+ #define fibheap_insert finsert
+ #define fibheap_min fmin
+ #define fibheap_min_key fminkey
+ #define fibheap_new fnew
+ #define fibheap_replace_data frepdata
+ #define fibheap_replace_key frepkey
+ #define fibheap_replace_key_data frepkdata
+ #define fibheap_union fhunion
+ #define find_reg_equal_equiv_note fregeen
+ #define find_reg_fusage fregfus
+ #define find_reg_note fregnote
+ #define find_regno_fusage fregnfus
+ #define find_regno_note fregnono
+ #define finish_eh_generation f_ehgener
+ #define finish_enum f_enum
+ #define finish_expr_for_function f_exprff
+ #define finish_file f_file
+ #define finish_fname_decls f_fnamed
+ #define finish_function f_function
+ #define finish_incomplete_decl f_incdecl
+ #define finish_init f_init
+ #define finish_stmt_tree f_s_tree
+ #define finish_struct f_struct
+ #define flow_delete_block fdelblk
+ #define flow_delete_block_noexpunge fdelbnoexp
+ #define flow_loop_dump fldump
+ #define flow_loop_outside_edge_p flouts
+ #define flow_loop_scan flscan
+ #define flow_loops_dump flsdump
+ #define flow_loops_find flsfind
+ #define flow_loops_free flsfree
+ #define flow_loops_update flsupdate
+ #define for_each_eh_label feehlab
+ #define for_each_insn_in_loop f_e_iil
+ #define for_each_rtx f_e_rtx
+ #define for_each_successor_phi f_e_succ
+ #define force_nonfallthru fnonfal
+ #define free_after_compilation faftcomp
+ #define free_after_parsing faftpar
+ #define free_aux_for_blocks faforb
+ #define free_aux_for_edges faforedge
+ #define free_EXPR_LIST_list fEXlist
+ #define free_EXPR_LIST_node fEXnode
+ #define free_INSN_LIST_list fINlist
+ #define free_INSN_LIST_node fINnode
+ #define free_temp_slots ftempsl
+ #define free_temps_for_rtl_expr ftmpforte
+ #define function_attribute_inlinable_p fainlin
+ #define function_cannot_inline_p fcaninl
+ #define function_invariant_p finvarp
+ #define function_section fsectn
+ #define gen_abssf2 gsf2
+ #define gen_abssi2 gsi2
+ #define gen_adddf3 gdf3
+ #define gen_adddi3 gadddi3
+ #define gen_addsf3 gsf3
+ #define gen_addsi3 gsi3
+ #define gen_ashldi3 gdi3
+ #define gen_ashlhi3 ghi3
+ #define gen_ashlqi3 gqi3
+ #define gen_ashlsi3 galsi3
+ #define gen_ashrhi3 gahi3
+ #define gen_ashrqi3 gaqi3
+ #define gen_ashrsi3 gasi3
+ #define gen_call gcall
+ #define gen_call_value gcallval
+ #define gen_cmpsf gcmpsf
+ #define gen_cmpsi gcmpsi
+ #define gen_cmpstrsi gcmpssi
+ #define gen_cmpstrsi_1 gcmsi1
+ #define gen_divsf3 gdivsf3
+ #define gen_divsi3 gdifsi3
+ #define gen_extendhisi2 gesi2
+ #define gen_extendqihi2 gehi2
+ #define gen_extendqisi2 geqi2
+ #define gen_extendsfdf2 gesf2
+ #define gen_extendsidi2 gesid2
+ #define gen_highpart genhp
+ #define gen_highpart_mode genhpmod
+ #define gen_lowpart_common genlpc
+ #define gen_lowpart_if_possible g_l_i_p
+ #define gen_lowpart_SUBREG genlps
+ #define gen_lshrdi3 gldi3
+ #define gen_lshrhi3 glhi3
+ #define gen_lshrqi3 glqi3
+ #define gen_lshrsi3 glsi3
+ #define gen_movdf gmovdf
+ #define gen_movdi gmovdi
+ #define gen_movsf gmovsf
+ #define gen_movsi gmovsi
+ #define gen_movstricthi gmovthi
+ #define gen_movstrictqi gmovqi
+ #define gen_movstrsi gmovtrsi
+ #define gen_movstrsi_1 gmovt1
+ #define gen_mulsf3 gmulsf3
+ #define gen_mulsi3 gmulsi3
+ #define gen_negsf2 gnegsf2
+ #define gen_negsi2 gnegsi2
+ #define gen_one_cmplhi2 gochi2
+ #define gen_one_cmplqi2 gocqi2
+ #define gen_one_cmplsi2 cocli2
+ #define gen_rtvec genrv
+ #define gen_rtvec_v genrtv
+ #define gen_rtx_CONST_DOUBLE grcd
+ #define gen_rtx_CONST_INT grcint
+ #define gen_rtx_fmt_ grf_
+ #define gen_rtx_fmt_0 grf_0
+ #define gen_rtx_fmt_0ww grf_0ww
+ #define gen_rtx_fmt_bi grf_bi
+ #define gen_rtx_fmt_e  grfe
+ #define gen_rtx_fmt_E grfmE
+ #define gen_rtx_fmt_e0 grfme0
+ #define gen_rtx_fmt_Ee grf_Ee
+ #define gen_rtx_fmt_eE grfebige
+ #define gen_rtx_fmt_ee grfee
+ #define gen_rtx_fmt_eee greee
+ #define gen_rtx_fmt_eEee0 greE0
+ #define gen_rtx_fmt_eeeee greeee
+ #define gen_rtx_fmt_Ei grf_Ei
+ #define gen_rtx_fmt_ei grfei
+ #define gen_rtx_fmt_eit grfeit
+ #define gen_rtx_fmt_Ess grf_Es
+ #define gen_rtx_fmt_eti grfeti
+ #define gen_rtx_fmt_i grfi
+ #define gen_rtx_fmt_i0 grfmi0
+ #define gen_rtx_fmt_iE grfiE
+ #define gen_rtx_fmt_iiiiiiiitt grfiii
+ #define gen_rtx_fmt_is grfis
+ #define gen_rtx_fmt_isE grfisE
+ #define gen_rtx_fmt_iss grfiss
+ #define gen_rtx_fmt_iuu grfiuu
+ #define gen_rtx_fmt_iuu00iss grfmiss
+ #define gen_rtx_fmt_iuueiee grfiee
+ #define gen_rtx_fmt_iuueiee0 grfie0
+ #define gen_rtx_fmt_iuueieee grfiei
+ #define gen_rtx_fmt_s grf_s
+ #define gen_rtx_fmt_sE grf_sE
+ #define gen_rtx_fmt_sEss grfsEs
+ #define gen_rtx_fmt_ss grfss
+ #define gen_rtx_fmt_sse grfsse
+ #define gen_rtx_fmt_ssiEEsi grfssi
+ #define gen_rtx_fmt_u00 grfu00
+ #define gen_rtx_fmt_ue grfmue
+ #define gen_rtx_fmt_uuEiiiiiibbii grfuuE
+ #define gen_rtx_fmt_uuuu grfuuu
+ #define gen_rtx_fmt_w grfmtw
+ #define gen_rtx_MEM grmem
+ #define gen_rtx_REG grreg
+ #define gen_rtx_SUBREG grsub
+ #define gen_subsf3 gensf3
+ #define gen_truncdfsf2 gentsf2
+ #define gen_truncsihi2 genthi2
+ #define gen_tstdf gntsdf
+ #define gen_tstdi gntsdi
+ #define gen_tstsf gntssf
+ #define gen_tstsi gntssi
+ #define gen_zero_extendhisi2 gzsi2
+ #define gen_zero_extendqihi2 gzhi2
+ #define gen_zero_extendqisi2 gzqsi2
+ #define gen_zero_extendsidi2 gzei2
+ #define genrtl_case_label genclab
+ #define genrtl_compound_stmt gencstmt
+ #define genrtl_continue_stmt genconts
+ #define genrtl_decl_cleanup gendclean
+ #define genrtl_decl_stmt gendstmt
+ #define genrtl_do_pushlevel gendpush
+ #define genrtl_do_stmt gendostmt
+ #define genrtl_expr_stmt genexst
+ #define genrtl_expr_stmt_value genesval
+ #define genrtl_scope_stmt genscope
+ #define genrtl_switch_stmt genswitch
+ #define get_condition gcond
+ #define get_condition_for_loop gcondfl
+ #define get_file_function_name getffn
+ #define get_file_function_name_long getfnl
+ #define get_first_block_beg getfblbeg
+ #define get_first_nonparm_insn getfnonins
+ #define get_frame_alias_set g_f_alias
+ #define get_frame_size g_f_size
+ #define get_func_frame_size g_f_f_size
+ #define get_func_hard_reg_initial_val g_f_h_reg
+ #define get_hard_reg_initial_reg ghreinreg
+ #define get_hard_reg_initial_val ghrinival
+ #define get_identifier getident
+ #define get_identifier_with_length getiwl
+ #define get_inner_array_type g_i_arr
+ #define get_inner_reference g_i_ref
+ #define get_insn_name g_insname
+ #define get_insn_template g_ins_t
+ #define get_insns g_ins
+ #define get_label_after glabaft
+ #define get_label_before glabbef
+ #define get_last_insn glinsn
+ #define get_last_insn_anywhere gliany
+ #define get_pool_constant gpconst
+ #define get_pool_constant_for_function gpcoforf
+ #define get_pool_constant_mark gpcmark
+ #define get_pool_mode gpmode
+ #define get_pool_mode_for_function gpmform
+ #define get_pool_offset gpoffs
+ #define get_pool_size gpsize
+ #define get_set_constructor_bits getscb
+ #define get_set_constructor_bytes getsbytes
+ #define ggc_add_deletable_htab gadel
+ #define ggc_add_root garoot
+ #define ggc_add_rtx_root gartxroot
+ #define ggc_add_rtx_varray_root garvr
+ #define ggc_add_tree_hash_table_root gatht
+ #define ggc_add_tree_root gatreer
+ #define ggc_add_tree_varray_root gatvar
+ #define ggc_alloc ggcall
+ #define ggc_alloc_cleared g_allclr
+ #define ggc_alloc_string g_allstr
+ #define ggc_mark_roots gm_roots
+ #define ggc_mark_rtvec_children gm_rtvec
+ #define ggc_mark_rtx_children gm_rchild
+ #define ggc_mark_rtx_varray gm_rvarr
+ #define ggc_mark_struct_function gm_stfunc
+ #define ggc_mark_tree_hash_table gm_thasht
+ #define ggc_mark_tree_varray gmtrvar
+ #define ggc_print_common_statistics g_prcmstat
+ #define ggc_print_statistics g_prstats
+ #define groktypename gtypn
+ #define groktypename_in_parm_context gtypninpc
+ #define handle_format_arg_attribute hfmtaa
+ #define handle_format_attribute hfmtatt
+ #define hash_table_free htabfree
+ #define hash_table_init htabinit
+ #define hash_table_init_n htabnn
+ #define hook_void_bool_false hvboolf
+ #define hook_void_void hookvv
+ #define htab_find htfind
+ #define htab_find_slot htfslot
+ #define htab_find_slot_with_hash htfswhash
+ #define htab_find_with_hash htfwhash
+ #define htab_hash_string hh_string
+ #define i370_branch_dest ip_bdest
+ #define i370_branch_length ip_blen
+ #define i370_pr_checkout ip_checkout
+ #define i370_pr_map ip_map
+ #define i370_pr_skipit ip_skipit
+ #define immed_real_const irlcnst
+ #define immed_real_const_1 irlc1
+ #define immediate_operand imoperand
+ #define implicit_decl_warning impdwarn
+ #define implicitly_declare impdclr
+ #define incomplete_type_error inctyperr
+ #define indirect_operand indopr
+ #define init_alias_analysis ia_anal
+ #define init_alias_once ia_once
+ #define init_emit iniemi
+ #define init_emit_once iniemonce
+ #define init_expr initexpr
+ #define init_EXPR_INSN_LIST_cache i_ex_cache
+ #define init_expr_once initeonce
+ #define init_function_for_compilation ifuncfor
+ #define init_function_once ifunconce
+ #define init_function_start ifuncstart
+ #define init_recog irecog
+ #define init_recog_no_volatile irecnov
+ #define init_reg_sets inregsets
+ #define init_regs inregs
+ #define init_stmt istmt
+ #define init_stmt_for_function istforf
+ #define init_varasm_once ivaronce
+ #define init_varasm_status ivarstat
+ #define initialize_sizetypes i_sizety
+ #define initialize_uninitialized_subregs i_un_sub
+ #define initializer_constant_valid_p i_consvalp
+ #define insn_current_length incrlen
+ #define insn_current_reference_address incrra
+ #define integer_all_onesp intaones
+ #define integer_onep intone
+ #define integer_pow2p intp2p
+ #define integer_zerop intzerp
+ #define internal_error interror
+ #define invert_jump invjmp
+ #define invert_jump_1 invjp1
+ #define iterative_dataflow_bitmap itdfb
+ #define iterative_dataflow_sbitmap itdsb
+ #define lang_mark_tree lmrktree
+ #define lang_specific_driver lsdrver
+ #define lang_specific_pre_link lspplink
+ #define lhd_tree_dump_dump_tree lhdddtr
+ #define lhd_tree_dump_type_quals lhddtq
+ #define lhd_tree_inlining_add_pending_fn_decls lhiapd
+ #define lhd_tree_inlining_anon_aggr_type_p lhiaatp
+ #define lhd_tree_inlining_auto_var_in_fn_p lhiavip
+ #define lhd_tree_inlining_cannot_inline_tree_fn lhticit
+ #define lhd_tree_inlining_convert_parm_for_inlining lticpfi
+ #define lhd_tree_inlining_copy_res_decl_for_inlining lhicrdi
+ #define lhd_tree_inlining_disregard_inline_limits lhtidin
+ #define lhd_tree_inlining_end_inlining lhdtiei
+ #define lhd_tree_inlining_start_inlining lhtisi
+ #define lhd_tree_inlining_tree_chain_matters_p lhtitcm
+ #define lhd_tree_inlining_walk_subtrees lhtiws
+ #define lookup_label lklabel
+ #define lookup_line lkline
+ #define lookup_name lname
+ #define lookup_name_current_level lnamecl
+ #define loop_insn_emit_before li_embef
+ #define loop_insn_first_p li_firstp
+ #define loop_insn_hoist li_hoist
+ #define loop_insn_sink li_sink
+ #define loop_iv_add_mult_emit_before li_ameb
+ #define loop_iv_add_mult_hoist li_amh
+ #define loop_iv_add_mult_sink li_ams
+ #define make_decl_one_only mdoneonly
+ #define make_decl_rtl mddclrtl
+ #define make_lang_type mltype
+ #define make_tree mktre
+ #define make_tree_vec mktvec
+ #define mark_stmt_status msstat
+ #define mark_stmt_tree msttree
+ #define mark_varargs mvarargs
+ #define mark_varasm_status mvarasm
+ #define max_reg_num mxrgnm
+ #define maybe_apply_pragma_weak mapprweak
+ #define maybe_apply_renaming_pragma maprenprag
+ #define maybe_build_cleanup mbbclnup
+ #define maybe_building_objc_message_expr mbbobmexpr
+ #define maybe_objc_check_decl mobchkdecl
+ #define maybe_objc_comptypes mobcomptype
+ #define memory_address memadd
+ #define memory_address_noforce memanof
+ #define memory_address_p memadp
+ #define mergeable_constant_section mergcs
+ #define mergeable_string_section mergss
+ #define mode_for_size modfrsize
+ #define mode_for_size_tree modfrtree
+ #define modified_between_p modbetwe
+ #define modified_in_p modinp
+ #define move_block_from_reg movblkfr
+ #define move_block_to_reg mvbltoreg
+ #define mvs_add_alias mvs_aalias
+ #define mvs_add_label mvs_alabel
+ #define mvs_check_alias mvs_calias
+ #define mvs_check_label mvs_clabel
+ #define mvs_check_page mvs_cpage
+ #define named_section namsec
+ #define named_section_first_declaration namsfd
+ #define named_section_flags namsflag
+ #define next_insn nxtinsn
+ #define next_insn_tests_no_inequality nxtitni
+ #define next_nondeleted_insn nxtndel
+ #define next_nonnote_insn nxtnon
+ #define normalize_offset normoff
+ #define normalize_rli normrli
+ #define offsettable_address_p offadd
+ #define offsettable_memref_p offmem
+ #define offsettable_nonstrict_memref_p offnsmem
+ #define operand_equal_p operep
+ #define operand_subword opsubw
+ #define operand_subword_force opsubwf
+ #define optimize_inline_calls oticalls
+ #define optimize_sibling_and_tail_recursive_calls optstrc
+ #define optimize_tail_recursion opttrecurs
+ #define output_add_character oaddch
+ #define output_add_newline oaddnl
+ #define output_add_space oaddsp
+ #define output_add_string oaddstr
+ #define output_addr_const oaddrc
+ #define output_address oaddress
+ #define output_append oapp
+ #define output_asm_insn oasminsn
+ #define output_asm_label oasmlab
+ #define output_clear oclr
+ #define output_clear_message_text oclrmt
+ #define output_constant oconst
+ #define output_constant_def oconstdef
+ #define output_constant_pool oconspl
+ #define output_decimal odec
+ #define output_deferred_addressed_constants oudef
+ #define output_dependence oudep
+ #define output_destroy_prefix odestr
+ #define output_file_directive ofdirect
+ #define output_finalize_message ofinmsg
+ #define output_func_start_profiler ofstprof
+ #define output_function_exception_table ofxtable
+ #define output_is_line_wrapping oisline
+ #define output_set_maximum_length osetmaxl
+ #define output_set_prefix osetpref
+ #define output_space_left ospleft
+ #define partition_delete partdlt
+ #define partition_new partnew
+ #define partition_print partpr
+ #define partition_union partun
+ #define pedwarn_init pdwinit
+ #define pedwarn_with_decl pwwdecl
+ #define pedwarn_with_file_and_line pwwfil
+ #define pending_xref_error pendxref
+ #define pop_function_context popfcon
+ #define pop_function_context_from popfcf
+ #define pos_from_bit pfrbit
+ #define pos_from_byte pfrbyt
+ #define pre_edge_lcm prelcm
+ #define pre_edge_rev_lcm prerevlcm
+ #define predict_edge predge
+ #define predict_edge_def predgdef
+ #define predict_insn predinsn
+ #define predict_insn_def pridef
+ #define prepare_operand propernd
+ #define preserve_rtl_expr_result prsrer
+ #define preserve_temp_slots prstslots
+ #define print_node prnode
+ #define print_node_brief prnodbrief
+ #define print_rtl prrtl
+ #define print_rtl_graph_with_bb prrgwbb
+ #define print_rtl_single prsing
+ #define print_rtl_with_bb prrtlwbb
+ #define propagate_block propblk
+ #define propagate_one_insn proponei
+ #define push_function_context pushfc
+ #define push_function_context_to pushft
+ #define push_to_full_sequence ptofseq
+ #define push_to_sequence ptoseq
+ #define pushcase pcase
+ #define pushcase_range pcasrang
+ #define pushdecl pdecl
+ #define pushdecl_top_level pdecltl
+ #define put_pending_size pupsiz
+ #define put_pending_sizes pupszs
+ #define queue_and_dump_index qanddind
+ #define queue_and_dump_type qanddtyp
+ #define readonly_data_section rdodsec
+ #define readonly_fields_p rdofldsp
+ #define readonly_warning rdowarn
+ #define real_value_from_int_cst rvalfic
+ #define real_value_truncate rvaltrunc
+ #define record_base_value rbvalue
+ #define record_builtin_type rbtype
+ #define record_last_error_function reclef
+ #define record_last_error_module reclem
+ #define redirect_edge_and_branch reeabranc
+ #define redirect_edge_and_branch_force reeabfor
+ #define redirect_edge_pred redpred
+ #define redirect_edge_succ redsuc
+ #define redirect_edge_succ_nodup redsunodup
+ #define redirect_jump redirjmp
+ #define redirect_jump_1 redjp1
+ #define refers_to_mem_for_reload_p refmemr
+ #define refers_to_regno_for_reload_p refregr
+ #define reg_class_subset_p rcsubp
+ #define reg_classes_intersect_p rcintp
+ #define reg_overlap_mentioned_for_reload_p romfrp
+ #define reg_overlap_mentioned_p romp
+ #define reg_referenced_between_p rrefbet
+ #define reg_referenced_p rrefp
+ #define reg_scan rscan
+ #define reg_scan_update rscanu
+ #define reg_set_between_p regstbp
+ #define reg_set_last rsetlast
+ #define reg_set_p rsetp
+ #define regclass rclass
+ #define regclass_init rclasinit
+ #define regno_clobbered_at_setjmp regclatsj
+ #define regno_clobbered_p regclbd
+ #define reload_cse_regs rlc_rgs
+ #define remove_node_from_expr_list rmnfel
+ #define remove_note remnote
+ #define reorder_blocks reorb
+ #define reorder_insns reoinsns
+ #define reorder_insns_nobb reoinobb
+ #define reorder_insns_with_line_notes reoiwln
+ #define replace_equiv_address repeqadd
+ #define replace_equiv_address_nv repeqnv
+ #define replace_regs rregs
+ #define replace_rtx rplrtx
+ #define rest_of_compilation ro_comp
+ #define rest_of_decl_compilation ro_decl_comp
+ #define rest_of_type_compilation ro_type_comp
+ #define restore_emit_status resems
+ #define restore_line_number_status reslns
+ #define reverse_comparison revcomp
+ #define reverse_condition revcond
+ #define reverse_condition_maybe_unordered revcndmu
+ #define reversed_comparison_code revcocode
+ #define reversed_comparison_code_parts revccpart
+ #define rli_size_so_far rlissof
+ #define rli_size_unit_so_far rlisusofar
+ #define rtx_addr_can_trap_p rtadcant
+ #define rtx_addr_varies_p rtadvarp
+ #define rtx_equal_for_cselib_p refcselib
+ #define rtx_equal_p rteqp
+ #define safe_from_earlyclobber sfreclb
+ #define safe_from_p sffrmp
+ #define sbitmap_a_and_b sbaandb
+ #define sbitmap_a_and_b_or_c sbabc
+ #define sbitmap_a_or_b sbaorb
+ #define sbitmap_a_or_b_and_c sbaorbc
+ #define sbitmap_a_subset_b_p sasubbp
+ #define sbitmap_a_xor_b saxorb
+ #define sbitmap_alloc sballoc
+ #define sbitmap_copy sbcopy
+ #define sbitmap_difference sbdiff
+ #define sbitmap_equal sbequal
+ #define sbitmap_first_set_bit sbfsetbit
+ #define sbitmap_intersection_of_preds sbintpred
+ #define sbitmap_intersection_of_succs sbintsucc
+ #define sbitmap_last_set_bit sblastsb
+ #define sbitmap_not sbnot
+ #define sbitmap_ones sbones
+ #define sbitmap_union_of_diff sbundiff
+ #define sbitmap_union_of_preds sbunpreds
+ #define sbitmap_union_of_succs sbunsuccs
+ #define sbitmap_vector_alloc sbvalloc
+ #define sbitmap_vector_ones sbvones
+ #define sbitmap_vector_zero sbveczero
+ #define sbitmap_zero sbzero
+ #define scope_to_insns_finalize scptoif
+ #define scope_to_insns_initialize scptii
+ #define set_block sblock
+ #define set_block_for_insn sbfinsn
+ #define set_decl_abstract_flags sdeclabs
+ #define set_decl_origin_self sdeclorig
+ #define set_init_index setii
+ #define set_init_label setil
+ #define set_mem_alias_set smemal
+ #define set_mem_align smalig
+ #define set_mem_attributes smatt
+ #define set_mem_attributes_minus_bitpos smamb
+ #define set_mem_expr smexpr
+ #define set_mem_offset smoffs
+ #define set_mem_size smsize
+ #define set_new_first_and_last_insn snfali
+ #define set_new_last_label_num snllnum
+ #define setjmp_protect setjprot
+ #define setjmp_protect_args setjpa
+ #define shadow_tag shadtag
+ #define shadow_tag_warned shadtwarn
+ #define shorten_branches shrtbranch
+ #define shorten_compare shcmpre
+ #define simple_cst_equal scstequal
+ #define simple_cst_list_equal scstle
+ #define simplify_binary_operation sbinopt
+ #define simplify_gen_binary sgbin
+ #define simplify_gen_relational sgrelat
+ #define simplify_gen_subreg sgensub
+ #define simplify_gen_ternary sgtern
+ #define simplify_gen_unary sgenunry
+ #define simplify_relational_operation sreloper
+ #define simplify_replace_rtx sreprtx
+ #define simplify_rtx sfyrtx
+ #define simplify_subreg ssubreg
+ #define simplify_subtraction sfysubtr
+ #define simplify_ternary_operation sternop
+ #define simplify_unary_operation sunaryop
+ #define size_int_type_wide szitw
+ #define size_int_wide szintw
+ #define size_of_encoded_value sofencv
+ #define size_of_sleb128 sofsleb
+ #define size_of_uleb128 sofuleb
+ #define splay_tree_compare_ints stcmints
+ #define splay_tree_compare_pointers stcmptrs
+ #define splay_tree_delete stdelete
+ #define splay_tree_foreach stfeach
+ #define splay_tree_insert stins
+ #define splay_tree_lookup stlook
+ #define splay_tree_max stmax
+ #define splay_tree_min stmin
+ #define splay_tree_new stnew
+ #define splay_tree_new_with_allocator stnewwal
+ #define splay_tree_predecessor stpred
+ #define splay_tree_remove strem
+ #define splay_tree_successor stsucc
+ #define split_all_insns spltains
+ #define split_all_insns_noflow spltnof
+ #define stabilize_reference stabref
+ #define stabilize_reference_1 stabrf1
+ #define start_sequence sseque
+ #define start_sequence_for_rtl_expr ssqfre
+ #define std_expand_builtin_va_arg stdevarg
+ #define std_expand_builtin_va_start stdevstart
+ #define string_compare strcomp
+ #define string_copy strcopy
+ #define subreg_hard_regno subhrn
+ #define subreg_highpart_offset subhoff
+ #define subreg_lowpart_offset slopoff
+ #define subreg_lowpart_p slopp
+ #define subreg_realpart_p sr_rp_p
+ #define subreg_regno sregno
+ #define subreg_regno_offset sr_r_o
+ #define target_isinf tgtisinf
+ #define target_isnan tgtisnan
+ #define tidy_fallthru_edge tidyfe
+ #define tidy_fallthru_edges tidfedg
+ #define timevar_get tvget
+ #define timevar_pop tvpop
+ #define timevar_print tvprint
+ #define timevar_push tvpush
+ #define timevar_start tfstart
+ #define timevar_stop tvstop
+ #define tree_int_cst_compare ticstcc
+ #define tree_int_cst_equal ticste
+ #define tree_int_cst_lt ticstlt
+ #define tree_int_cst_msb ticstmsb
+ #define tree_int_cst_sgn ticstsgn
+ #define type_for_mode typfmod
+ #define type_for_size typfsize
+ #define type_hash_add th_add
+ #define type_hash_canon th_canon
+ #define type_hash_list th_list
+ #define type_hash_lookup th_look
+ #define unsave_expr unsexp
+ #define unsave_expr_1 unsxp1
+ #define unsave_expr_now unsxnow
+ #define unshare_all_rtl unsartl
+ #define unshare_all_rtl_again unsara
+ #define unsigned_condition unscond
+ #define unsigned_conversion_warning ucwarn
+ #define unsigned_type untype
+ #define update_bb_for_insn upbbfor
+ #define update_br_prob_note upbprob
+ #define validate_change valchange
+ #define validate_replace_rtx valrrtx
+ #define validate_replace_rtx_group valrtg
+ #define validate_replace_rtx_subexp valrts
+ #define validate_replace_src valrsc
+ #define variable_section varsec
+ #define variable_size varsize
+ #define volatile_insn_p volinsp
+ #define volatile_refs_p volrefp
+ #define walk_tree wlktree
+ #define walk_tree_without_duplicates wlktwd
+ #define warn_deprecated_use wrndepus
+ #define warning_with_decl warnwdecl
+ #define warning_with_file_and_line warnwfl
+ #define xmalloc_failed xmalfail
+ #define xmalloc_set_program_name xmalspgn
+ 
+ 
+ /* External variable redefines */
+ 
+ #define align_functions alfuncs
+ #define align_functions_log alfunlog
+ #define align_jumps aljump
+ #define align_jumps_log aljmpl
+ #define align_jumps_max_skip aljmpms
+ #define align_labels allab
+ #define align_labels_log allabl
+ #define align_labels_max_skip allabms
+ #define align_loops alloop
+ #define align_loops_log allopl
+ #define align_loops_max_skip allopms
+ #define basic_block_for_insn bbforin
+ #define basic_block_info bbinfo
+ #define built_in_class_names bi_class
+ #define built_in_decls bi_decls
+ #define built_in_names bi_names
+ #define call_fixed_reg_set cfixregset
+ #define call_fixed_regs cfixrgs
+ #define call_used_reg_set cusdrs
+ #define call_used_regs cusdregs
+ #define const_int_rtx cirtx
+ #define constructor_no_implicit ctr_noim
+ #define constructor_range_stack ctr_rang
+ #define constructor_stack ctr_stk
+ #define cpp_GCC_INCLUDE_DIR cppgdir
+ #define cpp_GCC_INCLUDE_DIR_len cppgdlen
+ #define cpp_include_defaults cpidefls
+ #define current_funcdef_number crtfdnum
+ #define current_function_decl cf_decl
+ #define current_function_func_begin_label cffbl
+ #define current_function_is_leaf curfisleaf
+ #define current_function_nothrow curfnothrow
+ #define current_function_returns_abnormally cf_rabn
+ #define current_function_returns_null cf_rnull
+ #define current_function_returns_value cf_rval
+ #define current_function_sp_is_unchanging curfspunch
+ #define current_function_uses_only_leaf_regs curfuolr
+ #define current_output_insn coutinsn
+ #define diagnostic_buffer diagbuf
+ #define fixed_reg_set fregset
+ #define fixed_regs fregs
+ #define flag_bounded_pointers fbpoint
+ #define flag_bounds_check fbcheck
+ #define flag_branch_on_count_reg fbocr
+ #define flag_branch_probabilities fbprob
+ #define flag_cond_mismatch fc_mism
+ #define flag_const_strings fc_str
+ #define flag_cse_follow_jumps fcfjump
+ #define flag_cse_skip_blocks fcskip
+ #define flag_dump_rtl_in_asm flgdrtl
+ #define flag_dump_unnumbered flgdmpun
+ #define flag_force_addr ffaddr
+ #define flag_force_mem ffmem
+ #define flag_gcse_lm fgclm
+ #define flag_gcse_sm fgcsm
+ #define flag_inline_functions flinfncs
+ #define flag_inline_trees flintrs
+ #define flag_isoc94 f_i94
+ #define flag_isoc99 f_i99
+ #define flag_keep_inline_functions fkinf
+ #define flag_keep_static_consts fksconst
+ #define flag_no_builtin fnobuilt
+ #define flag_no_common fnocom
+ #define flag_no_function_cse fnofcse
+ #define flag_no_ident fnoind
+ #define flag_no_inline fnoinl
+ #define flag_no_nonansi_builtin fnononab
+ #define flag_no_peephole fnopeep
+ #define flag_non_call_exceptions flncalxcpt
+ #define flag_noniso_default_format_attributes flnisodef
+ #define flag_prefetch_loop_arrays fprefl
+ #define flag_pretend_float fpretf
+ #define flag_rename_registers frenreg
+ #define flag_renumber_insns freumin
+ #define flag_schedule_insns fsinsn
+ #define flag_schedule_insns_after_reload fsciar
+ #define flag_schedule_interblock fsiblk
+ #define flag_schedule_speculative fsspec
+ #define flag_schedule_speculative_load fsspcl
+ #define flag_schedule_speculative_load_dangerous fspcld
+ #define flag_short_double fshdouble
+ #define flag_short_wchar fshwchar
+ #define flag_signed_bitfields flsbitf
+ #define flag_signed_char flschr
+ #define flag_ssa fssa
+ #define flag_ssa_ccp fssaccp
+ #define flag_ssa_dce fssadce
+ #define flag_strength_reduce fsreduce
+ #define flag_strict_aliasing fstralias
+ #define flag_trapping_math ftrapmath
+ #define flag_trapv ftrapv
+ #define flag_unroll_all_loops funraloop
+ #define flag_unroll_loops funrloop
+ #define flag_volatile fvolat
+ #define flag_volatile_global fvolglob
+ #define flag_volatile_static fvolstat
+ #define float_handled flhled
+ #define float_handler flhler
+ #define g_switch_set gswset
+ #define g_switch_value gswvue
+ #define global_regs glbrgs
+ #define global_rtl glbrtl
+ #define htab_hash_pointer hh_point
+ #define immediate_size_expand imszexp
+ #define incomplete_decl_finalize_hook incdecfinh
+ #define indirect_symref_ok indsym
+ #define input_file_stack infstk
+ #define input_file_stack_tick infstick
+ #define input_filename inpfname
+ #define input_filename_length infpflen
+ #define insn_current_address incradd
+ #define insn_current_align incral
+ #define integer_types inttys
+ #define lang_attribute_common lacommon
+ #define lang_eh_runtime_type leruntype
+ #define lang_eh_type_covers letypcov
+ #define lang_expand_decl_stmt le_decl
+ #define lang_expand_expr leexpr
+ #define lang_expand_function_end lefend
+ #define lang_expand_stmt le_stmt
+ #define lang_mark_false_label_stack lmflselabst
+ #define lang_unsafe_for_reeval lunsfre
+ #define lang_unsave lunsav
+ #define lang_unsave_expr_now lunsen
+ #define libiberty_len libty_len
+ #define libiberty_nptr libty_nptr
+ #define libiberty_optr libty_optr
+ #define make_lang_type_fn mltypfn
+ #define max_reg_before_loop mxrgbl
+ #define mvs_function_name mf_name
+ #define mvs_function_name_length mf_nlen
+ #define mvs_need_base_reload mn_base
+ #define mvs_need_entry mn_entry
+ #define mvs_need_to_globalize mn_toglob
+ #define mvs_page_code mp_code
+ #define mvs_page_lit mp_lit
+ #define mvs_page_num mp_num
+ #define obstack_alloc_failed_handler os_failh
+ #define obstack_exit_failure os_exitf
+ #define optimize optze
+ #define optimize_size optzsz
+ #define pedantic pednt
+ #define pedantic_lvalues pedntlv
+ #define pending_invalid_xref pinvx
+ #define pending_invalid_xref_file pinvxf
+ #define pending_invalid_xref_line pinvxl
+ #define profile_arc_flag profaflag
+ #define profile_flag profflag
+ #define reg_class_contents rclconts
+ #define reg_class_size rcsize
+ #define reg_class_subclasses rcsubc
+ #define reg_class_subunion rcsubu
+ #define reg_class_superclasses rcsuper
+ #define reg_class_superunion rcsupun
+ #define reg_equiv_address regea
+ #define reg_equiv_constant regec
+ #define reg_equiv_mem regemem
+ #define reg_equiv_memory_loc regemloc
+ #define reg_known_equiv_p rke_p
+ #define reload_completed rl_comp
+ #define reload_first_uid rl_fuid
+ #define reload_firstobj rl_fobj
+ #define reload_in_optab rl_iopt
+ #define reload_in_progress rlinprog
+ #define reload_inheritance_insn rlininsn
+ #define reload_inherited rl_inh
+ #define reload_insn_chain rl_inch
+ #define reload_obstack rl_obst
+ #define reload_out_optab rl_oopt
+ #define reload_override_in rl_ovin
+ #define reload_spill_index rl_spind
+ #define reload_startobj rl_start
+ #define rtl_dump_and_exit rtdande
+ #define rtl_dump_file rtdfile
+ #define save_argc savac
+ #define save_argv savav
+ #define ssa_rename_from ssarfrom
+ #define ssa_rename_from_ht ssafht
+ #define static_chain_incoming_rtx scincrtx
+ #define static_chain_rtx stcrtx
+ #define struct_value_incoming_rtx svincrtx
+ #define struct_value_rtx svrtx
+ #define tree_code_length tcodlen
+ #define tree_code_name tcodname
+ #define tree_code_type tcodtype
+ #define tree_node_counts tn_counts
+ #define tree_node_sizes tn_size
+ #define warn_cast_align wcalign
+ #define warn_cast_qual wcqual
+ #define warn_deprecated_decl wrnddecl
+ #define warn_format wfmt
+ #define warn_format_extra_args wf_exta
+ #define warn_format_nonliteral wf_nonl
+ #define warn_format_security wf_sec
+ #define warn_format_y2k wf_y2k
+ #define warn_missing_braces wm_brac
+ #define warn_missing_declarations wm_decl
+ #define warn_missing_format_attribute wm_fa
+ #define warn_missing_noreturn wm_noret
+ #define warn_missing_prototypes wm_prot
+ #define warn_unused_function wun_func
+ #define warn_unused_parameter wun_parm
+ #define warn_unused_value wu_val
+ #define warn_unused_variable wu_var
+ 
+ 
+ /* Stuff in generator files */
+ 
+ #define debug_decision d_decision
+ #define debug_decision_list dd_list
+ #define init_md_reader im_reader
+ #define init_md_reader_args imr_args
+ #define read_rtx_filename rrtxfile
+ #define read_rtx_lineno rrtxlin
Index: gcc/gcc/config/i370/mvs.h
diff -c gcc/gcc/config/i370/mvs.h:1.1.1.1 gcc/gcc/config/i370/mvs.h:1.3
*** gcc/gcc/config/i370/mvs.h:1.1.1.1	Wed Feb 15 21:22:45 2006
--- gcc/gcc/config/i370/mvs.h	Fri Nov 03 16:15:23 2006
***************
*** 20,26 ****
  the Free Software Foundation, 59 Temple Place - Suite 330,
  Boston, MA 02111-1307, USA.  */
  
! #define TARGET_VERSION printf (" (370/MVS)");
  
  /* Specify that we're generating code for the Language Environment */
  
--- 20,26 ----
  the Free Software Foundation, 59 Temple Place - Suite 330,
  Boston, MA 02111-1307, USA.  */
  
! #define TARGET_VERSION fprintf (stderr, " (370/MVS)");
  
  /* Specify that we're generating code for the Language Environment */
  
Index: gcc/gcc/config/i370/mvs38_dignus.h
diff -c nul gcc/gcc/config/i370/mvs38_dignus.h:1.1.3.1
*** nul	Tue Oct 01 16:28:50 2019
--- gcc/gcc/config/i370/mvs38_dignus.h	Fri Nov 03 11:47:12 2006
***************
*** 0 ****
--- 1,48 ----
+ /* Definitions of target machine for GNU compiler.  System/370 version.
+    Copyright (C) 1989, 1993, 1995, 1996, 1997 Free Software Foundation, Inc.
+    Contributed by Jan Stein (jan@cd.chalmers.se).
+    Modified for OS/390 LanguageEnvironment C by Dave Pitts (dpitts@cozx.com)
+ 
+ This file is part of GNU CC.
+ 
+ GNU CC is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2, or (at your option)
+ any later version.
+ 
+ GNU CC is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+ 
+ You should have received a copy of the GNU General Public License
+ along with GNU CC; see the file COPYING.  If not, write to
+ the Free Software Foundation, 59 Temple Place - Suite 330,
+ Boston, MA 02111-1307, USA.  */
+ 
+ #define TARGET_VERSION fprintf (stderr, " (370/MVS38)");
+ 
+ /* Specify that we're generating code for MVS.  */
+ 
+ #define TARGET_MVS 1
+ #define TARGET_HLASM 1
+ #define TARGET_EBCDIC 1
+ 
+ /* Specify that we're using the Dignus runtime library.  */
+ 
+ #define TARGET_DIGNUS 1
+ #define STARTFILE_SPEC ""
+ 
+ /* Specify that we're using macro prolog/epilog.  */
+ 
+ #define TARGET_MACROS 1
+ 
+ /* Options for the preprocessor for this target machine.  */
+ 
+ #define CPP_SPEC "-trigraphs"
+ 
+ /* Names to predefine in the preprocessor for this target machine.  */
+ 
+ #define CPP_PREDEFINES "-DGCC -Dgcc -DMVS -Dmvs -DDIGNUS -Asystem=mvs -Acpu=i370 -Amachine=i370"
+ 
+ 
Index: gcc/gcc/config/i370/mvsdignus.h
diff -c nul gcc/gcc/config/i370/mvsdignus.h:1.3
*** nul	Tue Oct 01 16:28:50 2019
--- gcc/gcc/config/i370/mvsdignus.h	Fri Nov 03 16:15:23 2006
***************
*** 0 ****
--- 1,49 ----
+ /* Definitions of target machine for GNU compiler.  System/370 version.
+    Copyright (C) 1989, 1993, 1995, 1996, 1997 Free Software Foundation, Inc.
+    Contributed by Jan Stein (jan@cd.chalmers.se).
+    Modified for OS/390 LanguageEnvironment C by Dave Pitts (dpitts@cozx.com)
+ 
+ This file is part of GNU CC.
+ 
+ GNU CC is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2, or (at your option)
+ any later version.
+ 
+ GNU CC is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+ 
+ You should have received a copy of the GNU General Public License
+ along with GNU CC; see the file COPYING.  If not, write to
+ the Free Software Foundation, 59 Temple Place - Suite 330,
+ Boston, MA 02111-1307, USA.  */
+ 
+ #define TARGET_VERSION fprintf (stderr, " (370/MVS-DIGNUS)");
+ 
+ /* Specify that we're generating code for MVS.  */
+ 
+ #define TARGET_MVS 1
+ #define TARGET_HLASM 1
+ #define TARGET_EBCDIC 1
+ #define TARGET_ALIASES 1
+ 
+ /* Specify that we're using the Dignus runtime library.  */
+ 
+ #define TARGET_DIGNUS 1
+ 
+ /* Specify that we're using macro prolog/epilog.  */
+ 
+ #define TARGET_MACROS 1
+ 
+ /* Options for the preprocessor for this target machine.  */
+ 
+ #define CPP_SPEC "-trigraphs"
+ #define STARTFILE_SPEC ""
+ 
+ /* Names to predefine in the preprocessor for this target machine.  */
+ 
+ #define CPP_PREDEFINES "-DGCC -Dgcc -DMVS -Dmvs -DDIGNUS -Asystem=mvs -Acpu=i370 -Amachine=i370"
+ 
+ 
Index: gcc/gcc/config/i370/mvsle.h
diff -c nul gcc/gcc/config/i370/mvsle.h:1.1
*** nul	Tue Oct 01 16:28:50 2019
--- gcc/gcc/config/i370/mvsle.h	Wed Feb 15 21:25:44 2006
***************
*** 0 ****
--- 1,49 ----
+ /* Definitions of target machine for GNU compiler.  System/370 version.
+    Copyright (C) 1989, 1993, 1995, 1996, 1997 Free Software Foundation, Inc.
+    Contributed by Jan Stein (jan@cd.chalmers.se).
+    Modified for OS/390 LanguageEnvironment C by Dave Pitts (dpitts@cozx.com)
+ 
+ This file is part of GNU CC.
+ 
+ GNU CC is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2, or (at your option)
+ any later version.
+ 
+ GNU CC is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+ 
+ You should have received a copy of the GNU General Public License
+ along with GNU CC; see the file COPYING.  If not, write to
+ the Free Software Foundation, 59 Temple Place - Suite 330,
+ Boston, MA 02111-1307, USA.  */
+ 
+ #define TARGET_VERSION fprintf (stderr, " (370/MVS-LE)");
+ 
+ /* Specify that we're generating code for MVS.  */
+ 
+ #define TARGET_MVS 1
+ #define TARGET_HLASM 1
+ #define TARGET_EBCDIC 1
+ #define TARGET_ALIASES 1
+ 
+ /* Specify that we're using the Language Environment runtime.  */
+ 
+ #define TARGET_LE 1
+ 
+ /* Specify that we're using macro prolog/epilog.  */
+ 
+ /*#define TARGET_MACROS 1*/
+ 
+ /* Options for the preprocessor for this target machine.  */
+ 
+ #define CPP_SPEC "-trigraphs"
+ #define STARTFILE_SPEC ""
+ 
+ /* Names to predefine in the preprocessor for this target machine.  */
+ 
+ #define CPP_PREDEFINES "-DGCC -Dgcc -DMVS -Dmvs -DLE370 -Asystem=mvs -Acpu=i370 -Amachine=i370"
+ 
+ 
Index: gcc/gcc/config/i370/mvspdp.h
diff -c nul gcc/gcc/config/i370/mvspdp.h:1.3
*** nul	Tue Oct 01 16:28:50 2019
--- gcc/gcc/config/i370/mvspdp.h	Sat Oct 15 17:41:46 2016
***************
*** 0 ****
--- 1,52 ----
+ /* Definitions of target machine for GNU compiler.  System/370 version.
+    Copyright (C) 1989, 1993, 1995, 1996, 1997 Free Software Foundation, Inc.
+    Contributed by Jan Stein (jan@cd.chalmers.se).
+    Modified for OS/390 LanguageEnvironment C by Dave Pitts (dpitts@cozx.com)
+    Modified for use with PDPCLIB by Paul Edwards.
+ 
+ This file is part of GNU CC.
+ 
+ GNU CC is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2, or (at your option)
+ any later version.
+ 
+ GNU CC is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+ 
+ You should have received a copy of the GNU General Public License
+ along with GNU CC; see the file COPYING.  If not, write to
+ the Free Software Foundation, 59 Temple Place - Suite 330,
+ Boston, MA 02111-1307, USA.  */
+ 
+ #define TARGET_VERSION fprintf (stderr, " (370/MVS)");
+ 
+ /* Specify that we're generating code for MVS.  */
+ 
+ #define TARGET_MVS 1
+ #define TARGET_HLASM 1
+ #define TARGET_EBCDIC 1
+ 
+ /* Specify that we're using the PDP macros */
+ 
+ #define TARGET_PDPMAC 1
+ #define STARTFILE_SPEC ""
+ 
+ /* Specify that we're using macro prolog/epilog.  */
+ 
+ #define TARGET_MACROS 1
+ 
+ /* Options for the preprocessor for this target machine.  */
+ 
+ #define CPP_SPEC "-trigraphs"
+ 
+ /* Names to predefine in the preprocessor for this target machine.  */
+ 
+ #define CPP_PREDEFINES "-D__GCC__ -D__MVS__ -Asystem=mvs -Acpu=i370 -Amachine=i370"
+ 
+ 
+ #ifdef PUREISO
+ #include "pureiso.h"
+ #endif
Index: gcc/gcc/config/i370/oe.h
diff -c gcc/gcc/config/i370/oe.h:1.1.1.1 gcc/gcc/config/i370/oe.h:1.2
*** gcc/gcc/config/i370/oe.h:1.1.1.1	Wed Feb 15 21:22:45 2006
--- gcc/gcc/config/i370/oe.h	Wed Feb 15 21:24:30 2006
***************
*** 20,33 ****
  the Free Software Foundation, 59 Temple Place - Suite 330,
  Boston, MA 02111-1307, USA.  */
  
! #define TARGET_VERSION printf (" (370/OpenEdition)");
  
! /* Specify that we're generating code for the Language Environment */
  
! #define LE370 1
! #define LONGEXTERNAL 1
! #define TARGET_EBCDIC 1
  #define TARGET_HLASM 1
  
  /* Options for the preprocessor for this target machine.  */
  
--- 20,41 ----
  the Free Software Foundation, 59 Temple Place - Suite 330,
  Boston, MA 02111-1307, USA.  */
  
! #define TARGET_VERSION fprintf (stderr, " (370/OpenEdition)");
  
! /* Specify that we're generating code for OpenEdition.  */
  
! #define TARGET_OE 1
  #define TARGET_HLASM 1
+ #define TARGET_EBCDIC 1
+ #define TARGET_ALIASES 1
+ 
+ /* Specify that we're using the Language Environment runtime.  */
+ 
+ #define TARGET_LE 1
+ 
+ /* Specify that we're using macro prolog/epilog.  */
+ 
+ /*#define TARGET_MACROS 1*/
  
  /* Options for the preprocessor for this target machine.  */
  
***************
*** 41,49 ****
  
  /* Names to predefine in the preprocessor for this target machine.  */
  
! #define CPP_PREDEFINES "-DGCC -Dgcc -DUNIX -Dunix -Dopenedition -D__i370__ -Asystem=openedition -Asystem=unix -Acpu=i370 -Amachine=i370"
! 
! /* Include system common definitions */
! 
! #include "config/i370/i370.h"
  
--- 49,53 ----
  
  /* Names to predefine in the preprocessor for this target machine.  */
  
! #define CPP_PREDEFINES "-DGCC -Dgcc -DUNIX -Dunix -Dopenedition -D__i370__ -DLE370 -Asystem=openedition -Asystem=unix -Acpu=i370 -Amachine=i370"
  
Index: gcc/gcc/config/i370/onecomp.bat
diff -c nul gcc/gcc/config/i370/onecomp.bat:1.1
*** nul	Tue Oct 01 16:28:50 2019
--- gcc/gcc/config/i370/onecomp.bat	Fri Mar 31 19:51:35 2017
***************
*** 0 ****
--- 1,10 ----
+ rem this should be run in a directory under config/i370
+ copy ..\..\..\testsuite\gcc.c-torture\execute\%1 cprog.c
+ call mvsgccr cprog.c output.txt
+ grep "EXECC     CPROG     RC= 0000" output.txt
+ if errorlevel 1 goto bad
+ echo %1 passed >>results.txt
+ goto exit
+ :bad
+ echo %1 failed >>results.txt
+ :exit
Index: gcc/gcc/config/i370/oneconly.bat
diff -c nul gcc/gcc/config/i370/oneconly.bat:1.2
*** nul	Tue Oct 01 16:28:50 2019
--- gcc/gcc/config/i370/oneconly.bat	Sat Apr 01 19:08:19 2017
***************
*** 0 ****
--- 1,19 ----
+ rem this should be run in a directory under config/i370
+ copy ..\..\..\testsuite\gcc.c-torture\compile\%1 cprog.c
+ call mvsgcc cprog.c cprog.s output.txt
+ 
+ grep "COMP      GCC       RC= 0000" output.txt
+ if errorlevel 1 goto bad
+ echo %1 passed >>resconly.txt
+ goto exit
+ 
+ :bad
+ grep "COMP      GCC       RC= 0004" output.txt
+ if errorlevel 1 goto bad2
+ echo %1 passed >>resconly.txt
+ goto exit
+ 
+ :bad2
+ echo %1 failed >>resconly.txt
+ 
+ :exit
Index: gcc/gcc/config/i370/pureiso.h
diff -c nul gcc/gcc/config/i370/pureiso.h:1.17
*** nul	Tue Oct 01 16:28:50 2019
--- gcc/gcc/config/i370/pureiso.h	Tue Dec 14 01:38:52 2010
***************
*** 0 ****
--- 1,174 ----
+ /* things that are required to compile in a pure
+    ISO environment. */
+ 
+ #if defined(__MVS__) || defined(__CMS__) || defined(__VSE__)
+ #include "xm-mvs.h"
+ #endif
+ 
+ #include <stdio.h>
+ #include <stdlib.h>
+ #include <time.h>
+ #include <string.h>
+ #include <errno.h>
+ #include <stdarg.h>
+ 
+ #ifndef NO_DETAB
+ #define fputs t_fputs
+ #define fprintf t_fprintf
+ #define vfprintf t_vfprintf
+ #define fwrite t_fwrite
+ #define fputc t_fputc
+ #undef putc
+ #define putc t_fputc
+ 
+ int t_fputs (const char *str, FILE *file);
+ int t_fprintf (FILE *file, const char *format, ...);
+ int t_vfprintf (FILE *file, const char *format, va_list arg);
+ size_t t_fwrite (const void *ptr, size_t size, size_t nmemb, FILE *file);
+ int t_fputc (int c, FILE *file);
+ #endif
+ 
+ #include "unixio.h"
+ 
+ #define SINGLE_EXECUTABLE 1
+ #define ANSI_PROTOTYPES 1
+ #define PARAMS(ARGS) ARGS
+ #define PTR void *
+ 
+ #define DEFAULT_TARGET_VERSION "1.1"
+ #define DEFAULT_TARGET_MACHINE "i370"
+ #define PREFIX ""
+ #define TARGET_EBCDIC 1
+ #define TARGET_NAME "mvs"
+ 
+ #define USE_SHORT_NAMES 1
+ /* now redefine all functions that are too long
+    to handle on MVS, before anyone tries to start
+    using them. */
+ #if USE_SHORT_NAMES
+ #include "mshort.h"
+ #endif
+ 
+ /* unfortunately toplev.c doesn't compile with IFOX
+    because there are more than 399 external references.
+    You get an error message like this:
+    IFO264      TOO MANY ESD ENTRIES
+    To combat this problem, we index into an array
+    instead. */
+ /*#define IFOX 1*/
+ #if IFOX
+ #undef flag_test_coverage
+ #undef flag_branch_probabilities
+ #undef flag_reorder_blocks
+ #undef flag_rename_registers
+ #undef flag_cprop_registers
+ #undef flag_force_mem
+ #undef flag_force_addr
+ #undef flag_defer_pop
+ #undef flag_float_store
+ #undef flag_cse_follow_jumps
+ #undef flag_cse_skip_blocks
+ #undef flag_expensive_optimizations
+ #undef flag_thread_jumps
+ #undef flag_strength_reduce
+ #undef flag_unroll_loops
+ #undef flag_unroll_all_loops
+ #undef flag_prefetch_loop_arrays
+ #undef flag_move_all_movables
+ #undef flag_reduce_all_givs
+ #undef flag_regmove
+ #undef flag_writable_strings
+ #undef flag_no_function_cse
+ #undef flag_omit_frame_pointer
+ #undef flag_function_sections
+ #undef flag_data_sections
+ #undef flag_no_peephole
+ #undef flag_optimize_sibling_calls
+ #undef flag_complex_divide_method
+ #undef flag_volatile
+ #undef flag_volatile_global
+ #undef flag_volatile_static
+ #undef flag_syntax_only
+ #define flag_test_coverage gflags[0]
+ #define flag_branch_probabilities gflags[1]
+ #define flag_reorder_blocks gflags[2]
+ #define flag_rename_registers gflags[3]
+ #define flag_cprop_registers gflags[4]
+ #define flag_force_mem gflags[5]
+ #define flag_force_addr gflags[6]
+ #define flag_defer_pop gflags[7]
+ #define flag_float_store gflags[8]
+ #define flag_cse_follow_jumps gflags[9]
+ #define flag_cse_skip_blocks gflags[10]
+ #define flag_expensive_optimizations gflags[11]
+ #define flag_thread_jumps gflags[12]
+ #define flag_strength_reduce gflags[13]
+ #define flag_unroll_loops gflags[14]
+ #define flag_unroll_all_loops gflags[15]
+ #define flag_prefetch_loop_arrays gflags[16]
+ #define flag_move_all_movables gflags[17]
+ #define flag_reduce_all_givs gflags[18]
+ #define flag_regmove gflags[19]
+ #define flag_writable_strings gflags[20]
+ #define flag_no_function_cse gflags[21]
+ #define flag_omit_frame_pointer gflags[22]
+ #define flag_function_sections gflags[23]
+ #define flag_data_sections gflags[24]
+ #define flag_no_peephole gflags[25]
+ #define flag_optimize_sibling_calls gflags[26]
+ #define flag_complex_divide_method gflags[27]
+ #define flag_volatile gflags[28]
+ #define flag_volatile_global gflags[29]
+ #define flag_volatile_static gflags[30]
+ #define flag_syntax_only gflags[31]
+ #endif
+ 
+ /* we define this in order to get consistent results
+    regardless of whether using gcc or non-gcc compiler */
+ #define GCC_VERSION 0
+ #include "ansidecl.h"
+ 
+ #include "i370.h"
+ #include "defaults.h"
+ 
+ #include "auto-host.h"
+ 
+ /* Provide three core typedefs used by everything, if we are compiling
+    GCC.  These used to be found in rtl.h and tree.h, but this is no
+    longer practical.  Providing these here rather that system.h allows
+    the typedefs to be used everywhere within GCC. */
+ #ifndef RTX_FORWARD
+ #define RTX_FORWARD 1
+ struct rtx_def;
+ typedef struct rtx_def *rtx;
+ struct rtvec_def;
+ typedef struct rtvec_def *rtvec;
+ union tree_node;
+ typedef union tree_node *tree;
+ #endif
+ 
+ #include "libiberty.h"
+ 
+ /* override some of libiberty's stuff with our own */
+ #if defined(__MVS__) || defined(__CMS__) || defined(__VSE__)
+ #define make_temp_file(a) "DD:WORK"
+ #else
+ #define make_temp_file(a) tmpnam(NULL)
+ #endif
+ #define pwait(a,b,c) (0)
+ 
+ #ifndef POSIX
+ #define POSIX
+ #endif
+ 
+ #ifndef GENERATOR_FILE
+ # include "insn-constants.h"
+ # include "insn-flags.h"
+ #endif
+ 
+ #include "system.h"
+ 
+ #include "machmode.h"
+ #include "real.h"
+ 
+ #define getpwd() ""
Index: gcc/gcc/config/i370/showres.bat
diff -c nul gcc/gcc/config/i370/showres.bat:1.2
*** nul	Tue Oct 01 16:28:50 2019
--- gcc/gcc/config/i370/showres.bat	Sat Apr 01 02:31:05 2017
***************
*** 0 ****
--- 1,5 ----
+ grep passed results.txt | wc
+ grep failed results.txt | wc
+ 
+ grep passed resconly.txt | wc
+ grep failed resconly.txt | wc
Index: gcc/gcc/config/i370/t-mvs
diff -c nul gcc/gcc/config/i370/t-mvs:1.1
*** nul	Tue Oct 01 16:28:50 2019
--- gcc/gcc/config/i370/t-mvs	Wed Feb 15 21:25:44 2006
***************
*** 0 ****
--- 1,7 ----
+ #
+ # Target is an i370 running MVS (OS/390)
+ #
+ 
+ # Don't bother making libgcc, we don't use it.
+ LIBGCC =
+ INSTALL_LIBGCC =
Index: gcc/gcc/config/i370/t-oe
diff -c gcc/gcc/config/i370/t-oe:1.1.1.1 gcc/gcc/config/i370/t-oe:1.3
*** gcc/gcc/config/i370/t-oe:1.1.1.1	Wed Feb 15 21:22:45 2006
--- gcc/gcc/config/i370/t-oe	Fri Nov 03 16:15:23 2006
***************
*** 2,6 ****
  # Target is an i370 running OpenEdition
  #
  
! # Don't bother fixing up header files, they're weird
  STMP_FIXPROTO =
--- 2,10 ----
  # Target is an i370 running OpenEdition
  #
  
! # Don't run fixproto
  STMP_FIXPROTO =
+ 
+ # Don't bother making libgcc, we don't use it.
+ LIBGCC =
+ INSTALL_LIBGCC =
Index: gcc/gcc/config/i370/vse.h
diff -c nul gcc/gcc/config/i370/vse.h:1.2
*** nul	Tue Oct 01 16:28:50 2019
--- gcc/gcc/config/i370/vse.h	Sat Oct 15 17:41:47 2016
***************
*** 0 ****
--- 1,51 ----
+ /* Definitions of target machine for GNU compiler.  System/370 version.
+    Copyright (C) 1989, 1993, 1995, 1996, 1997 Free Software Foundation, Inc.
+    Contributed by Jan Stein (jan@cd.chalmers.se).
+    Modified for DOS/VSE by Paul Edwards.
+ 
+ This file is part of GNU CC.
+ 
+ GNU CC is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2, or (at your option)
+ any later version.
+ 
+ GNU CC is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+ 
+ You should have received a copy of the GNU General Public License
+ along with GNU CC; see the file COPYING.  If not, write to
+ the Free Software Foundation, 59 Temple Place - Suite 330,
+ Boston, MA 02111-1307, USA.  */
+ 
+ #define TARGET_VERSION fprintf (stderr, " (370/VSE)");
+ 
+ /* Specify that we're generating code for MVS.  */
+ 
+ #define TARGET_MVS 1
+ #define TARGET_HLASM 1
+ #define TARGET_EBCDIC 1
+ 
+ /* Specify that we're using the GCC macros */
+ 
+ #define TARGET_PDPMAC 1
+ #define STARTFILE_SPEC ""
+ 
+ /* Specify that we're using macro prolog/epilog.  */
+ 
+ #define TARGET_MACROS 1
+ 
+ /* Options for the preprocessor for this target machine.  */
+ 
+ #define CPP_SPEC "-trigraphs"
+ 
+ /* Names to predefine in the preprocessor for this target machine.  */
+ 
+ #define CPP_PREDEFINES "-D__GCC__ -D__VSE__ -Asystem=mvs -Acpu=i370 -Amachine=i370"
+ 
+ 
+ #ifdef PUREISO
+ #include "pureiso.h"
+ #endif
Index: gcc/gcc/config/i370/xm-mvs.h
diff -c nul gcc/gcc/config/i370/xm-mvs.h:1.4
*** nul	Tue Oct 01 16:28:50 2019
--- gcc/gcc/config/i370/xm-mvs.h	Sat Nov 10 09:05:20 2007
***************
*** 0 ****
--- 1,39 ----
+ /* Configuration for GNU C-compiler for System/370.
+    Copyright (C) 1989, 1993, 1997 Free Software Foundation, Inc.
+    Contributed by Jan Stein (jan@cd.chalmers.se).
+    Modified for OS/390 LanguageEnvironment C by Dave Pitts (dpitts@cozx.com)
+ 
+ This file is part of GNU CC.
+ 
+ GNU CC is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2, or (at your option)
+ any later version.
+ 
+ GNU CC is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+ 
+ You should have received a copy of the GNU General Public License
+ along with GNU CC; see the file COPYING.  If not, write to
+ the Free Software Foundation, 59 Temple Place - Suite 330,
+ Boston, MA 02111-1307, USA.  */
+ 
+ /* This describes the machine the compiler is hosted on.  */
+ 
+ #define HOST_FLOAT_FORMAT	IBM_FLOAT_FORMAT
+ #define HOST_EBCDIC		1
+ 
+ #define USG
+ #ifndef MVS
+ #define MVS
+ #endif
+ 
+ /* Arguments to use with `exit'.  */
+ 
+ #define SUCCESS_EXIT_CODE	0
+ #define FATAL_EXIT_CODE		12
+ 
+ #define NO_DBX_FORMAT
+ 
Index: gcc/gcc/config/i370/xm-oe.h
diff -c nul gcc/gcc/config/i370/xm-oe.h:1.1
*** nul	Tue Oct 01 16:28:50 2019
--- gcc/gcc/config/i370/xm-oe.h	Wed Feb 15 21:25:44 2006
***************
*** 0 ****
--- 1,54 ----
+ /* Configuration for GNU C-compiler for System/370.
+    Copyright (C) 1989, 1993, 1997 Free Software Foundation, Inc.
+    Contributed by Jan Stein (jan@cd.chalmers.se).
+    Modified for OS/390 OpenEdition by Dave Pitts (dpitts@cozx.com)
+ 
+ This file is part of GNU CC.
+ 
+ GNU CC is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2, or (at your option)
+ any later version.
+ 
+ GNU CC is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+ 
+ You should have received a copy of the GNU General Public License
+ along with GNU CC; see the file COPYING.  If not, write to
+ the Free Software Foundation, 59 Temple Place - Suite 330,
+ Boston, MA 02111-1307, USA.  */
+ 
+ /* #defines that need visibility everywhere.  */
+ 
+ #ifndef FALSE
+ #define FALSE 0
+ #endif
+ #ifndef TRUE
+ #define TRUE 1
+ #endif
+ 
+ #define USE_STDARGS 1
+ #define USE_PROTOTYPES 1
+ 
+ /* This describes the machine the compiler is hosted on.  */
+ 
+ #define HOST_FLOAT_FORMAT	IBM_FLOAT_FORMAT
+ #define HOST_EBCDIC		1
+ 
+ #define ONLY_INT_FIELDS		1
+ 
+ #define USG
+ 
+ /* Arguments to use with `exit'.  */
+ 
+ #define SUCCESS_EXIT_CODE	0
+ #define FATAL_EXIT_CODE		1
+ 
+ #define NO_DBX_FORMAT
+ 
+ /* The mmap function on OS/390 is broken, bypass */
+ 
+ #define MMAP_THRESHOLD 0
+ 
Index: gcc/gcc/config/i386/cygwin.h
diff -c gcc/gcc/config/i386/cygwin.h:1.1.1.1 gcc/gcc/config/i386/cygwin.h:1.2
*** gcc/gcc/config/i386/cygwin.h:1.1.1.1	Wed Feb 15 21:22:45 2006
--- gcc/gcc/config/i386/cygwin.h	Thu Jul 04 16:19:20 2019
***************
*** 354,360 ****
  #undef TARGET_SUBTARGET_DEFAULT
  
  #define TARGET_SUBTARGET_DEFAULT \
!    (MASK_80387 | MASK_IEEE_FP | MASK_FLOAT_RETURNS | MASK_STACK_PROBE) 
  
  /* This is how to output an assembler line
     that says to advance the location counter
--- 354,360 ----
  #undef TARGET_SUBTARGET_DEFAULT
  
  #define TARGET_SUBTARGET_DEFAULT \
!    (MASK_80387 | MASK_IEEE_FP | MASK_FLOAT_RETURNS /* | MASK_STACK_PROBE */) 
  
  /* This is how to output an assembler line
     that says to advance the location counter
Index: gcc/gcc/config/i386/i386.h
diff -c gcc/gcc/config/i386/i386.h:1.1.1.1 gcc/gcc/config/i386/i386.h:1.2
*** gcc/gcc/config/i386/i386.h:1.1.1.1	Wed Feb 15 21:22:45 2006
--- gcc/gcc/config/i386/i386.h	Mon Jun 18 04:14:51 2018
***************
*** 19,24 ****
--- 19,27 ----
  the Free Software Foundation, 59 Temple Place - Suite 330,
  Boston, MA 02111-1307, USA.  */
  
+ #ifndef GCC_I386_H
+ #define GCC_I386_H
+ 
  /* The purpose of this file is to define the characteristics of the i386,
     independent of assembler syntax or operating system.
  
***************
*** 3223,3228 ****
--- 3226,3233 ----
  #define HARD_REGNO_RENAME_OK(SRC, TARGET)  \
     ((SRC) < FIRST_STACK_REG || (SRC) > LAST_STACK_REG)
  
+ #endif
+ 
  
  /*
  Local variables:
Index: gcc/gcc/config/i386/pdos386.h
diff -c nul gcc/gcc/config/i386/pdos386.h:1.9
*** nul	Tue Oct 01 16:28:50 2019
--- gcc/gcc/config/i386/pdos386.h	Wed Jul 03 16:27:31 2019
***************
*** 0 ****
--- 1,241 ----
+ /* Configuration for an i386 running MS-DOS with DJGPP.
+    Copyright (C) 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
+ 
+ This file is part of GNU CC.
+ 
+ GNU CC is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2, or (at your option)
+ any later version.
+ 
+ GNU CC is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+ 
+ You should have received a copy of the GNU General Public License
+ along with GNU CC; see the file COPYING.  If not, write to
+ the Free Software Foundation, 59 Temple Place - Suite 330,
+ Boston, MA 02111-1307, USA.  */
+ 
+ #include "dbxcoff.h"
+ 
+ /* Support generation of DWARF2 debugging info.  */
+ #define DWARF2_DEBUGGING_INFO
+ 
+ /* Don't assume anything about the header files.  */
+ #define NO_IMPLICIT_EXTERN_C
+ 
+ #define HANDLE_SYSV_PRAGMA
+ 
+ /* Enable parsing of #pragma pack(push,<n>) and #pragma pack(pop).  */
+ #define HANDLE_PRAGMA_PACK_PUSH_POP 1
+ 
+ #define YES_UNDERSCORES
+ 
+ #include "i386/gas.h"
+ 
+ /* If defined, a C expression whose value is a string containing the
+    assembler operation to identify the following data as
+    uninitialized global data.  If not defined, and neither
+    `ASM_OUTPUT_BSS' nor `ASM_OUTPUT_ALIGNED_BSS' are defined,
+    uninitialized global data will be output in the data section if
+    `-fno-common' is passed, otherwise `ASM_OUTPUT_COMMON' will be
+    used.  */
+ #undef BSS_SECTION_ASM_OP
+ #define BSS_SECTION_ASM_OP "\t.bss"
+ 
+ /* Define the name of the .data section.  */
+ #undef DATA_SECTION_ASM_OP
+ #define DATA_SECTION_ASM_OP "\t.data"
+ 
+ /* Define the name of the .ident op.  */
+ #undef IDENT_ASM_OP
+ #define IDENT_ASM_OP "\t.ident\t"
+ 
+ /* Enable alias attribute support.  */
+ #ifndef SET_ASM_OP
+ #define SET_ASM_OP "\t.set\t"
+ #endif
+ 
+ /* Define the name of the .text section.  */
+ #undef TEXT_SECTION_ASM_OP
+ #define TEXT_SECTION_ASM_OP "\t.text"
+ 
+ /* Define standard DJGPP installation paths.                             */
+ /* We override default /usr or /usr/local part with /dev/env/DJDIR which */
+ /* points to actual DJGPP instalation directory.                         */
+ 
+ /* Standard include directory */
+ #undef STANDARD_INCLUDE_DIR
+ #define STANDARD_INCLUDE_DIR "/dev/env/DJDIR/include/"
+ 
+ /* Search for as.exe and ld.exe in DJGPP's binary directory.  */ 
+ #undef MD_EXEC_PREFIX
+ #define MD_EXEC_PREFIX "/dev/env/DJDIR/bin/"
+ 
+ /* Standard DJGPP library and startup files */
+ #undef MD_STARTFILE_PREFIX
+ #define MD_STARTFILE_PREFIX "/dev/env/DJDIR/lib/"
+ 
+ /* Correctly handle absolute filename detection in cp/xref.c */
+ #define FILE_NAME_ABSOLUTE_P(NAME) \
+         (((NAME)[0] == '/') || ((NAME)[0] == '\\') || \
+         (((NAME)[0] >= 'A') && ((NAME)[0] <= 'z') && ((NAME)[1] == ':')))
+ 
+ #undef CPP_PREDEFINES
+ #define CPP_PREDEFINES "-Asystem=msdos"
+ 
+ /* Include <sys/version.h> so __DJGPP__ and __DJGPP_MINOR__ are defined.  */
+ #undef CPP_SPEC
+ #define CPP_SPEC "-remap %(cpp_cpu) %{posix:-D_POSIX_SOURCE} \
+   %{!ansi:%{!std=c*:%{!std=i*:-DMSDOS}}} %{!ansi:%{!std=c*:%{!std=i*:-DGO32}}}"
+ 
+ /* We need to override link_command_spec in gcc.c so support -Tdjgpp.djl.
+    This cannot be done in LINK_SPECS as that LINK_SPECS is processed
+    before library search directories are known by the linker.
+    This avoids problems when specs file is not available. An alternate way,
+    suggested by Robert Hoehne, is to use SUBTARGET_EXTRA_SPECS instead.
+ */ 
+ 
+ #undef LINK_COMMAND_SPEC
+ #define LINK_COMMAND_SPEC \
+ "%{!fsyntax-only: \
+ %{!c:%{!M:%{!MM:%{!E:%{!S:%(linker) %l %X %{o*} %{A} %{d} %{e*} %{m} %{N} %{n} \
+ \t%{r} %{s} %{t} %{u*} %{x} %{z} %{Z}\
+ \t%{!A:%{!nostdlib:%{!nostartfiles:%S}}}\
+ \t%{static:} %{L*} %D %o\
+ \t%{!nostdlib:%{!nodefaultlibs:%G %L %G}}\
+ \t%{!A:%{!nostdlib:%{!nostartfiles:%E}}}\
+ \t-Tdjgpp.djl %{T*}}}}}}}\n\
+ %{!c:%{!M:%{!MM:%{!E:%{!S:stubify %{v} %{o*:%*} %{!o*:a.out} }}}}}"
+ 
+ /* Always just link in 'libc.a'.  */
+ #undef LIB_SPEC
+ #define LIB_SPEC "-lc"
+ 
+ /* Pick the right startup code depending on the -pg flag.  */
+ #undef STARTFILE_SPEC
+ #define STARTFILE_SPEC "%{pg:gcrt0.o%s}%{!pg:crt0.o%s}"
+ 
+ /* Make sure that gcc will not look for .h files in /usr/local/include 
+    unless user explicitly requests it.  */
+ #undef LOCAL_INCLUDE_DIR
+ 
+ /* Switch into a generic section.  */
+ #define TARGET_ASM_NAMED_SECTION  default_coff_asm_named_section
+ 
+ /* Output at beginning of assembler file.  */
+ /* The .file command should always begin the output.  */
+ 
+ #undef ASM_FILE_START
+ #define ASM_FILE_START(FILE)						\
+   do {									\
+ 	output_file_directive (FILE, main_input_filename);		\
+   } while (0)
+ 
+ /* This is how to output an assembler line
+    that says to advance the location counter
+    to a multiple of 2**LOG bytes.  */
+ 
+ #undef ASM_OUTPUT_ALIGN
+ #define ASM_OUTPUT_ALIGN(FILE,LOG) \
+   if ((LOG) != 0) fprintf ((FILE), "\t.p2align %d\n", LOG)
+ 
+ /* This is how to output a global symbol in the BSS section.  */
+ #undef ASM_OUTPUT_ALIGNED_BSS
+ #define ASM_OUTPUT_ALIGNED_BSS(FILE, DECL, NAME, SIZE, ALIGN) \
+   asm_output_aligned_bss ((FILE), (DECL), (NAME), (SIZE), (ALIGN))
+ 
+ /* This is how to tell assembler that a symbol is weak  */ 
+ #undef ASM_WEAKEN_LABEL
+ #define ASM_WEAKEN_LABEL(FILE,NAME) \
+   do { fputs ("\t.weak\t", FILE); assemble_name (FILE, NAME); \
+        fputc ('\n', FILE); } while (0)
+ 
+ /* djgpp automatically calls its own version of __main, so don't define one
+    in libgcc, nor call one in main().  */
+ #define HAS_INIT_SECTION
+ 
+ /* Definitions for types and sizes. Wide characters are 16-bits long so
+    Win32 compiler add-ons will be wide character compatible.  */
+ #undef WCHAR_UNSIGNED
+ #define WCHAR_UNSIGNED 1
+ 
+ #undef WCHAR_TYPE_SIZE
+ #define WCHAR_TYPE_SIZE 16
+ 
+ #undef WCHAR_TYPE
+ #define WCHAR_TYPE "short unsigned int"
+ 
+ #undef WINT_TYPE
+ #define WINT_TYPE "int"
+ 
+ #undef SIZE_TYPE
+ #define SIZE_TYPE "long unsigned int"
+ 
+ #undef PTRDIFF_TYPE
+ #define PTRDIFF_TYPE "int"
+ 
+ /* Used to be defined in xm-djgpp.h, but moved here for cross-compilers.  */
+ #define LIBSTDCXX "-lstdcxx"
+ 
+ /* -mbnu210 is now ignored and obsolete. It was used to enable support for
+    weak symbols, and .gnu.linkonce support.  */
+ #undef MASK_BNU210
+ #define MASK_BNU210 (0x40000000)
+ 
+ #undef SUBTARGET_SWITCHES
+ #define SUBTARGET_SWITCHES \
+   { "no-bnu210", -MASK_BNU210, "Ignored (obsolete)" }, \
+   { "bnu210", MASK_BNU210, "Ignored (obsolete)" },
+ 
+ /* Warn that -mbnu210 is now obsolete.  */
+ #undef  SUBTARGET_OVERRIDE_OPTIONS
+ #define SUBTARGET_OVERRIDE_OPTIONS \
+ do \
+   { \
+     if (target_flags & MASK_BNU210) \
+       {	\
+         warning ("-mbnu210 is ignored (option is obsolete)"); \
+       }	\
+   } \
+ while (0)
+ 
+ /* Support for C++ templates.  */
+ #undef MAKE_DECL_ONE_ONLY
+ #define MAKE_DECL_ONE_ONLY(DECL) (DECL_WEAK (DECL) = 1)
+ 
+ #undef UNIQUE_SECTION
+ #define UNIQUE_SECTION(DECL,RELOC)				\
+ do {								\
+   int len;							\
+   const char *name, *prefix;					\
+   char *string;							\
+ 								\
+   name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (DECL));	\
+   /* Strip off any encoding in fnname.  */                      \
+   STRIP_NAME_ENCODING (name, name);                             \
+ 								\
+   if (! DECL_ONE_ONLY (DECL))					\
+     {								\
+       if (TREE_CODE (DECL) == FUNCTION_DECL)			\
+ 	prefix = ".text.";					\
+       else if (DECL_READONLY_SECTION (DECL, RELOC))		\
+ 	prefix = ".rodata.";					\
+       else							\
+ 	prefix = ".data.";					\
+     }								\
+   else if (TREE_CODE (DECL) == FUNCTION_DECL)			\
+     prefix = ".gnu.linkonce.t.";				\
+   else if (DECL_READONLY_SECTION (DECL, RELOC))			\
+     prefix = ".gnu.linkonce.r.";				\
+   else								\
+     prefix = ".gnu.linkonce.d.";				\
+ 								\
+   len = strlen (name) + strlen (prefix);			\
+   string = alloca (len + 1);					\
+   sprintf (string, "%s%s", prefix, name);			\
+ 								\
+   DECL_SECTION_NAME (DECL) = build_string (len, string);	\
+ } while (0)
Index: gcc/gcc/config/i386/uwin.h
diff -c gcc/gcc/config/i386/uwin.h:1.1.1.1 gcc/gcc/config/i386/uwin.h:1.2
*** gcc/gcc/config/i386/uwin.h:1.1.1.1	Wed Feb 15 21:22:45 2006
--- gcc/gcc/config/i386/uwin.h	Thu Jul 04 16:19:20 2019
***************
*** 34,40 ****
  
  #undef CPP_PREDEFINES
  #define CPP_PREDEFINES "-D_WIN32 -D__WIN32__ \
!   -D_UWIN -DWINNT  -D_X86_=1 -D__STDC__=1 \
    -D__UWIN__ -D__MSVCRT__ \
    -D_STD_INCLUDE_DIR=mingw32 \
    -D__stdcall=__attribute__((__stdcall__)) \
--- 34,40 ----
  
  #undef CPP_PREDEFINES
  #define CPP_PREDEFINES "-D_WIN32 -D__WIN32__ \
!   -D_UWIN -DWINNT  -D_X86_=1 \
    -D__UWIN__ -D__MSVCRT__ \
    -D_STD_INCLUDE_DIR=mingw32 \
    -D__stdcall=__attribute__((__stdcall__)) \
***************
*** 44,52 ****
    -Asystem=winnt"
  
  #undef CPP_SPEC
! #define CPP_SPEC "-remap %(cpp_cpu) %{posix:-D_POSIX_SOURCE} \
    -include /usr/include/astwin32.h \
!   -idirafter /usr/gnu/include/mingw32"
  
  /* For Windows applications, include more libraries, but always include
     kernel32.  */
--- 44,53 ----
    -Asystem=winnt"
  
  #undef CPP_SPEC
! #define CPP_SPEC "-remap %(cpp_cpu) %{posix:-D_POSIX_SOURCE}"
!   /* \
    -include /usr/include/astwin32.h \
!   -idirafter /usr/gnu/include/mingw32" */
  
  /* For Windows applications, include more libraries, but always include
     kernel32.  */
Index: gcc/gcc/f/bad.c
diff -c gcc/gcc/f/bad.c:1.1.1.1 gcc/gcc/f/bad.c:1.2
*** gcc/gcc/f/bad.c:1.1.1.1	Wed Feb 15 21:22:41 2006
--- gcc/gcc/f/bad.c	Wed Feb 15 21:24:30 2006
***************
*** 350,355 ****
--- 350,367 ----
  {
  #define MAX_SPACES 132
    static const char *const spaces
+ #ifdef HOST_EBCDIC
+   = "...>\
+ \100\100\100\100\100\100\100\100\100\100\100\100\100\100\100\100\
+ \100\100\100\100\100\100\100\100\100\100\100\100\100\100\100\100\
+ \100\100\100\100\100\100\100\100\100\100\100\100\100\100\100\100\
+ \100\100\100\100\100\100\100\100\100\100\100\100\100\100\100\100\
+ \100\100\100\100\100\100\100\100\100\100\100\100\100\100\100\100\
+ \100\100\100\100\100\100\100\100\100\100\100\100\100\100\100\100\
+ \100\100\100\100\100\100\100\100\100\100\100\100\100\100\100\100\
+ \100\100\100\100\100\100\100\100\100\100\100\100\100\100\100\100\
+ \100\100\100";			/* MAX_SPACES - 1 spaces. */
+ #else
    = "...>\
  \040\040\040\040\040\040\040\040\040\040\040\040\040\040\040\040\
  \040\040\040\040\040\040\040\040\040\040\040\040\040\040\040\040\
***************
*** 360,365 ****
--- 372,378 ----
  \040\040\040\040\040\040\040\040\040\040\040\040\040\040\040\040\
  \040\040\040\040\040\040\040\040\040\040\040\040\040\040\040\040\
  \040\040\040";			/* MAX_SPACES - 1 spaces. */
+ #endif
    ffewhereLineNumber last_line_num;
    ffewhereLineNumber ln;
    ffewhereLineNumber rn;
Index: gcc/gcc/f/implic.c
diff -c gcc/gcc/f/implic.c:1.1.1.1 gcc/gcc/f/implic.c:1.3
*** gcc/gcc/f/implic.c:1.1.1.1	Wed Feb 15 21:22:42 2006
--- gcc/gcc/f/implic.c	Fri Nov 03 16:15:23 2006
***************
*** 69,75 ****
--- 69,79 ----
  
  /* NOTE: This is definitely ASCII-specific!!  */
  
+ #ifdef HOST_EBCDIC
+ static struct _ffeimplic_ ffeimplic_table_['Z' - '_' + 1];
+ #else
  static struct _ffeimplic_ ffeimplic_table_['z' - 'A' + 1];
+ #endif
  
  /* Static functions (internal). */
  
***************
*** 93,99 ****
--- 97,107 ----
  {
    /* NOTE: This is definitely ASCII-specific!!  */
    if (ISIDST (c))
+ #ifdef HOST_EBCDIC
+     return &ffeimplic_table_[c - '_'];
+ #else
      return &ffeimplic_table_[c - 'A'];
+ #endif
    return NULL;
  }
  
***************
*** 225,233 ****
--- 233,249 ----
    ffeimplic_ imp;
    char c;
  
+ #ifdef HOST_EBCDIC
+   for (c = '_'; c <= 'Z'; ++c)
+ #else
    for (c = 'A'; c <= 'z'; ++c)
+ #endif
      {
+ #ifdef HOST_EBCDIC
+       imp = &ffeimplic_table_[c - '_'];
+ #else
        imp = &ffeimplic_table_[c - 'A'];
+ #endif
        imp->state = FFEIMPLIC_stateINITIAL_;
        switch (c)
  	{
Index: gcc/gcc/f/intrin.def
diff -c gcc/gcc/f/intrin.def:1.1.1.1 gcc/gcc/f/intrin.def:1.2
*** gcc/gcc/f/intrin.def:1.1.1.1	Wed Feb 15 21:22:42 2006
--- gcc/gcc/f/intrin.def	Fri Nov 03 16:15:23 2006
***************
*** 3125,3358 ****
  
  */
  
! DEFIMP	(ABS,		"ABS",		,ABS,,		"S=:0:A=N*")
! DEFIMP	(ACOS,		"ACOS",		L_ACOS,ACOS,,	"R=:0:X=R*")
! DEFIMP	(AIMAG,		"AIMAG",	,AIMAG,,	"RC:0:Z=C*")
! DEFIMP	(AINT,		"AINT",		,AINT,,		"R=:0:A=R*")
! DEFIMP	(ALOG,		"ALOG",		L_LOG,ALOG,,	"R1:-:X=R1")
! DEFIMP	(ALOG10,	"ALOG10",	L_LOG10,ALOG10,,"R1:-:X=R1")
! DEFIMP	(AMAX0,		"AMAX0",	,,,		"R1:*:A=pI1")
! DEFIMP	(AMAX1,		"AMAX1",	,,,		"R1:*:A=pR1")
! DEFIMP	(AMIN0,		"AMIN0",	,,,		"R1:*:A=pI1")
! DEFIMP	(AMIN1,		"AMIN1",	,,,		"R1:*:A=pR1")
! DEFIMP	(AMOD,		"AMOD",		L_FMOD,AMOD,,	"R1:*:A=R1,P=R1")
! DEFIMP	(ANINT,		"ANINT",	,ANINT,,	"R=:0:A=R*")
! DEFIMP	(ASIN,		"ASIN",		L_ASIN,ASIN,,	"R=:0:X=R*")
! DEFIMP	(ATAN,		"ATAN",		L_ATAN,ATAN,,	"R=:0:X=R*")
! DEFIMP	(ATAN2,		"ATAN2",	L_ATAN2,ATAN2,,	"R=:*:Y=R*,X=R*")
! DEFIMP	(CABS,		"CABS",		,CABS,,		"R1:-:A=C1")
! DEFIMP	(CCOS,		"CCOS",		,CCOS,,		"C1:-:X=C1")
! DEFIMP	(CEXP,		"CEXP",		,CEXP,,		"C1:-:X=C1")
! DEFIMP	(CHAR,		"CHAR",		,,,		"A1:-:I=I*")
! DEFIMP	(CLOG,		"CLOG",		,CLOG,,		"C1:-:X=C1")
! DEFIMP	(CMPLX,		"CMPLX",	,,,		"C1:*:X=N*,Y=!S*")
! DEFIMP	(CONJG,		"CONJG",	,CONJG,,	"C=:0:Z=C*")
! DEFIMP	(COS,		"COS",		L_COS,COS,,	"F=:0:X=F*")
! DEFIMP	(COSH,		"COSH",		L_COSH,COSH,,	"R=:0:X=R*")
! DEFIMP	(CSIN,		"CSIN",		,CSIN,,		"C1:-:X=C1")
! DEFIMP	(CSQRT,		"CSQRT",	,CSQRT,,	"C1:-:X=C1")
! DEFIMP	(DABS,		"DABS",		,DABS,,		"R2:-:A=R2")
! DEFIMP	(DACOS,		"DACOS",	L_ACOS,DACOS,,	"R2:-:X=R2")
! DEFIMP	(DASIN,		"DASIN",	L_ASIN,DASIN,,	"R2:-:X=R2")
! DEFIMP	(DATAN,		"DATAN",	L_ATAN,DATAN,,	"R2:-:X=R2")
! DEFIMP	(DATAN2,	"DATAN2",	L_ATAN2,DATAN2,,"R2:*:Y=R2,X=R2")
! DEFIMP	(DBLE,		"DBLE",		,,,		"R2:-:A=N*")
! DEFIMP	(DCMPLX,	"DCMPLX",	,,,		"C2:*:X=N*,Y=!S*")
! DEFIMP	(DCOS,		"DCOS",		L_COS,DCOS,,	"R2:-:X=R2")
! DEFIMP	(DCOSH,		"DCOSH",	L_COSH,DCOSH,,	"R2:-:X=R2")
! DEFIMP	(DDIM,		"DDIM",		,DDIM,,		"R2:*:X=R2,Y=R2")
! DEFIMP	(DEXP,		"DEXP",		L_EXP,DEXP,,	"R2:-:X=R2")
! DEFIMP	(DIM,		"DIM",		,DIM,,		"S=:*:X=S*,Y=S*")
! DEFIMP	(DINT,		"DINT",		,DINT,,		"R2:-:A=R2")
! DEFIMP	(DLOG,		"DLOG",		L_LOG,DLOG,,	"R2:-:X=R2")
! DEFIMP	(DLOG10,	"DLOG10",	L_LOG10,DLOG10,,"R2:-:X=R2")
! DEFIMP	(DMAX1,		"DMAX1",	,,,		"R2:*:A=pR2")
! DEFIMP	(DMIN1,		"DMIN1",	,,,		"R2:*:A=pR2")
! DEFIMP	(DMOD,		"DMOD",		L_FMOD,DMOD,,	"R2:*:A=R2,P=R2")
! DEFIMP	(DNINT,		"DNINT",	,DNINT,,	"R2:-:A=R2")
! DEFIMP	(DPROD,		"DPROD",	,DPROD,,	"R2:*:X=R1,Y=R1")
! DEFIMP	(DSIGN,		"DSIGN",	,DSIGN,,	"R2:*:A=R2,B=R2")
! DEFIMP	(DSIN,		"DSIN",		L_SIN,DSIN,,	"R2:-:X=R2")
! DEFIMP	(DSINH,		"DSINH",	L_SINH,DSINH,,	"R2:-:X=R2")
! DEFIMP	(DSQRT,		"DSQRT",	L_SQRT,DSQRT,,	"R2:-:X=R2")
! DEFIMP	(DTAN,		"DTAN",		L_TAN,DTAN,,	"R2:-:X=R2")
! DEFIMP	(DTANH,		"DTANH",	L_TANH,DTANH,,	"R2:-:X=R2")
! DEFIMP	(EXP,		"EXP",		L_EXP,EXP,,	"F=:0:X=F*")
! DEFIMP	(FLOAT,		"FLOAT",	,,,		"R1:-:A=I*")
! DEFIMP	(IABS,		"IABS",		,IABS,IABS,	"I1:-:A=I1")
! DEFIMP	(ICHAR,		"ICHAR",	,,,		"I1:-:C=A*")
! DEFIMP	(IDIM,		"IDIM",		,IDIM,IDIM,	"I1:*:X=I1,Y=I1")
! DEFIMP	(IDINT,		"IDINT",	,,,		"I1:-:A=R2")
! DEFIMP	(IDNINT,	"IDNINT",	,IDNINT,IDNINT,	"I1:-:A=R2")
! DEFIMP	(IFIX,		"IFIX",		,,,		"I1:-:A=R1")
! DEFIMP	(INDEX,		"INDEX",	,INDEX,INDEX,	"I1:*:String=A*,Substring=A*")
! DEFIMP	(INT,		"INT",		,,,		"I1:-:A=N*")
! DEFIMP	(ISIGN,		"ISIGN",	,ISIGN,ISIGN,	"I1:*:A=I1,B=I1")
! DEFIMP	(LEN,		"LEN",		,LEN,LEN,	"I1:-:String=A*i")
! DEFIMP	(LGE,		"LGE",		,LGE,LGE,	"L1:*:String_A=A1,String_B=A1")
! DEFIMP	(LGT,		"LGT",		,LGT,LGT,	"L1:*:String_A=A1,String_B=A1")
! DEFIMP	(LLE,		"LLE",		,LLE,LLE,	"L1:*:String_A=A1,String_B=A1")
! DEFIMP	(LLT,		"LLT",		,LLT,LLT,	"L1:*:String_A=A1,String_B=A1")
! DEFIMP	(LOG,		"LOG",		L_LOG,ALOG,,	"F=:0:X=F*")
! DEFIMP	(LOG10,		"LOG10",	L_LOG10,ALOG10,,"R=:0:X=R*")
! DEFIMP	(MAX,		"MAX",		,,,		"S=:*:A=pS*")
! DEFIMP	(MIN,		"MIN",		,,,		"S=:*:A=pS*")
! DEFIMP	(MAX0,		"MAX0",		,,,		"I1:*:A=pI1")
! DEFIMP	(MAX1,		"MAX1",		,,,		"I1:*:A=pR1")
! DEFIMP	(MIN0,		"MIN0",		,,,		"I1:*:A=pI1")
! DEFIMP	(MIN1,		"MIN1",		,,,		"I1:*:A=pR1")
! DEFIMP	(MOD,		"MOD",		,MOD,MOD,	"S=:*:A=S*,P=S*")
! DEFIMP	(NINT,		"NINT",		,NINT,NINT,	"I1:-:A=R*")
! DEFIMP	(REAL,		"REAL",		,,,		"RC:0:A=N*")
! DEFIMP	(SIGN,		"SIGN",		,SIGN,,		"S=:*:A=S*,B=S*")
! DEFIMP	(SIN,		"SIN",		L_SIN,SIN,,	"F=:0:X=F*")
! DEFIMP	(SINH,		"SINH",		L_SINH,SINH,,	"R=:0:X=R*")
! DEFIMP	(SNGL,		"SNGL",		,,,		"R1:-:A=R2")
! DEFIMP	(SQRT,		"SQRT",		L_SQRT,SQRT,,	"F=:0:X=F*")
! DEFIMP	(TAN,		"TAN",		L_TAN,TAN,,	"R=:0:X=R*")
! DEFIMP	(TANH,		"TANH",		L_TANH,TANH,,	"R=:0:X=R*")
  
! DEFIMP	(ABORT,		"ABORT",	ABORT,,,	"--:-:")
! DEFIMP	(ACCESS,	"ACCESS",	ACCESS,,,	"I1:-:Name=A1,Mode=A1")
! DEFIMP	(ACHAR,		"ACHAR",	,,,		"A1:-:I=I*")
! DEFIMP	(ALARM,		"ALARM",	ALARM,,,	"--:-:Seconds=I*,Handler=s*,Status=?I1w")
! DEFIMP	(AND,		"AND",		,,,		"B=:*:I=B*,J=B*")
! DEFIMP	(BESJ0,		"BESJ0",	L_BESJ0,,,	"R=:0:X=R*")
! DEFIMP	(BESJ1,		"BESJ1",	L_BESJ1,,,	"R=:0:X=R*")
! DEFIMP	(BESJN,		"BESJN",	L_BESJN,,,	"R=:1:N=IN,X=R*")
! DEFIMP	(BESY0,		"BESY0",	L_BESY0,,,	"R=:0:X=R*")
! DEFIMP	(BESY1,		"BESY1",	L_BESY1,,,	"R=:0:X=R*")
! DEFIMP	(BESYN,		"BESYN",	L_BESYN,,,	"R=:1:N=IN,X=R*")
! DEFIMP	(BIT_SIZE,	"BIT_SIZE",	,,,		"I=:0:I=I*i")
! DEFIMP	(BTEST,		"BTEST",	,,,		"L1:*:I=I*,Pos=I*")
! DEFIMP	(CDABS,		"CDABS",	,CDABS,,	"R2:-:A=C2")
! DEFIMP	(CDCOS,		"CDCOS",	,CDCOS,,	"C2:-:X=C2")
! DEFIMP	(CDEXP,		"CDEXP",	,CDEXP,,	"C2:-:X=C2")
! DEFIMP	(CDLOG,		"CDLOG",	,CDLOG,,	"C2:-:X=C2")
! DEFIMP	(CDSIN,		"CDSIN",	,CDSIN,,	"C2:-:X=C2")
! DEFIMP	(CDSQRT,	"CDSQRT",	,CDSQRT,,	"C2:-:X=C2")
! DEFIMP	(CHDIR_func,	"CHDIR_func",	CHDIR,,,	"I1:-:Dir=A1")
! DEFIMP	(CHDIR_subr,	"CHDIR_subr",	CHDIR,,,	"--:-:Dir=A1,Status=?I1w")
! DEFIMP	(CHMOD_func,	"CHMOD_func",	CHMOD,,,	"I1:-:Name=A1,Mode=A1")
! DEFIMP	(CHMOD_subr,	"CHMOD_subr",	CHMOD,,,	"--:-:Name=A1,Mode=A1,Status=?I1w")
! DEFIMP	(COMPLEX,	"COMPLEX",	,,,		"C=:*:Real=S*,Imag=S*")
! DEFIMP	(CPU_TIME,	"CPU_TIME",	SECOND,,,	"--:-:Seconds=R*w")
! DEFIMP	(CTIME_func,	"CTIME_func",	CTIME,,,	"A1*:-:STime=I*")
! DEFIMP	(CTIME_subr,	"CTIME_subr",	CTIME,,,	"--:-:STime=I*,Result=A1w")
! DEFIMPY	(DATE,		"DATE",		DATE,,,		"--:-:Date=A1w",	TRUE)
! DEFIMP	(DATE_AND_TIME,	"DATE_AND_TIME", DATE_AND_TIME,,, "--:-:Date=A1w,Time=?A1w,Zone=?A1w,Values=?I1(8)w")
! DEFIMP	(DBESJ0,	"DBESJ0",	L_BESJ0,,,	"R2:-:X=R2")
! DEFIMP	(DBESJ1,	"DBESJ1",	L_BESJ1,,,	"R2:-:X=R2")
! DEFIMP	(DBESJN,	"DBESJN",	L_BESJN,,,	"R2:-:N=IN,X=R2")
! DEFIMP	(DBESY0,	"DBESY0",	L_BESY0,,,	"R2:-:X=R2")
! DEFIMP	(DBESY1,	"DBESY1",	L_BESY1,,,	"R2:-:X=R2")
! DEFIMP	(DBESYN,	"DBESYN",	L_BESYN,,,	"R2:-:N=IN,X=R2")
! DEFIMP	(DCONJG,	"DCONJG",	,DCONJG,,	"C2:-:Z=C2")
! DEFIMP	(DERF,		"DERF",		L_ERF,DERF,,	"R2:-:X=R2")
! DEFIMP	(DERFC,		"DERFC",	L_ERFC,DERFC,,	"R2:-:X=R2")
! DEFIMP	(DFLOAT,	"DFLOAT",	,,,		"R2:-:A=I*")
! DEFIMP	(DIMAG,		"DIMAG",	,DIMAG,,	"R2:-:Z=C2")
! DEFIMP	(DREAL,		"DREAL",	,,,		"R2:-:A=N*")
! DEFIMP	(DTIME_func,	"DTIME_func",	DTIME,,,	"R1:-:TArray=R1(2)w")
! DEFIMP	(DTIME_subr,	"DTIME_subr",	DTIME,,,	"--:-:TArray=R1(2)w,Result=R1w")
! DEFIMP	(ERF,		"ERF",		L_ERF,ERF,,	"R=:0:X=R*")
! DEFIMP	(ERFC,		"ERFC",		L_ERFC,ERFC,,	"R=:0:X=R*")
! DEFIMP	(ETIME_func,	"ETIME_func",	ETIME,,,	"R1:-:TArray=R1(2)w")
! DEFIMP	(ETIME_subr,	"ETIME_subr",	ETIME,,,	"--:-:TArray=R1(2)w,Result=R1w")
! DEFIMP	(EXIT,		"EXIT",		EXIT,,,		"--:-:Status=?IN")
! DEFIMP	(FDATE_func,	"FDATE_func",	FDATE,,,	"A1*:-:")
! DEFIMP	(FDATE_subr,	"FDATE_subr",	FDATE,,,	"--:-:Date=A1w")
! DEFIMP	(FGET_func,	"FGET_func",	FGET,,,		"I1:-:C=A1w")
! DEFIMP	(FGET_subr,	"FGET_subr",	FGET,,,		"--:-:C=A1w,Status=?I1w")
! DEFIMP	(FGETC_func,	"FGETC_func",	FGETC,,,	"I1:-:Unit=I*,C=A1w")
! DEFIMP	(FGETC_subr,	"FGETC_subr",	FGETC,,,	"--:-:Unit=I*,C=A1w,Status=?I1w")
! DEFIMP	(FLUSH,		"FLUSH",	,,,		"--:-:Unit=?I*")
! DEFIMP	(FNUM,		"FNUM",		FNUM,,,		"I1:-:Unit=I*")
! DEFIMP	(FPUT_func,	"FPUT_func",	FPUT,,,		"I1:-:C=A1")
! DEFIMP	(FPUT_subr,	"FPUT_subr",	FPUT,,,		"--:-:C=A1,Status=?I1w")
! DEFIMP	(FPUTC_func,	"FPUTC_func",	FPUTC,,,	"I1:-:Unit=I*,C=A1")
! DEFIMP	(FPUTC_subr,	"FPUTC_subr",	FPUTC,,,	"--:-:Unit=I*,C=A1,Status=?I1w")
! DEFIMP	(FSEEK,		"FSEEK",	FSEEK,,,	"--:-:Unit=I*,Offset=I*,Whence=I*,ErrLab=?g*")
! DEFIMP	(FSTAT_func,	"FSTAT_func",	FSTAT,,,	"I1:-:Unit=I*,SArray=I1(13)w")
! DEFIMP	(FSTAT_subr,	"FSTAT_subr",	FSTAT,,,	"--:-:Unit=I*,SArray=I1(13)w,Status=?I1w")
! DEFIMP	(FTELL_func,	"FTELL_func",	FTELL,,,	"I1:-:Unit=I*")
! DEFIMP	(FTELL_subr,	"FTELL_subr",	FTELL,,,	"--:-:Unit=I*,Offset=I1w")
! DEFIMP	(GERROR,	"GERROR",	GERROR,,,	"--:-:Message=A1w")
! DEFIMP	(GETARG,	"GETARG",	GETARG,,,	"--:-:Pos=IN,Value=A1w")
! DEFIMP	(GETCWD_func,	"GETCWD_func",	GETCWD,,,	"I1:-:Name=A1w")
! DEFIMP	(GETCWD_subr,	"GETCWD_subr",	GETCWD,,,	"--:-:Name=A1w,Status=?I1w")
! DEFIMP	(GETGID,	"GETGID",	GETGID,,,	"I1:-:")
! DEFIMP	(GETLOG,	"GETLOG",	GETLOG,,,	"--:-:Login=A1w")
! DEFIMP	(GETPID,	"GETPID",	GETPID,,,	"I1:-:")
! DEFIMP	(GETUID,	"GETUID",	GETUID,,,	"I1:-:")
! DEFIMP	(GETENV,	"GETENV",	GETENV,,,	"--:-:Name=A1,Value=A1w")
! DEFIMP	(GMTIME,	"GMTIME",	GMTIME,,,	"--:-:STime=I1,TArray=I1(9)w")
! DEFIMP	(HOSTNM_func,	"HOSTNM_func",	HOSTNM,,,	"I1:-:Name=A1w")
! DEFIMP	(HOSTNM_subr,	"HOSTNM_subr",	HOSTNM,,,	"--:-:Name=A1w,Status=?I1w")
! DEFIMP	(IACHAR,	"IACHAR",	,,,		"I1:-:C=A*")
! DEFIMP	(IAND,		"IAND",		,,,		"I=:*:I=I*,J=I*")
! DEFIMP	(IARGC,		"IARGC",	IARGC,,,	"I1:-:")
! DEFIMP	(IBCLR,		"IBCLR",	,,,		"I=:0:I=I*,Pos=I*")
! DEFIMP	(IBITS,		"IBITS",	,,,		"I=:0:I=I*,Pos=I*,Len=I*")
! DEFIMP	(IBSET,		"IBSET",	,,,		"I=:0:I=I*,Pos=I*")
! DEFIMP	(IDATE_unix,	"IDATE_unix",	IDATE,,,	"--:-:TArray=I1(3)w")
! DEFIMPY	(IDATE_vxt,	"IDATE_vxt",	VXTIDATE,,,	"--:-:M=I1w,D=I1w,Y=I1w",	TRUE)
! DEFIMP	(IEOR,		"IEOR",		,,,		"I=:*:I=I*,J=I*")
! DEFIMP	(IOR,		"IOR",		,,,		"I=:*:I=I*,J=I*")
! DEFIMP	(IERRNO,	"IERRNO",	IERRNO,,,	"I1:-:")
! DEFIMP	(IMAGPART,	"IMAGPART",	,,,		"R=:0:Z=C*")
! DEFIMP	(INT2,		"INT2",		,,,		"I6:-:A=N*")
! DEFIMP	(INT8,		"INT8",		,,,		"I2:-:A=N*")
! DEFIMP	(IRAND,		"IRAND",	IRAND,,,	"I1:-:Flag=?I*")
! DEFIMP	(ISATTY,	"ISATTY",	ISATTY,,,	"L1:-:Unit=I*")
! DEFIMP	(ISHFT,		"ISHFT",	,,,		"I=:0:I=I*,Shift=I*")
! DEFIMP	(ISHFTC,	"ISHFTC",	,,,		"I=:0:I=I*,Shift=I*,Size=I*")
! DEFIMP	(ITIME,		"ITIME",	ITIME,,,	"--:-:TArray=I1(3)w")
! DEFIMP	(KILL_func,	"KILL_func",	KILL,,,		"I1:-:Pid=I*,Signal=I*")
! DEFIMP	(KILL_subr,	"KILL_subr",	KILL,,,		"--:-:Pid=I*,Signal=I*,Status=?I1w")
! DEFIMP	(LINK_func,	"LINK_func",	LINK,,,		"I1:-:Path1=A1,Path2=A1")
! DEFIMP	(LINK_subr,	"LINK_subr",	LINK,,,		"--:-:Path1=A1,Path2=A1,Status=?I1w")
! DEFIMP	(LNBLNK,	"LNBLNK",	LNBLNK,,,	"I1:-:String=A1")
! DEFIMP	(LONG,		"LONG",		,,,		"I1:-:A=I6")
! DEFIMP	(LSTAT_func,	"LSTAT_func",	LSTAT,,,	"I1:-:File=A1,SArray=I1(13)w")
! DEFIMP	(LSTAT_subr,	"LSTAT_subr",	LSTAT,,,	"--:-:File=A1,SArray=I1(13)w,Status=?I1w")
! DEFIMP	(LTIME,		"LTIME",	LTIME,,,	"--:-:STime=I1,TArray=I1(9)w")
! DEFIMP	(LOC,		"LOC",		,,,		"I7:-:Entity=-*&&")
! DEFIMP	(LSHIFT,	"LSHIFT",	,,,		"I=:0:I=I*,Shift=I*")
! DEFIMP	(MCLOCK,	"MCLOCK",	MCLOCK,,,	"I1:-:")
! DEFIMP	(MCLOCK8,	"MCLOCK8",	MCLOCK,,,	"I2:-:")
! DEFIMP	(MVBITS,	"MVBITS",	,,,		"--:-:From=I*,FromPos=I*,Len=I*,TO=IAx,ToPos=I*")
! DEFIMP	(NOT,		"NOT",		,,,		"I=:0:I=I*")
! DEFIMP	(OR,		"OR",		,,,		"B=:*:I=B*,J=B*")
! DEFIMP	(PERROR,	"PERROR",	PERROR,,,	"--:-:String=A1")
! DEFIMP	(RAND,		"RAND",		RAND,,,		"R1:-:Flag=?I*")
! DEFIMP	(REALPART,	"REALPART",	,,,		"R=:0:Z=C*")
! DEFIMP	(RENAME_func,	"RENAME_func",	RENAME,,,	"I1:-:Path1=A1,Path2=A1")
! DEFIMP	(RENAME_subr,	"RENAME_subr",	RENAME,,,	"--:-:Path1=A1,Path2=A1,Status=?I1w")
! DEFIMP	(RSHIFT,	"RSHIFT",	,,,		"I=:0:I=I*,Shift=I*")
! DEFIMP	(SECNDS,	"SECNDS",	SECNDS,,,	"R1:-:T=R1")
! DEFIMP	(SECOND_func,	"SECOND_func",	SECOND,SECOND,,	"R1:-:")
! DEFIMP	(SECOND_subr,	"SECOND_subr",	SECOND,,,	"--:-:Seconds=R*w")
! DEFIMP	(SHORT,		"SHORT",	,,,		"I6:-:A=I*")
! DEFIMP	(SIGNAL_func,	"SIGNAL_func",	L_SIGNAL,,,	"I7:-:Number=I*,Handler=s*")
! DEFIMP	(SIGNAL_subr,	"SIGNAL_subr",	L_SIGNAL,,,	"--:-:Number=I*,Handler=s*,Status=?I7w")
! DEFIMP	(SLEEP,		"SLEEP",	SLEEP,,,	"--:-:Seconds=I1")
! DEFIMP	(SRAND,		"SRAND",	SRAND,,,	"--:-:Seed=I*")
! DEFIMP	(STAT_func,	"STAT_func",	STAT,,,		"I1:-:File=A1,SArray=I1(13)w")
! DEFIMP	(STAT_subr,	"STAT_subr",	STAT,,,		"--:-:File=A1,SArray=I1(13)w,Status=?I1w")
! DEFIMP	(SYMLNK_func,	"SYMLNK_func",	SYMLNK,,,	"I1:-:Path1=A1,Path2=A1")
! DEFIMP	(SYMLNK_subr,	"SYMLNK_subr",	SYMLNK,,,	"--:-:Path1=A1,Path2=A1,Status=?I1w")
  DEFIMP	(SYSTEM_func,	"SYSTEM_func",	SYSTEM,SYSTEM,SYSTEM,"I1:-:Command=A1")
! DEFIMP	(SYSTEM_subr,	"SYSTEM_subr",	SYSTEM,,,	"--:-:Command=A1,Status=?I1w")
! DEFIMP	(SYSTEM_CLOCK,	"SYSTEM_CLOCK",	SYSTEM_CLOCK,,,	"--:-:Count=I1w,Rate=?I1w,Max=?I1w")
! DEFIMP	(TIME8,		"TIME8",	TIME,,,		"I2:-:")
! DEFIMP	(TIME_unix,	"TIME_unix",	TIME,,,		"I1:-:")
! DEFIMP	(TIME_vxt,	"TIME_vxt",	VXTTIME,,,	"--:-:Time=A1[8]w")
! DEFIMP	(TTYNAM_func,	"TTYNAM_func",	TTYNAM,,,	"A1*:-:Unit=I*")
! DEFIMP	(TTYNAM_subr,	"TTYNAM_subr",	TTYNAM,,,	"--:-:Unit=I*,Name=A1w")
! DEFIMP	(UMASK_func,	"UMASK_func",	UMASK,,,	"I1:-:Mask=I*")
! DEFIMP	(UMASK_subr,	"UMASK_subr",	UMASK,,,	"--:-:Mask=I*,Old=?I1w")
! DEFIMP	(UNLINK_func,	"UNLINK_func",	UNLINK,,,	"I1:-:File=A1")
! DEFIMP	(UNLINK_subr,	"UNLINK_subr",	UNLINK,,,	"--:-:File=A1,Status=?I1w")
! DEFIMP	(XOR,		"XOR",		,,,		"B=:*:I=B*,J=B*")
! DEFIMP	(NONE,		"none",		,,,		"")
--- 3125,3358 ----
  
  */
  
! DEFIMP	(ABS,		"ABS",		0,ABS,0,	"S=:0:A=N*")
! DEFIMP	(ACOS,		"ACOS",		L_ACOS,ACOS,0,	"R=:0:X=R*")
! DEFIMP	(AIMAG,		"AIMAG",	0,AIMAG,0,	"RC:0:Z=C*")
! DEFIMP	(AINT,		"AINT",		0,AINT,0,	"R=:0:A=R*")
! DEFIMP	(ALOG,		"ALOG",		L_LOG,ALOG,0,	"R1:-:X=R1")
! DEFIMP	(ALOG10,	"ALOG10",	L_LOG10,ALOG10,0,"R1:-:X=R1")
! DEFIMP	(AMAX0,		"AMAX0",	0,0,0,		"R1:*:A=pI1")
! DEFIMP	(AMAX1,		"AMAX1",	0,0,0,		"R1:*:A=pR1")
! DEFIMP	(AMIN0,		"AMIN0",	0,0,0,		"R1:*:A=pI1")
! DEFIMP	(AMIN1,		"AMIN1",	0,0,0,		"R1:*:A=pR1")
! DEFIMP	(AMOD,		"AMOD",		L_FMOD,AMOD,0,	"R1:*:A=R1,P=R1")
! DEFIMP	(ANINT,		"ANINT",	0,ANINT,0,	"R=:0:A=R*")
! DEFIMP	(ASIN,		"ASIN",		L_ASIN,ASIN,0,	"R=:0:X=R*")
! DEFIMP	(ATAN,		"ATAN",		L_ATAN,ATAN,0,	"R=:0:X=R*")
! DEFIMP	(ATAN2,		"ATAN2",	L_ATAN2,ATAN2,0,"R=:*:Y=R*,X=R*")
! DEFIMP	(CABS,		"CABS",		0,CABS,0,	"R1:-:A=C1")
! DEFIMP	(CCOS,		"CCOS",		0,CCOS,0,	"C1:-:X=C1")
! DEFIMP	(CEXP,		"CEXP",		0,CEXP,0,	"C1:-:X=C1")
! DEFIMP	(CHAR,		"CHAR",		0,0,0,		"A1:-:I=I*")
! DEFIMP	(CLOG,		"CLOG",		0,CLOG,0,	"C1:-:X=C1")
! DEFIMP	(CMPLX,		"CMPLX",	0,0,0,		"C1:*:X=N*,Y=!S*")
! DEFIMP	(CONJG,		"CONJG",	0,CONJG,0,	"C=:0:Z=C*")
! DEFIMP	(COS,		"COS",		L_COS,COS,0,	"F=:0:X=F*")
! DEFIMP	(COSH,		"COSH",		L_COSH,COSH,0,	"R=:0:X=R*")
! DEFIMP	(CSIN,		"CSIN",		0,CSIN,0,	"C1:-:X=C1")
! DEFIMP	(CSQRT,		"CSQRT",	0,CSQRT,0,	"C1:-:X=C1")
! DEFIMP	(DABS,		"DABS",		0,DABS,0,	"R2:-:A=R2")
! DEFIMP	(DACOS,		"DACOS",	L_ACOS,DACOS,0,	"R2:-:X=R2")
! DEFIMP	(DASIN,		"DASIN",	L_ASIN,DASIN,0,	"R2:-:X=R2")
! DEFIMP	(DATAN,		"DATAN",	L_ATAN,DATAN,0,	"R2:-:X=R2")
! DEFIMP	(DATAN2,	"DATAN2",	L_ATAN2,DATAN2,0,"R2:*:Y=R2,X=R2")
! DEFIMP	(DBLE,		"DBLE",		0,0,0,		"R2:-:A=N*")
! DEFIMP	(DCMPLX,	"DCMPLX",	0,0,0,		"C2:*:X=N*,Y=!S*")
! DEFIMP	(DCOS,		"DCOS",		L_COS,DCOS,0,	"R2:-:X=R2")
! DEFIMP	(DCOSH,		"DCOSH",	L_COSH,DCOSH,0,	"R2:-:X=R2")
! DEFIMP	(DDIM,		"DDIM",		0,DDIM,0,	"R2:*:X=R2,Y=R2")
! DEFIMP	(DEXP,		"DEXP",		L_EXP,DEXP,0,	"R2:-:X=R2")
! DEFIMP	(DIM,		"DIM",		0,DIM,0,	"S=:*:X=S*,Y=S*")
! DEFIMP	(DINT,		"DINT",		0,DINT,0,	"R2:-:A=R2")
! DEFIMP	(DLOG,		"DLOG",		L_LOG,DLOG,0,	"R2:-:X=R2")
! DEFIMP	(DLOG10,	"DLOG10",	L_LOG10,DLOG10,0,"R2:-:X=R2")
! DEFIMP	(DMAX1,		"DMAX1",	0,0,0,		"R2:*:A=pR2")
! DEFIMP	(DMIN1,		"DMIN1",	0,0,0,		"R2:*:A=pR2")
! DEFIMP	(DMOD,		"DMOD",		L_FMOD,DMOD,0,	"R2:*:A=R2,P=R2")
! DEFIMP	(DNINT,		"DNINT",	0,DNINT,0,	"R2:-:A=R2")
! DEFIMP	(DPROD,		"DPROD",	0,DPROD,0,	"R2:*:X=R1,Y=R1")
! DEFIMP	(DSIGN,		"DSIGN",	0,DSIGN,0,	"R2:*:A=R2,B=R2")
! DEFIMP	(DSIN,		"DSIN",		L_SIN,DSIN,0,	"R2:-:X=R2")
! DEFIMP	(DSINH,		"DSINH",	L_SINH,DSINH,0,	"R2:-:X=R2")
! DEFIMP	(DSQRT,		"DSQRT",	L_SQRT,DSQRT,0,	"R2:-:X=R2")
! DEFIMP	(DTAN,		"DTAN",		L_TAN,DTAN,0,	"R2:-:X=R2")
! DEFIMP	(DTANH,		"DTANH",	L_TANH,DTANH,0,	"R2:-:X=R2")
! DEFIMP	(EXP,		"EXP",		L_EXP,EXP,0,	"F=:0:X=F*")
! DEFIMP	(FLOAT,		"FLOAT",	0,0,0,		"R1:-:A=I*")
! DEFIMP	(IABS,		"IABS",		0,IABS,IABS,	"I1:-:A=I1")
! DEFIMP	(ICHAR,		"ICHAR",	0,0,0,		"I1:-:C=A*")
! DEFIMP	(IDIM,		"IDIM",		0,IDIM,IDIM,	"I1:*:X=I1,Y=I1")
! DEFIMP	(IDINT,		"IDINT",	0,0,0,		"I1:-:A=R2")
! DEFIMP	(IDNINT,	"IDNINT",	0,IDNINT,IDNINT,"I1:-:A=R2")
! DEFIMP	(IFIX,		"IFIX",		0,0,0,		"I1:-:A=R1")
! DEFIMP	(INDEX,		"INDEX",	0,INDEX,INDEX,	"I1:*:String=A*,Substring=A*")
! DEFIMP	(INT,		"INT",		0,0,0,		"I1:-:A=N*")
! DEFIMP	(ISIGN,		"ISIGN",	0,ISIGN,ISIGN,	"I1:*:A=I1,B=I1")
! DEFIMP	(LEN,		"LEN",		0,LEN,LEN,	"I1:-:String=A*i")
! DEFIMP	(LGE,		"LGE",		0,LGE,LGE,	"L1:*:String_A=A1,String_B=A1")
! DEFIMP	(LGT,		"LGT",		0,LGT,LGT,	"L1:*:String_A=A1,String_B=A1")
! DEFIMP	(LLE,		"LLE",		0,LLE,LLE,	"L1:*:String_A=A1,String_B=A1")
! DEFIMP	(LLT,		"LLT",		0,LLT,LLT,	"L1:*:String_A=A1,String_B=A1")
! DEFIMP	(LOG,		"LOG",		L_LOG,ALOG,0,	"F=:0:X=F*")
! DEFIMP	(LOG10,		"LOG10",	L_LOG10,ALOG10,0,"R=:0:X=R*")
! DEFIMP	(MAX,		"MAX",		0,0,0,		"S=:*:A=pS*")
! DEFIMP	(MIN,		"MIN",		0,0,0,		"S=:*:A=pS*")
! DEFIMP	(MAX0,		"MAX0",		0,0,0,		"I1:*:A=pI1")
! DEFIMP	(MAX1,		"MAX1",		0,0,0,		"I1:*:A=pR1")
! DEFIMP	(MIN0,		"MIN0",		0,0,0,		"I1:*:A=pI1")
! DEFIMP	(MIN1,		"MIN1",		0,0,0,		"I1:*:A=pR1")
! DEFIMP	(MOD,		"MOD",		0,MOD,MOD,	"S=:*:A=S*,P=S*")
! DEFIMP	(NINT,		"NINT",		0,NINT,NINT,	"I1:-:A=R*")
! DEFIMP	(REAL,		"REAL",		0,0,0,		"RC:0:A=N*")
! DEFIMP	(SIGN,		"SIGN",		0,SIGN,0,	"S=:*:A=S*,B=S*")
! DEFIMP	(SIN,		"SIN",		L_SIN,SIN,0,	"F=:0:X=F*")
! DEFIMP	(SINH,		"SINH",		L_SINH,SINH,0,	"R=:0:X=R*")
! DEFIMP	(SNGL,		"SNGL",		0,0,0,		"R1:-:A=R2")
! DEFIMP	(SQRT,		"SQRT",		L_SQRT,SQRT,0,	"F=:0:X=F*")
! DEFIMP	(TAN,		"TAN",		L_TAN,TAN,0,	"R=:0:X=R*")
! DEFIMP	(TANH,		"TANH",		L_TANH,TANH,0,	"R=:0:X=R*")
  
! DEFIMP	(ABORT,		"ABORT",	ABORT,0,0,	"--:-:")
! DEFIMP	(ACCESS,	"ACCESS",	ACCESS,0,0,	"I1:-:Name=A1,Mode=A1")
! DEFIMP	(ACHAR,		"ACHAR",	0,0,0,		"A1:-:I=I*")
! DEFIMP	(ALARM,		"ALARM",	ALARM,0,0,	"--:-:Seconds=I*,Handler=s*,Status=?I1w")
! DEFIMP	(AND,		"AND",		0,0,0,		"B=:*:I=B*,J=B*")
! DEFIMP	(BESJ0,		"BESJ0",	L_BESJ0,0,0,	"R=:0:X=R*")
! DEFIMP	(BESJ1,		"BESJ1",	L_BESJ1,0,0,	"R=:0:X=R*")
! DEFIMP	(BESJN,		"BESJN",	L_BESJN,0,0,	"R=:1:N=IN,X=R*")
! DEFIMP	(BESY0,		"BESY0",	L_BESY0,0,0,	"R=:0:X=R*")
! DEFIMP	(BESY1,		"BESY1",	L_BESY1,0,0,	"R=:0:X=R*")
! DEFIMP	(BESYN,		"BESYN",	L_BESYN,0,0,	"R=:1:N=IN,X=R*")
! DEFIMP	(BIT_SIZE,	"BIT_SIZE",	0,0,0,		"I=:0:I=I*i")
! DEFIMP	(BTEST,		"BTEST",	0,0,0,		"L1:*:I=I*,Pos=I*")
! DEFIMP	(CDABS,		"CDABS",	0,CDABS,0,	"R2:-:A=C2")
! DEFIMP	(CDCOS,		"CDCOS",	0,CDCOS,0,	"C2:-:X=C2")
! DEFIMP	(CDEXP,		"CDEXP",	0,CDEXP,0,	"C2:-:X=C2")
! DEFIMP	(CDLOG,		"CDLOG",	0,CDLOG,0,	"C2:-:X=C2")
! DEFIMP	(CDSIN,		"CDSIN",	0,CDSIN,0,	"C2:-:X=C2")
! DEFIMP	(CDSQRT,	"CDSQRT",	0,CDSQRT,0,	"C2:-:X=C2")
! DEFIMP	(CHDIR_func,	"CHDIR_func",	CHDIR,0,0,	"I1:-:Dir=A1")
! DEFIMP	(CHDIR_subr,	"CHDIR_subr",	CHDIR,0,0,	"--:-:Dir=A1,Status=?I1w")
! DEFIMP	(CHMOD_func,	"CHMOD_func",	CHMOD,0,0,	"I1:-:Name=A1,Mode=A1")
! DEFIMP	(CHMOD_subr,	"CHMOD_subr",	CHMOD,0,0,	"--:-:Name=A1,Mode=A1,Status=?I1w")
! DEFIMP	(COMPLEX,	"COMPLEX",	0,0,0,		"C=:*:Real=S*,Imag=S*")
! DEFIMP	(CPU_TIME,	"CPU_TIME",	SECOND,0,0,	"--:-:Seconds=R*w")
! DEFIMP	(CTIME_func,	"CTIME_func",	CTIME,0,0,	"A1*:-:STime=I*")
! DEFIMP	(CTIME_subr,	"CTIME_subr",	CTIME,0,0,	"--:-:STime=I*,Result=A1w")
! DEFIMPY	(DATE,		"DATE",		DATE,0,0,	"--:-:Date=A1w",	TRUE)
! DEFIMP	(DATE_AND_TIME,	"DATE_AND_TIME", DATE_AND_TIME,0,0, "--:-:Date=A1w,Time=?A1w,Zone=?A1w,Values=?I1(8)w")
! DEFIMP	(DBESJ0,	"DBESJ0",	L_BESJ0,0,0,	"R2:-:X=R2")
! DEFIMP	(DBESJ1,	"DBESJ1",	L_BESJ1,0,0,	"R2:-:X=R2")
! DEFIMP	(DBESJN,	"DBESJN",	L_BESJN,0,0,	"R2:-:N=IN,X=R2")
! DEFIMP	(DBESY0,	"DBESY0",	L_BESY0,0,0,	"R2:-:X=R2")
! DEFIMP	(DBESY1,	"DBESY1",	L_BESY1,0,0,	"R2:-:X=R2")
! DEFIMP	(DBESYN,	"DBESYN",	L_BESYN,0,0,	"R2:-:N=IN,X=R2")
! DEFIMP	(DCONJG,	"DCONJG",	0,DCONJG,0,	"C2:-:Z=C2")
! DEFIMP	(DERF,		"DERF",		L_ERF,DERF,0,	"R2:-:X=R2")
! DEFIMP	(DERFC,		"DERFC",	L_ERFC,DERFC,0,	"R2:-:X=R2")
! DEFIMP	(DFLOAT,	"DFLOAT",	0,0,0,		"R2:-:A=I*")
! DEFIMP	(DIMAG,		"DIMAG",	0,DIMAG,0,	"R2:-:Z=C2")
! DEFIMP	(DREAL,		"DREAL",	0,0,0,		"R2:-:A=N*")
! DEFIMP	(DTIME_func,	"DTIME_func",	DTIME,0,0,	"R1:-:TArray=R1(2)w")
! DEFIMP	(DTIME_subr,	"DTIME_subr",	DTIME,0,0,	"--:-:TArray=R1(2)w,Result=R1w")
! DEFIMP	(ERF,		"ERF",		L_ERF,ERF,0,	"R=:0:X=R*")
! DEFIMP	(ERFC,		"ERFC",		L_ERFC,ERFC,0,	"R=:0:X=R*")
! DEFIMP	(ETIME_func,	"ETIME_func",	ETIME,0,0,	"R1:-:TArray=R1(2)w")
! DEFIMP	(ETIME_subr,	"ETIME_subr",	ETIME,0,0,	"--:-:TArray=R1(2)w,Result=R1w")
! DEFIMP	(EXIT,		"EXIT",		EXIT,0,0,	"--:-:Status=?IN")
! DEFIMP	(FDATE_func,	"FDATE_func",	FDATE,0,0,	"A1*:-:")
! DEFIMP	(FDATE_subr,	"FDATE_subr",	FDATE,0,0,	"--:-:Date=A1w")
! DEFIMP	(FGET_func,	"FGET_func",	FGET,0,0,	"I1:-:C=A1w")
! DEFIMP	(FGET_subr,	"FGET_subr",	FGET,0,0,	"--:-:C=A1w,Status=?I1w")
! DEFIMP	(FGETC_func,	"FGETC_func",	FGETC,0,0,	"I1:-:Unit=I*,C=A1w")
! DEFIMP	(FGETC_subr,	"FGETC_subr",	FGETC,0,0,	"--:-:Unit=I*,C=A1w,Status=?I1w")
! DEFIMP	(FLUSH,		"FLUSH",	0,0,0,		"--:-:Unit=?I*")
! DEFIMP	(FNUM,		"FNUM",		FNUM,0,0,	"I1:-:Unit=I*")
! DEFIMP	(FPUT_func,	"FPUT_func",	FPUT,0,0,	"I1:-:C=A1")
! DEFIMP	(FPUT_subr,	"FPUT_subr",	FPUT,0,0,	"--:-:C=A1,Status=?I1w")
! DEFIMP	(FPUTC_func,	"FPUTC_func",	FPUTC,0,0,	"I1:-:Unit=I*,C=A1")
! DEFIMP	(FPUTC_subr,	"FPUTC_subr",	FPUTC,0,0,	"--:-:Unit=I*,C=A1,Status=?I1w")
! DEFIMP	(FSEEK,		"FSEEK",	FSEEK,0,0,	"--:-:Unit=I*,Offset=I*,Whence=I*,ErrLab=?g*")
! DEFIMP	(FSTAT_func,	"FSTAT_func",	FSTAT,0,0,	"I1:-:Unit=I*,SArray=I1(13)w")
! DEFIMP	(FSTAT_subr,	"FSTAT_subr",	FSTAT,0,0,	"--:-:Unit=I*,SArray=I1(13)w,Status=?I1w")
! DEFIMP	(FTELL_func,	"FTELL_func",	FTELL,0,0,	"I1:-:Unit=I*")
! DEFIMP	(FTELL_subr,	"FTELL_subr",	FTELL,0,0,	"--:-:Unit=I*,Offset=I1w")
! DEFIMP	(GERROR,	"GERROR",	GERROR,0,0,	"--:-:Message=A1w")
! DEFIMP	(GETARG,	"GETARG",	GETARG,0,0,	"--:-:Pos=IN,Value=A1w")
! DEFIMP	(GETCWD_func,	"GETCWD_func",	GETCWD,0,0,	"I1:-:Name=A1w")
! DEFIMP	(GETCWD_subr,	"GETCWD_subr",	GETCWD,0,0,	"--:-:Name=A1w,Status=?I1w")
! DEFIMP	(GETGID,	"GETGID",	GETGID,0,0,	"I1:-:")
! DEFIMP	(GETLOG,	"GETLOG",	GETLOG,0,0,	"--:-:Login=A1w")
! DEFIMP	(GETPID,	"GETPID",	GETPID,0,0,	"I1:-:")
! DEFIMP	(GETUID,	"GETUID",	GETUID,0,0,	"I1:-:")
! DEFIMP	(GETENV,	"GETENV",	GETENV,0,0,	"--:-:Name=A1,Value=A1w")
! DEFIMP	(GMTIME,	"GMTIME",	GMTIME,0,0,	"--:-:STime=I1,TArray=I1(9)w")
! DEFIMP	(HOSTNM_func,	"HOSTNM_func",	HOSTNM,0,0,	"I1:-:Name=A1w")
! DEFIMP	(HOSTNM_subr,	"HOSTNM_subr",	HOSTNM,0,0,	"--:-:Name=A1w,Status=?I1w")
! DEFIMP	(IACHAR,	"IACHAR",	0,0,0,		"I1:-:C=A*")
! DEFIMP	(IAND,		"IAND",		0,0,0,		"I=:*:I=I*,J=I*")
! DEFIMP	(IARGC,		"IARGC",	IARGC,0,0,	"I1:-:")
! DEFIMP	(IBCLR,		"IBCLR",	0,0,0,		"I=:0:I=I*,Pos=I*")
! DEFIMP	(IBITS,		"IBITS",	0,0,0,		"I=:0:I=I*,Pos=I*,Len=I*")
! DEFIMP	(IBSET,		"IBSET",	0,0,0,		"I=:0:I=I*,Pos=I*")
! DEFIMP	(IDATE_unix,	"IDATE_unix",	IDATE,0,0,	"--:-:TArray=I1(3)w")
! DEFIMPY	(IDATE_vxt,	"IDATE_vxt",	VXTIDATE,0,0,	"--:-:M=I1w,D=I1w,Y=I1w",	TRUE)
! DEFIMP	(IEOR,		"IEOR",		0,0,0,		"I=:*:I=I*,J=I*")
! DEFIMP	(IOR,		"IOR",		0,0,0,		"I=:*:I=I*,J=I*")
! DEFIMP	(IERRNO,	"IERRNO",	IERRNO,0,0,	"I1:-:")
! DEFIMP	(IMAGPART,	"IMAGPART",	0,0,0,		"R=:0:Z=C*")
! DEFIMP	(INT2,		"INT2",		0,0,0,		"I6:-:A=N*")
! DEFIMP	(INT8,		"INT8",		0,0,0,		"I2:-:A=N*")
! DEFIMP	(IRAND,		"IRAND",	IRAND,0,0,	"I1:-:Flag=?I*")
! DEFIMP	(ISATTY,	"ISATTY",	ISATTY,0,0,	"L1:-:Unit=I*")
! DEFIMP	(ISHFT,		"ISHFT",	0,0,0,		"I=:0:I=I*,Shift=I*")
! DEFIMP	(ISHFTC,	"ISHFTC",	0,0,0,		"I=:0:I=I*,Shift=I*,Size=I*")
! DEFIMP	(ITIME,		"ITIME",	ITIME,0,0,	"--:-:TArray=I1(3)w")
! DEFIMP	(KILL_func,	"KILL_func",	KILL,0,0,	"I1:-:Pid=I*,Signal=I*")
! DEFIMP	(KILL_subr,	"KILL_subr",	KILL,0,0,	"--:-:Pid=I*,Signal=I*,Status=?I1w")
! DEFIMP	(LINK_func,	"LINK_func",	LINK,0,0,	"I1:-:Path1=A1,Path2=A1")
! DEFIMP	(LINK_subr,	"LINK_subr",	LINK,0,0,	"--:-:Path1=A1,Path2=A1,Status=?I1w")
! DEFIMP	(LNBLNK,	"LNBLNK",	LNBLNK,0,0,	"I1:-:String=A1")
! DEFIMP	(LONG,		"LONG",		0,0,0,		"I1:-:A=I6")
! DEFIMP	(LSTAT_func,	"LSTAT_func",	LSTAT,0,0,	"I1:-:File=A1,SArray=I1(13)w")
! DEFIMP	(LSTAT_subr,	"LSTAT_subr",	LSTAT,0,0,	"--:-:File=A1,SArray=I1(13)w,Status=?I1w")
! DEFIMP	(LTIME,		"LTIME",	LTIME,0,0,	"--:-:STime=I1,TArray=I1(9)w")
! DEFIMP	(LOC,		"LOC",		0,0,0,		"I7:-:Entity=-*&&")
! DEFIMP	(LSHIFT,	"LSHIFT",	0,0,0,		"I=:0:I=I*,Shift=I*")
! DEFIMP	(MCLOCK,	"MCLOCK",	MCLOCK,0,0,	"I1:-:")
! DEFIMP	(MCLOCK8,	"MCLOCK8",	MCLOCK,0,0,	"I2:-:")
! DEFIMP	(MVBITS,	"MVBITS",	0,0,0,		"--:-:From=I*,FromPos=I*,Len=I*,TO=IAx,ToPos=I*")
! DEFIMP	(NOT,		"NOT",		0,0,0,		"I=:0:I=I*")
! DEFIMP	(OR,		"OR",		0,0,0,		"B=:*:I=B*,J=B*")
! DEFIMP	(PERROR,	"PERROR",	PERROR,0,0,	"--:-:String=A1")
! DEFIMP	(RAND,		"RAND",		RAND,0,0,	"R1:-:Flag=?I*")
! DEFIMP	(REALPART,	"REALPART",	0,0,0,		"R=:0:Z=C*")
! DEFIMP	(RENAME_func,	"RENAME_func",	RENAME,0,0,	"I1:-:Path1=A1,Path2=A1")
! DEFIMP	(RENAME_subr,	"RENAME_subr",	RENAME,0,0,	"--:-:Path1=A1,Path2=A1,Status=?I1w")
! DEFIMP	(RSHIFT,	"RSHIFT",	0,0,0,		"I=:0:I=I*,Shift=I*")
! DEFIMP	(SECNDS,	"SECNDS",	SECNDS,0,0,	"R1:-:T=R1")
! DEFIMP	(SECOND_func,	"SECOND_func",	SECOND,SECOND,0,"R1:-:")
! DEFIMP	(SECOND_subr,	"SECOND_subr",	SECOND,0,0,	"--:-:Seconds=R*w")
! DEFIMP	(SHORT,		"SHORT",	0,0,0,		"I6:-:A=I*")
! DEFIMP	(SIGNAL_func,	"SIGNAL_func",	L_SIGNAL,0,0,	"I7:-:Number=I*,Handler=s*")
! DEFIMP	(SIGNAL_subr,	"SIGNAL_subr",	L_SIGNAL,0,0,	"--:-:Number=I*,Handler=s*,Status=?I7w")
! DEFIMP	(SLEEP,		"SLEEP",	SLEEP,0,0,	"--:-:Seconds=I1")
! DEFIMP	(SRAND,		"SRAND",	SRAND,0,0,	"--:-:Seed=I*")
! DEFIMP	(STAT_func,	"STAT_func",	STAT,0,0,	"I1:-:File=A1,SArray=I1(13)w")
! DEFIMP	(STAT_subr,	"STAT_subr",	STAT,0,0,	"--:-:File=A1,SArray=I1(13)w,Status=?I1w")
! DEFIMP	(SYMLNK_func,	"SYMLNK_func",	SYMLNK,0,0,	"I1:-:Path1=A1,Path2=A1")
! DEFIMP	(SYMLNK_subr,	"SYMLNK_subr",	SYMLNK,0,0,	"--:-:Path1=A1,Path2=A1,Status=?I1w")
  DEFIMP	(SYSTEM_func,	"SYSTEM_func",	SYSTEM,SYSTEM,SYSTEM,"I1:-:Command=A1")
! DEFIMP	(SYSTEM_subr,	"SYSTEM_subr",	SYSTEM,0,0,	"--:-:Command=A1,Status=?I1w")
! DEFIMP	(SYSTEM_CLOCK,	"SYSTEM_CLOCK",	SYSTEM_CLOCK,0,0,"--:-:Count=I1w,Rate=?I1w,Max=?I1w")
! DEFIMP	(TIME8,		"TIME8",	TIME,0,0,	"I2:-:")
! DEFIMP	(TIME_unix,	"TIME_unix",	TIME,0,0,	"I1:-:")
! DEFIMP	(TIME_vxt,	"TIME_vxt",	VXTTIME,0,0,	"--:-:Time=A1[8]w")
! DEFIMP	(TTYNAM_func,	"TTYNAM_func",	TTYNAM,0,0,	"A1*:-:Unit=I*")
! DEFIMP	(TTYNAM_subr,	"TTYNAM_subr",	TTYNAM,0,0,	"--:-:Unit=I*,Name=A1w")
! DEFIMP	(UMASK_func,	"UMASK_func",	UMASK,0,0,	"I1:-:Mask=I*")
! DEFIMP	(UMASK_subr,	"UMASK_subr",	UMASK,0,0,	"--:-:Mask=I*,Old=?I1w")
! DEFIMP	(UNLINK_func,	"UNLINK_func",	UNLINK,0,0,	"I1:-:File=A1")
! DEFIMP	(UNLINK_subr,	"UNLINK_subr",	UNLINK,0,0,	"--:-:File=A1,Status=?I1w")
! DEFIMP	(XOR,		"XOR",		0,0,0,		"B=:*:I=B*,J=B*")
! DEFIMP	(NONE,		"none",		0,0,0,		"")
Index: gcc/gcc/f/lex.c
diff -c gcc/gcc/f/lex.c:1.1.1.1 gcc/gcc/f/lex.c:1.2
*** gcc/gcc/f/lex.c:1.1.1.1	Wed Feb 15 21:22:42 2006
--- gcc/gcc/f/lex.c	Fri Nov 03 16:15:23 2006
***************
*** 364,370 ****
  	  return c;
  
  	default:
! 	  if (c >= 040 && c < 0177)
  	    {
  	      char m[2];
  
--- 364,370 ----
  	  return c;
  
  	default:
! 	  if (ISPRINT(c))
  	    {
  	      char m[2];
  
***************
*** 705,711 ****
  	pedwarn ("non-ISO escape sequence `\\%c'", c);
        return c;
      }
!   if (c >= 040 && c < 0177)
      pedwarn ("unknown escape sequence `\\%c'", c);
    else
      pedwarn ("unknown escape sequence: `\\' followed by char code 0x%x", c);
--- 705,711 ----
  	pedwarn ("non-ISO escape sequence `\\%c'", c);
        return c;
      }
!   if (isprint(c))
      pedwarn ("unknown escape sequence `\\%c'", c);
    else
      pedwarn ("unknown escape sequence: `\\' followed by char code 0x%x", c);
Index: gcc/gcc/f/proj.h
diff -c gcc/gcc/f/proj.h:1.1.1.1 gcc/gcc/f/proj.h:1.2
*** gcc/gcc/f/proj.h:1.1.1.1	Wed Feb 15 21:22:42 2006
--- gcc/gcc/f/proj.h	Fri Nov 03 16:15:23 2006
***************
*** 31,37 ****
  #endif
  #include "system.h"
  
! #if (GCC_VERSION < 2000)
   #error "You have to use gcc 2.x to build g77."
  #endif
  
--- 31,37 ----
  #endif
  #include "system.h"
  
! #if 0 /*(GCC_VERSION < 2000)*/
   #error "You have to use gcc 2.x to build g77."
  #endif
  
Index: gcc/gcc/f/src.c
diff -c gcc/gcc/f/src.c:1.1.1.1 gcc/gcc/f/src.c:1.2
*** gcc/gcc/f/src.c:1.1.1.1	Wed Feb 15 21:22:42 2006
--- gcc/gcc/f/src.c	Wed Feb 15 21:24:30 2006
***************
*** 131,171 ****
  
    if (!ffesrc_ok_match_init_upper_)
      for (i = 'A'; i <= 'Z'; ++i)
!       ffesrc_char_match_init_[i] = FFESRC_INVALID_SYMBOL_CHAR_;
  
!   if (ffesrc_ok_match_init_lower_)
      for (i = 'a'; i <= 'z'; ++i)
!       ffesrc_char_match_init_[i] = TOUPPER (i);
!   else
      for (i = 'a'; i <= 'z'; ++i)
!       ffesrc_char_match_init_[i] = FFESRC_INVALID_SYMBOL_CHAR_;
  
    if (!ffesrc_ok_match_noninit_upper_)
      for (i = 'A'; i <= 'Z'; ++i)
!       ffesrc_char_match_noninit_[i] = FFESRC_INVALID_SYMBOL_CHAR_;
  
!   if (ffesrc_ok_match_noninit_lower_)
      for (i = 'a'; i <= 'z'; ++i)
!       ffesrc_char_match_noninit_[i] = TOUPPER (i);
!   else
      for (i = 'a'; i <= 'z'; ++i)
!       ffesrc_char_match_noninit_[i] = FFESRC_INVALID_SYMBOL_CHAR_;
  
!   if (ffe_case_source () == FFE_caseLOWER)
      for (i = 'A'; i <= 'Z'; ++i)
!       ffesrc_char_source_[i] = TOLOWER (i);
    else if (ffe_case_source () == FFE_caseUPPER)
      for (i = 'a'; i <= 'z'; ++i)
!       ffesrc_char_source_[i] = TOUPPER (i);
  
    if (ffe_case_match () == FFE_caseLOWER)
      for (i = 'A'; i <= 'Z'; ++i)
!       ffesrc_char_internal_init_[i] = TOLOWER (i);
  
    switch (ffe_case_symbol ())
      {
      case FFE_caseLOWER:
!       for (i = 'A'; i <= 'Z'; ++i)
  	{
  	  ffesrc_bad_symbol_init_[i] = FFEBAD_SYMBOL_UPPER_CASE;
  	  ffesrc_bad_symbol_noninit_[i] = FFEBAD_SYMBOL_UPPER_CASE;
--- 131,183 ----
  
    if (!ffesrc_ok_match_init_upper_)
      for (i = 'A'; i <= 'Z'; ++i)
!       if (ISUPPER(i))
!         ffesrc_char_match_init_[i] = FFESRC_INVALID_SYMBOL_CHAR_;
  
!   if (ffesrc_ok_match_init_lower_) {
      for (i = 'a'; i <= 'z'; ++i)
!       if (ISLOWER(i))
!         ffesrc_char_match_init_[i] = TOUPPER (i);
!   } else {
      for (i = 'a'; i <= 'z'; ++i)
!       if (ISLOWER(i))
!         ffesrc_char_match_init_[i] = FFESRC_INVALID_SYMBOL_CHAR_;
!   }
  
    if (!ffesrc_ok_match_noninit_upper_)
      for (i = 'A'; i <= 'Z'; ++i)
!       if (ISUPPER(i))
!         ffesrc_char_match_noninit_[i] = FFESRC_INVALID_SYMBOL_CHAR_;
  
!   if (ffesrc_ok_match_noninit_lower_) {
      for (i = 'a'; i <= 'z'; ++i)
!       if (ISLOWER(i))
!         ffesrc_char_match_noninit_[i] = TOUPPER (i);
!   } else {
      for (i = 'a'; i <= 'z'; ++i)
!       if (ISLOWER(i))
!         ffesrc_char_match_noninit_[i] = FFESRC_INVALID_SYMBOL_CHAR_;
!   }
  
!   if (ffe_case_source () == FFE_caseLOWER) {
      for (i = 'A'; i <= 'Z'; ++i)
!       if (ISUPPER(i))
!         ffesrc_char_source_[i] = TOLOWER (i);
!   }
    else if (ffe_case_source () == FFE_caseUPPER)
      for (i = 'a'; i <= 'z'; ++i)
!       if (ISLOWER(i))
!         ffesrc_char_source_[i] = TOUPPER (i);
  
    if (ffe_case_match () == FFE_caseLOWER)
      for (i = 'A'; i <= 'Z'; ++i)
!       if (ISUPPER(i))
!         ffesrc_char_internal_init_[i] = TOLOWER (i);
  
    switch (ffe_case_symbol ())
      {
      case FFE_caseLOWER:
!       for (i = 'A'; i <= 'Z'; ++i) if (ISUPPER(i))
  	{
  	  ffesrc_bad_symbol_init_[i] = FFEBAD_SYMBOL_UPPER_CASE;
  	  ffesrc_bad_symbol_noninit_[i] = FFEBAD_SYMBOL_UPPER_CASE;
***************
*** 173,179 ****
        break;
  
      case FFE_caseUPPER:
!       for (i = 'a'; i <= 'z'; ++i)
  	{
  	  ffesrc_bad_symbol_init_[i] = FFEBAD_SYMBOL_LOWER_CASE;
  	  ffesrc_bad_symbol_noninit_[i] = FFEBAD_SYMBOL_LOWER_CASE;
--- 185,191 ----
        break;
  
      case FFE_caseUPPER:
!       for (i = 'a'; i <= 'z'; ++i) if (ISLOWER(i))
  	{
  	  ffesrc_bad_symbol_init_[i] = FFEBAD_SYMBOL_LOWER_CASE;
  	  ffesrc_bad_symbol_noninit_[i] = FFEBAD_SYMBOL_LOWER_CASE;
***************
*** 183,189 ****
      case FFE_caseINITCAP:
        for (i = 0; i < 256; ++i)
  	ffesrc_bad_symbol_noninit_[i] = FFEBAD_SYMBOL_NOLOWER_INITCAP;
!       for (i = 'a'; i <= 'z'; ++i)
  	{
  	  ffesrc_bad_symbol_init_[i] = FFEBAD_SYMBOL_LOWER_INITCAP;
  	  ffesrc_bad_symbol_noninit_[i] = FFEBAD;
--- 195,201 ----
      case FFE_caseINITCAP:
        for (i = 0; i < 256; ++i)
  	ffesrc_bad_symbol_noninit_[i] = FFEBAD_SYMBOL_NOLOWER_INITCAP;
!       for (i = 'a'; i <= 'z'; ++i) if (ISLOWER(i))
  	{
  	  ffesrc_bad_symbol_init_[i] = FFEBAD_SYMBOL_LOWER_INITCAP;
  	  ffesrc_bad_symbol_noninit_[i] = FFEBAD;
Index: gcc/gcc/fixinc/mkfixinc.sh
diff -c gcc/gcc/fixinc/mkfixinc.sh:1.1.1.1 gcc/gcc/fixinc/mkfixinc.sh:1.4
*** gcc/gcc/fixinc/mkfixinc.sh:1.1.1.1	Wed Feb 15 21:22:48 2006
--- gcc/gcc/fixinc/mkfixinc.sh	Fri Nov 03 18:10:08 2006
***************
*** 71,76 ****
--- 71,77 ----
      hppa1.1-*-bsd* | \
      hppa1.0-*-bsd* | \
      hppa*-*-lites* | \
+     i370-*-openedition | \
      i?86-moss-msdos* | \
      i?86-*-moss* | \
      i?86-*-osf1* | \
Index: gcc/include/ansidecl.h
diff -c gcc/include/ansidecl.h:1.1.1.1 gcc/include/ansidecl.h:1.4
*** gcc/include/ansidecl.h:1.1.1.1	Wed Feb 15 21:23:44 2006
--- gcc/include/ansidecl.h	Sat Nov 10 10:06:21 2007
***************
*** 136,141 ****
--- 136,145 ----
  #define GCC_VERSION (__GNUC__ * 1000 + __GNUC_MINOR__)
  #endif /* GCC_VERSION */
  
+ #ifndef GCC_VERSION_REAL
+ #define GCC_VERSION_REAL (__GNUC__ * 1000 + __GNUC_MINOR__)
+ #endif /* GCC_VERSION_REAL */
+ 
  #if defined (__STDC__) || defined (_AIX) || (defined (__mips) && defined (_SYSTYPE_SVR4)) || defined(_WIN32)
  /* All known AIX compilers implement these things (but don't always
     define __STDC__).  The RISC/OS MIPS compiler defines these things
***************
*** 277,283 ****
  /* We use __extension__ in some places to suppress -pedantic warnings
     about GCC extensions.  This feature didn't work properly before
     gcc 2.8.  */
! #if GCC_VERSION < 2008
  #define __extension__
  #endif
  
--- 281,290 ----
  /* We use __extension__ in some places to suppress -pedantic warnings
     about GCC extensions.  This feature didn't work properly before
     gcc 2.8.  */
! /* note - for MVS we need to keep this on in order to support
!    -pedantic-errors, even though we've dummied up the GCC_VERSION, 
!    so we use GCC_VERSION_REAL to activate it */
! #if GCC_VERSION_REAL < 2008
  #define __extension__
  #endif
  
Index: gcc/include/obstack.h
diff -c gcc/include/obstack.h:1.1.1.1 gcc/include/obstack.h:1.3
*** gcc/include/obstack.h:1.1.1.1	Wed Feb 15 21:23:44 2006
--- gcc/include/obstack.h	Fri Jun 22 21:10:15 2007
***************
*** 343,349 ****
  
  #endif
  
! #define obstack_1grow_fast(h,achar) (*((h)->next_free)++ = achar)
  
  #define obstack_blank_fast(h,n) ((h)->next_free += (n))
  
--- 343,349 ----
  
  #endif
  
! #define obstack_1grow_fast(h,achar) (*((h)->next_free)++ = (achar))
  
  #define obstack_blank_fast(h,n) ((h)->next_free += (n))
  
***************
*** 411,417 ****
  ({ struct obstack *__o = (OBSTACK);					\
     if (__o->next_free + 1 > __o->chunk_limit)				\
       _obstack_newchunk (__o, 1);					\
!    *(__o->next_free)++ = (datum);					\
     (void) 0; })
  
  /* These assume that the obstack alignment is good enough for pointers or ints,
--- 411,417 ----
  ({ struct obstack *__o = (OBSTACK);					\
     if (__o->next_free + 1 > __o->chunk_limit)				\
       _obstack_newchunk (__o, 1);					\
!    obstack_1grow_fast (__o, datum);					\
     (void) 0; })
  
  /* These assume that the obstack alignment is good enough for pointers or ints,
***************
*** 423,441 ****
  ({ struct obstack *__o = (OBSTACK);					\
     if (__o->next_free + sizeof (void *) > __o->chunk_limit)		\
       _obstack_newchunk (__o, sizeof (void *));				\
!    *((void **)__o->next_free)++ = ((void *)datum);			\
!    (void) 0; })
  
  # define obstack_int_grow(OBSTACK,datum)				\
  __extension__								\
  ({ struct obstack *__o = (OBSTACK);					\
     if (__o->next_free + sizeof (int) > __o->chunk_limit)		\
       _obstack_newchunk (__o, sizeof (int));				\
!    *((int *)__o->next_free)++ = ((int)datum);				\
     (void) 0; })
  
! # define obstack_ptr_grow_fast(h,aptr) (*((void **) (h)->next_free)++ = (void *)aptr)
! # define obstack_int_grow_fast(h,aint) (*((int *) (h)->next_free)++ = (int) aint)
  
  # define obstack_blank(OBSTACK,length)					\
  __extension__								\
--- 423,450 ----
  ({ struct obstack *__o = (OBSTACK);					\
     if (__o->next_free + sizeof (void *) > __o->chunk_limit)		\
       _obstack_newchunk (__o, sizeof (void *));				\
!    obstack_ptr_grow_fast (__o, datum); })
  
  # define obstack_int_grow(OBSTACK,datum)				\
  __extension__								\
  ({ struct obstack *__o = (OBSTACK);					\
     if (__o->next_free + sizeof (int) > __o->chunk_limit)		\
       _obstack_newchunk (__o, sizeof (int));				\
!    obstack_int_grow_fast (__o, datum); })
! 
! # define obstack_ptr_grow_fast(OBSTACK,aptr)				\
! __extension__								\
! ({ struct obstack *__o1 = (OBSTACK);					\
!    *(const void **) __o1->next_free = (aptr);				\
!    __o1->next_free += sizeof (const void *);				\
     (void) 0; })
  
! # define obstack_int_grow_fast(OBSTACK,aint)				\
! __extension__								\
! ({ struct obstack *__o1 = (OBSTACK);					\
!    *(int *) __o1->next_free = (aint);					\
!    __o1->next_free += sizeof (int);					\
!    (void) 0; })
  
  # define obstack_blank(OBSTACK,length)					\
  __extension__								\
***************
*** 443,449 ****
     int __len = (length);						\
     if (__o->chunk_limit - __o->next_free < __len)			\
       _obstack_newchunk (__o, __len);					\
!    __o->next_free += __len;						\
     (void) 0; })
  
  # define obstack_alloc(OBSTACK,length)					\
--- 452,458 ----
     int __len = (length);						\
     if (__o->chunk_limit - __o->next_free < __len)			\
       _obstack_newchunk (__o, __len);					\
!    obstack_blank_fast (__o, __len);					\
     (void) 0; })
  
  # define obstack_alloc(OBSTACK,length)					\
***************
*** 530,555 ****
  # define obstack_1grow(h,datum)						\
  ( (((h)->next_free + 1 > (h)->chunk_limit)				\
     ? (_obstack_newchunk ((h), 1), 0) : 0),				\
!   (*((h)->next_free)++ = (datum)))
  
  # define obstack_ptr_grow(h,datum)					\
  ( (((h)->next_free + sizeof (char *) > (h)->chunk_limit)		\
     ? (_obstack_newchunk ((h), sizeof (char *)), 0) : 0),		\
!   (*((char **) (((h)->next_free+=sizeof(char *))-sizeof(char *))) = ((char *) datum)))
  
  # define obstack_int_grow(h,datum)					\
  ( (((h)->next_free + sizeof (int) > (h)->chunk_limit)			\
     ? (_obstack_newchunk ((h), sizeof (int)), 0) : 0),			\
!   (*((int *) (((h)->next_free+=sizeof(int))-sizeof(int))) = ((int) datum)))
  
! # define obstack_ptr_grow_fast(h,aptr) (*((char **) (h)->next_free)++ = (char *) aptr)
! # define obstack_int_grow_fast(h,aint) (*((int *) (h)->next_free)++ = (int) aint)
  
  # define obstack_blank(h,length)					\
  ( (h)->temp = (length),							\
    (((h)->chunk_limit - (h)->next_free < (h)->temp)			\
     ? (_obstack_newchunk ((h), (h)->temp), 0) : 0),			\
!   ((h)->next_free += (h)->temp))
  
  # define obstack_alloc(h,length)					\
   (obstack_blank ((h), (length)), obstack_finish ((h)))
--- 539,567 ----
  # define obstack_1grow(h,datum)						\
  ( (((h)->next_free + 1 > (h)->chunk_limit)				\
     ? (_obstack_newchunk ((h), 1), 0) : 0),				\
!   obstack_1grow_fast (h, datum))
  
  # define obstack_ptr_grow(h,datum)					\
  ( (((h)->next_free + sizeof (char *) > (h)->chunk_limit)		\
     ? (_obstack_newchunk ((h), sizeof (char *)), 0) : 0),		\
!   obstack_ptr_grow_fast (h, datum))
  
  # define obstack_int_grow(h,datum)					\
  ( (((h)->next_free + sizeof (int) > (h)->chunk_limit)			\
     ? (_obstack_newchunk ((h), sizeof (int)), 0) : 0),			\
!   obstack_int_grow_fast (h, datum))
! 
! # define obstack_ptr_grow_fast(h,aptr)					\
!   (((const void **) ((h)->next_free += sizeof (void *)))[-1] = (aptr))
  
! # define obstack_int_grow_fast(h,aint)					\
!   (((int *) ((h)->next_free += sizeof (int)))[-1] = (aptr))
  
  # define obstack_blank(h,length)					\
  ( (h)->temp = (length),							\
    (((h)->chunk_limit - (h)->next_free < (h)->temp)			\
     ? (_obstack_newchunk ((h), (h)->temp), 0) : 0),			\
!   obstack_blank_fast (h, (h)->temp))
  
  # define obstack_alloc(h,length)					\
   (obstack_blank ((h), (length)), obstack_finish ((h)))
Index: gcc/include/safe-ctype.h
diff -c gcc/include/safe-ctype.h:1.1.1.1 gcc/include/safe-ctype.h:1.2
*** gcc/include/safe-ctype.h:1.1.1.1	Wed Feb 15 21:23:44 2006
--- gcc/include/safe-ctype.h	Wed Feb 15 21:24:30 2006
***************
*** 99,103 ****
--- 99,109 ----
  #define TOUPPER(c) _sch_toupper[(c) & 0xff]
  #define TOLOWER(c) _sch_tolower[(c) & 0xff]
  
+ /* Character conversion.  */
+ extern const unsigned char _sch_ebcasc[256];
+ extern const unsigned char _sch_ascebc[256];
+ #define EBCTOASC(c) _sch_ebcasc[(c) & 0xff]
+ #define ASCTOEBC(c) _sch_ascebc[(c) & 0xff]
+ 
  #endif /* no ctype.h */
  #endif /* SAFE_CTYPE_H */
Index: gcc/libiberty/concat.c
diff -c gcc/libiberty/concat.c:1.1.1.1 gcc/libiberty/concat.c:1.3
*** gcc/libiberty/concat.c:1.1.1.1	Wed Feb 15 21:23:46 2006
--- gcc/libiberty/concat.c	Fri Nov 03 17:01:00 2006
***************
*** 49,55 ****
--- 49,57 ----
  #endif
  #include "ansidecl.h"
  #include "libiberty.h"
+ #ifdef HAVE_SYS_TYPES_H
  #include <sys/types.h>		/* size_t */
+ #endif
  
  #ifdef ANSI_PROTOTYPES
  #include <stdarg.h>
Index: gcc/libiberty/cplus-dem.c
diff -c gcc/libiberty/cplus-dem.c:1.1.1.1 gcc/libiberty/cplus-dem.c:1.3
*** gcc/libiberty/cplus-dem.c:1.1.1.1	Wed Feb 15 21:23:47 2006
--- gcc/libiberty/cplus-dem.c	Fri Nov 03 17:01:00 2006
***************
*** 36,42 ****
--- 36,44 ----
  
  #include "safe-ctype.h"
  
+ #ifdef HAVE_SYS_TYPES_H
  #include <sys/types.h>
+ #endif
  #include <string.h>
  #include <stdio.h>
  
Index: gcc/libiberty/getpagesize.c
diff -c gcc/libiberty/getpagesize.c:1.1.1.1 gcc/libiberty/getpagesize.c:1.3
*** gcc/libiberty/getpagesize.c:1.1.1.1	Wed Feb 15 21:23:47 2006
--- gcc/libiberty/getpagesize.c	Fri Nov 03 17:01:00 2006
***************
*** 24,30 ****
--- 24,32 ----
  
  #include "config.h"
  
+ #ifdef HAVE_SYS_TYPES_H
  #include <sys/types.h>
+ #endif
  #ifdef HAVE_SYS_PARAM_H
  #include <sys/param.h>
  #endif
Index: gcc/libiberty/hashtab.c
diff -c gcc/libiberty/hashtab.c:1.1.1.1 gcc/libiberty/hashtab.c:1.3
*** gcc/libiberty/hashtab.c:1.1.1.1	Wed Feb 15 21:23:47 2006
--- gcc/libiberty/hashtab.c	Fri Nov 03 17:01:01 2006
***************
*** 35,41 ****
--- 35,43 ----
  #include "config.h"
  #endif
  
+ #ifdef HAVE_SYS_TYPES_H
  #include <sys/types.h>
+ #endif
  
  #ifdef HAVE_STDLIB_H
  #include <stdlib.h>
Index: gcc/libiberty/hex.c
diff -c gcc/libiberty/hex.c:1.1.1.1 gcc/libiberty/hex.c:1.5
*** gcc/libiberty/hex.c:1.1.1.1	Wed Feb 15 21:23:47 2006
--- gcc/libiberty/hex.c	Fri Nov 03 18:12:44 2006
***************
*** 1,5 ****
--- 1,6 ----
  /* Hex character manipulation support.
     Copyright (C) 1995, 2001 Free Software Foundation, Inc.
+    EBCDIC support by Dave Pitts <dpitts@cozx.com>.
  
  This file is part of the libiberty library.
  Libiberty is free software; you can redistribute it and/or
***************
*** 20,31 ****
  #include <stdio.h>  /* for EOF */
  #include "libiberty.h"
  
- /* Provided for ABI compatibility.  */
- void
- hex_init ()
- {
- }
- 
  /* Are we ASCII? */
  #if '\n' == 0x0A && ' ' == 0x20 && '0' == 0x30 \
    && 'A' == 0x41 && 'a' == 0x61 && '!' == 0x21 \
--- 21,26 ----
***************
*** 106,111 ****
    _hex_bad, _hex_bad, _hex_bad, _hex_bad,
    _hex_bad, _hex_bad, _hex_bad, _hex_bad,
  };
! #else
!  #error "Unsupported host character set"
! #endif /* not ASCII */
--- 101,231 ----
    _hex_bad, _hex_bad, _hex_bad, _hex_bad,
    _hex_bad, _hex_bad, _hex_bad, _hex_bad,
  };
! #define HEX_TABLE_INITIALIZED
! 
! #endif
! 
! /* Are we EBCDIC? CP-1047 */
! #if '\n' == 0x15 && ' ' == 0x40 && '0' == 0xf0 \
!   && 'A' == 0xC1 && 'a' == 0x81 && '!' == 0x5A \
!   && EOF == -1
! 
! const char _hex_value[_hex_array_size] =
! {
!   _hex_bad, _hex_bad, _hex_bad, _hex_bad,
!   _hex_bad, _hex_bad, _hex_bad, _hex_bad,
!   _hex_bad, _hex_bad, _hex_bad, _hex_bad,
!   _hex_bad, _hex_bad, _hex_bad, _hex_bad,
!   _hex_bad, _hex_bad, _hex_bad, _hex_bad,
!   _hex_bad, _hex_bad, _hex_bad, _hex_bad,
!   _hex_bad, _hex_bad, _hex_bad, _hex_bad,
!   _hex_bad, _hex_bad, _hex_bad, _hex_bad,
! 
!   _hex_bad, _hex_bad, _hex_bad, _hex_bad,
!   _hex_bad, _hex_bad, _hex_bad, _hex_bad,
!   _hex_bad, _hex_bad, _hex_bad, _hex_bad,
!   _hex_bad, _hex_bad, _hex_bad, _hex_bad,
!   _hex_bad, _hex_bad, _hex_bad, _hex_bad,       
!   _hex_bad, _hex_bad, _hex_bad, _hex_bad,       
!   _hex_bad, _hex_bad, _hex_bad, _hex_bad,
!   _hex_bad, _hex_bad, _hex_bad, _hex_bad,
! 
!   _hex_bad, _hex_bad, _hex_bad, _hex_bad,      
!   _hex_bad, _hex_bad, _hex_bad, _hex_bad,
!   _hex_bad, _hex_bad, _hex_bad, _hex_bad,
!   _hex_bad, _hex_bad, _hex_bad, _hex_bad,
!   _hex_bad, _hex_bad, _hex_bad, _hex_bad,
!   _hex_bad, _hex_bad, _hex_bad, _hex_bad,
!   _hex_bad, _hex_bad, _hex_bad, _hex_bad,
!   _hex_bad, _hex_bad, _hex_bad, _hex_bad,
! 
!   _hex_bad, _hex_bad, _hex_bad, _hex_bad,     
!   _hex_bad, _hex_bad, _hex_bad, _hex_bad,
!   _hex_bad, _hex_bad, _hex_bad, _hex_bad,
!   _hex_bad, _hex_bad, _hex_bad, _hex_bad,
!   _hex_bad, _hex_bad, _hex_bad, _hex_bad,
!   _hex_bad, _hex_bad, _hex_bad, _hex_bad,
!   _hex_bad, _hex_bad, _hex_bad, _hex_bad,
!   _hex_bad, _hex_bad, _hex_bad, _hex_bad,
! 
!   _hex_bad, 10,       11,       12,       /*     a   b   c   */
!   13,       14,       15,       _hex_bad, /* d   e   f   g   */
!   _hex_bad, _hex_bad, _hex_bad, _hex_bad, /* h   i           */
!   _hex_bad, _hex_bad, _hex_bad, _hex_bad,
!   _hex_bad, _hex_bad, _hex_bad, _hex_bad, /*     j   k   l   */
!   _hex_bad, _hex_bad, _hex_bad, _hex_bad, /* m   n   o   p   */
!   _hex_bad, _hex_bad, _hex_bad, _hex_bad, /* q   r           */
!   _hex_bad, _hex_bad, _hex_bad, _hex_bad,
! 
!   _hex_bad, _hex_bad, _hex_bad, _hex_bad, /*         s   t   */
!   _hex_bad, _hex_bad, _hex_bad, _hex_bad, /* u   v   w   x   */
!   _hex_bad, _hex_bad, _hex_bad, _hex_bad, /* y   z           */
!   _hex_bad, _hex_bad, _hex_bad, _hex_bad,
!   _hex_bad, _hex_bad, _hex_bad, _hex_bad,
!   _hex_bad, _hex_bad, _hex_bad, _hex_bad,
!   _hex_bad, _hex_bad, _hex_bad, _hex_bad,
!   _hex_bad, _hex_bad, _hex_bad, _hex_bad,
! 
!   _hex_bad, 10,       11,       12,       /*     A   B   C   */
!   13,       14,       15,       _hex_bad, /* D   E   F   G   */
!   _hex_bad, _hex_bad, _hex_bad, _hex_bad, /* H   I           */
!   _hex_bad, _hex_bad, _hex_bad, _hex_bad,
!   _hex_bad, _hex_bad, _hex_bad, _hex_bad, /*     J   K   L   */
!   _hex_bad, _hex_bad, _hex_bad, _hex_bad, /* M   N   O   P   */
!   _hex_bad, _hex_bad, _hex_bad, _hex_bad, /* Q   R           */
!   _hex_bad, _hex_bad, _hex_bad, _hex_bad,
! 
!   _hex_bad, _hex_bad, _hex_bad, _hex_bad, /*         S   T   */
!   _hex_bad, _hex_bad, _hex_bad, _hex_bad, /* U   V   W   X   */
!   _hex_bad, _hex_bad, _hex_bad, _hex_bad, /* Y   Z           */
!   _hex_bad, _hex_bad, _hex_bad, _hex_bad,
!   0,        1,        2,        3,        /* 0   1   2   3   */
!   4,        5,        6,        7,        /* 4   5   6   7   */
!   8,        9,        _hex_bad, _hex_bad, /* 8   9           */
!   _hex_bad, _hex_bad, _hex_bad, _hex_bad,
! };
! #define HEX_TABLE_INITIALIZED
! 
! #endif /* EBCDIC */
! 
! #ifndef HEX_TABLE_INITIALIZED
! 
! const char _hex_value[_hex_array_size];
! 
! #endif /* neither ASCII nor EBCDIC */
! 
! void
! hex_init ()
! {
! #ifndef HEX_TABLE_INITIALIZED
!   int i;
! 
!   for (i=0; i<_hex_array_size; i++)
!     {
!       switch (i)
! 	{
! 	case '0': _hex_value[i] = 0; break;
! 	case '1': _hex_value[i] = 1; break;
! 	case '2': _hex_value[i] = 2; break;
! 	case '3': _hex_value[i] = 3; break;
! 	case '4': _hex_value[i] = 4; break;
! 	case '5': _hex_value[i] = 5; break;
! 	case '6': _hex_value[i] = 6; break;
! 	case '7': _hex_value[i] = 7; break;
! 	case '8': _hex_value[i] = 8; break;
! 	case '9': _hex_value[i] = 9; break;
! 
! 	case 'a': case 'A': _hex_value[i] = 10; break;
! 	case 'b': case 'B': _hex_value[i] = 11; break;
! 	case 'c': case 'C': _hex_value[i] = 12; break;
! 	case 'd': case 'D': _hex_value[i] = 13; break;
! 	case 'e': case 'E': _hex_value[i] = 14; break;
! 	case 'f': case 'F': _hex_value[i] = 15; break;
! 
! 	default:
! 	  _hex_value[i] = _hex_bad;
! 	  break;
! 	}
!     }
! #endif
! }
Index: gcc/libiberty/make-temp-file.c
diff -c gcc/libiberty/make-temp-file.c:1.1.1.1 gcc/libiberty/make-temp-file.c:1.3
*** gcc/libiberty/make-temp-file.c:1.1.1.1	Wed Feb 15 21:23:47 2006
--- gcc/libiberty/make-temp-file.c	Fri Nov 03 17:01:01 2006
***************
*** 22,28 ****
--- 22,30 ----
  #endif
  
  #include <stdio.h>	/* May get P_tmpdir.  */
+ #ifdef HAVE_SYS_TYPES_H
  #include <sys/types.h>
+ #endif
  #ifdef HAVE_UNISTD_H
  #include <unistd.h>
  #endif
Index: gcc/libiberty/md5.c
diff -c gcc/libiberty/md5.c:1.1.1.1 gcc/libiberty/md5.c:1.2
*** gcc/libiberty/md5.c:1.1.1.1	Wed Feb 15 21:23:47 2006
--- gcc/libiberty/md5.c	Mon Aug 17 20:26:54 2009
***************
*** 25,31 ****
--- 25,33 ----
  # include <config.h>
  #endif
  
+ #ifdef HAVE_SYS_TYPES_H
  #include <sys/types.h>
+ #endif
  
  #if STDC_HEADERS || defined _LIBC
  # include <stdlib.h>
Index: gcc/libiberty/obstack.c
diff -c gcc/libiberty/obstack.c:1.1.1.1 gcc/libiberty/obstack.c:1.3
*** gcc/libiberty/obstack.c:1.1.1.1	Wed Feb 15 21:23:47 2006
--- gcc/libiberty/obstack.c	Fri Jun 19 07:40:38 2009
***************
*** 44,52 ****
--- 44,54 ----
  #if !defined (_LIBC) && defined (__GNU_LIBRARY__) && __GNU_LIBRARY__ > 1
  #include <gnu-versions.h>
  #if _GNU_OBSTACK_INTERFACE_VERSION == OBSTACK_INTERFACE_VERSION
+ #if !defined(PUREISO)
  #define ELIDE_CODE
  #endif
  #endif
+ #endif
  
  
  #ifndef ELIDE_CODE
Index: gcc/libiberty/safe-ctype.c
diff -c gcc/libiberty/safe-ctype.c:1.1.1.1 gcc/libiberty/safe-ctype.c:1.5
*** gcc/libiberty/safe-ctype.c:1.1.1.1	Wed Feb 15 21:23:47 2006
--- gcc/libiberty/safe-ctype.c	Fri Apr 24 22:26:47 2009
***************
*** 2,7 ****
--- 2,8 ----
  
     Copyright (C) 2000 Free Software Foundation, Inc.
     Contributed by Zack Weinberg <zackw@stanford.edu>.
+    EBCDIC support by Dave Pitts <dpitts@cozx.com>.
  
  This file is part of the libiberty library.
  Libiberty is free software; you can redistribute it and/or
***************
*** 56,61 ****
--- 57,68 ----
  #define P  pn      |pr	/* punctuation */
  #define _  pn|is   |pr	/* underscore */
  
+ /* don't define anything for characters that can't easily
+    be translated into ASCII. Let them be generated as their
+    hex values, the same way that say a French accented e
+    would be */
+ #define E  0          	/* EBCDIC-only character */
+ 
  #define C           cn	/* control character */
  #define Z  nv      |cn	/* NUL */
  #define M  nv|sp   |cn	/* cursor movement: \f \v */
***************
*** 68,73 ****
--- 75,82 ----
    && 'A' == 0x41 && 'a' == 0x61 && '!' == 0x21 \
    && EOF == -1
  
+ #define _SCH_GOODCHARSET
+ 
  const unsigned short _sch_istable[256] =
  {
    Z,  C,  C,  C,   C,  C,  C,  C,   /* NUL SOH STX ETX  EOT ENQ ACK BEL */
***************
*** 157,163 ****
   224,225,226,227, 228,229,230,231, 232,233,234,235, 236,237,238,239,
   240,241,242,243, 244,245,246,247, 248,249,250,251, 252,253,254,255,
  };
  
! #else
   #error "Unsupported host character set"
! #endif /* not ASCII */
--- 166,393 ----
   224,225,226,227, 228,229,230,231, 232,233,234,235, 236,237,238,239,
   240,241,242,243, 244,245,246,247, 248,249,250,251, 252,253,254,255,
  };
+ #endif
+ 
+ /* Are we EBCDIC? CP-1047 */
+ #if '\n' == 0x15 && ' ' == 0x40 && '0' == 0xf0 \
+   && 'A' == 0xC1 && 'a' == 0x81 && '!' == 0x5A \
+   && EOF == -1
  
! #define _SCH_GOODCHARSET
! 
! const unsigned short _sch_istable[256] =
! {
!   Z,  C,  C,  C,   C,  T,  C,  C,   /* NUL SOH STX ETX  PF  HT  LC  DEL */
!   0,  0,  C,  M,   M,  V,  C,  C,   /*         SMM VT   FF  CR  SO  SI  */
!   C,  C,  C,  C,   C,  V,  C,  C,   /* DLE DC1 DC2 TM   RES NL  BS  IL  */
!   C,  C,  C,  C,   C,  C,  C,  C,   /* CAN EM  CC  CU1 IFS  IGS IRS IUS */
!   C,  C,  C,  0,   C,  C,  C,  C,   /* DS  SOS FS       BYP LF  ETB ESC */
!   0,  0,  C,  C,   0,  C,  C,  C,   /*         SM  CU2      ENQ ACK BEL */
!   0,  0,  C,  0,   C,  C,  C,  C,   /*         SYN      PN  RS  UC  EOT */
!   0,  0,  0,  C,   C,  C,  0,  C,   /*             CU3  DC4 NAK     SUB */
! 
!   S,  0,  0,  0,   0,  0,  0,  0,   /* SP                               */
!   0,  0,  E,  P,   P,  P,  P,  P,   /*         CNT .    <   (   +   |   */
!   P,  0,  0,  0,   0,  0,  0,  0,   /* &                                */
!   0,  0,  P,  P,   P,  P,  P,  P,   /*         !   $    *   )   ;   NOT */
!   P,  P,  0,  0,   0,  0,  0,  0,   /* -   /                            */
!   0,  0,  E,  P,   P,  _,  P,  P,   /*         BRB ,    %   _   >   ?   */
!   0,  0,  0,  0,   0,  0,  0,  0,   /*                                  */
!   0,  P,  P,  P,   P,  P,  P,  P,   /*     `   :   #    @   '   =   "   */
! 
!   0, XL, XL, XL,  XL, XL, XL,  L,   /*     a   b   c    d   e   f   g   */
!   L,  L,  0,  0,   0,  0,  0,  0,   /* h   i                            */
!   0,  L,  L,  L,   L,  L,  L,  L,   /*     j   k   l    m   n   o   p   */
!   L,  L,  0,  0,   0,  0,  0,  0,   /* q   r                            */
!   0,  P,  L,  L,   L,  L,  L,  L,   /*     ~   s   t    u   v   w   x   */
!   L,  L,  0,  0,   0,  P,  0,  0,   /* y   z                [           */
!   0,  0,  0,  0,   0,  0,  0,  0,   /*                                  */
!   0,  0,  0,  0,   0,  P,  0,  0,   /*                      ]           */
! 
!   P, XU, XU, XU,  XU, XU, XU,  U,   /* {   A   B   C    D   E   F   G   */
!   U,  U,  0,  0,   0,  0,  0,  0,   /* H   I                            */
!   P,  U,  U,  U,   U,  U,  U,  U,   /* }   J   K   L    M   N   O   P   */
!   U,  U,  0,  0,   0,  0,  0,  0,   /* Q   R                            */
!   P,  0,  U,  U,   U,  U,  U,  U,   /* \       S   T    U   V   W   X   */
!   U,  U,  0,  0,   0,  0,  0,  0,   /* Y   Z                            */
!   D,  D,  D,  D,   D,  D,  D,  D,   /* 0   1   2   3    4   5   6   7   */
!   D,  D,  0,  0,   0,  0,  0,  0    /* 8   9                            */
! };
! 
! const unsigned char _sch_tolower[256] =
! {
!    0,  
!    1,  2,  3,  4,   5,  6,  7,  8,   9, 10, 11, 12,  13, 14, 15, 16,
!   17, 18, 19, 20,  21, 22, 23, 24,  25, 26, 27, 28,  29, 30, 31, 32,
!   33, 34, 35, 36,  37, 38, 39, 40,  41, 42, 43, 44,  45, 46, 47, 48,
!   49, 50, 51, 52,  53, 54, 55, 56,  57, 58, 59, 60,  61, 62, 63, 64,
!   65, 66, 67, 68,  69, 70, 71, 72,  73, 74, 75, 76,  77, 78, 79, 80,
!   81, 82, 83, 84,  85, 86, 87, 88,  89, 90, 91, 92,  93, 94, 95, 96,
!   97, 98, 99,100, 101,102,103,104, 105,106,106,108, 109,110,111,112,
!  113,114,115,116, 117,118,119,120, 121,122,123,124, 125,126,127,128,
! 
!  'a','b','c','d', 'e','f','g','h', 'i',138,139,140, 141,142,143,144,
!  'j','k','l','m', 'n','o','p','q', 'r',154,155,156, 157,158,159,160,
!  161,'s','t','u', 'v','w','x','y', 'z',170,171,172, 173,174,175,176,
! 
!  177,178,179,180, 181,182,183,184, 185,186,187,188, 189,190,191,192,
!  
!  'a','b','c','d', 'e','f','g','h', 'i',202,203,204, 205,206,207,208,
!  'j','k','l','m', 'n','o','p','q', 'r',218,219,220, 221,222,223,224,
!  225,'s','t','u', 'v','w','x','y', 'z',234,235,236, 237,238,239,240,
!  
!  241,242,243,244, 245,246,247,248, 249,250,251,252, 253,254,255,
! };
! 
! const unsigned char _sch_toupper[256] =
! {
!    0,  
!    1,  2,  3,  4,   5,  6,  7,  8,   9, 10, 11, 12,  13, 14, 15, 16,
!   17, 18, 19, 20,  21, 22, 23, 24,  25, 26, 27, 28,  29, 30, 31, 32,
!   33, 34, 35, 36,  37, 38, 39, 40,  41, 42, 43, 44,  45, 46, 47, 48,
!   49, 50, 51, 52,  53, 54, 55, 56,  57, 58, 59, 60,  61, 62, 63, 64,
!   65, 66, 67, 68,  69, 70, 71, 72,  73, 74, 75, 76,  77, 78, 79, 80,
!   81, 82, 83, 84,  85, 86, 87, 88,  89, 90, 91, 92,  93, 94, 95, 96,
!   97, 98, 99,100, 101,102,103,104, 105,106,106,108, 109,110,111,112,
!  113,114,115,116, 117,118,119,120, 121,122,123,124, 125,126,127,128,
! 
!  'A','B','C','D', 'E','F','G','H', 'I',138,139,140, 141,142,143,144,
!  'J','K','L','M', 'N','O','P','Q', 'R',154,155,156, 157,158,159,160,
!  161,'S','T','U', 'V','W','X','Y', 'Z',170,171,172, 173,174,175,176,
! 
!  177,178,179,180, 181,182,183,184, 185,186,187,188, 189,190,191,192,
!  
!  'A','B','C','D', 'E','F','G','H', 'I',202,203,204, 205,206,207,208,
!  'J','K','L','M', 'N','O','P','Q', 'R',218,219,220, 221,222,223,224,
!  225,'S','T','U', 'V','W','X','Y', 'Z',234,235,236, 237,238,239,240,
!  
!  241,242,243,244, 245,246,247,248, 249,250,251,252, 253,254,255,
! };
! 
! #endif
! 
! #if !defined(_SCH_GOODCHARSET)
   #error "Unsupported host character set"
! #endif /* neither ASCII nor EBCDIC */
! 
! /* ASCII to EBCDIC(CP-1047) conversion table.  */
! const unsigned char _sch_ascebc[256] =
! {
!  /*00  NL    SH    SX    EX    ET    NQ    AK    BL */
!      0x00, 0x01, 0x02, 0x03, 0x37, 0x2D, 0x2E, 0x2F,
!  /*08  BS    HT    LF    VT    FF    CR    SO    SI */
!      0x16, 0x05, 0x15, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
!  /*10  DL    D1    D2    D3    D4    NK    SN    EB */
!      0x10, 0x11, 0x12, 0x13, 0x3C, 0x3D, 0x32, 0x26,
!  /*18  CN    EM    SB    EC    FS    GS    RS    US */
!      0x18, 0x19, 0x3F, 0x27, 0x1C, 0x1D, 0x1E, 0x1F,
!  /*20  SP     !     "     #     $     %     &     ' */
!      0x40, 0x5A, 0x7F, 0x7B, 0x5B, 0x6C, 0x50, 0x7D,
!  /*28   (     )     *     +     ,     -    .      / */
!      0x4D, 0x5D, 0x5C, 0x4E, 0x6B, 0x60, 0x4B, 0x61,
!  /*30   0     1     2     3     4     5     6     7 */
!      0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,
!  /*38   8     9     :     ;     <     =     >     ? */
!      0xF8, 0xF9, 0x7A, 0x5E, 0x4C, 0x7E, 0x6E, 0x6F,
!  /*40   @     A     B     C     D     E     F     G */
!      0x7C, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7,
!  /*48   H     I     J     K     L     M     N     O */
!      0xC8, 0xC9, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6,
!  /*50   P     Q     R     S     T     U     V     W */
!      0xD7, 0xD8, 0xD9, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6,
!  /*58   X     Y     Z     [     \     ]     ^     _ */
!      0xE7, 0xE8, 0xE9, 0xAD, 0xE0, 0xBD, 0x5F, 0x6D,
!  /*60   `     a     b     c     d     e     f     g */
!      0x79, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
!  /*68   h     i     j     k     l     m     n     o */
!      0x88, 0x89, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96,
!  /*70   p     q     r     s     t     u     v     w */
!      0x97, 0x98, 0x99, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6,
!  /*78   x     y     z     {     |     }     ~    DL */
!      0xA7, 0xA8, 0xA9, 0xC0, 0x4F, 0xD0, 0xA1, 0x07,
!      0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x06, 0x17,
!      0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x09, 0x0A, 0x1B,
!      0x30, 0x31, 0x1A, 0x33, 0x34, 0x35, 0x36, 0x08,
!      0x38, 0x39, 0x3A, 0x3B, 0x04, 0x14, 0x3E, 0xFF,
!      0x41, 0xAA, 0x4A, 0xB1, 0x9F, 0xB2, 0x6A, 0xB5,
!      0xBB, 0xB4, 0x9A, 0x8A, 0xB0, 0xCA, 0xAF, 0xBC,
!      0x90, 0x8F, 0xEA, 0xFA, 0xBE, 0xA0, 0xB6, 0xB3,
!      0x9D, 0xDA, 0x9B, 0x8B, 0xB7, 0xB8, 0xB9, 0xAB,
!      0x64, 0x65, 0x62, 0x66, 0x63, 0x67, 0x9E, 0x68,
!      0x74, 0x71, 0x72, 0x73, 0x78, 0x75, 0x76, 0x77,
!      0xAC, 0x69, 0xED, 0xEE, 0xEB, 0xEF, 0xEC, 0xBF,
!      0x80, 0xFD, 0xFE, 0xFB, 0xFC, 0xBA, 0xAE, 0x59,
!      0x44, 0x45, 0x42, 0x46, 0x43, 0x47, 0x9C, 0x48,
!      0x54, 0x51, 0x52, 0x53, 0x58, 0x55, 0x56, 0x57,
!      0x8C, 0x49, 0xCD, 0xCE, 0xCB, 0xCF, 0xCC, 0xE1,
!      0x70, 0xDD, 0xDE, 0xDB, 0xDC, 0x8D, 0x8E, 0xDF
! };
! 
! /* EBCDIC(CP-1047) to ASCII conversion table.  */
! const unsigned char _sch_ebcasc[256] =
! {
!  /*00  NU    SH    SX    EX    PF    HT    LC    DL */
!      0x00, 0x01, 0x02, 0x03, 0x9C, 0x09, 0x86, 0x7F,
!  /*08              SM    VT    FF    CR    SO    SI */
!      0x97, 0x8D, 0x8E, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
!  /*10  DE    D1    D2    TM    RS    NL    BS    IL */
!      0x10, 0x11, 0x12, 0x13, 0x9D, 0x0A, 0x08, 0x87,
!  /*18  CN    EM    CC    C1    FS    GS    RS    US */
!      0x18, 0x19, 0x92, 0x8F, 0x1C, 0x1D, 0x1E, 0x1F,
!  /*20  DS    SS    FS          BP    LF    EB    EC */
!      0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x17, 0x1B,
!  /*28              SM    C2    EQ    AK    BL       */
!      0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x05, 0x06, 0x07,
!  /*30              SY          PN    RS    UC    ET */
!      0x90, 0x91, 0x16, 0x93, 0x94, 0x95, 0x96, 0x04,
!  /*38                    C3    D4    NK          SB */
!      0x98, 0x99, 0x9A, 0x9B, 0x14, 0x15, 0x9E, 0x1A,
!  /*40  SP                                           */
!      0x20, 0xA0, 0xE2, 0xE4, 0xE0, 0xE1, 0xE3, 0xE5,
!  /*48                     .     <     (     +     | */
!      0xE7, 0xF1, 0xA2, 0x2E, 0x3C, 0x28, 0x2B, 0x7C,
!  /*50   &                                           */
!      0x26, 0xE9, 0xEA, 0xEB, 0xE8, 0xED, 0xEE, 0xEF,
!  /*58               !     $     *     )     ;     ^ */
!      0xEC, 0xDF, 0x21, 0x24, 0x2A, 0x29, 0x3B, 0x5E,
!  /*60   -     /                                     */
!      0x2D, 0x2F, 0xC2, 0xC4, 0xC0, 0xC1, 0xC3, 0xC5,
!  /*68                     ,     %     _     >     ? */
!      0xC7, 0xD1, 0xA6, 0x2C, 0x25, 0x5F, 0x3E, 0x3F,
!  /*70                                               */
!      0xF8, 0xC9, 0xCA, 0xCB, 0xC8, 0xCD, 0xCE, 0xCF,
!  /*78         `     :     #     @     '     =     " */
!      0xCC, 0x60, 0x3A, 0x23, 0x40, 0x27, 0x3D, 0x22,
!  /*80         a     b     c     d     e     f     g */
!      0xD8, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
!  /*88   h     i           {                         */
!      0x68, 0x69, 0xAB, 0xBB, 0xF0, 0xFD, 0xFE, 0xB1,
!  /*90         j     k     l     m     n     o     p */
!      0xB0, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70,
!  /*98   q     r           }                         */
!      0x71, 0x72, 0xAA, 0xBA, 0xE6, 0xB8, 0xC6, 0xA4,
!  /*A0         ~     s     t     u     v     w     x */
!      0xB5, 0x7E, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78,
!  /*A8   y     z                       [             */
!      0x79, 0x7A, 0xA1, 0xBF, 0xD0, 0x5B, 0xDE, 0xAE,
!  /*B0                                               */
!      0xAC, 0xA3, 0xA5, 0xB7, 0xA9, 0xA7, 0xB6, 0xBC,
!  /*B8                                 ]             */
!      0xBD, 0xBE, 0xDD, 0xA8, 0xAF, 0x5D, 0xB4, 0xD7,
!  /*C0   {     A     B     C     D     E     F     G */
!      0x7B, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
!  /*C8   H     I                                     */
!      0x48, 0x49, 0xAD, 0xF4, 0xF6, 0xF2, 0xF3, 0xF5,
!  /*D0   }     J     K     L     M     N     O     P */
!      0x7D, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50,
!  /*D8   Q     R                                     */
!      0x51, 0x52, 0xB9, 0xFB, 0xFC, 0xF9, 0xFA, 0xFF,
!  /*E0   \           S     T     U     V     W     X */
!      0x5C, 0xF7, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,
!  /*E8   Y     Z                                     */
!      0x59, 0x5A, 0xB2, 0xD4, 0xD6, 0xD2, 0xD3, 0xD5,
!  /*F0   0     1     2     3     4     5     6     7 */
!      0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
!  /*F8   8     9                                     */
!      0x38, 0x39, 0xB3, 0xDB, 0xDC, 0xD9, 0xDA, 0x9F
! };
Index: gcc/libiberty/strsignal.c
diff -c gcc/libiberty/strsignal.c:1.1.1.1 gcc/libiberty/strsignal.c:1.2
*** gcc/libiberty/strsignal.c:1.1.1.1	Wed Feb 15 21:23:47 2006
--- gcc/libiberty/strsignal.c	Wed Feb 15 21:24:31 2006
***************
*** 2,12 ****
     Written by Fred Fish.  fnf@cygnus.com
     This file is in the public domain.  */
  
  #include "ansidecl.h"
  #include "libiberty.h"
  
- #include "config.h"
- 
  /* We need to declare sys_siglist, because even if the system provides
     it we can't assume that it is declared in <signal.h> (for example,
     SunOS provides sys_siglist, but it does not declare it in any
--- 2,11 ----
     Written by Fred Fish.  fnf@cygnus.com
     This file is in the public domain.  */
  
+ #include "config.h"
  #include "ansidecl.h"
  #include "libiberty.h"
  
  /* We need to declare sys_siglist, because even if the system provides
     it we can't assume that it is declared in <signal.h> (for example,
     SunOS provides sys_siglist, but it does not declare it in any
Index: gcc/libiberty/vasprintf.c
diff -c gcc/libiberty/vasprintf.c:1.1.1.1 gcc/libiberty/vasprintf.c:1.4
*** gcc/libiberty/vasprintf.c:1.1.1.1	Wed Feb 15 21:23:47 2006
--- gcc/libiberty/vasprintf.c	Thu May 31 07:45:05 2007
***************
*** 59,71 ****
--- 59,79 ----
  
  */
  
+ #ifdef VALIST_NOT_PTR
+ static int int_vasprintf PARAMS ((char **, const char *, va_list ));
+ #else
  static int int_vasprintf PARAMS ((char **, const char *, va_list *));
+ #endif
  
  static int
  int_vasprintf (result, format, args)
       char **result;
       const char *format;
+ #ifdef VALIST_NOT_PTR
+      va_list args;
+ #else
       va_list *args;
+ #endif
  {
    const char *p = format;
    /* Add one to make sure that it is never zero, which might cause malloc
***************
*** 73,79 ****
--- 81,91 ----
    int total_width = strlen (format) + 1;
    va_list ap;
  
+ #ifdef VALIST_NOT_PTR
+   memcpy ((PTR) ap, (PTR) args, sizeof (va_list));
+ #else
    memcpy ((PTR) &ap, (PTR) args, sizeof (va_list));
+ #endif
  
    while (*p != '\0')
      {
***************
*** 138,146 ****
  #ifdef TEST
    global_total_width = total_width;
  #endif
!   *result = malloc (total_width);
    if (*result != NULL)
      return vsprintf (*result, format, *args);
    else
      return 0;
  }
--- 150,162 ----
  #ifdef TEST
    global_total_width = total_width;
  #endif
!   *result = (char *) malloc (total_width);
    if (*result != NULL)
+ #ifdef VALIST_NOT_PTR
+     return vsprintf (*result, format, args);
+ #else
      return vsprintf (*result, format, *args);
+ #endif
    else
      return 0;
  }
***************
*** 155,161 ****
--- 171,181 ----
       va_list args;
  #endif
  {
+ #ifdef VALIST_NOT_PTR
+   return int_vasprintf (result, format, args);
+ #else
    return int_vasprintf (result, format, &args);
+ #endif
  }
  
  #ifdef TEST
Index: gcc/libiberty/xmalloc.c
diff -c gcc/libiberty/xmalloc.c:1.1.1.1 gcc/libiberty/xmalloc.c:1.5
*** gcc/libiberty/xmalloc.c:1.1.1.1	Wed Feb 15 21:23:47 2006
--- gcc/libiberty/xmalloc.c	Thu Apr 16 20:30:13 2009
***************
*** 67,72 ****
--- 67,73 ----
  #include "libiberty.h"
  
  #include <stdio.h>
+ #include <stdlib.h>
  
  #ifdef __STDC__
  #include <stddef.h>
***************
*** 83,89 ****
  PTR malloc PARAMS ((size_t));
  PTR realloc PARAMS ((PTR, size_t));
  PTR calloc PARAMS ((size_t, size_t));
! PTR sbrk PARAMS ((ptrdiff_t));
  #endif
  
  /* The program name if set.  */
--- 84,92 ----
  PTR malloc PARAMS ((size_t));
  PTR realloc PARAMS ((PTR, size_t));
  PTR calloc PARAMS ((size_t, size_t));
! #ifdef HAVE_SBRK
! PTR sbrk PARAMS ((int));
! #endif
  #endif
  
  /* The program name if set.  */
***************
*** 129,135 ****
  	   name, *name ? ": " : "",
  	   (unsigned long) size);
  #endif /* HAVE_SBRK */
!   xexit (1);
  }  
  
  PTR
--- 132,138 ----
  	   name, *name ? ": " : "",
  	   (unsigned long) size);
  #endif /* HAVE_SBRK */
!   xexit (EXIT_FAILURE);
  }  
  
  PTR
Index: gcc/libiberty/xstrdup.c
diff -c gcc/libiberty/xstrdup.c:1.1.1.1 gcc/libiberty/xstrdup.c:1.3
*** gcc/libiberty/xstrdup.c:1.1.1.1	Wed Feb 15 21:23:47 2006
--- gcc/libiberty/xstrdup.c	Fri Nov 03 17:01:01 2006
***************
*** 13,19 ****
--- 13,21 ----
  
  */
  
+ #ifdef HAVE_SYS_TYPES_H
  #include <sys/types.h>
+ #endif
  #ifdef HAVE_CONFIG_H
  #include "config.h"
  #endif
Index: gcc/libiberty/xstrerror.c
diff -c gcc/libiberty/xstrerror.c:1.1.1.1 gcc/libiberty/xstrerror.c:1.2
*** gcc/libiberty/xstrerror.c:1.1.1.1	Wed Feb 15 21:23:47 2006
--- gcc/libiberty/xstrerror.c	Wed Feb 15 21:24:31 2006
***************
*** 15,22 ****
  
  #include <stdio.h>
  
- #include "libiberty.h"
  #include "config.h"
  
  #ifdef VMS
  #include <errno.h>
--- 15,22 ----
  
  #include <stdio.h>
  
  #include "config.h"
+ #include "libiberty.h"
  
  #ifdef VMS
  #include <errno.h>
